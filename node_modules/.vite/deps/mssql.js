import {
  require_crypto,
  require_node_events,
  require_url,
  require_util
} from "./chunk-HTZYRONX.js";
import {
  require_browser,
  require_buffer,
  require_inherits_browser,
  require_lib,
  require_stream,
  require_string_decoder
} from "./chunk-C3M2BVV5.js";
import {
  BrowserPerformanceMeasurement,
  init_BrowserPerformanceMeasurement
} from "./chunk-WFUGUVAC.js";
import {
  __commonJS,
  __esm,
  __export,
  __publicField,
  __toCommonJS
} from "./chunk-LK32TJAX.js";

// node_modules/@tediousjs/connection-string/lib/parser/connection-string.js
var require_connection_string = __commonJS({
  "node_modules/@tediousjs/connection-string/lib/parser/connection-string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CollectionMode;
    (function(CollectionMode2) {
      CollectionMode2[CollectionMode2["key"] = 0] = "key";
      CollectionMode2[CollectionMode2["value"] = 1] = "value";
    })(CollectionMode || (CollectionMode = {}));
    var CONFIG = Object.freeze({
      key: {
        terminator: "=",
        quotes: {}
      },
      value: {
        terminator: ";",
        quotes: {
          '"': '"',
          "'": "'",
          "{": "}"
        }
      }
    });
    function connectionStringParser(connectionString, parserConfig = CONFIG) {
      const parsed = {};
      let collectionMode = CollectionMode.key;
      let started = false;
      let finished = false;
      let quoted = false;
      let quote = "";
      let buffer = "";
      let currentKey = "";
      let pointer = 0;
      function start() {
        started = true;
      }
      function finish() {
        finished = true;
      }
      function reset() {
        started = false;
        finished = false;
        quoted = false;
        quote = "";
        buffer = "";
      }
      function config() {
        return collectionMode === CollectionMode.key ? parserConfig.key : parserConfig.value;
      }
      function isTerminator(char) {
        return config().terminator === char;
      }
      function isStartQuote(char) {
        return Object.keys(config().quotes).some((val) => char === val);
      }
      function isEndQuote(char) {
        return quoted && char === config().quotes[quote];
      }
      function push(char) {
        buffer += char;
      }
      function collect() {
        if (!quoted) {
          buffer = buffer.trim();
        }
        switch (collectionMode) {
          case CollectionMode.key:
            currentKey = buffer.toLowerCase();
            collectionMode = CollectionMode.value;
            break;
          case CollectionMode.value:
            collectionMode = CollectionMode.key;
            parsed[currentKey] = buffer;
            currentKey = "";
            break;
        }
        reset();
      }
      while (pointer < connectionString.length) {
        const current = connectionString.charAt(pointer);
        if (!finished) {
          if (!started) {
            if (current.trim()) {
              start();
              if (isStartQuote(current)) {
                quoted = true;
                quote = current;
              } else {
                push(current);
              }
            }
          } else {
            if (quoted && isEndQuote(current)) {
              const next = connectionString.charAt(pointer + 1);
              if (current === next) {
                push(current);
                pointer++;
              } else {
                finish();
              }
            } else if (!quoted && isTerminator(current)) {
              const next = connectionString.charAt(pointer + 1);
              if (current === next) {
                push(current);
                pointer++;
              } else {
                collect();
              }
            } else {
              push(current);
            }
          }
        } else if (isTerminator(current)) {
          collect();
        } else if (current.trim()) {
          throw new Error("Malformed connection string");
        }
        pointer++;
      }
      if (quoted && !finished) {
        throw new Error("Connection string terminated unexpectedly");
      } else {
        collect();
      }
      return parsed;
    }
    exports.default = connectionStringParser;
  }
});

// node_modules/@tediousjs/connection-string/lib/parser/sql-connection-string.js
var require_sql_connection_string = __commonJS({
  "node_modules/@tediousjs/connection-string/lib/parser/sql-connection-string.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SCHEMA = exports.SchemaTypes = void 0;
    var connection_string_1 = __importDefault(require_connection_string());
    var SchemaTypes;
    (function(SchemaTypes2) {
      SchemaTypes2[SchemaTypes2["BOOL"] = 0] = "BOOL";
      SchemaTypes2[SchemaTypes2["STRING"] = 1] = "STRING";
      SchemaTypes2[SchemaTypes2["NUMBER"] = 2] = "NUMBER";
    })(SchemaTypes = exports.SchemaTypes || (exports.SchemaTypes = {}));
    exports.SCHEMA = {
      "Application Name": {
        type: SchemaTypes.STRING,
        aliases: ["App"],
        validator(val) {
          return typeof val === "string" && val.length <= 128;
        }
      },
      "ApplicationIntent": {
        type: SchemaTypes.STRING,
        allowedValues: ["ReadOnly", "ReadWrite"],
        default: "ReadWrite"
      },
      "Asynchronous Processing": {
        type: SchemaTypes.BOOL,
        default: false,
        aliases: ["Async"]
      },
      "AttachDBFilename": {
        type: SchemaTypes.STRING,
        aliases: ["Extended Properties", "Initial File Name"]
      },
      "Authentication": {
        type: SchemaTypes.STRING,
        allowedValues: ["Active Directory Integrated", "Active Directory Password", "Sql Password"]
      },
      "Column Encryption Setting": {
        type: SchemaTypes.STRING
      },
      "Connection Timeout": {
        type: SchemaTypes.NUMBER,
        aliases: ["Connect Timeout", "Timeout"],
        default: 15
      },
      "Connection Lifetime": {
        type: SchemaTypes.NUMBER,
        aliases: ["Load Balance Timeout"],
        default: 0
      },
      "ConnectRetryCount": {
        type: SchemaTypes.NUMBER,
        default: 1,
        validator(val) {
          return val > 0 && val <= 255;
        }
      },
      "ConnectRetryInterval": {
        type: SchemaTypes.NUMBER,
        default: 10
      },
      "Context Connection": {
        type: SchemaTypes.BOOL,
        default: false
      },
      "Current Language": {
        aliases: ["Language"],
        type: SchemaTypes.STRING,
        validator(val) {
          return typeof val === "string" && val.length <= 128;
        }
      },
      "Data Source": {
        aliases: ["Addr", "Address", "Server", "Network Address"],
        type: SchemaTypes.STRING
      },
      "Encrypt": {
        type: SchemaTypes.BOOL,
        default: false
      },
      "Enlist": {
        type: SchemaTypes.BOOL,
        default: true
      },
      "Failover Partner": {
        type: SchemaTypes.STRING
      },
      "Initial Catalog": {
        type: SchemaTypes.STRING,
        aliases: ["Database"],
        validator(val) {
          return typeof val === "string" && val.length <= 128;
        }
      },
      "Integrated Security": {
        type: SchemaTypes.BOOL,
        aliases: ["Trusted_Connection"],
        coerce(val) {
          return val === "sspi" || null;
        }
      },
      "Max Pool Size": {
        type: SchemaTypes.NUMBER,
        default: 100,
        validator(val) {
          return val >= 1;
        }
      },
      "Min Pool Size": {
        type: SchemaTypes.NUMBER,
        default: 0,
        validator(val) {
          return val >= 0;
        }
      },
      "MultipleActiveResultSets": {
        type: SchemaTypes.BOOL,
        default: false
      },
      "MultiSubnetFailover": {
        type: SchemaTypes.BOOL,
        default: false
      },
      "Network Library": {
        type: SchemaTypes.STRING,
        aliases: ["Network", "Net"],
        allowedValues: ["dbnmpntw", "dbmsrpcn", "dbmsadsn", "dbmsgnet", "dbmslpcn", "dbmsspxn", "dbmssocn", "Dbmsvinn"]
      },
      "Packet Size": {
        type: SchemaTypes.NUMBER,
        default: 8e3,
        validator(val) {
          return val >= 512 && val <= 32768;
        }
      },
      "Password": {
        type: SchemaTypes.STRING,
        aliases: ["PWD"],
        validator(val) {
          return typeof val === "string" && val.length <= 128;
        }
      },
      "Persist Security Info": {
        type: SchemaTypes.BOOL,
        aliases: ["PersistSecurityInfo"],
        default: false
      },
      "PoolBlockingPeriod": {
        type: SchemaTypes.NUMBER,
        default: 0,
        coerce(val) {
          if (typeof val !== "string") {
            return null;
          }
          switch (val.toLowerCase()) {
            case "alwaysblock":
              return 1;
            case "auto":
              return 0;
            case "neverblock":
              return 2;
          }
          return null;
        }
      },
      "Pooling": {
        type: SchemaTypes.BOOL,
        default: true
      },
      "Replication": {
        type: SchemaTypes.BOOL,
        default: false
      },
      "Transaction Binding": {
        type: SchemaTypes.STRING,
        allowedValues: ["Implicit Unbind", "Explicit Unbind"],
        default: "Implicit Unbind"
      },
      "TransparentNetworkIPResolution": {
        type: SchemaTypes.BOOL,
        default: true
      },
      "TrustServerCertificate": {
        type: SchemaTypes.BOOL,
        default: false
      },
      "Type System Version": {
        type: SchemaTypes.STRING,
        allowedValues: ["SQL Server 2012", "SQL Server 2008", "SQL Server 2005", "Latest"]
      },
      "User ID": {
        type: SchemaTypes.STRING,
        aliases: ["UID"],
        validator(val) {
          return typeof val === "string" && val.length <= 128;
        }
      },
      "User Instance": {
        type: SchemaTypes.BOOL,
        default: false
      },
      "Workstation ID": {
        type: SchemaTypes.STRING,
        aliases: ["WSID"],
        validator(val) {
          return typeof val === "string" && val.length <= 128;
        }
      }
    };
    function guessType(value) {
      if (value.trim() === "") {
        return SchemaTypes.STRING;
      }
      const asNum = parseInt(value, 10);
      if (!Number.isNaN(asNum) && asNum.toString() === value) {
        return SchemaTypes.NUMBER;
      }
      if (["true", "false", "yes", "no"].includes(value.toLowerCase())) {
        return SchemaTypes.BOOL;
      }
      return SchemaTypes.STRING;
    }
    function coerce(value, type, coercer) {
      if (coercer) {
        const coerced = coercer(value);
        if (coerced !== null) {
          return coerced;
        }
      }
      switch (type) {
        case SchemaTypes.BOOL:
          if (["true", "yes", "1"].includes(value.toLowerCase())) {
            return true;
          }
          if (["false", "no", "0"].includes(value.toLowerCase())) {
            return false;
          }
          return value;
        case SchemaTypes.NUMBER:
          return parseInt(value, 10);
      }
      return value;
    }
    function validate(value, allowedValues, validator) {
      let valid = true;
      if (validator) {
        valid = validator(value);
      }
      if (valid) {
        valid = (allowedValues === null || allowedValues === void 0 ? void 0 : allowedValues.includes(value)) || false;
      }
      return valid;
    }
    function parseSqlConnectionString(connectionString, canonicalProps = false, allowUnknown = false, strict = false, schema = exports.SCHEMA) {
      const flattenedSchema = Object.entries(schema).reduce((flattened, [key, item]) => {
        var _a3;
        Object.assign(flattened, {
          [key.toLowerCase()]: item
        });
        return ((_a3 = item.aliases) === null || _a3 === void 0 ? void 0 : _a3.reduce((accum, alias) => {
          return Object.assign(accum, {
            [alias.toLowerCase()]: {
              ...item,
              canonical: key.toLowerCase()
            }
          });
        }, flattened)) || flattened;
      }, {});
      return Object.entries((0, connection_string_1.default)(connectionString)).reduce((config, [prop, value]) => {
        if (!Object.prototype.hasOwnProperty.call(flattenedSchema, prop)) {
          return Object.assign(config, {
            [prop]: coerce(value, guessType(value))
          });
        }
        let coercedValue = coerce(value, flattenedSchema[prop].type, flattenedSchema[prop].coerce);
        if (strict && !validate(coercedValue, flattenedSchema[prop].allowedValues, flattenedSchema[prop].validator)) {
          coercedValue = flattenedSchema[prop].default;
        }
        const propName = canonicalProps ? flattenedSchema[prop].canonical || prop : prop;
        return Object.assign(config, {
          [propName]: coercedValue
        });
      }, {});
    }
    exports.default = parseSqlConnectionString;
  }
});

// node_modules/@tediousjs/connection-string/lib/builder/index.js
var require_builder = __commonJS({
  "node_modules/@tediousjs/connection-string/lib/builder/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildConnectionString = void 0;
    function isQuoted(val) {
      if (val[0] !== "{") {
        return false;
      }
      for (let i = 1; i < val.length; i++) {
        if (val[i] === "}") {
          if (i + 1 === val.length) {
            return true;
          } else if (val[i + 1] !== "}") {
            return false;
          } else {
            i++;
          }
        }
      }
      return false;
    }
    function needsQuotes(val) {
      var _a3;
      return !isQuoted(val) && !!((_a3 = val.match(/\[|]|{|}|\|\(|\)|,|;|\?|\*|=|!|@/)) === null || _a3 === void 0 ? void 0 : _a3.length);
    }
    function encodeTuple(key, value) {
      if (value === null || value === void 0) {
        return [key, ""];
      }
      switch (typeof value) {
        case "boolean":
          return [key, value ? "Yes" : "No"];
        default: {
          const strVal = value.toString();
          if (needsQuotes(strVal)) {
            return [key, `{${strVal.replace(/}/g, "}}")}}`];
          }
          return [key, strVal];
        }
      }
    }
    function buildConnectionString(data) {
      return Object.entries(data).map(([key, value]) => {
        return encodeTuple(key.trim(), value).join("=");
      }).join(";");
    }
    exports.buildConnectionString = buildConnectionString;
  }
});

// node_modules/@tediousjs/connection-string/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@tediousjs/connection-string/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseSqlConnectionString = exports.parseConnectionString = void 0;
    var connection_string_1 = __importDefault(require_connection_string());
    exports.parseConnectionString = connection_string_1.default;
    var sql_connection_string_1 = __importDefault(require_sql_connection_string());
    exports.parseSqlConnectionString = sql_connection_string_1.default;
    __exportStar(require_builder(), exports);
  }
});

// node_modules/tarn/dist/TimeoutError.js
var require_TimeoutError = __commonJS({
  "node_modules/tarn/dist/TimeoutError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TimeoutError = class extends Error {
    };
    exports.TimeoutError = TimeoutError;
  }
});

// node_modules/tarn/dist/PromiseInspection.js
var require_PromiseInspection = __commonJS({
  "node_modules/tarn/dist/PromiseInspection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PromiseInspection = class {
      constructor(args) {
        this._value = args.value;
        this._error = args.error;
      }
      value() {
        return this._value;
      }
      reason() {
        return this._error;
      }
      isRejected() {
        return !!this._error;
      }
      isFulfilled() {
        return !!this._value;
      }
    };
    exports.PromiseInspection = PromiseInspection;
  }
});

// node_modules/tarn/dist/utils.js
var require_utils = __commonJS({
  "node_modules/tarn/dist/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PromiseInspection_1 = require_PromiseInspection();
    function defer() {
      let resolve = null;
      let reject = null;
      const promise = new Promise((resolver, rejecter) => {
        resolve = resolver;
        reject = rejecter;
      });
      return {
        promise,
        resolve,
        reject
      };
    }
    exports.defer = defer;
    function now() {
      return Date.now();
    }
    exports.now = now;
    function duration(t1, t2) {
      return Math.abs(t2 - t1);
    }
    exports.duration = duration;
    function checkOptionalTime(time) {
      if (typeof time === "undefined") {
        return true;
      }
      return checkRequiredTime(time);
    }
    exports.checkOptionalTime = checkOptionalTime;
    function checkRequiredTime(time) {
      return typeof time === "number" && time === Math.round(time) && time > 0;
    }
    exports.checkRequiredTime = checkRequiredTime;
    function delay4(millis) {
      return new Promise((resolve) => setTimeout(resolve, millis));
    }
    exports.delay = delay4;
    function reflect(promise) {
      return promise.then((value) => {
        return new PromiseInspection_1.PromiseInspection({ value });
      }).catch((error) => {
        return new PromiseInspection_1.PromiseInspection({ error });
      });
    }
    exports.reflect = reflect;
    function tryPromise(cb) {
      try {
        const result = cb();
        return Promise.resolve(result);
      } catch (err) {
        return Promise.reject(err);
      }
    }
    exports.tryPromise = tryPromise;
  }
});

// node_modules/tarn/dist/PendingOperation.js
var require_PendingOperation = __commonJS({
  "node_modules/tarn/dist/PendingOperation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TimeoutError_1 = require_TimeoutError();
    var utils_1 = require_utils();
    var PendingOperation = class {
      constructor(timeoutMillis) {
        this.timeoutMillis = timeoutMillis;
        this.deferred = utils_1.defer();
        this.possibleTimeoutCause = null;
        this.isRejected = false;
        this.promise = timeout(this.deferred.promise, timeoutMillis).catch((err) => {
          if (err instanceof TimeoutError_1.TimeoutError) {
            if (this.possibleTimeoutCause) {
              err = new TimeoutError_1.TimeoutError(this.possibleTimeoutCause.message);
            } else {
              err = new TimeoutError_1.TimeoutError("operation timed out for an unknown reason");
            }
          }
          this.isRejected = true;
          return Promise.reject(err);
        });
      }
      abort() {
        this.reject(new Error("aborted"));
      }
      reject(err) {
        this.deferred.reject(err);
      }
      resolve(value) {
        this.deferred.resolve(value);
      }
    };
    exports.PendingOperation = PendingOperation;
    function timeout(promise, time) {
      return new Promise((resolve, reject) => {
        const timeoutHandle = setTimeout(() => reject(new TimeoutError_1.TimeoutError()), time);
        promise.then((result) => {
          clearTimeout(timeoutHandle);
          resolve(result);
        }).catch((err) => {
          clearTimeout(timeoutHandle);
          reject(err);
        });
      });
    }
  }
});

// node_modules/tarn/dist/Resource.js
var require_Resource = __commonJS({
  "node_modules/tarn/dist/Resource.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils();
    var Resource = class _Resource {
      constructor(resource) {
        this.resource = resource;
        this.resource = resource;
        this.timestamp = utils_1.now();
        this.deferred = utils_1.defer();
      }
      get promise() {
        return this.deferred.promise;
      }
      resolve() {
        this.deferred.resolve(void 0);
        return new _Resource(this.resource);
      }
    };
    exports.Resource = Resource;
  }
});

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    "use strict";
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    module.exports = EventEmitter;
    module.exports.once = once;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state3 = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state3);
      wrapped.listener = listener;
      state3.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name3) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name3, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name3, resolver, { once: true });
        if (name3 !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name3, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name3, listener);
        } else {
          emitter.on(name3, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name3, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name3, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// browser-external:timers
var require_timers = __commonJS({
  "browser-external:timers"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "timers" has been externalized for browser compatibility. Cannot access "timers.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/tarn/dist/Pool.js
var require_Pool = __commonJS({
  "node_modules/tarn/dist/Pool.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PendingOperation_1 = require_PendingOperation();
    var Resource_1 = require_Resource();
    var utils_1 = require_utils();
    var events_1 = require_events();
    var timers_1 = require_timers();
    var Pool = class {
      constructor(opt) {
        this.destroyed = false;
        this.emitter = new events_1.EventEmitter();
        opt = opt || {};
        if (!opt.create) {
          throw new Error("Tarn: opt.create function most be provided");
        }
        if (!opt.destroy) {
          throw new Error("Tarn: opt.destroy function most be provided");
        }
        if (typeof opt.min !== "number" || opt.min < 0 || opt.min !== Math.round(opt.min)) {
          throw new Error("Tarn: opt.min must be an integer >= 0");
        }
        if (typeof opt.max !== "number" || opt.max <= 0 || opt.max !== Math.round(opt.max)) {
          throw new Error("Tarn: opt.max must be an integer > 0");
        }
        if (opt.min > opt.max) {
          throw new Error("Tarn: opt.max is smaller than opt.min");
        }
        if (!utils_1.checkOptionalTime(opt.acquireTimeoutMillis)) {
          throw new Error("Tarn: invalid opt.acquireTimeoutMillis " + JSON.stringify(opt.acquireTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.createTimeoutMillis)) {
          throw new Error("Tarn: invalid opt.createTimeoutMillis " + JSON.stringify(opt.createTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.destroyTimeoutMillis)) {
          throw new Error("Tarn: invalid opt.destroyTimeoutMillis " + JSON.stringify(opt.destroyTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.idleTimeoutMillis)) {
          throw new Error("Tarn: invalid opt.idleTimeoutMillis " + JSON.stringify(opt.idleTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.reapIntervalMillis)) {
          throw new Error("Tarn: invalid opt.reapIntervalMillis " + JSON.stringify(opt.reapIntervalMillis));
        }
        if (!utils_1.checkOptionalTime(opt.createRetryIntervalMillis)) {
          throw new Error("Tarn: invalid opt.createRetryIntervalMillis " + JSON.stringify(opt.createRetryIntervalMillis));
        }
        const allowedKeys = {
          create: true,
          validate: true,
          destroy: true,
          log: true,
          min: true,
          max: true,
          acquireTimeoutMillis: true,
          createTimeoutMillis: true,
          destroyTimeoutMillis: true,
          idleTimeoutMillis: true,
          reapIntervalMillis: true,
          createRetryIntervalMillis: true,
          propagateCreateError: true
        };
        for (const key of Object.keys(opt)) {
          if (!allowedKeys[key]) {
            throw new Error(`Tarn: unsupported option opt.${key}`);
          }
        }
        this.creator = opt.create;
        this.destroyer = opt.destroy;
        this.validate = typeof opt.validate === "function" ? opt.validate : () => true;
        this.log = opt.log || (() => {
        });
        this.acquireTimeoutMillis = opt.acquireTimeoutMillis || 3e4;
        this.createTimeoutMillis = opt.createTimeoutMillis || 3e4;
        this.destroyTimeoutMillis = opt.destroyTimeoutMillis || 5e3;
        this.idleTimeoutMillis = opt.idleTimeoutMillis || 3e4;
        this.reapIntervalMillis = opt.reapIntervalMillis || 1e3;
        this.createRetryIntervalMillis = opt.createRetryIntervalMillis || 200;
        this.propagateCreateError = !!opt.propagateCreateError;
        this.min = opt.min;
        this.max = opt.max;
        this.used = [];
        this.free = [];
        this.pendingCreates = [];
        this.pendingAcquires = [];
        this.pendingDestroys = [];
        this.pendingValidations = [];
        this.destroyed = false;
        this.interval = null;
        this.eventId = 1;
      }
      numUsed() {
        return this.used.length;
      }
      numFree() {
        return this.free.length;
      }
      numPendingAcquires() {
        return this.pendingAcquires.length;
      }
      numPendingValidations() {
        return this.pendingValidations.length;
      }
      numPendingCreates() {
        return this.pendingCreates.length;
      }
      acquire() {
        const eventId = this.eventId++;
        this._executeEventHandlers("acquireRequest", eventId);
        const pendingAcquire = new PendingOperation_1.PendingOperation(this.acquireTimeoutMillis);
        this.pendingAcquires.push(pendingAcquire);
        pendingAcquire.promise = pendingAcquire.promise.then((resource) => {
          this._executeEventHandlers("acquireSuccess", eventId, resource);
          return resource;
        }).catch((err) => {
          this._executeEventHandlers("acquireFail", eventId, err);
          remove(this.pendingAcquires, pendingAcquire);
          return Promise.reject(err);
        });
        this._tryAcquireOrCreate();
        return pendingAcquire;
      }
      release(resource) {
        this._executeEventHandlers("release", resource);
        for (let i = 0, l = this.used.length; i < l; ++i) {
          const used = this.used[i];
          if (used.resource === resource) {
            this.used.splice(i, 1);
            this.free.push(used.resolve());
            this._tryAcquireOrCreate();
            return true;
          }
        }
        return false;
      }
      isEmpty() {
        return [
          this.numFree(),
          this.numUsed(),
          this.numPendingAcquires(),
          this.numPendingValidations(),
          this.numPendingCreates()
        ].reduce((total, value) => total + value) === 0;
      }
      /**
       * Reaping cycle.
       */
      check() {
        const timestamp = utils_1.now();
        const newFree = [];
        const minKeep = this.min - this.used.length;
        const maxDestroy = this.free.length - minKeep;
        let numDestroyed = 0;
        this.free.forEach((free) => {
          if (utils_1.duration(timestamp, free.timestamp) >= this.idleTimeoutMillis && numDestroyed < maxDestroy) {
            numDestroyed++;
            this._destroy(free.resource);
          } else {
            newFree.push(free);
          }
        });
        this.free = newFree;
        if (this.isEmpty()) {
          this._stopReaping();
        }
      }
      destroy() {
        const eventId = this.eventId++;
        this._executeEventHandlers("poolDestroyRequest", eventId);
        this._stopReaping();
        this.destroyed = true;
        return utils_1.reflect(Promise.all(this.pendingCreates.map((create) => utils_1.reflect(create.promise))).then(() => {
          return new Promise((resolve, reject) => {
            if (this.numPendingValidations() === 0) {
              resolve();
              return;
            }
            const interval = setInterval(() => {
              if (this.numPendingValidations() === 0) {
                timers_1.clearInterval(interval);
                resolve();
              }
            }, 100);
          });
        }).then(() => {
          return Promise.all(this.used.map((used) => utils_1.reflect(used.promise)));
        }).then(() => {
          return Promise.all(this.pendingAcquires.map((acquire) => {
            acquire.abort();
            return utils_1.reflect(acquire.promise);
          }));
        }).then(() => {
          return Promise.all(this.free.map((free) => utils_1.reflect(this._destroy(free.resource))));
        }).then(() => {
          return Promise.all(this.pendingDestroys.map((pd) => pd.promise));
        }).then(() => {
          this.free = [];
          this.pendingAcquires = [];
        })).then((res) => {
          this._executeEventHandlers("poolDestroySuccess", eventId);
          this.emitter.removeAllListeners();
          return res;
        });
      }
      on(event, listener) {
        this.emitter.on(event, listener);
      }
      removeListener(event, listener) {
        this.emitter.removeListener(event, listener);
      }
      removeAllListeners(event) {
        this.emitter.removeAllListeners(event);
      }
      /**
       * The most important method that is called always when resources
       * are created / destroyed / acquired / released. In other words
       * every time when resources are moved from used to free or vice
       * versa.
       *
       * Either assigns free resources to pendingAcquires or creates new
       * resources if there is room for it in the pool.
       */
      _tryAcquireOrCreate() {
        if (this.destroyed) {
          return;
        }
        if (this._hasFreeResources()) {
          this._doAcquire();
        } else if (this._shouldCreateMoreResources()) {
          this._doCreate();
        }
      }
      _hasFreeResources() {
        return this.free.length > 0;
      }
      _doAcquire() {
        while (this._canAcquire()) {
          const pendingAcquire = this.pendingAcquires.shift();
          const free = this.free.pop();
          if (free === void 0 || pendingAcquire === void 0) {
            const errMessage = "this.free was empty while trying to acquire resource";
            this.log(`Tarn: ${errMessage}`, "warn");
            throw new Error(`Internal error, should never happen. ${errMessage}`);
          }
          this.pendingValidations.push(pendingAcquire);
          this.used.push(free);
          const abortAbleValidation = new PendingOperation_1.PendingOperation(this.acquireTimeoutMillis);
          pendingAcquire.promise.catch((err) => {
            abortAbleValidation.abort();
          });
          abortAbleValidation.promise.catch((err) => {
            this.log("Tarn: resource validator threw an exception " + err.stack, "warn");
            return false;
          }).then((validationSuccess) => {
            try {
              if (validationSuccess && !pendingAcquire.isRejected) {
                this._startReaping();
                pendingAcquire.resolve(free.resource);
              } else {
                remove(this.used, free);
                if (!validationSuccess) {
                  this._destroy(free.resource);
                  setTimeout(() => {
                    this._tryAcquireOrCreate();
                  }, 0);
                } else {
                  this.free.push(free);
                }
                if (!pendingAcquire.isRejected) {
                  this.pendingAcquires.unshift(pendingAcquire);
                }
              }
            } finally {
              remove(this.pendingValidations, pendingAcquire);
            }
          });
          this._validateResource(free.resource).then((validationSuccess) => {
            abortAbleValidation.resolve(validationSuccess);
          }).catch((err) => {
            abortAbleValidation.reject(err);
          });
        }
      }
      _canAcquire() {
        return this.free.length > 0 && this.pendingAcquires.length > 0;
      }
      _validateResource(resource) {
        try {
          return Promise.resolve(this.validate(resource));
        } catch (err) {
          return Promise.reject(err);
        }
      }
      _shouldCreateMoreResources() {
        return this.used.length + this.pendingCreates.length < this.max && this.pendingCreates.length < this.pendingAcquires.length;
      }
      _doCreate() {
        const pendingAcquiresBeforeCreate = this.pendingAcquires.slice();
        const pendingCreate = this._create();
        pendingCreate.promise.then(() => {
          this._tryAcquireOrCreate();
          return null;
        }).catch((err) => {
          if (this.propagateCreateError && this.pendingAcquires.length !== 0) {
            this.pendingAcquires[0].reject(err);
          }
          pendingAcquiresBeforeCreate.forEach((pendingAcquire) => {
            pendingAcquire.possibleTimeoutCause = err;
          });
          utils_1.delay(this.createRetryIntervalMillis).then(() => this._tryAcquireOrCreate());
        });
      }
      _create() {
        const eventId = this.eventId++;
        this._executeEventHandlers("createRequest", eventId);
        const pendingCreate = new PendingOperation_1.PendingOperation(this.createTimeoutMillis);
        pendingCreate.promise = pendingCreate.promise.catch((err) => {
          if (remove(this.pendingCreates, pendingCreate)) {
            this._executeEventHandlers("createFail", eventId, err);
          }
          throw err;
        });
        this.pendingCreates.push(pendingCreate);
        callbackOrPromise(this.creator).then((resource) => {
          if (pendingCreate.isRejected) {
            this.destroyer(resource);
            return null;
          }
          remove(this.pendingCreates, pendingCreate);
          this.free.push(new Resource_1.Resource(resource));
          pendingCreate.resolve(resource);
          this._executeEventHandlers("createSuccess", eventId, resource);
          return null;
        }).catch((err) => {
          if (pendingCreate.isRejected) {
            return null;
          }
          if (remove(this.pendingCreates, pendingCreate)) {
            this._executeEventHandlers("createFail", eventId, err);
          }
          pendingCreate.reject(err);
          return null;
        });
        return pendingCreate;
      }
      _destroy(resource) {
        const eventId = this.eventId++;
        this._executeEventHandlers("destroyRequest", eventId, resource);
        const pendingDestroy = new PendingOperation_1.PendingOperation(this.destroyTimeoutMillis);
        const retVal = Promise.resolve().then(() => this.destroyer(resource));
        retVal.then(() => {
          pendingDestroy.resolve(resource);
        }).catch((err) => {
          pendingDestroy.reject(err);
        });
        this.pendingDestroys.push(pendingDestroy);
        return pendingDestroy.promise.then((res) => {
          this._executeEventHandlers("destroySuccess", eventId, resource);
          return res;
        }).catch((err) => this._logDestroyerError(eventId, resource, err)).then((res) => {
          const index = this.pendingDestroys.findIndex((pd) => pd === pendingDestroy);
          this.pendingDestroys.splice(index, 1);
          return res;
        });
      }
      _logDestroyerError(eventId, resource, err) {
        this._executeEventHandlers("destroyFail", eventId, resource, err);
        this.log("Tarn: resource destroyer threw an exception " + err.stack, "warn");
      }
      _startReaping() {
        if (!this.interval) {
          this._executeEventHandlers("startReaping");
          this.interval = setInterval(() => this.check(), this.reapIntervalMillis);
        }
      }
      _stopReaping() {
        if (this.interval !== null) {
          this._executeEventHandlers("stopReaping");
          timers_1.clearInterval(this.interval);
        }
        this.interval = null;
      }
      _executeEventHandlers(eventName, ...args) {
        const listeners = this.emitter.listeners(eventName);
        listeners.forEach((listener) => {
          try {
            listener(...args);
          } catch (err) {
            this.log(`Tarn: event handler "${eventName}" threw an exception ${err.stack}`, "warn");
          }
        });
      }
    };
    exports.Pool = Pool;
    function remove(arr, item) {
      const idx = arr.indexOf(item);
      if (idx === -1) {
        return false;
      } else {
        arr.splice(idx, 1);
        return true;
      }
    }
    function callbackOrPromise(func) {
      return new Promise((resolve, reject) => {
        const callback = (err, resource) => {
          if (err) {
            reject(err);
          } else {
            resolve(resource);
          }
        };
        utils_1.tryPromise(() => func(callback)).then((res) => {
          if (res) {
            resolve(res);
          }
        }).catch((err) => {
          reject(err);
        });
      });
    }
  }
});

// node_modules/tarn/dist/tarn.js
var require_tarn = __commonJS({
  "node_modules/tarn/dist/tarn.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Pool_1 = require_Pool();
    exports.Pool = Pool_1.Pool;
    var TimeoutError_1 = require_TimeoutError();
    exports.TimeoutError = TimeoutError_1.TimeoutError;
    module.exports = {
      Pool: Pool_1.Pool,
      TimeoutError: TimeoutError_1.TimeoutError
    };
  }
});

// node_modules/mssql/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/mssql/lib/utils.js"(exports, module) {
    var IDS = /* @__PURE__ */ new WeakMap();
    var INCREMENT = {
      Connection: 1,
      ConnectionPool: 1,
      Request: 1,
      Transaction: 1,
      PreparedStatement: 1
    };
    module.exports = {
      objectHasProperty: (object, property) => Object.prototype.hasOwnProperty.call(object, property),
      INCREMENT,
      IDS: {
        get: IDS.get.bind(IDS),
        add: (object, type, id) => {
          if (id) return IDS.set(object, id);
          IDS.set(object, INCREMENT[type]++);
        }
      }
    };
  }
});

// node_modules/mssql/lib/error/mssql-error.js
var require_mssql_error = __commonJS({
  "node_modules/mssql/lib/error/mssql-error.js"(exports, module) {
    "use strict";
    var MSSQLError = class extends Error {
      /**
       * Creates a new ConnectionError.
       *
       * @param {String} message Error message.
       * @param {String} [code] Error code.
       */
      constructor(message, code) {
        if (message instanceof Error) {
          super(message.message);
          this.code = message.code || code;
          Error.captureStackTrace(this, this.constructor);
          Object.defineProperty(this, "originalError", { enumerable: true, value: message });
        } else {
          super(message);
          this.code = code;
        }
        this.name = "MSSQLError";
      }
    };
    module.exports = MSSQLError;
  }
});

// node_modules/mssql/lib/error/connection-error.js
var require_connection_error = __commonJS({
  "node_modules/mssql/lib/error/connection-error.js"(exports, module) {
    "use strict";
    var MSSQLError = require_mssql_error();
    var ConnectionError = class extends MSSQLError {
      /**
       * Creates a new ConnectionError.
       *
       * @param {String} message Error message.
       * @param {String} [code] Error code.
       */
      constructor(message, code) {
        super(message, code);
        this.name = "ConnectionError";
      }
    };
    module.exports = ConnectionError;
  }
});

// node_modules/mssql/lib/datatypes.js
var require_datatypes = __commonJS({
  "node_modules/mssql/lib/datatypes.js"(exports, module) {
    "use strict";
    var objectHasProperty2 = require_utils2().objectHasProperty;
    var inspect = Symbol.for("nodejs.util.inspect.custom");
    var TYPES = {
      VarChar(length) {
        return { type: TYPES.VarChar, length };
      },
      NVarChar(length) {
        return { type: TYPES.NVarChar, length };
      },
      Text() {
        return { type: TYPES.Text };
      },
      Int() {
        return { type: TYPES.Int };
      },
      BigInt() {
        return { type: TYPES.BigInt };
      },
      TinyInt() {
        return { type: TYPES.TinyInt };
      },
      SmallInt() {
        return { type: TYPES.SmallInt };
      },
      Bit() {
        return { type: TYPES.Bit };
      },
      Float() {
        return { type: TYPES.Float };
      },
      Numeric(precision, scale) {
        return { type: TYPES.Numeric, precision, scale };
      },
      Decimal(precision, scale) {
        return { type: TYPES.Decimal, precision, scale };
      },
      Real() {
        return { type: TYPES.Real };
      },
      Date() {
        return { type: TYPES.Date };
      },
      DateTime() {
        return { type: TYPES.DateTime };
      },
      DateTime2(scale) {
        return { type: TYPES.DateTime2, scale };
      },
      DateTimeOffset(scale) {
        return { type: TYPES.DateTimeOffset, scale };
      },
      SmallDateTime() {
        return { type: TYPES.SmallDateTime };
      },
      Time(scale) {
        return { type: TYPES.Time, scale };
      },
      UniqueIdentifier() {
        return { type: TYPES.UniqueIdentifier };
      },
      SmallMoney() {
        return { type: TYPES.SmallMoney };
      },
      Money() {
        return { type: TYPES.Money };
      },
      Binary(length) {
        return { type: TYPES.Binary, length };
      },
      VarBinary(length) {
        return { type: TYPES.VarBinary, length };
      },
      Image() {
        return { type: TYPES.Image };
      },
      Xml() {
        return { type: TYPES.Xml };
      },
      Char(length) {
        return { type: TYPES.Char, length };
      },
      NChar(length) {
        return { type: TYPES.NChar, length };
      },
      NText() {
        return { type: TYPES.NText };
      },
      TVP(tvpType) {
        return { type: TYPES.TVP, tvpType };
      },
      UDT() {
        return { type: TYPES.UDT };
      },
      Geography() {
        return { type: TYPES.Geography };
      },
      Geometry() {
        return { type: TYPES.Geometry };
      },
      Variant() {
        return { type: TYPES.Variant };
      }
    };
    module.exports.TYPES = TYPES;
    module.exports.DECLARATIONS = {};
    var zero = function(value, length) {
      if (length == null) length = 2;
      value = String(value);
      if (value.length < length) {
        for (let i = 1; i <= length - value.length; i++) {
          value = `0${value}`;
        }
      }
      return value;
    };
    for (const key in TYPES) {
      if (objectHasProperty2(TYPES, key)) {
        const value = TYPES[key];
        value.declaration = key.toLowerCase();
        module.exports.DECLARATIONS[value.declaration] = value;
        ((key2, value2) => {
          value2[inspect] = () => `[sql.${key2}]`;
        })(key, value);
      }
    }
    module.exports.declare = (type, options) => {
      switch (type) {
        case TYPES.VarChar:
        case TYPES.VarBinary:
          return `${type.declaration} (${options.length > 8e3 ? "MAX" : options.length == null ? "MAX" : options.length})`;
        case TYPES.NVarChar:
          return `${type.declaration} (${options.length > 4e3 ? "MAX" : options.length == null ? "MAX" : options.length})`;
        case TYPES.Char:
        case TYPES.NChar:
        case TYPES.Binary:
          return `${type.declaration} (${options.length == null ? 1 : options.length})`;
        case TYPES.Decimal:
        case TYPES.Numeric:
          return `${type.declaration} (${options.precision == null ? 18 : options.precision}, ${options.scale == null ? 0 : options.scale})`;
        case TYPES.Time:
        case TYPES.DateTime2:
        case TYPES.DateTimeOffset:
          return `${type.declaration} (${options.scale == null ? 7 : options.scale})`;
        case TYPES.TVP:
          return `${options.tvpType} readonly`;
        default:
          return type.declaration;
      }
    };
    module.exports.cast = (value, type, options) => {
      if (value == null) {
        return null;
      }
      switch (typeof value) {
        case "string":
          return `N'${value.replace(/'/g, "''")}'`;
        case "number":
        case "bigint":
          return value;
        case "boolean":
          return value ? 1 : 0;
        case "object":
          if (value instanceof Date) {
            let ns = value.getUTCMilliseconds() / 1e3;
            if (value.nanosecondDelta != null) {
              ns += value.nanosecondDelta;
            }
            const scale = options.scale == null ? 7 : options.scale;
            if (scale > 0) {
              ns = String(ns).substr(1, scale + 1);
            } else {
              ns = "";
            }
            return `N'${value.getUTCFullYear()}-${zero(value.getUTCMonth() + 1)}-${zero(value.getUTCDate())} ${zero(value.getUTCHours())}:${zero(value.getUTCMinutes())}:${zero(value.getUTCSeconds())}${ns}'`;
          } else if (Buffer.isBuffer(value)) {
            return `0x${value.toString("hex")}`;
          }
          return null;
        default:
          return null;
      }
    };
  }
});

// node_modules/mssql/lib/table.js
var require_table = __commonJS({
  "node_modules/mssql/lib/table.js"(exports, module) {
    "use strict";
    var TYPES = require_datatypes().TYPES;
    var declareType = require_datatypes().declare;
    var objectHasProperty2 = require_utils2().objectHasProperty;
    var MAX = 65535;
    var JSON_COLUMN_ID = "JSON_F52E2B61-18A1-11d1-B105-00805F49916B";
    function Table(name3) {
      if (name3) {
        const parsed = Table.parseName(name3);
        this.name = parsed.name;
        this.schema = parsed.schema;
        this.database = parsed.database;
        this.path = (this.database ? `[${this.database}].` : "") + (this.schema ? `[${this.schema}].` : "") + `[${this.name}]`;
        this.temporary = this.name.charAt(0) === "#";
      }
      this.columns = [];
      this.rows = [];
      Object.defineProperty(this.columns, "add", {
        value(name4, column, options) {
          if (column == null) {
            throw new Error("Column data type is not defined.");
          }
          if (column instanceof Function) {
            column = column();
          }
          options = options || {};
          column.name = name4;
          ["nullable", "primary", "identity", "readOnly", "length"].forEach((prop) => {
            if (objectHasProperty2(options, prop)) {
              column[prop] = options[prop];
            }
          });
          return this.push(column);
        }
      });
      Object.defineProperty(
        this.rows,
        "add",
        {
          value() {
            return this.push(Array.prototype.slice.call(arguments));
          }
        }
      );
      Object.defineProperty(
        this.rows,
        "clear",
        {
          value() {
            return this.splice(0, this.length);
          }
        }
      );
    }
    Table.prototype._makeBulk = function _makeBulk() {
      for (let i = 0; i < this.columns.length; i++) {
        const col = this.columns[i];
        switch (col.type) {
          case TYPES.Date:
          case TYPES.DateTime:
          case TYPES.DateTime2:
            for (let j = 0; j < this.rows.length; j++) {
              const dateValue = this.rows[j][i];
              if (typeof dateValue === "string" || typeof dateValue === "number") {
                const date = new Date(dateValue);
                if (isNaN(date.getDate())) {
                  throw new TypeError("Invalid date value passed to bulk rows");
                }
                this.rows[j][i] = date;
              }
            }
            break;
          case TYPES.Xml:
            col.type = TYPES.NVarChar(MAX).type;
            break;
          case TYPES.UDT:
          case TYPES.Geography:
          case TYPES.Geometry:
            col.type = TYPES.VarBinary(MAX).type;
            break;
          default:
            break;
        }
      }
      return this;
    };
    Table.prototype.declare = function declare() {
      const pkey = this.columns.filter((col) => col.primary === true).map((col) => `[${col.name}]`);
      const cols = this.columns.map((col) => {
        const def = [`[${col.name}] ${declareType(col.type, col)}`];
        if (col.nullable === true) {
          def.push("null");
        } else if (col.nullable === false) {
          def.push("not null");
        }
        if (col.primary === true && pkey.length === 1) {
          def.push("primary key");
        }
        return def.join(" ");
      });
      const constraint = pkey.length > 1 ? `, constraint [PK_${this.temporary ? this.name.substr(1) : this.name}] primary key (${pkey.join(", ")})` : "";
      return `create table ${this.path} (${cols.join(", ")}${constraint})`;
    };
    Table.fromRecordset = function fromRecordset(recordset, name3) {
      const t = new this(name3);
      for (const colName in recordset.columns) {
        if (objectHasProperty2(recordset.columns, colName)) {
          const col = recordset.columns[colName];
          t.columns.add(colName, {
            type: col.type,
            length: col.length,
            scale: col.scale,
            precision: col.precision
          }, {
            nullable: col.nullable,
            identity: col.identity,
            readOnly: col.readOnly
          });
        }
      }
      if (t.columns.length === 1 && t.columns[0].name === JSON_COLUMN_ID) {
        for (let i = 0; i < recordset.length; i++) {
          t.rows.add(JSON.stringify(recordset[i]));
        }
      } else {
        for (let i = 0; i < recordset.length; i++) {
          t.rows.add.apply(t.rows, t.columns.map((col) => recordset[i][col.name]));
        }
      }
      return t;
    };
    Table.parseName = function parseName(name3) {
      const length = name3.length;
      let cursor = -1;
      let buffer = "";
      let escaped = false;
      const path = [];
      while (++cursor < length) {
        const char = name3.charAt(cursor);
        if (char === "[") {
          if (escaped) {
            buffer += char;
          } else {
            escaped = true;
          }
        } else if (char === "]") {
          if (escaped) {
            escaped = false;
          } else {
            throw new Error("Invalid table name.");
          }
        } else if (char === ".") {
          if (escaped) {
            buffer += char;
          } else {
            path.push(buffer);
            buffer = "";
          }
        } else {
          buffer += char;
        }
      }
      if (buffer) {
        path.push(buffer);
      }
      switch (path.length) {
        case 1:
          return {
            name: path[0],
            schema: null,
            database: null
          };
        case 2:
          return {
            name: path[1],
            schema: path[0],
            database: null
          };
        case 3:
          return {
            name: path[2],
            schema: path[1],
            database: path[0]
          };
        default:
          throw new Error("Invalid table name.");
      }
    };
    module.exports = Table;
  }
});

// node_modules/mssql/lib/shared.js
var require_shared = __commonJS({
  "node_modules/mssql/lib/shared.js"(exports, module) {
    "use strict";
    var TYPES = require_datatypes().TYPES;
    var Table = require_table();
    var PromiseLibrary = Promise;
    var driver = {};
    var map = [];
    map.register = function(jstype, sqltype) {
      for (let index = 0; index < this.length; index++) {
        const item = this[index];
        if (item.js === jstype) {
          this.splice(index, 1);
          break;
        }
      }
      this.push({
        js: jstype,
        sql: sqltype
      });
      return null;
    };
    map.register(String, TYPES.NVarChar);
    map.register(Number, TYPES.Int);
    map.register(Boolean, TYPES.Bit);
    map.register(Date, TYPES.DateTime);
    map.register(Buffer, TYPES.VarBinary);
    map.register(Table, TYPES.TVP);
    var getTypeByValue = function(value) {
      if (value === null || value === void 0) {
        return TYPES.NVarChar;
      }
      switch (typeof value) {
        case "string":
          for (const item of Array.from(map)) {
            if (item.js === String) {
              return item.sql;
            }
          }
          return TYPES.NVarChar;
        case "number":
          if (value % 1 === 0) {
            if (value < -2147483648 || value > 2147483647) {
              return TYPES.BigInt;
            } else {
              return TYPES.Int;
            }
          } else {
            return TYPES.Float;
          }
        case "bigint":
          if (value < -2147483648n || value > 2147483647n) {
            return TYPES.BigInt;
          } else {
            return TYPES.Int;
          }
        case "boolean":
          for (const item of Array.from(map)) {
            if (item.js === Boolean) {
              return item.sql;
            }
          }
          return TYPES.Bit;
        case "object":
          for (const item of Array.from(map)) {
            if (value instanceof item.js) {
              return item.sql;
            }
          }
          return TYPES.NVarChar;
        default:
          return TYPES.NVarChar;
      }
    };
    module.exports = {
      driver,
      getTypeByValue,
      map
    };
    Object.defineProperty(module.exports, "Promise", {
      get: () => {
        return PromiseLibrary;
      },
      set: (value) => {
        PromiseLibrary = value;
      }
    });
    Object.defineProperty(module.exports, "valueHandler", {
      enumerable: true,
      value: /* @__PURE__ */ new Map(),
      writable: false,
      configurable: false
    });
  }
});

// node_modules/rfdc/index.js
var require_rfdc = __commonJS({
  "node_modules/rfdc/index.js"(exports, module) {
    "use strict";
    module.exports = rfdc;
    function copyBuffer(cur) {
      if (cur instanceof Buffer) {
        return Buffer.from(cur);
      }
      return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length);
    }
    function rfdc(opts) {
      opts = opts || {};
      if (opts.circles) return rfdcCircles(opts);
      const constructorHandlers = /* @__PURE__ */ new Map();
      constructorHandlers.set(Date, (o) => new Date(o));
      constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
      constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
      if (opts.constructorHandlers) {
        for (const handler2 of opts.constructorHandlers) {
          constructorHandlers.set(handler2[0], handler2[1]);
        }
      }
      let handler = null;
      return opts.proto ? cloneProto : clone;
      function cloneArray(a, fn) {
        const keys = Object.keys(a);
        const a2 = new Array(keys.length);
        for (let i = 0; i < keys.length; i++) {
          const k = keys[i];
          const cur = a[k];
          if (typeof cur !== "object" || cur === null) {
            a2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            a2[k] = handler(cur, fn);
          } else if (ArrayBuffer.isView(cur)) {
            a2[k] = copyBuffer(cur);
          } else {
            a2[k] = fn(cur);
          }
        }
        return a2;
      }
      function clone(o) {
        if (typeof o !== "object" || o === null) return o;
        if (Array.isArray(o)) return cloneArray(o, clone);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, clone);
        }
        const o2 = {};
        for (const k in o) {
          if (Object.hasOwnProperty.call(o, k) === false) continue;
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, clone);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            o2[k] = clone(cur);
          }
        }
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null) return o;
        if (Array.isArray(o)) return cloneArray(o, cloneProto);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, cloneProto);
        }
        const o2 = {};
        for (const k in o) {
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, cloneProto);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            o2[k] = cloneProto(cur);
          }
        }
        return o2;
      }
    }
    function rfdcCircles(opts) {
      const refs = [];
      const refsNew = [];
      const constructorHandlers = /* @__PURE__ */ new Map();
      constructorHandlers.set(Date, (o) => new Date(o));
      constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
      constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
      if (opts.constructorHandlers) {
        for (const handler2 of opts.constructorHandlers) {
          constructorHandlers.set(handler2[0], handler2[1]);
        }
      }
      let handler = null;
      return opts.proto ? cloneProto : clone;
      function cloneArray(a, fn) {
        const keys = Object.keys(a);
        const a2 = new Array(keys.length);
        for (let i = 0; i < keys.length; i++) {
          const k = keys[i];
          const cur = a[k];
          if (typeof cur !== "object" || cur === null) {
            a2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            a2[k] = handler(cur, fn);
          } else if (ArrayBuffer.isView(cur)) {
            a2[k] = copyBuffer(cur);
          } else {
            const index = refs.indexOf(cur);
            if (index !== -1) {
              a2[k] = refsNew[index];
            } else {
              a2[k] = fn(cur);
            }
          }
        }
        return a2;
      }
      function clone(o) {
        if (typeof o !== "object" || o === null) return o;
        if (Array.isArray(o)) return cloneArray(o, clone);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, clone);
        }
        const o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (const k in o) {
          if (Object.hasOwnProperty.call(o, k) === false) continue;
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, clone);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            const i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k] = refsNew[i];
            } else {
              o2[k] = clone(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null) return o;
        if (Array.isArray(o)) return cloneArray(o, cloneProto);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, cloneProto);
        }
        const o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (const k in o) {
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, cloneProto);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            const i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k] = refsNew[i];
            } else {
              o2[k] = cloneProto(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
    }
  }
});

// node_modules/rfdc/default.js
var require_default = __commonJS({
  "node_modules/rfdc/default.js"(exports, module) {
    "use strict";
    module.exports = require_rfdc()();
  }
});

// node_modules/mssql/lib/error/prepared-statement-error.js
var require_prepared_statement_error = __commonJS({
  "node_modules/mssql/lib/error/prepared-statement-error.js"(exports, module) {
    "use strict";
    var MSSQLError = require_mssql_error();
    var PreparedStatementError = class extends MSSQLError {
      /**
       * Creates a new PreparedStatementError.
       *
       * @param {String} message Error message.
       * @param {String} [code] Error code.
       */
      constructor(message, code) {
        super(message, code);
        this.name = "PreparedStatementError";
      }
    };
    module.exports = PreparedStatementError;
  }
});

// node_modules/mssql/lib/error/request-error.js
var require_request_error = __commonJS({
  "node_modules/mssql/lib/error/request-error.js"(exports, module) {
    "use strict";
    var MSSQLError = require_mssql_error();
    var RequestError = class extends MSSQLError {
      /**
       * Creates a new RequestError.
       *
       * @param {String} message Error message.
       * @param {String} [code] Error code.
       */
      constructor(message, code) {
        super(message, code);
        if (message instanceof Error) {
          if (message.info) {
            this.number = message.info.number || message.code;
            this.lineNumber = message.info.lineNumber;
            this.state = message.info.state || message.sqlstate;
            this.class = message.info.class;
            this.serverName = message.info.serverName;
            this.procName = message.info.procName;
          } else {
            this.number = message.code;
            this.lineNumber = message.lineNumber;
            this.state = message.sqlstate;
            this.class = message.severity;
            this.serverName = message.serverName;
            this.procName = message.procName;
          }
        }
        this.name = "RequestError";
        const parsedMessage = /^\[Microsoft\]\[SQL Server Native Client 11\.0\](?:\[SQL Server\])?([\s\S]*)$/.exec(this.message);
        if (parsedMessage) {
          this.message = parsedMessage[1];
        }
      }
    };
    module.exports = RequestError;
  }
});

// node_modules/mssql/lib/error/transaction-error.js
var require_transaction_error = __commonJS({
  "node_modules/mssql/lib/error/transaction-error.js"(exports, module) {
    "use strict";
    var MSSQLError = require_mssql_error();
    var TransactionError = class extends MSSQLError {
      /**
       * Creates a new TransactionError.
       *
       * @param {String} message Error message.
       * @param {String} [code] Error code.
       */
      constructor(message, code) {
        super(message, code);
        this.name = "TransactionError";
      }
    };
    module.exports = TransactionError;
  }
});

// node_modules/mssql/lib/error/index.js
var require_error = __commonJS({
  "node_modules/mssql/lib/error/index.js"(exports, module) {
    "use strict";
    var ConnectionError = require_connection_error();
    var MSSQLError = require_mssql_error();
    var PreparedStatementError = require_prepared_statement_error();
    var RequestError = require_request_error();
    var TransactionError = require_transaction_error();
    module.exports = {
      ConnectionError,
      MSSQLError,
      PreparedStatementError,
      RequestError,
      TransactionError
    };
  }
});

// node_modules/mssql/lib/base/connection-pool.js
var require_connection_pool = __commonJS({
  "node_modules/mssql/lib/base/connection-pool.js"(exports, module) {
    "use strict";
    var { EventEmitter } = require_node_events();
    var debug = require_browser()("mssql:base");
    var { parseSqlConnectionString } = require_lib2();
    var tarn = require_tarn();
    var { IDS } = require_utils2();
    var ConnectionError = require_connection_error();
    var shared = require_shared();
    var clone = require_default();
    var { MSSQLError } = require_error();
    var ConnectionPool = class extends EventEmitter {
      /**
       * Create new Connection.
       *
       * @param {Object|String} config Connection configuration object or connection string.
       * @param {basicCallback} [callback] A callback which is called after connection has established, or an error has occurred.
       */
      constructor(config, callback) {
        super();
        IDS.add(this, "ConnectionPool");
        debug("pool(%d): created", IDS.get(this));
        this._connectStack = [];
        this._closeStack = [];
        this._connected = false;
        this._connecting = false;
        this._healthy = false;
        if (typeof config === "string") {
          try {
            this.config = this.constructor.parseConnectionString(config);
          } catch (ex) {
            if (typeof callback === "function") {
              return setImmediate(callback, ex);
            }
            throw ex;
          }
        } else {
          this.config = clone(config);
        }
        this.config.port = this.config.port || 1433;
        this.config.options = this.config.options || {};
        this.config.stream = this.config.stream || false;
        this.config.parseJSON = this.config.parseJSON || false;
        this.config.arrayRowMode = this.config.arrayRowMode || false;
        this.config.validateConnection = "validateConnection" in this.config ? this.config.validateConnection : true;
        const namedServer = /^(.*)\\(.*)$/.exec(this.config.server);
        if (namedServer) {
          this.config.server = namedServer[1];
          this.config.options.instanceName = namedServer[2];
        }
        if (typeof this.config.options.useColumnNames !== "undefined" && this.config.options.useColumnNames !== true) {
          const ex = new MSSQLError("Invalid options `useColumnNames`, use `arrayRowMode` instead");
          if (typeof callback === "function") {
            return setImmediate(callback, ex);
          }
          throw ex;
        }
        if (typeof callback === "function") {
          this.connect(callback);
        }
      }
      get connected() {
        return this._connected;
      }
      get connecting() {
        return this._connecting;
      }
      get healthy() {
        return this._healthy;
      }
      static parseConnectionString(connectionString) {
        return this._parseConnectionString(connectionString);
      }
      static _parseAuthenticationType(type, entries) {
        switch (type.toLowerCase()) {
          case "active directory integrated":
            if (entries.includes("token")) {
              return "azure-active-directory-access-token";
            } else if (["client id", "client secret", "tenant id"].every((entry) => entries.includes(entry))) {
              return "azure-active-directory-service-principal-secret";
            } else if (["client id", "msi endpoint", "msi secret"].every((entry) => entries.includes(entry))) {
              return "azure-active-directory-msi-app-service";
            } else if (["client id", "msi endpoint"].every((entry) => entries.includes(entry))) {
              return "azure-active-directory-msi-vm";
            }
            return "azure-active-directory-default";
          case "active directory password":
            return "azure-active-directory-password";
          case "ntlm":
            return "ntlm";
          default:
            return "default";
        }
      }
      static _parseConnectionString(connectionString) {
        const parsed = parseSqlConnectionString(connectionString, true, true);
        return Object.entries(parsed).reduce((config, [key, value]) => {
          switch (key) {
            case "application name":
              break;
            case "applicationintent":
              Object.assign(config.options, {
                readOnlyIntent: value === "readonly"
              });
              break;
            case "asynchronous processing":
              break;
            case "attachdbfilename":
              break;
            case "authentication":
              Object.assign(config, {
                authentication_type: this._parseAuthenticationType(value, Object.keys(parsed))
              });
              break;
            case "column encryption setting":
              break;
            case "connection timeout":
              Object.assign(config, {
                connectionTimeout: value * 1e3
              });
              break;
            case "connection lifetime":
              break;
            case "connectretrycount":
              break;
            case "connectretryinterval":
              Object.assign(config.options, {
                connectionRetryInterval: value * 1e3
              });
              break;
            case "context connection":
              break;
            case "client id":
              Object.assign(config, {
                clientId: value
              });
              break;
            case "client secret":
              Object.assign(config, {
                clientSecret: value
              });
              break;
            case "current language":
              Object.assign(config.options, {
                language: value
              });
              break;
            case "data source": {
              let server = value;
              let instanceName;
              let port = 1433;
              if (/^np:/i.test(server)) {
                throw new Error("Connection via Named Pipes is not supported.");
              }
              if (/^tcp:/i.test(server)) {
                server = server.substr(4);
              }
              const namedServerParts = /^(.*)\\(.*)$/.exec(server);
              if (namedServerParts) {
                server = namedServerParts[1].trim();
                instanceName = namedServerParts[2].trim();
              }
              const serverParts = /^(.*),(.*)$/.exec(server);
              if (serverParts) {
                server = serverParts[1].trim();
                port = parseInt(serverParts[2].trim(), 10);
              } else {
                const instanceParts = /^(.*),(.*)$/.exec(instanceName);
                if (instanceParts) {
                  instanceName = instanceParts[1].trim();
                  port = parseInt(instanceParts[2].trim(), 10);
                }
              }
              if (server === "." || server === "(.)" || server.toLowerCase() === "(localdb)" || server.toLowerCase() === "(local)") {
                server = "localhost";
              }
              Object.assign(config, {
                port,
                server
              });
              if (instanceName) {
                Object.assign(config.options, {
                  instanceName
                });
              }
              break;
            }
            case "encrypt":
              Object.assign(config.options, {
                encrypt: !!value
              });
              break;
            case "enlist":
              break;
            case "failover partner":
              break;
            case "initial catalog":
              Object.assign(config, {
                database: value
              });
              break;
            case "integrated security":
              break;
            case "max pool size":
              Object.assign(config.pool, {
                max: value
              });
              break;
            case "min pool size":
              Object.assign(config.pool, {
                min: value
              });
              break;
            case "msi endpoint":
              Object.assign(config, {
                msiEndpoint: value
              });
              break;
            case "msi secret":
              Object.assign(config, {
                msiSecret: value
              });
              break;
            case "multipleactiveresultsets":
              break;
            case "multisubnetfailover":
              Object.assign(config.options, {
                multiSubnetFailover: value
              });
              break;
            case "network library":
              break;
            case "packet size":
              Object.assign(config.options, {
                packetSize: value
              });
              break;
            case "password":
              Object.assign(config, {
                password: value
              });
              break;
            case "persist security info":
              break;
            case "poolblockingperiod":
              break;
            case "pooling":
              break;
            case "replication":
              break;
            case "tenant id":
              Object.assign(config, {
                tenantId: value
              });
              break;
            case "token":
              Object.assign(config, {
                token: value
              });
              break;
            case "transaction binding":
              Object.assign(config.options, {
                enableImplicitTransactions: value.toLowerCase() === "implicit unbind"
              });
              break;
            case "transparentnetworkipresolution":
              break;
            case "trustservercertificate":
              Object.assign(config.options, {
                trustServerCertificate: value
              });
              break;
            case "type system version":
              break;
            case "user id": {
              let user = value;
              let domain;
              const domainUser = /^(.*)\\(.*)$/.exec(user);
              if (domainUser) {
                domain = domainUser[1];
                user = domainUser[2];
              }
              if (domain) {
                Object.assign(config, {
                  domain
                });
              }
              if (user) {
                Object.assign(config, {
                  user
                });
              }
              break;
            }
            case "user instance":
              break;
            case "workstation id":
              Object.assign(config.options, {
                workstationId: value
              });
              break;
            case "request timeout":
              Object.assign(config, {
                requestTimeout: parseInt(value, 10)
              });
              break;
            case "stream":
              Object.assign(config, {
                stream: !!value
              });
              break;
            case "useutc":
              Object.assign(config.options, {
                useUTC: !!value
              });
              break;
            case "parsejson":
              Object.assign(config, {
                parseJSON: !!value
              });
              break;
          }
          return config;
        }, { options: {}, pool: {} });
      }
      /**
       * Acquire connection from this connection pool.
       *
       * @param {ConnectionPool|Transaction|PreparedStatement} requester Requester.
       * @param {acquireCallback} [callback] A callback which is called after connection has been acquired, or an error has occurred. If omited, method returns Promise.
       * @return {ConnectionPool|Promise}
       */
      acquire(requester, callback) {
        const acquirePromise = shared.Promise.resolve(this._acquire()).catch((err) => {
          this.emit("error", err);
          throw err;
        });
        if (typeof callback === "function") {
          acquirePromise.then((connection) => callback(null, connection, this.config)).catch(callback);
          return this;
        }
        return acquirePromise;
      }
      _acquire() {
        if (!this.pool) {
          return shared.Promise.reject(new ConnectionError("Connection not yet open.", "ENOTOPEN"));
        } else if (this.pool.destroyed) {
          return shared.Promise.reject(new ConnectionError("Connection is closing", "ENOTOPEN"));
        }
        return this.pool.acquire().promise;
      }
      /**
       * Release connection back to the pool.
       *
       * @param {Connection} connection Previously acquired connection.
       * @return {ConnectionPool}
       */
      release(connection) {
        debug("connection(%d): released", IDS.get(connection));
        if (this.pool) {
          this.pool.release(connection);
        }
        return this;
      }
      /**
       * Creates a new connection pool with one active connection. This one initial connection serves as a probe to find out whether the configuration is valid.
       *
       * @param {basicCallback} [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.
       * @return {ConnectionPool|Promise}
       */
      connect(callback) {
        if (typeof callback === "function") {
          this._connect(callback);
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          return this._connect((err) => {
            if (err) return reject(err);
            resolve(this);
          });
        });
      }
      /**
       * @private
       * @param {basicCallback} callback
       */
      _connect(callback) {
        if (this._connected) {
          debug("pool(%d): already connected, executing connect callback immediately", IDS.get(this));
          return setImmediate(callback, null, this);
        }
        this._connectStack.push(callback);
        if (this._connecting) {
          return;
        }
        this._connecting = true;
        debug("pool(%d): connecting", IDS.get(this));
        this._poolCreate().then((connection) => {
          debug("pool(%d): connected", IDS.get(this));
          this._healthy = true;
          return this._poolDestroy(connection).then(() => {
            this.pool = new tarn.Pool(
              Object.assign({
                create: () => this._poolCreate().then((connection2) => {
                  this._healthy = true;
                  return connection2;
                }).catch((err) => {
                  if (this.pool.numUsed() + this.pool.numFree() <= 0) {
                    this._healthy = false;
                  }
                  throw err;
                }),
                validate: this._poolValidate.bind(this),
                destroy: this._poolDestroy.bind(this),
                max: 10,
                min: 0,
                idleTimeoutMillis: 3e4,
                propagateCreateError: true
              }, this.config.pool)
            );
            this._connecting = false;
            this._connected = true;
          });
        }).then(() => {
          this._connectStack.forEach((cb) => {
            setImmediate(cb, null, this);
          });
        }).catch((err) => {
          this._connecting = false;
          this._connectStack.forEach((cb) => {
            setImmediate(cb, err);
          });
        }).then(() => {
          this._connectStack = [];
        });
      }
      get size() {
        return this.pool.numFree() + this.pool.numUsed() + this.pool.numPendingCreates();
      }
      get available() {
        return this.pool.numFree();
      }
      get pending() {
        return this.pool.numPendingAcquires();
      }
      get borrowed() {
        return this.pool.numUsed();
      }
      /**
       * Close all active connections in the pool.
       *
       * @param {basicCallback} [callback] A callback which is called after connection has closed, or an error has occurred. If omited, method returns Promise.
       * @return {ConnectionPool|Promise}
       */
      close(callback) {
        if (typeof callback === "function") {
          this._close(callback);
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          this._close((err) => {
            if (err) return reject(err);
            resolve(this);
          });
        });
      }
      /**
       * @private
       * @param {basicCallback} callback
       */
      _close(callback) {
        if (this._connecting) {
          debug("pool(%d): close called while connecting", IDS.get(this));
          setImmediate(callback, new ConnectionError("Cannot close a pool while it is connecting"));
        }
        if (!this.pool) {
          debug("pool(%d): already closed, executing close callback immediately", IDS.get(this));
          return setImmediate(callback, null);
        }
        this._closeStack.push(callback);
        if (this.pool.destroyed) return;
        this._connecting = this._connected = this._healthy = false;
        this.pool.destroy().then(() => {
          debug("pool(%d): pool closed, removing pool reference and executing close callbacks", IDS.get(this));
          this.pool = null;
          this._closeStack.forEach((cb) => {
            setImmediate(cb, null);
          });
        }).catch((err) => {
          this.pool = null;
          this._closeStack.forEach((cb) => {
            setImmediate(cb, err);
          });
        }).then(() => {
          this._closeStack = [];
        });
      }
      /**
       * Returns new request using this connection.
       *
       * @return {Request}
       */
      request() {
        return new shared.driver.Request(this);
      }
      /**
       * Returns new transaction using this connection.
       *
       * @return {Transaction}
       */
      transaction() {
        return new shared.driver.Transaction(this);
      }
      /**
       * Creates a new query using this connection from a tagged template string.
       *
       * @variation 1
       * @param {Array} strings Array of string literals.
       * @param {...*} keys Values.
       * @return {Request}
       */
      /**
       * Execute the SQL command.
       *
       * @variation 2
       * @param {String} command T-SQL command to be executed.
       * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
       * @return {Request|Promise}
       */
      query() {
        if (typeof arguments[0] === "string") {
          return new shared.driver.Request(this).query(arguments[0], arguments[1]);
        }
        const values = Array.prototype.slice.call(arguments);
        const strings = values.shift();
        return new shared.driver.Request(this)._template(strings, values, "query");
      }
      /**
       * Creates a new batch using this connection from a tagged template string.
       *
       * @variation 1
       * @param {Array} strings Array of string literals.
       * @param {...*} keys Values.
       * @return {Request}
       */
      /**
       * Execute the SQL command.
       *
       * @variation 2
       * @param {String} command T-SQL command to be executed.
       * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
       * @return {Request|Promise}
       */
      batch() {
        if (typeof arguments[0] === "string") {
          return new shared.driver.Request(this).batch(arguments[0], arguments[1]);
        }
        const values = Array.prototype.slice.call(arguments);
        const strings = values.shift();
        return new shared.driver.Request(this)._template(strings, values, "batch");
      }
    };
    module.exports = ConnectionPool;
  }
});

// node_modules/mssql/lib/global-connection.js
var require_global_connection = __commonJS({
  "node_modules/mssql/lib/global-connection.js"(exports, module) {
    "use strict";
    var shared = require_shared();
    var globalConnection = null;
    var globalConnectionHandlers = {};
    function connect(config, callback) {
      if (!globalConnection) {
        globalConnection = new shared.driver.ConnectionPool(config);
        for (const event in globalConnectionHandlers) {
          for (let i = 0, l = globalConnectionHandlers[event].length; i < l; i++) {
            globalConnection.on(event, globalConnectionHandlers[event][i]);
          }
        }
        const ogClose = globalConnection.close;
        const globalClose = function(callback2) {
          for (const event in globalConnectionHandlers) {
            for (let i = 0, l = globalConnectionHandlers[event].length; i < l; i++) {
              this.removeListener(event, globalConnectionHandlers[event][i]);
            }
          }
          this.on("error", (err) => {
            if (globalConnectionHandlers.error) {
              for (let i = 0, l = globalConnectionHandlers.error.length; i < l; i++) {
                globalConnectionHandlers.error[i].call(this, err);
              }
            }
          });
          globalConnection = null;
          return ogClose.call(this, callback2);
        };
        globalConnection.close = globalClose.bind(globalConnection);
      }
      if (typeof callback === "function") {
        return globalConnection.connect((err, connection) => {
          if (err) {
            globalConnection = null;
          }
          callback(err, connection);
        });
      }
      return globalConnection.connect().catch((err) => {
        globalConnection = null;
        return shared.Promise.reject(err);
      });
    }
    function close(callback) {
      if (globalConnection) {
        const gc = globalConnection;
        globalConnection = null;
        return gc.close(callback);
      }
      if (typeof callback === "function") {
        setImmediate(callback);
        return null;
      }
      return new shared.Promise((resolve) => {
        resolve(globalConnection);
      });
    }
    function on(event, handler) {
      if (!globalConnectionHandlers[event]) globalConnectionHandlers[event] = [];
      globalConnectionHandlers[event].push(handler);
      if (globalConnection) globalConnection.on(event, handler);
      return globalConnection;
    }
    function removeListener(event, handler) {
      if (!globalConnectionHandlers[event]) return globalConnection;
      const index = globalConnectionHandlers[event].indexOf(handler);
      if (index === -1) return globalConnection;
      globalConnectionHandlers[event].splice(index, 1);
      if (globalConnectionHandlers[event].length === 0) globalConnectionHandlers[event] = void 0;
      if (globalConnection) globalConnection.removeListener(event, handler);
      return globalConnection;
    }
    function query() {
      if (typeof arguments[0] === "string") {
        return new shared.driver.Request().query(arguments[0], arguments[1]);
      }
      const values = Array.prototype.slice.call(arguments);
      const strings = values.shift();
      return new shared.driver.Request()._template(strings, values, "query");
    }
    function batch() {
      if (typeof arguments[0] === "string") {
        return new shared.driver.Request().batch(arguments[0], arguments[1]);
      }
      const values = Array.prototype.slice.call(arguments);
      const strings = values.shift();
      return new shared.driver.Request()._template(strings, values, "batch");
    }
    module.exports = {
      batch,
      close,
      connect,
      off: removeListener,
      on,
      query,
      removeListener
    };
    Object.defineProperty(module.exports, "pool", {
      get: () => {
        return globalConnection;
      },
      set: () => {
      }
    });
  }
});

// node_modules/mssql/lib/base/prepared-statement.js
var require_prepared_statement = __commonJS({
  "node_modules/mssql/lib/base/prepared-statement.js"(exports, module) {
    "use strict";
    var debug = require_browser()("mssql:base");
    var { EventEmitter } = require_node_events();
    var { IDS, objectHasProperty: objectHasProperty2 } = require_utils2();
    var globalConnection = require_global_connection();
    var { TransactionError, PreparedStatementError } = require_error();
    var shared = require_shared();
    var { TYPES, declare } = require_datatypes();
    var PreparedStatement = class extends EventEmitter {
      /**
       * Creates a new Prepared Statement.
       *
       * @param {ConnectionPool|Transaction} [holder]
       */
      constructor(parent) {
        super();
        IDS.add(this, "PreparedStatement");
        debug("ps(%d): created", IDS.get(this));
        this.parent = parent || globalConnection.pool;
        this._handle = 0;
        this.prepared = false;
        this.parameters = {};
      }
      get config() {
        return this.parent.config;
      }
      get connected() {
        return this.parent.connected;
      }
      /**
       * Acquire connection from connection pool.
       *
       * @param {Request} request Request.
       * @param {ConnectionPool~acquireCallback} [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.
       * @return {PreparedStatement|Promise}
       */
      acquire(request, callback) {
        if (!this._acquiredConnection) {
          setImmediate(callback, new PreparedStatementError("Statement is not prepared. Call prepare() first.", "ENOTPREPARED"));
          return this;
        }
        if (this._activeRequest) {
          setImmediate(callback, new TransactionError("Can't acquire connection for the request. There is another request in progress.", "EREQINPROG"));
          return this;
        }
        this._activeRequest = request;
        setImmediate(callback, null, this._acquiredConnection, this._acquiredConfig);
        return this;
      }
      /**
       * Release connection back to the pool.
       *
       * @param {Connection} connection Previously acquired connection.
       * @return {PreparedStatement}
       */
      release(connection) {
        if (connection === this._acquiredConnection) {
          this._activeRequest = null;
        }
        return this;
      }
      /**
       * Add an input parameter to the prepared statement.
       *
       * @param {String} name Name of the input parameter without @ char.
       * @param {*} type SQL data type of input parameter.
       * @return {PreparedStatement}
       */
      input(name3, type) {
        if (/--| |\/\*|\*\/|'/.test(name3)) {
          throw new PreparedStatementError(`SQL injection warning for param '${name3}'`, "EINJECT");
        }
        if (arguments.length < 2) {
          throw new PreparedStatementError("Invalid number of arguments. 2 arguments expected.", "EARGS");
        }
        if (type instanceof Function) {
          type = type();
        }
        if (objectHasProperty2(this.parameters, name3)) {
          throw new PreparedStatementError(`The parameter name ${name3} has already been declared. Parameter names must be unique`, "EDUPEPARAM");
        }
        this.parameters[name3] = {
          name: name3,
          type: type.type,
          io: 1,
          length: type.length,
          scale: type.scale,
          precision: type.precision,
          tvpType: type.tvpType
        };
        return this;
      }
      /**
       * Replace an input parameter on the request.
       *
       * @param {String} name Name of the input parameter without @ char.
       * @param {*} [type] SQL data type of input parameter. If you omit type, module automaticaly decide which SQL data type should be used based on JS data type.
       * @param {*} value Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.
       * @return {Request}
       */
      replaceInput(name3, type, value) {
        delete this.parameters[name3];
        return this.input(name3, type, value);
      }
      /**
       * Add an output parameter to the prepared statement.
       *
       * @param {String} name Name of the output parameter without @ char.
       * @param {*} type SQL data type of output parameter.
       * @return {PreparedStatement}
       */
      output(name3, type) {
        if (/--| |\/\*|\*\/|'/.test(name3)) {
          throw new PreparedStatementError(`SQL injection warning for param '${name3}'`, "EINJECT");
        }
        if (arguments.length < 2) {
          throw new PreparedStatementError("Invalid number of arguments. 2 arguments expected.", "EARGS");
        }
        if (type instanceof Function) type = type();
        if (objectHasProperty2(this.parameters, name3)) {
          throw new PreparedStatementError(`The parameter name ${name3} has already been declared. Parameter names must be unique`, "EDUPEPARAM");
        }
        this.parameters[name3] = {
          name: name3,
          type: type.type,
          io: 2,
          length: type.length,
          scale: type.scale,
          precision: type.precision
        };
        return this;
      }
      /**
       * Replace an output parameter on the request.
       *
       * @param {String} name Name of the output parameter without @ char.
       * @param {*} type SQL data type of output parameter.
       * @return {PreparedStatement}
       */
      replaceOutput(name3, type) {
        delete this.parameters[name3];
        return this.output(name3, type);
      }
      /**
       * Prepare a statement.
       *
       * @param {String} statement SQL statement to prepare.
       * @param {basicCallback} [callback] A callback which is called after preparation has completed, or an error has occurred. If omited, method returns Promise.
       * @return {PreparedStatement|Promise}
       */
      prepare(statement, callback) {
        if (typeof callback === "function") {
          this._prepare(statement, callback);
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          this._prepare(statement, (err) => {
            if (err) return reject(err);
            resolve(this);
          });
        });
      }
      /**
       * @private
       * @param {String} statement
       * @param {basicCallback} callback
       */
      _prepare(statement, callback) {
        debug("ps(%d): prepare", IDS.get(this));
        if (typeof statement === "function") {
          callback = statement;
          statement = void 0;
        }
        if (this.prepared) {
          return setImmediate(callback, new PreparedStatementError("Statement is already prepared.", "EALREADYPREPARED"));
        }
        this.statement = statement || this.statement;
        this.parent.acquire(this, (err, connection, config) => {
          if (err) return callback(err);
          this._acquiredConnection = connection;
          this._acquiredConfig = config;
          const req = new shared.driver.Request(this);
          req.stream = false;
          req.output("handle", TYPES.Int);
          req.input("params", TYPES.NVarChar, (() => {
            const result = [];
            for (const name3 in this.parameters) {
              if (!objectHasProperty2(this.parameters, name3)) {
                continue;
              }
              const param = this.parameters[name3];
              result.push(`@${name3} ${declare(param.type, param)}${param.io === 2 ? " output" : ""}`);
            }
            return result;
          })().join(","));
          req.input("stmt", TYPES.NVarChar, this.statement);
          req.execute("sp_prepare", (err2, result) => {
            if (err2) {
              this.parent.release(this._acquiredConnection);
              this._acquiredConnection = null;
              this._acquiredConfig = null;
              return callback(err2);
            }
            debug("ps(%d): prepared", IDS.get(this));
            this._handle = result.output.handle;
            this.prepared = true;
            callback(null);
          });
        });
      }
      /**
       * Execute a prepared statement.
       *
       * @param {Object} values An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.
       * @param {basicCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
       * @return {Request|Promise}
       */
      execute(values, callback) {
        if (this.stream || typeof callback === "function") {
          return this._execute(values, callback);
        }
        return new shared.Promise((resolve, reject) => {
          this._execute(values, (err, recordset) => {
            if (err) return reject(err);
            resolve(recordset);
          });
        });
      }
      /**
       * @private
       * @param {Object} values
       * @param {basicCallback} callback
       */
      _execute(values, callback) {
        const req = new shared.driver.Request(this);
        req.stream = this.stream;
        req.arrayRowMode = this.arrayRowMode;
        req.input("handle", TYPES.Int, this._handle);
        for (const name3 in this.parameters) {
          if (!objectHasProperty2(this.parameters, name3)) {
            continue;
          }
          const param = this.parameters[name3];
          req.parameters[name3] = {
            name: name3,
            type: param.type,
            io: param.io,
            value: values[name3],
            length: param.length,
            scale: param.scale,
            precision: param.precision
          };
        }
        req.execute("sp_execute", (err, result) => {
          if (err) return callback(err);
          callback(null, result);
        });
        return req;
      }
      /**
       * Unprepare a prepared statement.
       *
       * @param {basicCallback} [callback] A callback which is called after unpreparation has completed, or an error has occurred. If omited, method returns Promise.
       * @return {PreparedStatement|Promise}
       */
      unprepare(callback) {
        if (typeof callback === "function") {
          this._unprepare(callback);
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          this._unprepare((err) => {
            if (err) return reject(err);
            resolve();
          });
        });
      }
      /**
       * @private
       * @param {basicCallback} callback
       */
      _unprepare(callback) {
        debug("ps(%d): unprepare", IDS.get(this));
        if (!this.prepared) {
          return setImmediate(callback, new PreparedStatementError("Statement is not prepared. Call prepare() first.", "ENOTPREPARED"));
        }
        if (this._activeRequest) {
          return setImmediate(callback, new TransactionError("Can't unprepare the statement. There is a request in progress.", "EREQINPROG"));
        }
        const req = new shared.driver.Request(this);
        req.stream = false;
        req.input("handle", TYPES.Int, this._handle);
        req.execute("sp_unprepare", (err) => {
          if (err) return callback(err);
          this.parent.release(this._acquiredConnection);
          this._acquiredConnection = null;
          this._acquiredConfig = null;
          this._handle = 0;
          this.prepared = false;
          debug("ps(%d): unprepared", IDS.get(this));
          return callback(null);
        });
      }
    };
    module.exports = PreparedStatement;
  }
});

// browser-external:node:stream
var require_node_stream = __commonJS({
  "browser-external:node:stream"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:stream" has been externalized for browser compatibility. Cannot access "node:stream.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/mssql/lib/base/request.js
var require_request = __commonJS({
  "node_modules/mssql/lib/base/request.js"(exports, module) {
    "use strict";
    var debug = require_browser()("mssql:base");
    var { EventEmitter } = require_node_events();
    var { Readable } = require_node_stream();
    var { IDS, objectHasProperty: objectHasProperty2 } = require_utils2();
    var globalConnection = require_global_connection();
    var { RequestError, ConnectionError } = require_error();
    var { TYPES } = require_datatypes();
    var shared = require_shared();
    var Request2 = class extends EventEmitter {
      /**
       * Create new Request.
       *
       * @param {Connection|ConnectionPool|Transaction|PreparedStatement} parent If omitted, global connection is used instead.
       */
      constructor(parent) {
        super();
        IDS.add(this, "Request");
        debug("request(%d): created", IDS.get(this));
        this.canceled = false;
        this._paused = false;
        this.parent = parent || globalConnection.pool;
        this.parameters = {};
        this.stream = null;
        this.arrayRowMode = null;
      }
      get paused() {
        return this._paused;
      }
      /**
       * Generate sql string and set input parameters from tagged template string.
       *
       * @param {Template literal} template
       * @return {String}
       */
      template() {
        const values = Array.prototype.slice.call(arguments);
        const strings = values.shift();
        return this._template(strings, values);
      }
      /**
       * Fetch request from tagged template string.
       *
       * @private
       * @param {Array} strings
       * @param {Array} values
       * @param {String} [method] If provided, method is automatically called with serialized command on this object.
       * @return {Request}
       */
      _template(strings, values, method) {
        const command = [strings[0]];
        for (let index = 0; index < values.length; index++) {
          const value = values[index];
          if (Array.isArray(value)) {
            for (let parameterIndex = 0; parameterIndex < value.length; parameterIndex++) {
              this.input(`param${index + 1}_${parameterIndex}`, value[parameterIndex]);
              command.push(`@param${index + 1}_${parameterIndex}`);
              if (parameterIndex < value.length - 1) {
                command.push(", ");
              }
            }
            command.push(strings[index + 1]);
          } else {
            this.input(`param${index + 1}`, value);
            command.push(`@param${index + 1}`, strings[index + 1]);
          }
        }
        if (method) {
          return this[method](command.join(""));
        } else {
          return command.join("");
        }
      }
      /**
       * Add an input parameter to the request.
       *
       * @param {String} name Name of the input parameter without @ char.
       * @param {*} [type] SQL data type of input parameter. If you omit type, module automaticaly decide which SQL data type should be used based on JS data type.
       * @param {*} value Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.
       * @return {Request}
       */
      input(name3, type, value) {
        if (/--| |\/\*|\*\/|'/.test(name3)) {
          throw new RequestError(`SQL injection warning for param '${name3}'`, "EINJECT");
        }
        if (arguments.length < 2) {
          throw new RequestError("Invalid number of arguments. At least 2 arguments expected.", "EARGS");
        } else if (arguments.length === 2) {
          value = type;
          type = shared.getTypeByValue(value);
        }
        if (value && typeof value.valueOf === "function" && !(value instanceof Date)) value = value.valueOf();
        if (value === void 0) value = null;
        if (typeof value === "number" && isNaN(value)) value = null;
        if (type instanceof Function) type = type();
        if (objectHasProperty2(this.parameters, name3)) {
          throw new RequestError(`The parameter name ${name3} has already been declared. Parameter names must be unique`, "EDUPEPARAM");
        }
        this.parameters[name3] = {
          name: name3,
          type: type.type,
          io: 1,
          value,
          length: type.length,
          scale: type.scale,
          precision: type.precision,
          tvpType: type.tvpType
        };
        return this;
      }
      /**
       * Replace an input parameter on the request.
       *
       * @param {String} name Name of the input parameter without @ char.
       * @param {*} [type] SQL data type of input parameter. If you omit type, module automaticaly decide which SQL data type should be used based on JS data type.
       * @param {*} value Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.
       * @return {Request}
       */
      replaceInput(name3, type, value) {
        delete this.parameters[name3];
        return this.input(name3, type, value);
      }
      /**
       * Add an output parameter to the request.
       *
       * @param {String} name Name of the output parameter without @ char.
       * @param {*} type SQL data type of output parameter.
       * @param {*} [value] Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.
       * @return {Request}
       */
      output(name3, type, value) {
        if (!type) {
          type = TYPES.NVarChar;
        }
        if (/--| |\/\*|\*\/|'/.test(name3)) {
          throw new RequestError(`SQL injection warning for param '${name3}'`, "EINJECT");
        }
        if (type === TYPES.Text || type === TYPES.NText || type === TYPES.Image) {
          throw new RequestError("Deprecated types (Text, NText, Image) are not supported as OUTPUT parameters.", "EDEPRECATED");
        }
        if (value && typeof value.valueOf === "function" && !(value instanceof Date)) value = value.valueOf();
        if (value === void 0) value = null;
        if (typeof value === "number" && isNaN(value)) value = null;
        if (type instanceof Function) type = type();
        if (objectHasProperty2(this.parameters, name3)) {
          throw new RequestError(`The parameter name ${name3} has already been declared. Parameter names must be unique`, "EDUPEPARAM");
        }
        this.parameters[name3] = {
          name: name3,
          type: type.type,
          io: 2,
          value,
          length: type.length,
          scale: type.scale,
          precision: type.precision
        };
        return this;
      }
      /**
       * Replace an output parameter on the request.
       *
       * @param {String} name Name of the output parameter without @ char.
       * @param {*} type SQL data type of output parameter.
       * @param {*} [value] Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.
       * @return {Request}
       */
      replaceOutput(name3, type, value) {
        delete this.parameters[name3];
        return this.output(name3, type, value);
      }
      /**
       * Execute the SQL batch.
       *
       * @param {String} batch T-SQL batch to be executed.
       * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
       * @return {Request|Promise}
       */
      batch(batch, callback) {
        if (this.stream === null && this.parent) this.stream = this.parent.config.stream;
        if (this.arrayRowMode === null && this.parent) this.arrayRowMode = this.parent.config.arrayRowMode;
        this.rowsAffected = 0;
        if (typeof callback === "function") {
          this._batch(batch, (err, recordsets, output, rowsAffected) => {
            if (this.stream) {
              if (err) this.emit("error", err);
              err = null;
              this.emit("done", {
                output,
                rowsAffected
              });
            }
            if (err) return callback(err);
            callback(null, {
              recordsets,
              recordset: recordsets && recordsets[0],
              output,
              rowsAffected
            });
          });
          return this;
        }
        if (typeof batch === "object") {
          const values = Array.prototype.slice.call(arguments);
          const strings = values.shift();
          batch = this._template(strings, values);
        }
        return new shared.Promise((resolve, reject) => {
          this._batch(batch, (err, recordsets, output, rowsAffected) => {
            if (this.stream) {
              if (err) this.emit("error", err);
              err = null;
              this.emit("done", {
                output,
                rowsAffected
              });
            }
            if (err) return reject(err);
            resolve({
              recordsets,
              recordset: recordsets && recordsets[0],
              output,
              rowsAffected
            });
          });
        });
      }
      /**
       * @private
       * @param {String} batch
       * @param {Request~requestCallback} callback
       */
      _batch(batch, callback) {
        if (!this.parent) {
          return setImmediate(callback, new RequestError("No connection is specified for that request.", "ENOCONN"));
        }
        if (!this.parent.connected) {
          return setImmediate(callback, new ConnectionError("Connection is closed.", "ECONNCLOSED"));
        }
        this.canceled = false;
        setImmediate(callback);
      }
      /**
       * Bulk load.
       *
       * @param {Table} table SQL table.
       * @param {object} [options] Options to be passed to the underlying driver (tedious only).
       * @param {Request~bulkCallback} [callback] A callback which is called after bulk load has completed, or an error has occurred. If omited, method returns Promise.
       * @return {Request|Promise}
       */
      bulk(table, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        } else if (typeof options === "undefined") {
          options = {};
        }
        if (this.stream === null && this.parent) this.stream = this.parent.config.stream;
        if (this.arrayRowMode === null && this.parent) this.arrayRowMode = this.parent.config.arrayRowMode;
        if (this.stream || typeof callback === "function") {
          this._bulk(table, options, (err, rowsAffected) => {
            if (this.stream) {
              if (err) this.emit("error", err);
              return this.emit("done", {
                rowsAffected
              });
            }
            if (err) return callback(err);
            callback(null, {
              rowsAffected
            });
          });
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          this._bulk(table, options, (err, rowsAffected) => {
            if (err) return reject(err);
            resolve({
              rowsAffected
            });
          });
        });
      }
      /**
       * @private
       * @param {Table} table
       * @param {object} options
       * @param {Request~bulkCallback} callback
       */
      _bulk(table, options, callback) {
        if (!this.parent) {
          return setImmediate(callback, new RequestError("No connection is specified for that request.", "ENOCONN"));
        }
        if (!this.parent.connected) {
          return setImmediate(callback, new ConnectionError("Connection is closed.", "ECONNCLOSED"));
        }
        this.canceled = false;
        setImmediate(callback);
      }
      /**
       * Wrap original request in a Readable stream that supports back pressure and return.
       * It also sets request to `stream` mode and pulls all rows from all recordsets to a given stream.
       *
       * @param {Object} streamOptions - optional options to configure the readable stream with like highWaterMark
       * @return {Stream}
       */
      toReadableStream(streamOptions = {}) {
        this.stream = true;
        this.pause();
        const readableStream = new Readable({
          ...streamOptions,
          objectMode: true,
          read: () => {
            this.resume();
          }
        });
        this.on("row", (row) => {
          if (!readableStream.push(row)) {
            this.pause();
          }
        });
        this.on("error", (error) => {
          readableStream.emit("error", error);
        });
        this.on("done", () => {
          readableStream.push(null);
        });
        return readableStream;
      }
      /**
       * Wrap original request in a Readable stream that supports back pressure and pipe to the Writable stream.
       * It also sets request to `stream` mode and pulls all rows from all recordsets to a given stream.
       *
       * @param {Stream} stream Stream to pipe data into.
       * @return {Stream}
       */
      pipe(writableStream) {
        const readableStream = this.toReadableStream();
        return readableStream.pipe(writableStream);
      }
      /**
       * Execute the SQL command.
       *
       * @param {String} command T-SQL command to be executed.
       * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
       * @return {Request|Promise}
       */
      query(command, callback) {
        if (this.stream === null && this.parent) this.stream = this.parent.config.stream;
        if (this.arrayRowMode === null && this.parent) this.arrayRowMode = this.parent.config.arrayRowMode;
        this.rowsAffected = 0;
        if (typeof callback === "function") {
          this._query(command, (err, recordsets, output, rowsAffected, columns) => {
            if (this.stream) {
              if (err) this.emit("error", err);
              err = null;
              this.emit("done", {
                output,
                rowsAffected
              });
            }
            if (err) return callback(err);
            const result = {
              recordsets,
              recordset: recordsets && recordsets[0],
              output,
              rowsAffected
            };
            if (this.arrayRowMode) result.columns = columns;
            callback(null, result);
          });
          return this;
        }
        if (typeof command === "object") {
          const values = Array.prototype.slice.call(arguments);
          const strings = values.shift();
          command = this._template(strings, values);
        }
        return new shared.Promise((resolve, reject) => {
          this._query(command, (err, recordsets, output, rowsAffected, columns) => {
            if (this.stream) {
              if (err) this.emit("error", err);
              err = null;
              this.emit("done", {
                output,
                rowsAffected
              });
            }
            if (err) return reject(err);
            const result = {
              recordsets,
              recordset: recordsets && recordsets[0],
              output,
              rowsAffected
            };
            if (this.arrayRowMode) result.columns = columns;
            resolve(result);
          });
        });
      }
      /**
       * @private
       * @param {String} command
       * @param {Request~bulkCallback} callback
       */
      _query(command, callback) {
        if (!this.parent) {
          return setImmediate(callback, new RequestError("No connection is specified for that request.", "ENOCONN"));
        }
        if (!this.parent.connected) {
          return setImmediate(callback, new ConnectionError("Connection is closed.", "ECONNCLOSED"));
        }
        this.canceled = false;
        setImmediate(callback);
      }
      /**
       * Call a stored procedure.
       *
       * @param {String} procedure Name of the stored procedure to be executed.
       * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
       * @return {Request|Promise}
       */
      execute(command, callback) {
        if (this.stream === null && this.parent) this.stream = this.parent.config.stream;
        if (this.arrayRowMode === null && this.parent) this.arrayRowMode = this.parent.config.arrayRowMode;
        this.rowsAffected = 0;
        if (typeof callback === "function") {
          this._execute(command, (err, recordsets, output, returnValue, rowsAffected, columns) => {
            if (this.stream) {
              if (err) this.emit("error", err);
              err = null;
              this.emit("done", {
                output,
                rowsAffected,
                returnValue
              });
            }
            if (err) return callback(err);
            const result = {
              recordsets,
              recordset: recordsets && recordsets[0],
              output,
              rowsAffected,
              returnValue
            };
            if (this.arrayRowMode) result.columns = columns;
            callback(null, result);
          });
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          this._execute(command, (err, recordsets, output, returnValue, rowsAffected, columns) => {
            if (this.stream) {
              if (err) this.emit("error", err);
              err = null;
              this.emit("done", {
                output,
                rowsAffected,
                returnValue
              });
            }
            if (err) return reject(err);
            const result = {
              recordsets,
              recordset: recordsets && recordsets[0],
              output,
              rowsAffected,
              returnValue
            };
            if (this.arrayRowMode) result.columns = columns;
            resolve(result);
          });
        });
      }
      /**
       * @private
       * @param {String} procedure
       * @param {Request~bulkCallback} callback
       */
      _execute(procedure, callback) {
        if (!this.parent) {
          return setImmediate(callback, new RequestError("No connection is specified for that request.", "ENOCONN"));
        }
        if (!this.parent.connected) {
          return setImmediate(callback, new ConnectionError("Connection is closed.", "ECONNCLOSED"));
        }
        this.canceled = false;
        setImmediate(callback);
      }
      /**
       * Cancel currently executed request.
       *
       * @return {Boolean}
       */
      cancel() {
        this._cancel();
        return true;
      }
      /**
       * @private
       */
      _cancel() {
        this.canceled = true;
      }
      pause() {
        if (this.stream) {
          this._pause();
          return true;
        }
        return false;
      }
      _pause() {
        this._paused = true;
      }
      resume() {
        if (this.stream) {
          this._resume();
          return true;
        }
        return false;
      }
      _resume() {
        this._paused = false;
      }
      _setCurrentRequest(request) {
        this._currentRequest = request;
        if (this._paused) {
          this.pause();
        }
        return this;
      }
    };
    module.exports = Request2;
  }
});

// node_modules/mssql/lib/isolationlevel.js
var require_isolationlevel = __commonJS({
  "node_modules/mssql/lib/isolationlevel.js"(exports, module) {
    "use strict";
    module.exports = {
      READ_UNCOMMITTED: 1,
      READ_COMMITTED: 2,
      REPEATABLE_READ: 3,
      SERIALIZABLE: 4,
      SNAPSHOT: 5
    };
  }
});

// node_modules/mssql/lib/base/transaction.js
var require_transaction = __commonJS({
  "node_modules/mssql/lib/base/transaction.js"(exports, module) {
    "use strict";
    var debug = require_browser()("mssql:base");
    var { EventEmitter } = require_node_events();
    var { IDS } = require_utils2();
    var globalConnection = require_global_connection();
    var { TransactionError } = require_error();
    var shared = require_shared();
    var ISOLATION_LEVEL = require_isolationlevel();
    var Transaction = class _Transaction extends EventEmitter {
      /**
       * Create new Transaction.
       *
       * @param {Connection} [parent] If ommited, global connection is used instead.
       */
      constructor(parent) {
        super();
        IDS.add(this, "Transaction");
        debug("transaction(%d): created", IDS.get(this));
        this.parent = parent || globalConnection.pool;
        this.isolationLevel = _Transaction.defaultIsolationLevel;
        this.name = "";
      }
      get config() {
        return this.parent.config;
      }
      get connected() {
        return this.parent.connected;
      }
      /**
       * Acquire connection from connection pool.
       *
       * @param {Request} request Request.
       * @param {ConnectionPool~acquireCallback} [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.
       * @return {Transaction|Promise}
       */
      acquire(request, callback) {
        if (!this._acquiredConnection) {
          setImmediate(callback, new TransactionError("Transaction has not begun. Call begin() first.", "ENOTBEGUN"));
          return this;
        }
        if (this._activeRequest) {
          setImmediate(callback, new TransactionError("Can't acquire connection for the request. There is another request in progress.", "EREQINPROG"));
          return this;
        }
        this._activeRequest = request;
        setImmediate(callback, null, this._acquiredConnection, this._acquiredConfig);
        return this;
      }
      /**
       * Release connection back to the pool.
       *
       * @param {Connection} connection Previously acquired connection.
       * @return {Transaction}
       */
      release(connection) {
        if (connection === this._acquiredConnection) {
          this._activeRequest = null;
        }
        return this;
      }
      /**
       * Begin a transaction.
       *
       * @param {Number} [isolationLevel] Controls the locking and row versioning behavior of TSQL statements issued by a connection.
       * @param {basicCallback} [callback] A callback which is called after transaction has began, or an error has occurred. If omited, method returns Promise.
       * @return {Transaction|Promise}
       */
      begin(isolationLevel, callback) {
        if (isolationLevel instanceof Function) {
          callback = isolationLevel;
          isolationLevel = void 0;
        }
        if (typeof callback === "function") {
          this._begin(isolationLevel, (err) => {
            if (!err) {
              this.emit("begin");
            }
            callback(err);
          });
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          this._begin(isolationLevel, (err) => {
            if (err) return reject(err);
            this.emit("begin");
            resolve(this);
          });
        });
      }
      /**
       * @private
       * @param {Number} [isolationLevel]
       * @param {basicCallback} [callback]
       * @return {Transaction}
       */
      _begin(isolationLevel, callback) {
        if (this._acquiredConnection) {
          return setImmediate(callback, new TransactionError("Transaction has already begun.", "EALREADYBEGUN"));
        }
        this._aborted = false;
        this._rollbackRequested = false;
        if (isolationLevel) {
          if (Object.keys(ISOLATION_LEVEL).some((key) => {
            return ISOLATION_LEVEL[key] === isolationLevel;
          })) {
            this.isolationLevel = isolationLevel;
          } else {
            throw new TransactionError("Invalid isolation level.");
          }
        }
        setImmediate(callback);
      }
      /**
       * Commit a transaction.
       *
       * @param {basicCallback} [callback] A callback which is called after transaction has commited, or an error has occurred. If omited, method returns Promise.
       * @return {Transaction|Promise}
       */
      commit(callback) {
        if (typeof callback === "function") {
          this._commit((err) => {
            if (!err) {
              this.emit("commit");
            }
            callback(err);
          });
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          this._commit((err) => {
            if (err) return reject(err);
            this.emit("commit");
            resolve();
          });
        });
      }
      /**
       * @private
       * @param {basicCallback} [callback]
       * @return {Transaction}
       */
      _commit(callback) {
        if (this._aborted) {
          return setImmediate(callback, new TransactionError("Transaction has been aborted.", "EABORT"));
        }
        if (!this._acquiredConnection) {
          return setImmediate(callback, new TransactionError("Transaction has not begun. Call begin() first.", "ENOTBEGUN"));
        }
        if (this._activeRequest) {
          return setImmediate(callback, new TransactionError("Can't commit transaction. There is a request in progress.", "EREQINPROG"));
        }
        setImmediate(callback);
      }
      /**
       * Returns new request using this transaction.
       *
       * @return {Request}
       */
      request() {
        return new shared.driver.Request(this);
      }
      /**
       * Rollback a transaction.
       *
       * @param {basicCallback} [callback] A callback which is called after transaction has rolled back, or an error has occurred. If omited, method returns Promise.
       * @return {Transaction|Promise}
       */
      rollback(callback) {
        if (typeof callback === "function") {
          this._rollback((err) => {
            if (!err) {
              this.emit("rollback", this._aborted);
            }
            callback(err);
          });
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          return this._rollback((err) => {
            if (err) return reject(err);
            this.emit("rollback", this._aborted);
            resolve();
          });
        });
      }
      /**
       * @private
       * @param {basicCallback} [callback]
       * @return {Transaction}
       */
      _rollback(callback) {
        if (this._aborted) {
          return setImmediate(callback, new TransactionError("Transaction has been aborted.", "EABORT"));
        }
        if (!this._acquiredConnection) {
          return setImmediate(callback, new TransactionError("Transaction has not begun. Call begin() first.", "ENOTBEGUN"));
        }
        if (this._activeRequest) {
          return setImmediate(callback, new TransactionError("Can't rollback transaction. There is a request in progress.", "EREQINPROG"));
        }
        this._rollbackRequested = true;
        setImmediate(callback);
      }
    };
    Transaction.defaultIsolationLevel = ISOLATION_LEVEL.READ_COMMITTED;
    module.exports = Transaction;
  }
});

// node_modules/mssql/lib/base/index.js
var require_base = __commonJS({
  "node_modules/mssql/lib/base/index.js"(exports, module) {
    "use strict";
    var ConnectionPool = require_connection_pool();
    var PreparedStatement = require_prepared_statement();
    var Request2 = require_request();
    var Transaction = require_transaction();
    var { ConnectionError, TransactionError, RequestError, PreparedStatementError, MSSQLError } = require_error();
    var shared = require_shared();
    var Table = require_table();
    var ISOLATION_LEVEL = require_isolationlevel();
    var { TYPES } = require_datatypes();
    var { connect, close, on, off, removeListener, query, batch } = require_global_connection();
    module.exports = {
      ConnectionPool,
      Transaction,
      Request: Request2,
      PreparedStatement,
      ConnectionError,
      TransactionError,
      RequestError,
      PreparedStatementError,
      MSSQLError,
      driver: shared.driver,
      exports: {
        ConnectionError,
        TransactionError,
        RequestError,
        PreparedStatementError,
        MSSQLError,
        Table,
        ISOLATION_LEVEL,
        TYPES,
        MAX: 65535,
        // (1 << 16) - 1
        map: shared.map,
        getTypeByValue: shared.getTypeByValue,
        connect,
        close,
        on,
        removeListener,
        off,
        query,
        batch
      }
    };
    Object.defineProperty(module.exports, "Promise", {
      enumerable: true,
      get: () => {
        return shared.Promise;
      },
      set: (value) => {
        shared.Promise = value;
      }
    });
    Object.defineProperty(module.exports, "valueHandler", {
      enumerable: true,
      value: shared.valueHandler,
      writable: false,
      configurable: false
    });
    for (const key in TYPES) {
      const value = TYPES[key];
      module.exports.exports[key] = value;
      module.exports.exports[key.toUpperCase()] = value;
    }
  }
});

// node_modules/tedious/lib/tracking-buffer/writable-tracking-buffer.js
var require_writable_tracking_buffer = __commonJS({
  "node_modules/tedious/lib/tracking-buffer/writable-tracking-buffer.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
    var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
    var UNKNOWN_PLP_LEN = Buffer.from([254, 255, 255, 255, 255, 255, 255, 255]);
    var ZERO_LENGTH_BUFFER = Buffer.alloc(0);
    var WritableTrackingBuffer = class {
      constructor(initialSize, encoding, doubleSizeGrowth) {
        this.initialSize = initialSize;
        this.encoding = encoding || "ucs2";
        this.doubleSizeGrowth = doubleSizeGrowth || false;
        this.buffer = Buffer.alloc(this.initialSize, 0);
        this.compositeBuffer = ZERO_LENGTH_BUFFER;
        this.position = 0;
      }
      get data() {
        this.newBuffer(0);
        return this.compositeBuffer;
      }
      copyFrom(buffer) {
        const length = buffer.length;
        this.makeRoomFor(length);
        buffer.copy(this.buffer, this.position);
        this.position += length;
      }
      makeRoomFor(requiredLength) {
        if (this.buffer.length - this.position < requiredLength) {
          if (this.doubleSizeGrowth) {
            let size = Math.max(128, this.buffer.length * 2);
            while (size < requiredLength) {
              size *= 2;
            }
            this.newBuffer(size);
          } else {
            this.newBuffer(requiredLength);
          }
        }
      }
      newBuffer(size) {
        const buffer = this.buffer.slice(0, this.position);
        this.compositeBuffer = Buffer.concat([this.compositeBuffer, buffer]);
        this.buffer = size === 0 ? ZERO_LENGTH_BUFFER : Buffer.alloc(size, 0);
        this.position = 0;
      }
      writeUInt8(value) {
        const length = 1;
        this.makeRoomFor(length);
        this.buffer.writeUInt8(value, this.position);
        this.position += length;
      }
      writeUInt16LE(value) {
        const length = 2;
        this.makeRoomFor(length);
        this.buffer.writeUInt16LE(value, this.position);
        this.position += length;
      }
      writeUShort(value) {
        this.writeUInt16LE(value);
      }
      writeUInt16BE(value) {
        const length = 2;
        this.makeRoomFor(length);
        this.buffer.writeUInt16BE(value, this.position);
        this.position += length;
      }
      writeUInt24LE(value) {
        const length = 3;
        this.makeRoomFor(length);
        this.buffer[this.position + 2] = value >>> 16 & 255;
        this.buffer[this.position + 1] = value >>> 8 & 255;
        this.buffer[this.position] = value & 255;
        this.position += length;
      }
      writeUInt32LE(value) {
        const length = 4;
        this.makeRoomFor(length);
        this.buffer.writeUInt32LE(value, this.position);
        this.position += length;
      }
      writeBigInt64LE(value) {
        const length = 8;
        this.makeRoomFor(length);
        this.buffer.writeBigInt64LE(value, this.position);
        this.position += length;
      }
      writeInt64LE(value) {
        this.writeBigInt64LE(BigInt(value));
      }
      writeUInt64LE(value) {
        this.writeBigUInt64LE(BigInt(value));
      }
      writeBigUInt64LE(value) {
        const length = 8;
        this.makeRoomFor(length);
        this.buffer.writeBigUInt64LE(value, this.position);
        this.position += length;
      }
      writeUInt32BE(value) {
        const length = 4;
        this.makeRoomFor(length);
        this.buffer.writeUInt32BE(value, this.position);
        this.position += length;
      }
      writeUInt40LE(value) {
        this.writeInt32LE(value & -1);
        this.writeUInt8(Math.floor(value * SHIFT_RIGHT_32));
      }
      writeInt8(value) {
        const length = 1;
        this.makeRoomFor(length);
        this.buffer.writeInt8(value, this.position);
        this.position += length;
      }
      writeInt16LE(value) {
        const length = 2;
        this.makeRoomFor(length);
        this.buffer.writeInt16LE(value, this.position);
        this.position += length;
      }
      writeInt16BE(value) {
        const length = 2;
        this.makeRoomFor(length);
        this.buffer.writeInt16BE(value, this.position);
        this.position += length;
      }
      writeInt32LE(value) {
        const length = 4;
        this.makeRoomFor(length);
        this.buffer.writeInt32LE(value, this.position);
        this.position += length;
      }
      writeInt32BE(value) {
        const length = 4;
        this.makeRoomFor(length);
        this.buffer.writeInt32BE(value, this.position);
        this.position += length;
      }
      writeFloatLE(value) {
        const length = 4;
        this.makeRoomFor(length);
        this.buffer.writeFloatLE(value, this.position);
        this.position += length;
      }
      writeDoubleLE(value) {
        const length = 8;
        this.makeRoomFor(length);
        this.buffer.writeDoubleLE(value, this.position);
        this.position += length;
      }
      writeString(value, encoding) {
        if (encoding == null) {
          encoding = this.encoding;
        }
        const length = Buffer.byteLength(value, encoding);
        this.makeRoomFor(length);
        this.buffer.write(value, this.position, encoding);
        this.position += length;
      }
      writeBVarchar(value, encoding) {
        this.writeUInt8(value.length);
        this.writeString(value, encoding);
      }
      writeUsVarchar(value, encoding) {
        this.writeUInt16LE(value.length);
        this.writeString(value, encoding);
      }
      // TODO: Figure out what types are passed in other than `Buffer`
      writeUsVarbyte(value, encoding) {
        if (encoding == null) {
          encoding = this.encoding;
        }
        let length;
        if (value instanceof Buffer) {
          length = value.length;
        } else {
          value = value.toString();
          length = Buffer.byteLength(value, encoding);
        }
        this.writeUInt16LE(length);
        if (value instanceof Buffer) {
          this.writeBuffer(value);
        } else {
          this.makeRoomFor(length);
          this.buffer.write(value, this.position, encoding);
          this.position += length;
        }
      }
      writePLPBody(value, encoding) {
        if (encoding == null) {
          encoding = this.encoding;
        }
        let length;
        if (value instanceof Buffer) {
          length = value.length;
        } else {
          value = value.toString();
          length = Buffer.byteLength(value, encoding);
        }
        this.writeBuffer(UNKNOWN_PLP_LEN);
        if (length > 0) {
          this.writeUInt32LE(length);
          if (value instanceof Buffer) {
            this.writeBuffer(value);
          } else {
            this.makeRoomFor(length);
            this.buffer.write(value, this.position, encoding);
            this.position += length;
          }
        }
        this.writeUInt32LE(0);
      }
      writeBuffer(value) {
        const length = value.length;
        this.makeRoomFor(length);
        value.copy(this.buffer, this.position);
        this.position += length;
      }
      writeMoney(value) {
        this.writeInt32LE(Math.floor(value * SHIFT_RIGHT_32));
        this.writeInt32LE(value & -1);
      }
    };
    var _default = exports.default = WritableTrackingBuffer;
    module.exports = WritableTrackingBuffer;
  }
});

// node_modules/tedious/lib/token/token.js
var require_token = __commonJS({
  "node_modules/tedious/lib/token/token.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Token = exports.TYPE = exports.SSPIToken = exports.RowToken = exports.RoutingEnvChangeToken = exports.RollbackTransactionEnvChangeToken = exports.ReturnValueToken = exports.ReturnStatusToken = exports.ResetConnectionEnvChangeToken = exports.PacketSizeEnvChangeToken = exports.OrderToken = exports.NBCRowToken = exports.LoginAckToken = exports.LanguageEnvChangeToken = exports.InfoMessageToken = exports.FedAuthInfoToken = exports.FeatureExtAckToken = exports.ErrorMessageToken = exports.DoneToken = exports.DoneProcToken = exports.DoneInProcToken = exports.DatabaseMirroringPartnerEnvChangeToken = exports.DatabaseEnvChangeToken = exports.CommitTransactionEnvChangeToken = exports.CollationChangeToken = exports.ColMetadataToken = exports.CharsetEnvChangeToken = exports.BeginTransactionEnvChangeToken = void 0;
    var TYPE = exports.TYPE = {
      ALTMETADATA: 136,
      ALTROW: 211,
      COLMETADATA: 129,
      COLINFO: 165,
      DONE: 253,
      DONEPROC: 254,
      DONEINPROC: 255,
      ENVCHANGE: 227,
      ERROR: 170,
      FEATUREEXTACK: 174,
      FEDAUTHINFO: 238,
      INFO: 171,
      LOGINACK: 173,
      NBCROW: 210,
      OFFSET: 120,
      ORDER: 169,
      RETURNSTATUS: 121,
      RETURNVALUE: 172,
      ROW: 209,
      SSPI: 237,
      TABNAME: 164
    };
    var Token = class {
      constructor(name3, handlerName) {
        this.name = name3;
        this.handlerName = handlerName;
      }
    };
    exports.Token = Token;
    var ColMetadataToken = class extends Token {
      constructor(columns) {
        super("COLMETADATA", "onColMetadata");
        this.columns = columns;
      }
    };
    exports.ColMetadataToken = ColMetadataToken;
    var DoneToken = class extends Token {
      constructor({
        more,
        sqlError,
        attention,
        serverError,
        rowCount,
        curCmd
      }) {
        super("DONE", "onDone");
        this.more = more;
        this.sqlError = sqlError;
        this.attention = attention;
        this.serverError = serverError;
        this.rowCount = rowCount;
        this.curCmd = curCmd;
      }
    };
    exports.DoneToken = DoneToken;
    var DoneInProcToken = class extends Token {
      constructor({
        more,
        sqlError,
        attention,
        serverError,
        rowCount,
        curCmd
      }) {
        super("DONEINPROC", "onDoneInProc");
        this.more = more;
        this.sqlError = sqlError;
        this.attention = attention;
        this.serverError = serverError;
        this.rowCount = rowCount;
        this.curCmd = curCmd;
      }
    };
    exports.DoneInProcToken = DoneInProcToken;
    var DoneProcToken = class extends Token {
      constructor({
        more,
        sqlError,
        attention,
        serverError,
        rowCount,
        curCmd
      }) {
        super("DONEPROC", "onDoneProc");
        this.more = more;
        this.sqlError = sqlError;
        this.attention = attention;
        this.serverError = serverError;
        this.rowCount = rowCount;
        this.curCmd = curCmd;
      }
    };
    exports.DoneProcToken = DoneProcToken;
    var DatabaseEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onDatabaseChange");
        this.type = "DATABASE";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports.DatabaseEnvChangeToken = DatabaseEnvChangeToken;
    var LanguageEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onLanguageChange");
        this.type = "LANGUAGE";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports.LanguageEnvChangeToken = LanguageEnvChangeToken;
    var CharsetEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onCharsetChange");
        this.type = "CHARSET";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports.CharsetEnvChangeToken = CharsetEnvChangeToken;
    var PacketSizeEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onPacketSizeChange");
        this.type = "PACKET_SIZE";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports.PacketSizeEnvChangeToken = PacketSizeEnvChangeToken;
    var BeginTransactionEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onBeginTransaction");
        this.type = "BEGIN_TXN";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports.BeginTransactionEnvChangeToken = BeginTransactionEnvChangeToken;
    var CommitTransactionEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onCommitTransaction");
        this.type = "COMMIT_TXN";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports.CommitTransactionEnvChangeToken = CommitTransactionEnvChangeToken;
    var RollbackTransactionEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onRollbackTransaction");
        this.type = "ROLLBACK_TXN";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports.RollbackTransactionEnvChangeToken = RollbackTransactionEnvChangeToken;
    var DatabaseMirroringPartnerEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onDatabaseMirroringPartner");
        this.type = "DATABASE_MIRRORING_PARTNER";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports.DatabaseMirroringPartnerEnvChangeToken = DatabaseMirroringPartnerEnvChangeToken;
    var ResetConnectionEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onResetConnection");
        this.type = "RESET_CONNECTION";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports.ResetConnectionEnvChangeToken = ResetConnectionEnvChangeToken;
    var CollationChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onSqlCollationChange");
        this.type = "SQL_COLLATION";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports.CollationChangeToken = CollationChangeToken;
    var RoutingEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onRoutingChange");
        this.type = "ROUTING_CHANGE";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports.RoutingEnvChangeToken = RoutingEnvChangeToken;
    var FeatureExtAckToken = class extends Token {
      /** Value of UTF8_SUPPORT acknowledgement.
       *
       * undefined when UTF8_SUPPORT not included in token. */
      constructor(fedAuth, utf8Support) {
        super("FEATUREEXTACK", "onFeatureExtAck");
        this.fedAuth = fedAuth;
        this.utf8Support = utf8Support;
      }
    };
    exports.FeatureExtAckToken = FeatureExtAckToken;
    var FedAuthInfoToken = class extends Token {
      constructor(spn, stsurl) {
        super("FEDAUTHINFO", "onFedAuthInfo");
        this.spn = spn;
        this.stsurl = stsurl;
      }
    };
    exports.FedAuthInfoToken = FedAuthInfoToken;
    var InfoMessageToken = class extends Token {
      constructor({
        number,
        state: state3,
        class: clazz,
        message,
        serverName,
        procName,
        lineNumber
      }) {
        super("INFO", "onInfoMessage");
        this.number = number;
        this.state = state3;
        this.class = clazz;
        this.message = message;
        this.serverName = serverName;
        this.procName = procName;
        this.lineNumber = lineNumber;
      }
    };
    exports.InfoMessageToken = InfoMessageToken;
    var ErrorMessageToken = class extends Token {
      constructor({
        number,
        state: state3,
        class: clazz,
        message,
        serverName,
        procName,
        lineNumber
      }) {
        super("ERROR", "onErrorMessage");
        this.number = number;
        this.state = state3;
        this.class = clazz;
        this.message = message;
        this.serverName = serverName;
        this.procName = procName;
        this.lineNumber = lineNumber;
      }
    };
    exports.ErrorMessageToken = ErrorMessageToken;
    var LoginAckToken = class extends Token {
      constructor({
        interface: interfaze,
        tdsVersion,
        progName,
        progVersion
      }) {
        super("LOGINACK", "onLoginAck");
        this.interface = interfaze;
        this.tdsVersion = tdsVersion;
        this.progName = progName;
        this.progVersion = progVersion;
      }
    };
    exports.LoginAckToken = LoginAckToken;
    var NBCRowToken = class extends Token {
      constructor(columns) {
        super("NBCROW", "onRow");
        this.columns = columns;
      }
    };
    exports.NBCRowToken = NBCRowToken;
    var OrderToken = class extends Token {
      constructor(orderColumns) {
        super("ORDER", "onOrder");
        this.orderColumns = orderColumns;
      }
    };
    exports.OrderToken = OrderToken;
    var ReturnStatusToken = class extends Token {
      constructor(value) {
        super("RETURNSTATUS", "onReturnStatus");
        this.value = value;
      }
    };
    exports.ReturnStatusToken = ReturnStatusToken;
    var ReturnValueToken = class extends Token {
      constructor({
        paramOrdinal,
        paramName,
        metadata,
        value
      }) {
        super("RETURNVALUE", "onReturnValue");
        this.paramOrdinal = paramOrdinal;
        this.paramName = paramName;
        this.metadata = metadata;
        this.value = value;
      }
    };
    exports.ReturnValueToken = ReturnValueToken;
    var RowToken = class extends Token {
      constructor(columns) {
        super("ROW", "onRow");
        this.columns = columns;
      }
    };
    exports.RowToken = RowToken;
    var SSPIToken = class extends Token {
      constructor(ntlmpacket, ntlmpacketBuffer) {
        super("SSPICHALLENGE", "onSSPI");
        this.ntlmpacket = ntlmpacket;
        this.ntlmpacketBuffer = ntlmpacketBuffer;
      }
    };
    exports.SSPIToken = SSPIToken;
  }
});

// node_modules/tedious/lib/bulk-load.js
var require_bulk_load = __commonJS({
  "node_modules/tedious/lib/bulk-load.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _events = require_events();
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    var _stream = require_stream();
    var _token = require_token();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var FLAGS = {
      nullable: 1 << 0,
      caseSen: 1 << 1,
      updateableReadWrite: 1 << 2,
      updateableUnknown: 1 << 3,
      identity: 1 << 4,
      computed: 1 << 5,
      // introduced in TDS 7.2
      fixedLenCLRType: 1 << 8,
      // introduced in TDS 7.2
      sparseColumnSet: 1 << 10,
      // introduced in TDS 7.3.B
      hidden: 1 << 13,
      // introduced in TDS 7.2
      key: 1 << 14,
      // introduced in TDS 7.2
      nullableUnknown: 1 << 15
      // introduced in TDS 7.2
    };
    var DONE_STATUS = {
      FINAL: 0,
      MORE: 1,
      ERROR: 2,
      INXACT: 4,
      COUNT: 16,
      ATTN: 32,
      SRVERROR: 256
    };
    var rowTokenBuffer = Buffer.from([_token.TYPE.ROW]);
    var textPointerAndTimestampBuffer = Buffer.from([
      // TextPointer length
      16,
      // TextPointer
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // Timestamp
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    var textPointerNullBuffer = Buffer.from([0]);
    var RowTransform = class extends _stream.Transform {
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      constructor(bulkLoad) {
        super({
          writableObjectMode: true
        });
        this.bulkLoad = bulkLoad;
        this.mainOptions = bulkLoad.options;
        this.columns = bulkLoad.columns;
        this.columnMetadataWritten = false;
      }
      /**
       * @private
       */
      _transform(row, _encoding, callback) {
        if (!this.columnMetadataWritten) {
          this.push(this.bulkLoad.getColMetaData());
          this.columnMetadataWritten = true;
        }
        this.push(rowTokenBuffer);
        for (let i = 0; i < this.columns.length; i++) {
          const c = this.columns[i];
          let value = Array.isArray(row) ? row[i] : row[c.objName];
          if (!this.bulkLoad.firstRowWritten) {
            try {
              value = c.type.validate(value, c.collation);
            } catch (error) {
              return callback(error);
            }
          }
          const parameter = {
            length: c.length,
            scale: c.scale,
            precision: c.precision,
            value
          };
          if (c.type.name === "Text" || c.type.name === "Image" || c.type.name === "NText") {
            if (value == null) {
              this.push(textPointerNullBuffer);
              continue;
            }
            this.push(textPointerAndTimestampBuffer);
          }
          try {
            this.push(c.type.generateParameterLength(parameter, this.mainOptions));
            for (const chunk of c.type.generateParameterData(parameter, this.mainOptions)) {
              this.push(chunk);
            }
          } catch (error) {
            return callback(error);
          }
        }
        process.nextTick(callback);
      }
      /**
       * @private
       */
      _flush(callback) {
        this.push(this.bulkLoad.createDoneToken());
        process.nextTick(callback);
      }
    };
    var BulkLoad = class extends _events.EventEmitter {
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      constructor(table, collation, connectionOptions, {
        checkConstraints = false,
        fireTriggers = false,
        keepNulls = false,
        lockTable = false,
        order = {}
      }, callback) {
        if (typeof checkConstraints !== "boolean") {
          throw new TypeError('The "options.checkConstraints" property must be of type boolean.');
        }
        if (typeof fireTriggers !== "boolean") {
          throw new TypeError('The "options.fireTriggers" property must be of type boolean.');
        }
        if (typeof keepNulls !== "boolean") {
          throw new TypeError('The "options.keepNulls" property must be of type boolean.');
        }
        if (typeof lockTable !== "boolean") {
          throw new TypeError('The "options.lockTable" property must be of type boolean.');
        }
        if (typeof order !== "object" || order === null) {
          throw new TypeError('The "options.order" property must be of type object.');
        }
        for (const [column, direction] of Object.entries(order)) {
          if (direction !== "ASC" && direction !== "DESC") {
            throw new TypeError('The value of the "' + column + '" key in the "options.order" object must be either "ASC" or "DESC".');
          }
        }
        super();
        this.error = void 0;
        this.canceled = false;
        this.executionStarted = false;
        this.collation = collation;
        this.table = table;
        this.options = connectionOptions;
        this.callback = callback;
        this.columns = [];
        this.columnsByName = {};
        this.firstRowWritten = false;
        this.streamingMode = false;
        this.rowToPacketTransform = new RowTransform(this);
        this.bulkOptions = {
          checkConstraints,
          fireTriggers,
          keepNulls,
          lockTable,
          order
        };
      }
      /**
       * Adds a column to the bulk load.
       *
       * The column definitions should match the table you are trying to insert into.
       * Attempting to call addColumn after the first row has been added will throw an exception.
       *
       * ```js
       * bulkLoad.addColumn('MyIntColumn', TYPES.Int, { nullable: false });
       * ```
       *
       * @param name The name of the column.
       * @param type One of the supported `data types`.
       * @param __namedParameters Additional column type information. At a minimum, `nullable` must be set to true or false.
       * @param length For VarChar, NVarChar, VarBinary. Use length as `Infinity` for VarChar(max), NVarChar(max) and VarBinary(max).
       * @param nullable Indicates whether the column accepts NULL values.
       * @param objName If the name of the column is different from the name of the property found on `rowObj` arguments passed to [[addRow]] or [[Connection.execBulkLoad]], then you can use this option to specify the property name.
       * @param precision For Numeric, Decimal.
       * @param scale For Numeric, Decimal, Time, DateTime2, DateTimeOffset.
      */
      addColumn(name3, type, {
        output = false,
        length,
        precision,
        scale,
        objName = name3,
        nullable = true
      }) {
        if (this.firstRowWritten) {
          throw new Error("Columns cannot be added to bulk insert after the first row has been written.");
        }
        if (this.executionStarted) {
          throw new Error("Columns cannot be added to bulk insert after execution has started.");
        }
        const column = {
          type,
          name: name3,
          value: null,
          output,
          length,
          precision,
          scale,
          objName,
          nullable,
          collation: this.collation
        };
        if ((type.id & 48) === 32) {
          if (column.length == null && type.resolveLength) {
            column.length = type.resolveLength(column);
          }
        }
        if (type.resolvePrecision && column.precision == null) {
          column.precision = type.resolvePrecision(column);
        }
        if (type.resolveScale && column.scale == null) {
          column.scale = type.resolveScale(column);
        }
        this.columns.push(column);
        this.columnsByName[name3] = column;
      }
      /**
       * @private
       */
      getOptionsSql() {
        const addOptions = [];
        if (this.bulkOptions.checkConstraints) {
          addOptions.push("CHECK_CONSTRAINTS");
        }
        if (this.bulkOptions.fireTriggers) {
          addOptions.push("FIRE_TRIGGERS");
        }
        if (this.bulkOptions.keepNulls) {
          addOptions.push("KEEP_NULLS");
        }
        if (this.bulkOptions.lockTable) {
          addOptions.push("TABLOCK");
        }
        if (this.bulkOptions.order) {
          const orderColumns = [];
          for (const [column, direction] of Object.entries(this.bulkOptions.order)) {
            orderColumns.push(`${column} ${direction}`);
          }
          if (orderColumns.length) {
            addOptions.push(`ORDER (${orderColumns.join(", ")})`);
          }
        }
        if (addOptions.length > 0) {
          return ` WITH (${addOptions.join(",")})`;
        } else {
          return "";
        }
      }
      /**
       * @private
       */
      getBulkInsertSql() {
        let sql = "insert bulk " + this.table + "(";
        for (let i = 0, len = this.columns.length; i < len; i++) {
          const c = this.columns[i];
          if (i !== 0) {
            sql += ", ";
          }
          sql += "[" + c.name + "] " + c.type.declaration(c);
        }
        sql += ")";
        sql += this.getOptionsSql();
        return sql;
      }
      /**
       * This is simply a helper utility function which returns a `CREATE TABLE SQL` statement based on the columns added to the bulkLoad object.
       * This may be particularly handy when you want to insert into a temporary table (a table which starts with `#`).
       *
       * ```js
       * var sql = bulkLoad.getTableCreationSql();
       * ```
       *
       * A side note on bulk inserting into temporary tables: if you want to access a local temporary table after executing the bulk load,
       * you'll need to use the same connection and execute your requests using [[Connection.execSqlBatch]] instead of [[Connection.execSql]]
       */
      getTableCreationSql() {
        let sql = "CREATE TABLE " + this.table + "(\n";
        for (let i = 0, len = this.columns.length; i < len; i++) {
          const c = this.columns[i];
          if (i !== 0) {
            sql += ",\n";
          }
          sql += "[" + c.name + "] " + c.type.declaration(c);
          if (c.nullable !== void 0) {
            sql += " " + (c.nullable ? "NULL" : "NOT NULL");
          }
        }
        sql += "\n)";
        return sql;
      }
      /**
       * @private
       */
      getColMetaData() {
        const tBuf = new _writableTrackingBuffer.default(100, null, true);
        tBuf.writeUInt8(_token.TYPE.COLMETADATA);
        tBuf.writeUInt16LE(this.columns.length);
        for (let j = 0, len = this.columns.length; j < len; j++) {
          const c = this.columns[j];
          if (this.options.tdsVersion < "7_2") {
            tBuf.writeUInt16LE(0);
          } else {
            tBuf.writeUInt32LE(0);
          }
          let flags = FLAGS.updateableReadWrite;
          if (c.nullable) {
            flags |= FLAGS.nullable;
          } else if (c.nullable === void 0 && this.options.tdsVersion >= "7_2") {
            flags |= FLAGS.nullableUnknown;
          }
          tBuf.writeUInt16LE(flags);
          tBuf.writeBuffer(c.type.generateTypeInfo(c, this.options));
          if (c.type.hasTableName) {
            tBuf.writeUsVarchar(this.table, "ucs2");
          }
          tBuf.writeBVarchar(c.name, "ucs2");
        }
        return tBuf.data;
      }
      /**
       * Sets a timeout for this bulk load.
       *
       * ```js
       * bulkLoad.setTimeout(timeout);
       * ```
       *
       * @param timeout The number of milliseconds before the bulk load is considered failed, or 0 for no timeout.
       *   When no timeout is set for the bulk load, the [[ConnectionOptions.requestTimeout]] of the Connection is used.
       */
      setTimeout(timeout) {
        this.timeout = timeout;
      }
      /**
       * @private
       */
      createDoneToken() {
        const tBuf = new _writableTrackingBuffer.default(this.options.tdsVersion < "7_2" ? 9 : 13);
        tBuf.writeUInt8(_token.TYPE.DONE);
        const status = DONE_STATUS.FINAL;
        tBuf.writeUInt16LE(status);
        tBuf.writeUInt16LE(0);
        tBuf.writeUInt32LE(0);
        if (this.options.tdsVersion >= "7_2") {
          tBuf.writeUInt32LE(0);
        }
        return tBuf.data;
      }
      /**
       * @private
       */
      cancel() {
        if (this.canceled) {
          return;
        }
        this.canceled = true;
        this.emit("cancel");
      }
    };
    var _default = exports.default = BulkLoad;
    module.exports = BulkLoad;
  }
});

// browser-external:os
var require_os = __commonJS({
  "browser-external:os"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "os" has been externalized for browser compatibility. Cannot access "os.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:tls
var require_tls = __commonJS({
  "browser-external:tls"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "tls" has been externalized for browser compatibility. Cannot access "tls.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:net
var require_net = __commonJS({
  "browser-external:net"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "net" has been externalized for browser compatibility. Cannot access "net.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:dns
var require_dns = __commonJS({
  "browser-external:dns"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "dns" has been externalized for browser compatibility. Cannot access "dns.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:constants
var require_constants = __commonJS({
  "browser-external:constants"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "constants" has been externalized for browser compatibility. Cannot access "constants.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@azure/identity/dist/browser/plugins/consumer.js
function useIdentityPlugin(_plugin) {
  throw new Error("Identity plugins are not supported in browser environments.");
}
var init_consumer = __esm({
  "node_modules/@azure/identity/dist/browser/plugins/consumer.js"() {
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/logger/log.common.js
function log(...args) {
  if (args.length > 0) {
    const firstArg = String(args[0]);
    if (firstArg.includes(":error")) {
      console.error(...args);
    } else if (firstArg.includes(":warning")) {
      console.warn(...args);
    } else if (firstArg.includes(":info")) {
      console.info(...args);
    } else if (firstArg.includes(":verbose")) {
      console.debug(...args);
    } else {
      console.debug(...args);
    }
  }
}
var init_log_common = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/logger/log.common.js"() {
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/logger/log.js
var init_log = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/logger/log.js"() {
    init_log_common();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/logger/debug.js
function enable(namespaces) {
  enabledString = namespaces;
  enabledNamespaces = [];
  skippedNamespaces = [];
  const wildcard = /\*/g;
  const namespaceList = namespaces.split(",").map((ns) => ns.trim().replace(wildcard, ".*?"));
  for (const ns of namespaceList) {
    if (ns.startsWith("-")) {
      skippedNamespaces.push(new RegExp(`^${ns.substr(1)}$`));
    } else {
      enabledNamespaces.push(new RegExp(`^${ns}$`));
    }
  }
  for (const instance of debuggers) {
    instance.enabled = enabled(instance.namespace);
  }
}
function enabled(namespace) {
  if (namespace.endsWith("*")) {
    return true;
  }
  for (const skipped of skippedNamespaces) {
    if (skipped.test(namespace)) {
      return false;
    }
  }
  for (const enabledNamespace of enabledNamespaces) {
    if (enabledNamespace.test(namespace)) {
      return true;
    }
  }
  return false;
}
function disable() {
  const result = enabledString || "";
  enable("");
  return result;
}
function createDebugger(namespace) {
  const newDebugger = Object.assign(debug, {
    enabled: enabled(namespace),
    destroy,
    log: debugObj.log,
    namespace,
    extend
  });
  function debug(...args) {
    if (!newDebugger.enabled) {
      return;
    }
    if (args.length > 0) {
      args[0] = `${namespace} ${args[0]}`;
    }
    newDebugger.log(...args);
  }
  debuggers.push(newDebugger);
  return newDebugger;
}
function destroy() {
  const index = debuggers.indexOf(this);
  if (index >= 0) {
    debuggers.splice(index, 1);
    return true;
  }
  return false;
}
function extend(namespace) {
  const newDebugger = createDebugger(`${this.namespace}:${namespace}`);
  newDebugger.log = this.log;
  return newDebugger;
}
var debugEnvVariable, enabledString, enabledNamespaces, skippedNamespaces, debuggers, debugObj, debug_default;
var init_debug = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/logger/debug.js"() {
    init_log();
    debugEnvVariable = typeof process !== "undefined" && process.env && process.env.DEBUG || void 0;
    enabledNamespaces = [];
    skippedNamespaces = [];
    debuggers = [];
    if (debugEnvVariable) {
      enable(debugEnvVariable);
    }
    debugObj = Object.assign((namespace) => {
      return createDebugger(namespace);
    }, {
      enable,
      enabled,
      disable,
      log
    });
    debug_default = debugObj;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/logger/logger.js
function patchLogMethod(parent, child) {
  child.log = (...args) => {
    parent.log(...args);
  };
}
function isTypeSpecRuntimeLogLevel(level) {
  return TYPESPEC_RUNTIME_LOG_LEVELS.includes(level);
}
function createLoggerContext(options) {
  const registeredLoggers = /* @__PURE__ */ new Set();
  const logLevelFromEnv = typeof process !== "undefined" && process.env && process.env[options.logLevelEnvVarName] || void 0;
  let logLevel;
  const clientLogger = debug_default(options.namespace);
  clientLogger.log = (...args) => {
    debug_default.log(...args);
  };
  function contextSetLogLevel(level) {
    if (level && !isTypeSpecRuntimeLogLevel(level)) {
      throw new Error(`Unknown log level '${level}'. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS.join(",")}`);
    }
    logLevel = level;
    const enabledNamespaces2 = [];
    for (const logger24 of registeredLoggers) {
      if (shouldEnable(logger24)) {
        enabledNamespaces2.push(logger24.namespace);
      }
    }
    debug_default.enable(enabledNamespaces2.join(","));
  }
  if (logLevelFromEnv) {
    if (isTypeSpecRuntimeLogLevel(logLevelFromEnv)) {
      contextSetLogLevel(logLevelFromEnv);
    } else {
      console.error(`${options.logLevelEnvVarName} set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS.join(", ")}.`);
    }
  }
  function shouldEnable(logger24) {
    return Boolean(logLevel && levelMap[logger24.level] <= levelMap[logLevel]);
  }
  function createLogger(parent, level) {
    const logger24 = Object.assign(parent.extend(level), {
      level
    });
    patchLogMethod(parent, logger24);
    if (shouldEnable(logger24)) {
      const enabledNamespaces2 = debug_default.disable();
      debug_default.enable(enabledNamespaces2 + "," + logger24.namespace);
    }
    registeredLoggers.add(logger24);
    return logger24;
  }
  function contextGetLogLevel() {
    return logLevel;
  }
  function contextCreateClientLogger(namespace) {
    const clientRootLogger = clientLogger.extend(namespace);
    patchLogMethod(clientLogger, clientRootLogger);
    return {
      error: createLogger(clientRootLogger, "error"),
      warning: createLogger(clientRootLogger, "warning"),
      info: createLogger(clientRootLogger, "info"),
      verbose: createLogger(clientRootLogger, "verbose")
    };
  }
  return {
    setLogLevel: contextSetLogLevel,
    getLogLevel: contextGetLogLevel,
    createClientLogger: contextCreateClientLogger,
    logger: clientLogger
  };
}
function createClientLogger(namespace) {
  return context.createClientLogger(namespace);
}
var TYPESPEC_RUNTIME_LOG_LEVELS, levelMap, context, TypeSpecRuntimeLogger;
var init_logger = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/logger/logger.js"() {
    init_debug();
    TYPESPEC_RUNTIME_LOG_LEVELS = ["verbose", "info", "warning", "error"];
    levelMap = {
      verbose: 400,
      info: 300,
      warning: 200,
      error: 100
    };
    context = createLoggerContext({
      logLevelEnvVarName: "TYPESPEC_RUNTIME_LOG_LEVEL",
      namespace: "typeSpecRuntime"
    });
    TypeSpecRuntimeLogger = context.logger;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/logger/internal.js
var init_internal = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/logger/internal.js"() {
    init_logger();
  }
});

// node_modules/@azure/logger/dist/browser/index.js
function getLogLevel() {
  return context2.getLogLevel();
}
function createClientLogger2(namespace) {
  return context2.createClientLogger(namespace);
}
var context2, AzureLogger;
var init_browser = __esm({
  "node_modules/@azure/logger/dist/browser/index.js"() {
    init_internal();
    context2 = createLoggerContext({
      logLevelEnvVarName: "AZURE_LOG_LEVEL",
      namespace: "azure"
    });
    AzureLogger = context2.logger;
  }
});

// node_modules/@azure/identity/dist/browser/util/logging.js
function formatSuccess(scope) {
  return `SUCCESS. Scopes: ${Array.isArray(scope) ? scope.join(", ") : scope}.`;
}
function formatError(scope, error) {
  let message = "ERROR.";
  if (scope === null || scope === void 0 ? void 0 : scope.length) {
    message += ` Scopes: ${Array.isArray(scope) ? scope.join(", ") : scope}.`;
  }
  return `${message} Error message: ${typeof error === "string" ? error : error.message}.`;
}
function credentialLoggerInstance(title, parent, log2 = logger) {
  const fullTitle = parent ? `${parent.fullTitle} ${title}` : title;
  function info(message) {
    log2.info(`${fullTitle} =>`, message);
  }
  function warning(message) {
    log2.warning(`${fullTitle} =>`, message);
  }
  function verbose(message) {
    log2.verbose(`${fullTitle} =>`, message);
  }
  function error(message) {
    log2.error(`${fullTitle} =>`, message);
  }
  return {
    title,
    fullTitle,
    info,
    warning,
    verbose,
    error
  };
}
function credentialLogger(title, log2 = logger) {
  const credLogger = credentialLoggerInstance(title, void 0, log2);
  return Object.assign(Object.assign({}, credLogger), { parent: log2, getToken: credentialLoggerInstance("=> getToken()", credLogger, log2) });
}
var logger;
var init_logging = __esm({
  "node_modules/@azure/identity/dist/browser/util/logging.js"() {
    init_browser();
    logger = createClientLogger2("identity");
  }
});

// node_modules/@azure/identity/dist/browser/errors.js
function isErrorResponse(errorResponse) {
  return errorResponse && typeof errorResponse.error === "string" && typeof errorResponse.error_description === "string";
}
function convertOAuthErrorResponseToErrorResponse(errorBody) {
  return {
    error: errorBody.error,
    errorDescription: errorBody.error_description,
    correlationId: errorBody.correlation_id,
    errorCodes: errorBody.error_codes,
    timestamp: errorBody.timestamp,
    traceId: errorBody.trace_id
  };
}
var CredentialUnavailableErrorName, CredentialUnavailableError, AuthenticationErrorName, AuthenticationError, AggregateAuthenticationErrorName, AggregateAuthenticationError, AuthenticationRequiredError;
var init_errors = __esm({
  "node_modules/@azure/identity/dist/browser/errors.js"() {
    CredentialUnavailableErrorName = "CredentialUnavailableError";
    CredentialUnavailableError = class extends Error {
      constructor(message, options) {
        super(message, options);
        this.name = CredentialUnavailableErrorName;
      }
    };
    AuthenticationErrorName = "AuthenticationError";
    AuthenticationError = class extends Error {
      constructor(statusCode, errorBody, options) {
        let errorResponse = {
          error: "unknown",
          errorDescription: "An unknown error occurred and no additional details are available."
        };
        if (isErrorResponse(errorBody)) {
          errorResponse = convertOAuthErrorResponseToErrorResponse(errorBody);
        } else if (typeof errorBody === "string") {
          try {
            const oauthErrorResponse = JSON.parse(errorBody);
            errorResponse = convertOAuthErrorResponseToErrorResponse(oauthErrorResponse);
          } catch (e) {
            if (statusCode === 400) {
              errorResponse = {
                error: "invalid_request",
                errorDescription: `The service indicated that the request was invalid.

${errorBody}`
              };
            } else {
              errorResponse = {
                error: "unknown_error",
                errorDescription: `An unknown error has occurred. Response body:

${errorBody}`
              };
            }
          }
        } else {
          errorResponse = {
            error: "unknown_error",
            errorDescription: "An unknown error occurred and no additional details are available."
          };
        }
        super(
          `${errorResponse.error} Status code: ${statusCode}
More details:
${errorResponse.errorDescription},`,
          // @ts-expect-error - TypeScript does not recognize this until we use ES2022 as the target; however, all our major runtimes do support the `cause` property
          options
        );
        this.statusCode = statusCode;
        this.errorResponse = errorResponse;
        this.name = AuthenticationErrorName;
      }
    };
    AggregateAuthenticationErrorName = "AggregateAuthenticationError";
    AggregateAuthenticationError = class extends Error {
      constructor(errors, errorMessage2) {
        const errorDetail = errors.join("\n");
        super(`${errorMessage2}
${errorDetail}`);
        this.errors = errors;
        this.name = AggregateAuthenticationErrorName;
      }
    };
    AuthenticationRequiredError = class extends Error {
      constructor(options) {
        super(
          options.message,
          // @ts-expect-error - TypeScript does not recognize this until we use ES2022 as the target; however, all our major runtimes do support the `cause` property
          options.cause ? { cause: options.cause } : void 0
        );
        this.scopes = options.scopes;
        this.getTokenOptions = options.getTokenOptions;
        this.name = "AuthenticationRequiredError";
      }
    };
  }
});

// node_modules/@azure/identity/dist/browser/constants.js
var SDK_VERSION, DeveloperSignOnClientId, DefaultTenantId, AzureAuthorityHosts, DefaultAuthorityHost, DefaultAuthority, ALL_TENANTS;
var init_constants = __esm({
  "node_modules/@azure/identity/dist/browser/constants.js"() {
    SDK_VERSION = `4.10.2`;
    DeveloperSignOnClientId = "04b07795-8ddb-461a-bbee-02f9e1bf7b46";
    DefaultTenantId = "common";
    (function(AzureAuthorityHosts2) {
      AzureAuthorityHosts2["AzureChina"] = "https://login.chinacloudapi.cn";
      AzureAuthorityHosts2["AzureGermany"] = "https://login.microsoftonline.de";
      AzureAuthorityHosts2["AzureGovernment"] = "https://login.microsoftonline.us";
      AzureAuthorityHosts2["AzurePublicCloud"] = "https://login.microsoftonline.com";
    })(AzureAuthorityHosts || (AzureAuthorityHosts = {}));
    DefaultAuthorityHost = AzureAuthorityHosts.AzurePublicCloud;
    DefaultAuthority = "login.microsoftonline.com";
    ALL_TENANTS = ["*"];
  }
});

// node_modules/@azure/core-tracing/dist/browser/tracingContext.js
function createTracingContext(options = {}) {
  let context3 = new TracingContextImpl(options.parentContext);
  if (options.span) {
    context3 = context3.setValue(knownContextKeys.span, options.span);
  }
  if (options.namespace) {
    context3 = context3.setValue(knownContextKeys.namespace, options.namespace);
  }
  return context3;
}
var knownContextKeys, TracingContextImpl;
var init_tracingContext = __esm({
  "node_modules/@azure/core-tracing/dist/browser/tracingContext.js"() {
    knownContextKeys = {
      span: Symbol.for("@azure/core-tracing span"),
      namespace: Symbol.for("@azure/core-tracing namespace")
    };
    TracingContextImpl = class _TracingContextImpl {
      constructor(initialContext) {
        this._contextMap = initialContext instanceof _TracingContextImpl ? new Map(initialContext._contextMap) : /* @__PURE__ */ new Map();
      }
      setValue(key, value) {
        const newContext = new _TracingContextImpl(this);
        newContext._contextMap.set(key, value);
        return newContext;
      }
      getValue(key) {
        return this._contextMap.get(key);
      }
      deleteValue(key) {
        const newContext = new _TracingContextImpl(this);
        newContext._contextMap.delete(key);
        return newContext;
      }
    };
  }
});

// node_modules/@azure/core-tracing/dist/browser/state.js
var state;
var init_state = __esm({
  "node_modules/@azure/core-tracing/dist/browser/state.js"() {
    state = {
      instrumenterImplementation: void 0
    };
  }
});

// node_modules/@azure/core-tracing/dist/browser/instrumenter.js
function createDefaultTracingSpan() {
  return {
    end: () => {
    },
    isRecording: () => false,
    recordException: () => {
    },
    setAttribute: () => {
    },
    setStatus: () => {
    },
    addEvent: () => {
    }
  };
}
function createDefaultInstrumenter() {
  return {
    createRequestHeaders: () => {
      return {};
    },
    parseTraceparentHeader: () => {
      return void 0;
    },
    startSpan: (_name, spanOptions) => {
      return {
        span: createDefaultTracingSpan(),
        tracingContext: createTracingContext({ parentContext: spanOptions.tracingContext })
      };
    },
    withContext(_context, callback, ...callbackArgs) {
      return callback(...callbackArgs);
    }
  };
}
function getInstrumenter() {
  if (!state.instrumenterImplementation) {
    state.instrumenterImplementation = createDefaultInstrumenter();
  }
  return state.instrumenterImplementation;
}
var init_instrumenter = __esm({
  "node_modules/@azure/core-tracing/dist/browser/instrumenter.js"() {
    init_tracingContext();
    init_state();
  }
});

// node_modules/@azure/core-tracing/dist/browser/tracingClient.js
function createTracingClient(options) {
  const { namespace, packageName, packageVersion } = options;
  function startSpan(name3, operationOptions, spanOptions) {
    var _a3;
    const startSpanResult = getInstrumenter().startSpan(name3, Object.assign(Object.assign({}, spanOptions), { packageName, packageVersion, tracingContext: (_a3 = operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions) === null || _a3 === void 0 ? void 0 : _a3.tracingContext }));
    let tracingContext = startSpanResult.tracingContext;
    const span = startSpanResult.span;
    if (!tracingContext.getValue(knownContextKeys.namespace)) {
      tracingContext = tracingContext.setValue(knownContextKeys.namespace, namespace);
    }
    span.setAttribute("az.namespace", tracingContext.getValue(knownContextKeys.namespace));
    const updatedOptions = Object.assign({}, operationOptions, {
      tracingOptions: Object.assign(Object.assign({}, operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions), { tracingContext })
    });
    return {
      span,
      updatedOptions
    };
  }
  async function withSpan(name3, operationOptions, callback, spanOptions) {
    const { span, updatedOptions } = startSpan(name3, operationOptions, spanOptions);
    try {
      const result = await withContext(updatedOptions.tracingOptions.tracingContext, () => Promise.resolve(callback(updatedOptions, span)));
      span.setStatus({ status: "success" });
      return result;
    } catch (err) {
      span.setStatus({ status: "error", error: err });
      throw err;
    } finally {
      span.end();
    }
  }
  function withContext(context3, callback, ...callbackArgs) {
    return getInstrumenter().withContext(context3, callback, ...callbackArgs);
  }
  function parseTraceparentHeader(traceparentHeader) {
    return getInstrumenter().parseTraceparentHeader(traceparentHeader);
  }
  function createRequestHeaders(tracingContext) {
    return getInstrumenter().createRequestHeaders(tracingContext);
  }
  return {
    startSpan,
    withSpan,
    withContext,
    parseTraceparentHeader,
    createRequestHeaders
  };
}
var init_tracingClient = __esm({
  "node_modules/@azure/core-tracing/dist/browser/tracingClient.js"() {
    init_instrumenter();
    init_tracingContext();
  }
});

// node_modules/@azure/core-tracing/dist/browser/index.js
var init_browser2 = __esm({
  "node_modules/@azure/core-tracing/dist/browser/index.js"() {
    init_instrumenter();
    init_tracingClient();
  }
});

// node_modules/@azure/identity/dist/browser/util/tracing.js
var tracingClient;
var init_tracing = __esm({
  "node_modules/@azure/identity/dist/browser/util/tracing.js"() {
    init_constants();
    init_browser2();
    tracingClient = createTracingClient({
      namespace: "Microsoft.AAD",
      packageName: "@azure/identity",
      packageVersion: SDK_VERSION
    });
  }
});

// node_modules/@azure/identity/dist/browser/credentials/chainedTokenCredential.js
var logger2, ChainedTokenCredential;
var init_chainedTokenCredential = __esm({
  "node_modules/@azure/identity/dist/browser/credentials/chainedTokenCredential.js"() {
    init_errors();
    init_logging();
    init_tracing();
    logger2 = credentialLogger("ChainedTokenCredential");
    ChainedTokenCredential = class {
      /**
       * Creates an instance of ChainedTokenCredential using the given credentials.
       *
       * @param sources - `TokenCredential` implementations to be tried in order.
       *
       * Example usage:
       * ```ts snippet:chained_token_credential_example
       * import { ClientSecretCredential, ChainedTokenCredential } from "@azure/identity";
       *
       * const tenantId = "<tenant-id>";
       * const clientId = "<client-id>";
       * const clientSecret = "<client-secret>";
       * const anotherClientId = "<another-client-id>";
       * const anotherSecret = "<another-client-secret>";
       *
       * const firstCredential = new ClientSecretCredential(tenantId, clientId, clientSecret);
       * const secondCredential = new ClientSecretCredential(tenantId, anotherClientId, anotherSecret);
       *
       * const credentialChain = new ChainedTokenCredential(firstCredential, secondCredential);
       * ```
       */
      constructor(...sources) {
        this._sources = [];
        this._sources = sources;
      }
      /**
       * Returns the first access token returned by one of the chained
       * `TokenCredential` implementations.  Throws an {@link AggregateAuthenticationError}
       * when one or more credentials throws an {@link AuthenticationError} and
       * no credentials have returned an access token.
       *
       * This method is called automatically by Azure SDK client libraries. You may call this method
       * directly, but you must also handle token caching and token refreshing.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                `TokenCredential` implementation might make.
       */
      async getToken(scopes, options = {}) {
        const { token } = await this.getTokenInternal(scopes, options);
        return token;
      }
      async getTokenInternal(scopes, options = {}) {
        let token = null;
        let successfulCredential;
        const errors = [];
        return tracingClient.withSpan("ChainedTokenCredential.getToken", options, async (updatedOptions) => {
          for (let i = 0; i < this._sources.length && token === null; i++) {
            try {
              token = await this._sources[i].getToken(scopes, updatedOptions);
              successfulCredential = this._sources[i];
            } catch (err) {
              if (err.name === "CredentialUnavailableError" || err.name === "AuthenticationRequiredError") {
                errors.push(err);
              } else {
                logger2.getToken.info(formatError(scopes, err));
                throw err;
              }
            }
          }
          if (!token && errors.length > 0) {
            const err = new AggregateAuthenticationError(errors, "ChainedTokenCredential authentication failed.");
            logger2.getToken.info(formatError(scopes, err));
            throw err;
          }
          logger2.getToken.info(`Result for ${successfulCredential.constructor.name}: ${formatSuccess(scopes)}`);
          if (token === null) {
            throw new CredentialUnavailableError("Failed to retrieve a valid token");
          }
          return { token, successfulCredential };
        });
      }
    };
  }
});

// node_modules/@azure/identity/dist/browser/credentials/defaultAzureCredential.js
var BrowserNotSupportedError, logger3, DefaultAzureCredential;
var init_defaultAzureCredential = __esm({
  "node_modules/@azure/identity/dist/browser/credentials/defaultAzureCredential.js"() {
    init_logging();
    init_chainedTokenCredential();
    BrowserNotSupportedError = new Error("DefaultAzureCredential is not supported in the browser. Use InteractiveBrowserCredential instead.");
    logger3 = credentialLogger("DefaultAzureCredential");
    DefaultAzureCredential = class extends ChainedTokenCredential {
      /**
       * Creates an instance of the DefaultAzureCredential class.
       *
       * @param options - Options for configuring the client which makes the authentication request.
       */
      constructor(_tokenCredentialOptions) {
        super();
        logger3.info(formatError("", BrowserNotSupportedError));
        throw BrowserNotSupportedError;
      }
      getToken() {
        logger3.getToken.info(formatError("", BrowserNotSupportedError));
        throw BrowserNotSupportedError;
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/util/random.js
function getRandomIntegerInclusive(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  const offset = Math.floor(Math.random() * (max - min + 1));
  return offset + min;
}
var init_random = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/util/random.js"() {
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/util/delay.js
function calculateRetryDelay(retryAttempt, config) {
  const exponentialDelay = config.retryDelayInMs * Math.pow(2, retryAttempt);
  const clampedDelay = Math.min(config.maxRetryDelayInMs, exponentialDelay);
  const retryAfterInMs = clampedDelay / 2 + getRandomIntegerInclusive(0, clampedDelay / 2);
  return { retryAfterInMs };
}
var init_delay = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/util/delay.js"() {
    init_random();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/util/object.js
function isObject(input) {
  return typeof input === "object" && input !== null && !Array.isArray(input) && !(input instanceof RegExp) && !(input instanceof Date);
}
var init_object = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/util/object.js"() {
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/util/error.js
function isError(e) {
  if (isObject(e)) {
    const hasName = typeof e.name === "string";
    const hasMessage = typeof e.message === "string";
    return hasName && hasMessage;
  }
  return false;
}
var init_error = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/util/error.js"() {
    init_object();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/util/bytesEncoding.common.js
function stringToUint8Array(value, format) {
  switch (format) {
    case "utf-8":
      return utf8StringToUint8Array(value);
    case "base64":
      return base64ToUint8Array(value);
    case "base64url":
      return base64UrlToUint8Array(value);
    case "hex":
      return hexStringToUint8Array(value);
  }
}
function utf8StringToUint8Array(value) {
  return new TextEncoder().encode(value);
}
function base64ToUint8Array(value) {
  return new Uint8Array([...atob(value)].map((x) => x.charCodeAt(0)));
}
function base64UrlToUint8Array(value) {
  const base64String = value.replace(/-/g, "+").replace(/_/g, "/");
  return base64ToUint8Array(base64String);
}
function hexStringToUint8Array(value) {
  const bytes = new Uint8Array(value.length / 2);
  for (let i = 0; i < value.length / 2; ++i) {
    const highNibble = value[2 * i];
    const lowNibble = value[2 * i + 1];
    if (!hexDigits.has(highNibble) || !hexDigits.has(lowNibble)) {
      return bytes.slice(0, i);
    }
    bytes[i] = parseInt(`${highNibble}${lowNibble}`, 16);
  }
  return bytes;
}
var hexDigits;
var init_bytesEncoding_common = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/util/bytesEncoding.common.js"() {
    hexDigits = new Set("0123456789abcdefABCDEF");
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/util/bytesEncoding.js
var init_bytesEncoding = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/util/bytesEncoding.js"() {
    init_bytesEncoding_common();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/util/sha256.common.js
var init_sha256_common = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/util/sha256.common.js"() {
    init_bytesEncoding();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/util/sha256.js
var init_sha256 = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/util/sha256.js"() {
    init_sha256_common();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/util/uuidUtils.common.js
function generateUUID() {
  let uuid = "";
  for (let i = 0; i < 32; i++) {
    const randomNumber = Math.floor(Math.random() * 16);
    if (i === 12) {
      uuid += "4";
    } else if (i === 16) {
      uuid += randomNumber & 3 | 8;
    } else {
      uuid += randomNumber.toString(16);
    }
    if (i === 7 || i === 11 || i === 15 || i === 19) {
      uuid += "-";
    }
  }
  return uuid;
}
var init_uuidUtils_common = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/util/uuidUtils.common.js"() {
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/util/uuidUtils.js
function randomUUID() {
  return uuidFunction();
}
var _a, uuidFunction;
var init_uuidUtils = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/util/uuidUtils.js"() {
    init_uuidUtils_common();
    uuidFunction = typeof ((_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.crypto) === null || _a === void 0 ? void 0 : _a.randomUUID) === "function" ? globalThis.crypto.randomUUID.bind(globalThis.crypto) : generateUUID;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/util/checkEnvironment.js
var _a2, _b, _c, _d, isBrowser, isWebWorker, isDeno, isBun, isNodeLike, isReactNative;
var init_checkEnvironment = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/util/checkEnvironment.js"() {
    isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
    isWebWorker = typeof self === "object" && typeof (self === null || self === void 0 ? void 0 : self.importScripts) === "function" && (((_a2 = self.constructor) === null || _a2 === void 0 ? void 0 : _a2.name) === "DedicatedWorkerGlobalScope" || ((_b = self.constructor) === null || _b === void 0 ? void 0 : _b.name) === "ServiceWorkerGlobalScope" || ((_c = self.constructor) === null || _c === void 0 ? void 0 : _c.name) === "SharedWorkerGlobalScope");
    isDeno = typeof Deno !== "undefined" && typeof Deno.version !== "undefined" && typeof Deno.version.deno !== "undefined";
    isBun = typeof Bun !== "undefined" && typeof Bun.version !== "undefined";
    isNodeLike = typeof globalThis.process !== "undefined" && Boolean(globalThis.process.version) && Boolean((_d = globalThis.process.versions) === null || _d === void 0 ? void 0 : _d.node);
    isReactNative = typeof navigator !== "undefined" && (navigator === null || navigator === void 0 ? void 0 : navigator.product) === "ReactNative";
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/util/sanitizer.js
var RedactedString, defaultAllowedHeaderNames, defaultAllowedQueryParameters, Sanitizer;
var init_sanitizer = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/util/sanitizer.js"() {
    init_object();
    RedactedString = "REDACTED";
    defaultAllowedHeaderNames = [
      "x-ms-client-request-id",
      "x-ms-return-client-request-id",
      "x-ms-useragent",
      "x-ms-correlation-request-id",
      "x-ms-request-id",
      "client-request-id",
      "ms-cv",
      "return-client-request-id",
      "traceparent",
      "Access-Control-Allow-Credentials",
      "Access-Control-Allow-Headers",
      "Access-Control-Allow-Methods",
      "Access-Control-Allow-Origin",
      "Access-Control-Expose-Headers",
      "Access-Control-Max-Age",
      "Access-Control-Request-Headers",
      "Access-Control-Request-Method",
      "Origin",
      "Accept",
      "Accept-Encoding",
      "Cache-Control",
      "Connection",
      "Content-Length",
      "Content-Type",
      "Date",
      "ETag",
      "Expires",
      "If-Match",
      "If-Modified-Since",
      "If-None-Match",
      "If-Unmodified-Since",
      "Last-Modified",
      "Pragma",
      "Request-Id",
      "Retry-After",
      "Server",
      "Transfer-Encoding",
      "User-Agent",
      "WWW-Authenticate"
    ];
    defaultAllowedQueryParameters = ["api-version"];
    Sanitizer = class {
      constructor({ additionalAllowedHeaderNames: allowedHeaderNames = [], additionalAllowedQueryParameters: allowedQueryParameters = [] } = {}) {
        allowedHeaderNames = defaultAllowedHeaderNames.concat(allowedHeaderNames);
        allowedQueryParameters = defaultAllowedQueryParameters.concat(allowedQueryParameters);
        this.allowedHeaderNames = new Set(allowedHeaderNames.map((n) => n.toLowerCase()));
        this.allowedQueryParameters = new Set(allowedQueryParameters.map((p) => p.toLowerCase()));
      }
      /**
       * Sanitizes an object for logging.
       * @param obj - The object to sanitize
       * @returns - The sanitized object as a string
       */
      sanitize(obj) {
        const seen = /* @__PURE__ */ new Set();
        return JSON.stringify(obj, (key, value) => {
          if (value instanceof Error) {
            return Object.assign(Object.assign({}, value), { name: value.name, message: value.message });
          }
          if (key === "headers") {
            return this.sanitizeHeaders(value);
          } else if (key === "url") {
            return this.sanitizeUrl(value);
          } else if (key === "query") {
            return this.sanitizeQuery(value);
          } else if (key === "body") {
            return void 0;
          } else if (key === "response") {
            return void 0;
          } else if (key === "operationSpec") {
            return void 0;
          } else if (Array.isArray(value) || isObject(value)) {
            if (seen.has(value)) {
              return "[Circular]";
            }
            seen.add(value);
          }
          return value;
        }, 2);
      }
      /**
       * Sanitizes a URL for logging.
       * @param value - The URL to sanitize
       * @returns - The sanitized URL as a string
       */
      sanitizeUrl(value) {
        if (typeof value !== "string" || value === null || value === "") {
          return value;
        }
        const url = new URL(value);
        if (!url.search) {
          return value;
        }
        for (const [key] of url.searchParams) {
          if (!this.allowedQueryParameters.has(key.toLowerCase())) {
            url.searchParams.set(key, RedactedString);
          }
        }
        return url.toString();
      }
      sanitizeHeaders(obj) {
        const sanitized = {};
        for (const key of Object.keys(obj)) {
          if (this.allowedHeaderNames.has(key.toLowerCase())) {
            sanitized[key] = obj[key];
          } else {
            sanitized[key] = RedactedString;
          }
        }
        return sanitized;
      }
      sanitizeQuery(value) {
        if (typeof value !== "object" || value === null) {
          return value;
        }
        const sanitized = {};
        for (const k of Object.keys(value)) {
          if (this.allowedQueryParameters.has(k.toLowerCase())) {
            sanitized[k] = value[k];
          } else {
            sanitized[k] = RedactedString;
          }
        }
        return sanitized;
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/util/internal.js
var init_internal2 = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/util/internal.js"() {
    init_delay();
    init_random();
    init_object();
    init_error();
    init_sha256();
    init_uuidUtils();
    init_checkEnvironment();
    init_bytesEncoding();
    init_sanitizer();
  }
});

// node_modules/@azure/core-util/dist/browser/aborterUtils.js
var init_aborterUtils = __esm({
  "node_modules/@azure/core-util/dist/browser/aborterUtils.js"() {
  }
});

// node_modules/@azure/abort-controller/dist/browser/AbortError.js
var AbortError;
var init_AbortError = __esm({
  "node_modules/@azure/abort-controller/dist/browser/AbortError.js"() {
    AbortError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "AbortError";
      }
    };
  }
});

// node_modules/@azure/abort-controller/dist/browser/index.js
var init_browser3 = __esm({
  "node_modules/@azure/abort-controller/dist/browser/index.js"() {
    init_AbortError();
  }
});

// node_modules/@azure/core-util/dist/browser/createAbortablePromise.js
function createAbortablePromise(buildPromise, options) {
  const { cleanupBeforeAbort, abortSignal, abortErrorMsg } = options !== null && options !== void 0 ? options : {};
  return new Promise((resolve, reject) => {
    function rejectOnAbort() {
      reject(new AbortError(abortErrorMsg !== null && abortErrorMsg !== void 0 ? abortErrorMsg : "The operation was aborted."));
    }
    function removeListeners() {
      abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener("abort", onAbort);
    }
    function onAbort() {
      cleanupBeforeAbort === null || cleanupBeforeAbort === void 0 ? void 0 : cleanupBeforeAbort();
      removeListeners();
      rejectOnAbort();
    }
    if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {
      return rejectOnAbort();
    }
    try {
      buildPromise((x) => {
        removeListeners();
        resolve(x);
      }, (x) => {
        removeListeners();
        reject(x);
      });
    } catch (err) {
      reject(err);
    }
    abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.addEventListener("abort", onAbort);
  });
}
var init_createAbortablePromise = __esm({
  "node_modules/@azure/core-util/dist/browser/createAbortablePromise.js"() {
    init_browser3();
  }
});

// node_modules/@azure/core-util/dist/browser/delay.js
function delay(timeInMs, options) {
  let token;
  const { abortSignal, abortErrorMsg } = options !== null && options !== void 0 ? options : {};
  return createAbortablePromise((resolve) => {
    token = setTimeout(resolve, timeInMs);
  }, {
    cleanupBeforeAbort: () => clearTimeout(token),
    abortSignal,
    abortErrorMsg: abortErrorMsg !== null && abortErrorMsg !== void 0 ? abortErrorMsg : StandardAbortMessage
  });
}
var StandardAbortMessage;
var init_delay2 = __esm({
  "node_modules/@azure/core-util/dist/browser/delay.js"() {
    init_createAbortablePromise();
    init_internal2();
    StandardAbortMessage = "The delay was aborted.";
  }
});

// node_modules/@azure/core-util/dist/browser/error.js
function getErrorMessage(e) {
  if (isError(e)) {
    return e.message;
  } else {
    let stringified;
    try {
      if (typeof e === "object" && e) {
        stringified = JSON.stringify(e);
      } else {
        stringified = String(e);
      }
    } catch (err) {
      stringified = "[unable to stringify input]";
    }
    return `Unknown error ${stringified}`;
  }
}
var init_error2 = __esm({
  "node_modules/@azure/core-util/dist/browser/error.js"() {
    init_internal2();
  }
});

// node_modules/@azure/core-util/dist/browser/typeGuards.js
function isDefined(thing) {
  return typeof thing !== "undefined" && thing !== null;
}
function isObjectWithProperties(thing, properties) {
  if (!isDefined(thing) || typeof thing !== "object") {
    return false;
  }
  for (const property of properties) {
    if (!objectHasProperty(thing, property)) {
      return false;
    }
  }
  return true;
}
function objectHasProperty(thing, property) {
  return isDefined(thing) && typeof thing === "object" && property in thing;
}
var init_typeGuards = __esm({
  "node_modules/@azure/core-util/dist/browser/typeGuards.js"() {
  }
});

// node_modules/@azure/core-util/dist/browser/index.js
function isError2(e) {
  return isError(e);
}
var isNode, isNodeLike2;
var init_browser4 = __esm({
  "node_modules/@azure/core-util/dist/browser/index.js"() {
    init_internal2();
    init_aborterUtils();
    init_createAbortablePromise();
    init_delay2();
    init_error2();
    init_typeGuards();
    isNode = isNodeLike;
    isNodeLike2 = isNodeLike;
  }
});

// node_modules/@azure/msal-common/dist/utils/Constants.mjs
var Constants, HttpStatus, HttpMethod, OIDC_DEFAULT_SCOPES, OIDC_SCOPES, HeaderNames, PersistentCacheKeys, AADAuthorityConstants, ClaimsRequestKeys, PromptValue, OAuthResponseType, ServerResponseType, ResponseMode, GrantType, CacheAccountType, Separators, CredentialType, APP_METADATA, CLIENT_INFO, THE_FAMILY_ID, AUTHORITY_METADATA_CONSTANTS, AuthorityMetadataSource, SERVER_TELEM_CONSTANTS, AuthenticationScheme, ThrottlingConstants, Errors, PasswordGrantConstants, RegionDiscoverySources, RegionDiscoveryOutcomes, CacheOutcome, JsonWebTokenTypes, DEFAULT_TOKEN_RENEWAL_OFFSET_SEC;
var init_Constants = __esm({
  "node_modules/@azure/msal-common/dist/utils/Constants.mjs"() {
    "use strict";
    Constants = {
      LIBRARY_NAME: "MSAL.JS",
      SKU: "msal.js.common",
      // Prefix for all library cache entries
      CACHE_PREFIX: "msal",
      // default authority
      DEFAULT_AUTHORITY: "https://login.microsoftonline.com/common/",
      DEFAULT_AUTHORITY_HOST: "login.microsoftonline.com",
      DEFAULT_COMMON_TENANT: "common",
      // ADFS String
      ADFS: "adfs",
      DSTS: "dstsv2",
      // Default AAD Instance Discovery Endpoint
      AAD_INSTANCE_DISCOVERY_ENDPT: "https://login.microsoftonline.com/common/discovery/instance?api-version=1.1&authorization_endpoint=",
      // CIAM URL
      CIAM_AUTH_URL: ".ciamlogin.com",
      AAD_TENANT_DOMAIN_SUFFIX: ".onmicrosoft.com",
      // Resource delimiter - used for certain cache entries
      RESOURCE_DELIM: "|",
      // Placeholder for non-existent account ids/objects
      NO_ACCOUNT: "NO_ACCOUNT",
      // Claims
      CLAIMS: "claims",
      // Consumer UTID
      CONSUMER_UTID: "9188040d-6c67-4c5b-b112-36a304b66dad",
      // Default scopes
      OPENID_SCOPE: "openid",
      PROFILE_SCOPE: "profile",
      OFFLINE_ACCESS_SCOPE: "offline_access",
      EMAIL_SCOPE: "email",
      CODE_GRANT_TYPE: "authorization_code",
      RT_GRANT_TYPE: "refresh_token",
      S256_CODE_CHALLENGE_METHOD: "S256",
      URL_FORM_CONTENT_TYPE: "application/x-www-form-urlencoded;charset=utf-8",
      AUTHORIZATION_PENDING: "authorization_pending",
      NOT_DEFINED: "not_defined",
      EMPTY_STRING: "",
      NOT_APPLICABLE: "N/A",
      NOT_AVAILABLE: "Not Available",
      FORWARD_SLASH: "/",
      IMDS_ENDPOINT: "http://169.254.169.254/metadata/instance/compute/location",
      IMDS_VERSION: "2020-06-01",
      IMDS_TIMEOUT: 2e3,
      AZURE_REGION_AUTO_DISCOVER_FLAG: "TryAutoDetect",
      REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX: "login.microsoft.com",
      KNOWN_PUBLIC_CLOUDS: [
        "login.microsoftonline.com",
        "login.windows.net",
        "login.microsoft.com",
        "sts.windows.net"
      ],
      SHR_NONCE_VALIDITY: 240,
      INVALID_INSTANCE: "invalid_instance"
    };
    HttpStatus = {
      SUCCESS: 200,
      SUCCESS_RANGE_START: 200,
      SUCCESS_RANGE_END: 299,
      REDIRECT: 302,
      CLIENT_ERROR: 400,
      CLIENT_ERROR_RANGE_START: 400,
      BAD_REQUEST: 400,
      UNAUTHORIZED: 401,
      NOT_FOUND: 404,
      REQUEST_TIMEOUT: 408,
      GONE: 410,
      TOO_MANY_REQUESTS: 429,
      CLIENT_ERROR_RANGE_END: 499,
      SERVER_ERROR: 500,
      SERVER_ERROR_RANGE_START: 500,
      SERVICE_UNAVAILABLE: 503,
      GATEWAY_TIMEOUT: 504,
      SERVER_ERROR_RANGE_END: 599,
      MULTI_SIDED_ERROR: 600
    };
    HttpMethod = {
      GET: "GET",
      POST: "POST"
    };
    OIDC_DEFAULT_SCOPES = [
      Constants.OPENID_SCOPE,
      Constants.PROFILE_SCOPE,
      Constants.OFFLINE_ACCESS_SCOPE
    ];
    OIDC_SCOPES = [...OIDC_DEFAULT_SCOPES, Constants.EMAIL_SCOPE];
    HeaderNames = {
      CONTENT_TYPE: "Content-Type",
      CONTENT_LENGTH: "Content-Length",
      RETRY_AFTER: "Retry-After",
      CCS_HEADER: "X-AnchorMailbox",
      WWWAuthenticate: "WWW-Authenticate",
      AuthenticationInfo: "Authentication-Info",
      X_MS_REQUEST_ID: "x-ms-request-id",
      X_MS_HTTP_VERSION: "x-ms-httpver"
    };
    PersistentCacheKeys = {
      ACTIVE_ACCOUNT_FILTERS: "active-account-filters"
      // new cache entry for active_account for a more robust version for browser
    };
    AADAuthorityConstants = {
      COMMON: "common",
      ORGANIZATIONS: "organizations",
      CONSUMERS: "consumers"
    };
    ClaimsRequestKeys = {
      ACCESS_TOKEN: "access_token",
      XMS_CC: "xms_cc"
    };
    PromptValue = {
      LOGIN: "login",
      SELECT_ACCOUNT: "select_account",
      CONSENT: "consent",
      NONE: "none",
      CREATE: "create",
      NO_SESSION: "no_session"
    };
    OAuthResponseType = {
      CODE: "code",
      IDTOKEN_TOKEN: "id_token token",
      IDTOKEN_TOKEN_REFRESHTOKEN: "id_token token refresh_token"
    };
    ServerResponseType = {
      QUERY: "query",
      FRAGMENT: "fragment"
    };
    ResponseMode = {
      QUERY: "query",
      FRAGMENT: "fragment",
      FORM_POST: "form_post"
    };
    GrantType = {
      IMPLICIT_GRANT: "implicit",
      AUTHORIZATION_CODE_GRANT: "authorization_code",
      CLIENT_CREDENTIALS_GRANT: "client_credentials",
      RESOURCE_OWNER_PASSWORD_GRANT: "password",
      REFRESH_TOKEN_GRANT: "refresh_token",
      DEVICE_CODE_GRANT: "device_code",
      JWT_BEARER: "urn:ietf:params:oauth:grant-type:jwt-bearer"
    };
    CacheAccountType = {
      MSSTS_ACCOUNT_TYPE: "MSSTS",
      ADFS_ACCOUNT_TYPE: "ADFS",
      MSAV1_ACCOUNT_TYPE: "MSA",
      GENERIC_ACCOUNT_TYPE: "Generic"
      // NTLM, Kerberos, FBA, Basic etc
    };
    Separators = {
      CACHE_KEY_SEPARATOR: "-",
      CLIENT_INFO_SEPARATOR: "."
    };
    CredentialType = {
      ID_TOKEN: "IdToken",
      ACCESS_TOKEN: "AccessToken",
      ACCESS_TOKEN_WITH_AUTH_SCHEME: "AccessToken_With_AuthScheme",
      REFRESH_TOKEN: "RefreshToken"
    };
    APP_METADATA = "appmetadata";
    CLIENT_INFO = "client_info";
    THE_FAMILY_ID = "1";
    AUTHORITY_METADATA_CONSTANTS = {
      CACHE_KEY: "authority-metadata",
      REFRESH_TIME_SECONDS: 3600 * 24
      // 24 Hours
    };
    AuthorityMetadataSource = {
      CONFIG: "config",
      CACHE: "cache",
      NETWORK: "network",
      HARDCODED_VALUES: "hardcoded_values"
    };
    SERVER_TELEM_CONSTANTS = {
      SCHEMA_VERSION: 5,
      MAX_LAST_HEADER_BYTES: 330,
      MAX_CACHED_ERRORS: 50,
      CACHE_KEY: "server-telemetry",
      CATEGORY_SEPARATOR: "|",
      VALUE_SEPARATOR: ",",
      OVERFLOW_TRUE: "1",
      OVERFLOW_FALSE: "0",
      UNKNOWN_ERROR: "unknown_error"
    };
    AuthenticationScheme = {
      BEARER: "Bearer",
      POP: "pop",
      SSH: "ssh-cert"
    };
    ThrottlingConstants = {
      // Default time to throttle RequestThumbprint in seconds
      DEFAULT_THROTTLE_TIME_SECONDS: 60,
      // Default maximum time to throttle in seconds, overrides what the server sends back
      DEFAULT_MAX_THROTTLE_TIME_SECONDS: 3600,
      // Prefix for storing throttling entries
      THROTTLING_PREFIX: "throttling",
      // Value assigned to the x-ms-lib-capability header to indicate to the server the library supports throttling
      X_MS_LIB_CAPABILITY_VALUE: "retry-after, h429"
    };
    Errors = {
      INVALID_GRANT_ERROR: "invalid_grant",
      CLIENT_MISMATCH_ERROR: "client_mismatch"
    };
    PasswordGrantConstants = {
      username: "username",
      password: "password"
    };
    RegionDiscoverySources = {
      FAILED_AUTO_DETECTION: "1",
      INTERNAL_CACHE: "2",
      ENVIRONMENT_VARIABLE: "3",
      IMDS: "4"
    };
    RegionDiscoveryOutcomes = {
      CONFIGURED_NO_AUTO_DETECTION: "2",
      AUTO_DETECTION_REQUESTED_SUCCESSFUL: "4",
      AUTO_DETECTION_REQUESTED_FAILED: "5"
    };
    CacheOutcome = {
      // When a token is found in the cache or the cache is not supposed to be hit when making the request
      NOT_APPLICABLE: "0",
      // When the token request goes to the identity provider because force_refresh was set to true. Also occurs if claims were requested
      FORCE_REFRESH_OR_CLAIMS: "1",
      // When the token request goes to the identity provider because no cached access token exists
      NO_CACHED_ACCESS_TOKEN: "2",
      // When the token request goes to the identity provider because cached access token expired
      CACHED_ACCESS_TOKEN_EXPIRED: "3",
      // When the token request goes to the identity provider because refresh_in was used and the existing token needs to be refreshed
      PROACTIVELY_REFRESHED: "4"
    };
    JsonWebTokenTypes = {
      Jwt: "JWT",
      Jwk: "JWK",
      Pop: "pop"
    };
    DEFAULT_TOKEN_RENEWAL_OFFSET_SEC = 300;
  }
});

// node_modules/@azure/msal-common/dist/error/AuthErrorCodes.mjs
var AuthErrorCodes_exports = {};
__export(AuthErrorCodes_exports, {
  postRequestFailed: () => postRequestFailed,
  unexpectedError: () => unexpectedError
});
var unexpectedError, postRequestFailed;
var init_AuthErrorCodes = __esm({
  "node_modules/@azure/msal-common/dist/error/AuthErrorCodes.mjs"() {
    "use strict";
    unexpectedError = "unexpected_error";
    postRequestFailed = "post_request_failed";
  }
});

// node_modules/@azure/msal-common/dist/error/AuthError.mjs
function createAuthError(code, additionalMessage) {
  return new AuthError(code, additionalMessage ? `${AuthErrorMessages[code]} ${additionalMessage}` : AuthErrorMessages[code]);
}
var AuthErrorMessages, AuthErrorMessage, AuthError;
var init_AuthError = __esm({
  "node_modules/@azure/msal-common/dist/error/AuthError.mjs"() {
    "use strict";
    init_Constants();
    init_AuthErrorCodes();
    init_AuthErrorCodes();
    AuthErrorMessages = {
      [unexpectedError]: "Unexpected error in authentication.",
      [postRequestFailed]: "Post request failed from the network, could be a 4xx/5xx or a network unavailability. Please check the exact error code for details."
    };
    AuthErrorMessage = {
      unexpectedError: {
        code: unexpectedError,
        desc: AuthErrorMessages[unexpectedError]
      },
      postRequestFailed: {
        code: postRequestFailed,
        desc: AuthErrorMessages[postRequestFailed]
      }
    };
    AuthError = class _AuthError extends Error {
      constructor(errorCode, errorMessage2, suberror) {
        const errorString = errorMessage2 ? `${errorCode}: ${errorMessage2}` : errorCode;
        super(errorString);
        Object.setPrototypeOf(this, _AuthError.prototype);
        this.errorCode = errorCode || Constants.EMPTY_STRING;
        this.errorMessage = errorMessage2 || Constants.EMPTY_STRING;
        this.subError = suberror || Constants.EMPTY_STRING;
        this.name = "AuthError";
      }
      setCorrelationId(correlationId) {
        this.correlationId = correlationId;
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/error/ClientAuthErrorCodes.mjs
var ClientAuthErrorCodes_exports = {};
__export(ClientAuthErrorCodes_exports, {
  authTimeNotFound: () => authTimeNotFound,
  authorizationCodeMissingFromServerResponse: () => authorizationCodeMissingFromServerResponse,
  bindingKeyNotRemoved: () => bindingKeyNotRemoved,
  cannotAppendScopeSet: () => cannotAppendScopeSet,
  cannotRemoveEmptyScope: () => cannotRemoveEmptyScope,
  clientInfoDecodingError: () => clientInfoDecodingError,
  clientInfoEmptyError: () => clientInfoEmptyError,
  deviceCodeExpired: () => deviceCodeExpired,
  deviceCodePollingCancelled: () => deviceCodePollingCancelled,
  deviceCodeUnknownError: () => deviceCodeUnknownError,
  emptyInputScopeSet: () => emptyInputScopeSet,
  endSessionEndpointNotSupported: () => endSessionEndpointNotSupported,
  endpointResolutionError: () => endpointResolutionError,
  hashNotDeserialized: () => hashNotDeserialized,
  invalidAssertion: () => invalidAssertion,
  invalidCacheEnvironment: () => invalidCacheEnvironment,
  invalidCacheRecord: () => invalidCacheRecord,
  invalidClientCredential: () => invalidClientCredential,
  invalidState: () => invalidState,
  keyIdMissing: () => keyIdMissing,
  maxAgeTranspired: () => maxAgeTranspired,
  methodNotImplemented: () => methodNotImplemented,
  missingTenantIdError: () => missingTenantIdError,
  multipleMatchingAccounts: () => multipleMatchingAccounts,
  multipleMatchingAppMetadata: () => multipleMatchingAppMetadata,
  multipleMatchingTokens: () => multipleMatchingTokens,
  nestedAppAuthBridgeDisabled: () => nestedAppAuthBridgeDisabled,
  networkError: () => networkError,
  noAccountFound: () => noAccountFound,
  noAccountInSilentRequest: () => noAccountInSilentRequest,
  noCryptoObject: () => noCryptoObject,
  noNetworkConnectivity: () => noNetworkConnectivity,
  nonceMismatch: () => nonceMismatch,
  nullOrEmptyToken: () => nullOrEmptyToken,
  openIdConfigError: () => openIdConfigError,
  requestCannotBeMade: () => requestCannotBeMade,
  stateMismatch: () => stateMismatch,
  stateNotFound: () => stateNotFound,
  tokenClaimsCnfRequiredForSignedJwt: () => tokenClaimsCnfRequiredForSignedJwt,
  tokenParsingError: () => tokenParsingError,
  tokenRefreshRequired: () => tokenRefreshRequired,
  unexpectedCredentialType: () => unexpectedCredentialType,
  userCanceled: () => userCanceled,
  userTimeoutReached: () => userTimeoutReached
});
var clientInfoDecodingError, clientInfoEmptyError, tokenParsingError, nullOrEmptyToken, endpointResolutionError, networkError, openIdConfigError, hashNotDeserialized, invalidState, stateMismatch, stateNotFound, nonceMismatch, authTimeNotFound, maxAgeTranspired, multipleMatchingTokens, multipleMatchingAccounts, multipleMatchingAppMetadata, requestCannotBeMade, cannotRemoveEmptyScope, cannotAppendScopeSet, emptyInputScopeSet, deviceCodePollingCancelled, deviceCodeExpired, deviceCodeUnknownError, noAccountInSilentRequest, invalidCacheRecord, invalidCacheEnvironment, noAccountFound, noCryptoObject, unexpectedCredentialType, invalidAssertion, invalidClientCredential, tokenRefreshRequired, userTimeoutReached, tokenClaimsCnfRequiredForSignedJwt, authorizationCodeMissingFromServerResponse, bindingKeyNotRemoved, endSessionEndpointNotSupported, keyIdMissing, noNetworkConnectivity, userCanceled, missingTenantIdError, methodNotImplemented, nestedAppAuthBridgeDisabled;
var init_ClientAuthErrorCodes = __esm({
  "node_modules/@azure/msal-common/dist/error/ClientAuthErrorCodes.mjs"() {
    "use strict";
    clientInfoDecodingError = "client_info_decoding_error";
    clientInfoEmptyError = "client_info_empty_error";
    tokenParsingError = "token_parsing_error";
    nullOrEmptyToken = "null_or_empty_token";
    endpointResolutionError = "endpoints_resolution_error";
    networkError = "network_error";
    openIdConfigError = "openid_config_error";
    hashNotDeserialized = "hash_not_deserialized";
    invalidState = "invalid_state";
    stateMismatch = "state_mismatch";
    stateNotFound = "state_not_found";
    nonceMismatch = "nonce_mismatch";
    authTimeNotFound = "auth_time_not_found";
    maxAgeTranspired = "max_age_transpired";
    multipleMatchingTokens = "multiple_matching_tokens";
    multipleMatchingAccounts = "multiple_matching_accounts";
    multipleMatchingAppMetadata = "multiple_matching_appMetadata";
    requestCannotBeMade = "request_cannot_be_made";
    cannotRemoveEmptyScope = "cannot_remove_empty_scope";
    cannotAppendScopeSet = "cannot_append_scopeset";
    emptyInputScopeSet = "empty_input_scopeset";
    deviceCodePollingCancelled = "device_code_polling_cancelled";
    deviceCodeExpired = "device_code_expired";
    deviceCodeUnknownError = "device_code_unknown_error";
    noAccountInSilentRequest = "no_account_in_silent_request";
    invalidCacheRecord = "invalid_cache_record";
    invalidCacheEnvironment = "invalid_cache_environment";
    noAccountFound = "no_account_found";
    noCryptoObject = "no_crypto_object";
    unexpectedCredentialType = "unexpected_credential_type";
    invalidAssertion = "invalid_assertion";
    invalidClientCredential = "invalid_client_credential";
    tokenRefreshRequired = "token_refresh_required";
    userTimeoutReached = "user_timeout_reached";
    tokenClaimsCnfRequiredForSignedJwt = "token_claims_cnf_required_for_signedjwt";
    authorizationCodeMissingFromServerResponse = "authorization_code_missing_from_server_response";
    bindingKeyNotRemoved = "binding_key_not_removed";
    endSessionEndpointNotSupported = "end_session_endpoint_not_supported";
    keyIdMissing = "key_id_missing";
    noNetworkConnectivity = "no_network_connectivity";
    userCanceled = "user_canceled";
    missingTenantIdError = "missing_tenant_id_error";
    methodNotImplemented = "method_not_implemented";
    nestedAppAuthBridgeDisabled = "nested_app_auth_bridge_disabled";
  }
});

// node_modules/@azure/msal-common/dist/error/ClientAuthError.mjs
function createClientAuthError(errorCode, additionalMessage) {
  return new ClientAuthError(errorCode, additionalMessage);
}
var ClientAuthErrorMessages, ClientAuthErrorMessage, ClientAuthError;
var init_ClientAuthError = __esm({
  "node_modules/@azure/msal-common/dist/error/ClientAuthError.mjs"() {
    "use strict";
    init_AuthError();
    init_ClientAuthErrorCodes();
    init_ClientAuthErrorCodes();
    ClientAuthErrorMessages = {
      [clientInfoDecodingError]: "The client info could not be parsed/decoded correctly",
      [clientInfoEmptyError]: "The client info was empty",
      [tokenParsingError]: "Token cannot be parsed",
      [nullOrEmptyToken]: "The token is null or empty",
      [endpointResolutionError]: "Endpoints cannot be resolved",
      [networkError]: "Network request failed",
      [openIdConfigError]: "Could not retrieve endpoints. Check your authority and verify the .well-known/openid-configuration endpoint returns the required endpoints.",
      [hashNotDeserialized]: "The hash parameters could not be deserialized",
      [invalidState]: "State was not the expected format",
      [stateMismatch]: "State mismatch error",
      [stateNotFound]: "State not found",
      [nonceMismatch]: "Nonce mismatch error",
      [authTimeNotFound]: "Max Age was requested and the ID token is missing the auth_time variable. auth_time is an optional claim and is not enabled by default - it must be enabled. See https://aka.ms/msaljs/optional-claims for more information.",
      [maxAgeTranspired]: "Max Age is set to 0, or too much time has elapsed since the last end-user authentication.",
      [multipleMatchingTokens]: "The cache contains multiple tokens satisfying the requirements. Call AcquireToken again providing more requirements such as authority or account.",
      [multipleMatchingAccounts]: "The cache contains multiple accounts satisfying the given parameters. Please pass more info to obtain the correct account",
      [multipleMatchingAppMetadata]: "The cache contains multiple appMetadata satisfying the given parameters. Please pass more info to obtain the correct appMetadata",
      [requestCannotBeMade]: "Token request cannot be made without authorization code or refresh token.",
      [cannotRemoveEmptyScope]: "Cannot remove null or empty scope from ScopeSet",
      [cannotAppendScopeSet]: "Cannot append ScopeSet",
      [emptyInputScopeSet]: "Empty input ScopeSet cannot be processed",
      [deviceCodePollingCancelled]: "Caller has cancelled token endpoint polling during device code flow by setting DeviceCodeRequest.cancel = true.",
      [deviceCodeExpired]: "Device code is expired.",
      [deviceCodeUnknownError]: "Device code stopped polling for unknown reasons.",
      [noAccountInSilentRequest]: "Please pass an account object, silent flow is not supported without account information",
      [invalidCacheRecord]: "Cache record object was null or undefined.",
      [invalidCacheEnvironment]: "Invalid environment when attempting to create cache entry",
      [noAccountFound]: "No account found in cache for given key.",
      [noCryptoObject]: "No crypto object detected.",
      [unexpectedCredentialType]: "Unexpected credential type.",
      [invalidAssertion]: "Client assertion must meet requirements described in https://tools.ietf.org/html/rfc7515",
      [invalidClientCredential]: "Client credential (secret, certificate, or assertion) must not be empty when creating a confidential client. An application should at most have one credential",
      [tokenRefreshRequired]: "Cannot return token from cache because it must be refreshed. This may be due to one of the following reasons: forceRefresh parameter is set to true, claims have been requested, there is no cached access token or it is expired.",
      [userTimeoutReached]: "User defined timeout for device code polling reached",
      [tokenClaimsCnfRequiredForSignedJwt]: "Cannot generate a POP jwt if the token_claims are not populated",
      [authorizationCodeMissingFromServerResponse]: "Server response does not contain an authorization code to proceed",
      [bindingKeyNotRemoved]: "Could not remove the credential's binding key from storage.",
      [endSessionEndpointNotSupported]: "The provided authority does not support logout",
      [keyIdMissing]: "A keyId value is missing from the requested bound token's cache record and is required to match the token to it's stored binding key.",
      [noNetworkConnectivity]: "No network connectivity. Check your internet connection.",
      [userCanceled]: "User cancelled the flow.",
      [missingTenantIdError]: "A tenant id - not common, organizations, or consumers - must be specified when using the client_credentials flow.",
      [methodNotImplemented]: "This method has not been implemented",
      [nestedAppAuthBridgeDisabled]: "The nested app auth bridge is disabled"
    };
    ClientAuthErrorMessage = {
      clientInfoDecodingError: {
        code: clientInfoDecodingError,
        desc: ClientAuthErrorMessages[clientInfoDecodingError]
      },
      clientInfoEmptyError: {
        code: clientInfoEmptyError,
        desc: ClientAuthErrorMessages[clientInfoEmptyError]
      },
      tokenParsingError: {
        code: tokenParsingError,
        desc: ClientAuthErrorMessages[tokenParsingError]
      },
      nullOrEmptyToken: {
        code: nullOrEmptyToken,
        desc: ClientAuthErrorMessages[nullOrEmptyToken]
      },
      endpointResolutionError: {
        code: endpointResolutionError,
        desc: ClientAuthErrorMessages[endpointResolutionError]
      },
      networkError: {
        code: networkError,
        desc: ClientAuthErrorMessages[networkError]
      },
      unableToGetOpenidConfigError: {
        code: openIdConfigError,
        desc: ClientAuthErrorMessages[openIdConfigError]
      },
      hashNotDeserialized: {
        code: hashNotDeserialized,
        desc: ClientAuthErrorMessages[hashNotDeserialized]
      },
      invalidStateError: {
        code: invalidState,
        desc: ClientAuthErrorMessages[invalidState]
      },
      stateMismatchError: {
        code: stateMismatch,
        desc: ClientAuthErrorMessages[stateMismatch]
      },
      stateNotFoundError: {
        code: stateNotFound,
        desc: ClientAuthErrorMessages[stateNotFound]
      },
      nonceMismatchError: {
        code: nonceMismatch,
        desc: ClientAuthErrorMessages[nonceMismatch]
      },
      authTimeNotFoundError: {
        code: authTimeNotFound,
        desc: ClientAuthErrorMessages[authTimeNotFound]
      },
      maxAgeTranspired: {
        code: maxAgeTranspired,
        desc: ClientAuthErrorMessages[maxAgeTranspired]
      },
      multipleMatchingTokens: {
        code: multipleMatchingTokens,
        desc: ClientAuthErrorMessages[multipleMatchingTokens]
      },
      multipleMatchingAccounts: {
        code: multipleMatchingAccounts,
        desc: ClientAuthErrorMessages[multipleMatchingAccounts]
      },
      multipleMatchingAppMetadata: {
        code: multipleMatchingAppMetadata,
        desc: ClientAuthErrorMessages[multipleMatchingAppMetadata]
      },
      tokenRequestCannotBeMade: {
        code: requestCannotBeMade,
        desc: ClientAuthErrorMessages[requestCannotBeMade]
      },
      removeEmptyScopeError: {
        code: cannotRemoveEmptyScope,
        desc: ClientAuthErrorMessages[cannotRemoveEmptyScope]
      },
      appendScopeSetError: {
        code: cannotAppendScopeSet,
        desc: ClientAuthErrorMessages[cannotAppendScopeSet]
      },
      emptyInputScopeSetError: {
        code: emptyInputScopeSet,
        desc: ClientAuthErrorMessages[emptyInputScopeSet]
      },
      DeviceCodePollingCancelled: {
        code: deviceCodePollingCancelled,
        desc: ClientAuthErrorMessages[deviceCodePollingCancelled]
      },
      DeviceCodeExpired: {
        code: deviceCodeExpired,
        desc: ClientAuthErrorMessages[deviceCodeExpired]
      },
      DeviceCodeUnknownError: {
        code: deviceCodeUnknownError,
        desc: ClientAuthErrorMessages[deviceCodeUnknownError]
      },
      NoAccountInSilentRequest: {
        code: noAccountInSilentRequest,
        desc: ClientAuthErrorMessages[noAccountInSilentRequest]
      },
      invalidCacheRecord: {
        code: invalidCacheRecord,
        desc: ClientAuthErrorMessages[invalidCacheRecord]
      },
      invalidCacheEnvironment: {
        code: invalidCacheEnvironment,
        desc: ClientAuthErrorMessages[invalidCacheEnvironment]
      },
      noAccountFound: {
        code: noAccountFound,
        desc: ClientAuthErrorMessages[noAccountFound]
      },
      noCryptoObj: {
        code: noCryptoObject,
        desc: ClientAuthErrorMessages[noCryptoObject]
      },
      unexpectedCredentialType: {
        code: unexpectedCredentialType,
        desc: ClientAuthErrorMessages[unexpectedCredentialType]
      },
      invalidAssertion: {
        code: invalidAssertion,
        desc: ClientAuthErrorMessages[invalidAssertion]
      },
      invalidClientCredential: {
        code: invalidClientCredential,
        desc: ClientAuthErrorMessages[invalidClientCredential]
      },
      tokenRefreshRequired: {
        code: tokenRefreshRequired,
        desc: ClientAuthErrorMessages[tokenRefreshRequired]
      },
      userTimeoutReached: {
        code: userTimeoutReached,
        desc: ClientAuthErrorMessages[userTimeoutReached]
      },
      tokenClaimsRequired: {
        code: tokenClaimsCnfRequiredForSignedJwt,
        desc: ClientAuthErrorMessages[tokenClaimsCnfRequiredForSignedJwt]
      },
      noAuthorizationCodeFromServer: {
        code: authorizationCodeMissingFromServerResponse,
        desc: ClientAuthErrorMessages[authorizationCodeMissingFromServerResponse]
      },
      bindingKeyNotRemovedError: {
        code: bindingKeyNotRemoved,
        desc: ClientAuthErrorMessages[bindingKeyNotRemoved]
      },
      logoutNotSupported: {
        code: endSessionEndpointNotSupported,
        desc: ClientAuthErrorMessages[endSessionEndpointNotSupported]
      },
      keyIdMissing: {
        code: keyIdMissing,
        desc: ClientAuthErrorMessages[keyIdMissing]
      },
      noNetworkConnectivity: {
        code: noNetworkConnectivity,
        desc: ClientAuthErrorMessages[noNetworkConnectivity]
      },
      userCanceledError: {
        code: userCanceled,
        desc: ClientAuthErrorMessages[userCanceled]
      },
      missingTenantIdError: {
        code: missingTenantIdError,
        desc: ClientAuthErrorMessages[missingTenantIdError]
      },
      nestedAppAuthBridgeDisabled: {
        code: nestedAppAuthBridgeDisabled,
        desc: ClientAuthErrorMessages[nestedAppAuthBridgeDisabled]
      }
    };
    ClientAuthError = class _ClientAuthError extends AuthError {
      constructor(errorCode, additionalMessage) {
        super(errorCode, additionalMessage ? `${ClientAuthErrorMessages[errorCode]}: ${additionalMessage}` : ClientAuthErrorMessages[errorCode]);
        this.name = "ClientAuthError";
        Object.setPrototypeOf(this, _ClientAuthError.prototype);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/crypto/ICrypto.mjs
var DEFAULT_CRYPTO_IMPLEMENTATION;
var init_ICrypto = __esm({
  "node_modules/@azure/msal-common/dist/crypto/ICrypto.mjs"() {
    "use strict";
    init_ClientAuthError();
    init_ClientAuthErrorCodes();
    DEFAULT_CRYPTO_IMPLEMENTATION = {
      createNewGuid: () => {
        throw createClientAuthError(methodNotImplemented);
      },
      base64Decode: () => {
        throw createClientAuthError(methodNotImplemented);
      },
      base64Encode: () => {
        throw createClientAuthError(methodNotImplemented);
      },
      base64UrlEncode: () => {
        throw createClientAuthError(methodNotImplemented);
      },
      encodeKid: () => {
        throw createClientAuthError(methodNotImplemented);
      },
      async getPublicKeyThumbprint() {
        throw createClientAuthError(methodNotImplemented);
      },
      async removeTokenBindingKey() {
        throw createClientAuthError(methodNotImplemented);
      },
      async clearKeystore() {
        throw createClientAuthError(methodNotImplemented);
      },
      async signJwt() {
        throw createClientAuthError(methodNotImplemented);
      },
      async hashString() {
        throw createClientAuthError(methodNotImplemented);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/logger/Logger.mjs
var LogLevel, Logger;
var init_Logger = __esm({
  "node_modules/@azure/msal-common/dist/logger/Logger.mjs"() {
    "use strict";
    init_Constants();
    (function(LogLevel2) {
      LogLevel2[LogLevel2["Error"] = 0] = "Error";
      LogLevel2[LogLevel2["Warning"] = 1] = "Warning";
      LogLevel2[LogLevel2["Info"] = 2] = "Info";
      LogLevel2[LogLevel2["Verbose"] = 3] = "Verbose";
      LogLevel2[LogLevel2["Trace"] = 4] = "Trace";
    })(LogLevel || (LogLevel = {}));
    Logger = class _Logger {
      constructor(loggerOptions, packageName, packageVersion) {
        this.level = LogLevel.Info;
        const defaultLoggerCallback2 = () => {
          return;
        };
        const setLoggerOptions = loggerOptions || _Logger.createDefaultLoggerOptions();
        this.localCallback = setLoggerOptions.loggerCallback || defaultLoggerCallback2;
        this.piiLoggingEnabled = setLoggerOptions.piiLoggingEnabled || false;
        this.level = typeof setLoggerOptions.logLevel === "number" ? setLoggerOptions.logLevel : LogLevel.Info;
        this.correlationId = setLoggerOptions.correlationId || Constants.EMPTY_STRING;
        this.packageName = packageName || Constants.EMPTY_STRING;
        this.packageVersion = packageVersion || Constants.EMPTY_STRING;
      }
      static createDefaultLoggerOptions() {
        return {
          loggerCallback: () => {
          },
          piiLoggingEnabled: false,
          logLevel: LogLevel.Info
        };
      }
      /**
       * Create new Logger with existing configurations.
       */
      clone(packageName, packageVersion, correlationId) {
        return new _Logger({
          loggerCallback: this.localCallback,
          piiLoggingEnabled: this.piiLoggingEnabled,
          logLevel: this.level,
          correlationId: correlationId || this.correlationId
        }, packageName, packageVersion);
      }
      /**
       * Log message with required options.
       */
      logMessage(logMessage, options) {
        if (options.logLevel > this.level || !this.piiLoggingEnabled && options.containsPii) {
          return;
        }
        const timestamp = (/* @__PURE__ */ new Date()).toUTCString();
        const logHeader = `[${timestamp}] : [${options.correlationId || this.correlationId || ""}]`;
        const log2 = `${logHeader} : ${this.packageName}@${this.packageVersion} : ${LogLevel[options.logLevel]} - ${logMessage}`;
        this.executeCallback(options.logLevel, log2, options.containsPii || false);
      }
      /**
       * Execute callback with message.
       */
      executeCallback(level, message, containsPii) {
        if (this.localCallback) {
          this.localCallback(level, message, containsPii);
        }
      }
      /**
       * Logs error messages.
       */
      error(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel.Error,
          containsPii: false,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs error messages with PII.
       */
      errorPii(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel.Error,
          containsPii: true,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs warning messages.
       */
      warning(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel.Warning,
          containsPii: false,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs warning messages with PII.
       */
      warningPii(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel.Warning,
          containsPii: true,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs info messages.
       */
      info(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel.Info,
          containsPii: false,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs info messages with PII.
       */
      infoPii(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel.Info,
          containsPii: true,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs verbose messages.
       */
      verbose(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel.Verbose,
          containsPii: false,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs verbose messages with PII.
       */
      verbosePii(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel.Verbose,
          containsPii: true,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs trace messages.
       */
      trace(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel.Trace,
          containsPii: false,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs trace messages with PII.
       */
      tracePii(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel.Trace,
          containsPii: true,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Returns whether PII Logging is enabled or not.
       */
      isPiiLoggingEnabled() {
        return this.piiLoggingEnabled || false;
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/packageMetadata.mjs
var name, version;
var init_packageMetadata = __esm({
  "node_modules/@azure/msal-common/dist/packageMetadata.mjs"() {
    "use strict";
    name = "@azure/msal-common";
    version = "15.9.0";
  }
});

// node_modules/@azure/msal-common/dist/authority/AuthorityOptions.mjs
var AzureCloudInstance;
var init_AuthorityOptions = __esm({
  "node_modules/@azure/msal-common/dist/authority/AuthorityOptions.mjs"() {
    "use strict";
    AzureCloudInstance = {
      // AzureCloudInstance is not specified.
      None: "none",
      // Microsoft Azure public cloud
      AzurePublic: "https://login.microsoftonline.com",
      // Microsoft PPE
      AzurePpe: "https://login.windows-ppe.net",
      // Microsoft Chinese national/regional cloud
      AzureChina: "https://login.chinacloudapi.cn",
      // Microsoft German national/regional cloud ("Black Forest")
      AzureGermany: "https://login.microsoftonline.de",
      // US Government cloud
      AzureUsGovernment: "https://login.microsoftonline.us"
    };
  }
});

// node_modules/@azure/msal-common/dist/account/AuthToken.mjs
var AuthToken_exports = {};
__export(AuthToken_exports, {
  checkMaxAge: () => checkMaxAge,
  extractTokenClaims: () => extractTokenClaims,
  getJWSPayload: () => getJWSPayload
});
function extractTokenClaims(encodedToken, base64Decode2) {
  const jswPayload = getJWSPayload(encodedToken);
  try {
    const base64Decoded = base64Decode2(jswPayload);
    return JSON.parse(base64Decoded);
  } catch (err) {
    throw createClientAuthError(tokenParsingError);
  }
}
function getJWSPayload(authToken) {
  if (!authToken) {
    throw createClientAuthError(nullOrEmptyToken);
  }
  const tokenPartsRegex = /^([^\.\s]*)\.([^\.\s]+)\.([^\.\s]*)$/;
  const matches = tokenPartsRegex.exec(authToken);
  if (!matches || matches.length < 4) {
    throw createClientAuthError(tokenParsingError);
  }
  return matches[2];
}
function checkMaxAge(authTime, maxAge) {
  const fiveMinuteSkew = 3e5;
  if (maxAge === 0 || Date.now() - fiveMinuteSkew > authTime + maxAge) {
    throw createClientAuthError(maxAgeTranspired);
  }
}
var init_AuthToken = __esm({
  "node_modules/@azure/msal-common/dist/account/AuthToken.mjs"() {
    "use strict";
    init_ClientAuthError();
    init_ClientAuthErrorCodes();
  }
});

// node_modules/@azure/msal-common/dist/utils/TimeUtils.mjs
var TimeUtils_exports = {};
__export(TimeUtils_exports, {
  delay: () => delay2,
  isTokenExpired: () => isTokenExpired,
  nowSeconds: () => nowSeconds,
  toDateFromSeconds: () => toDateFromSeconds,
  toSecondsFromDate: () => toSecondsFromDate,
  wasClockTurnedBack: () => wasClockTurnedBack
});
function nowSeconds() {
  return Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3);
}
function toSecondsFromDate(date) {
  return date.getTime() / 1e3;
}
function toDateFromSeconds(seconds) {
  if (seconds) {
    return new Date(Number(seconds) * 1e3);
  }
  return /* @__PURE__ */ new Date();
}
function isTokenExpired(expiresOn, offset) {
  const expirationSec = Number(expiresOn) || 0;
  const offsetCurrentTimeSec = nowSeconds() + offset;
  return offsetCurrentTimeSec > expirationSec;
}
function wasClockTurnedBack(cachedAt) {
  const cachedAtSec = Number(cachedAt);
  return cachedAtSec > nowSeconds();
}
function delay2(t, value) {
  return new Promise((resolve) => setTimeout(() => resolve(value), t));
}
var init_TimeUtils = __esm({
  "node_modules/@azure/msal-common/dist/utils/TimeUtils.mjs"() {
    "use strict";
  }
});

// node_modules/@azure/msal-common/dist/cache/utils/CacheHelpers.mjs
var CacheHelpers_exports = {};
__export(CacheHelpers_exports, {
  createAccessTokenEntity: () => createAccessTokenEntity,
  createIdTokenEntity: () => createIdTokenEntity,
  createRefreshTokenEntity: () => createRefreshTokenEntity,
  generateAppMetadataKey: () => generateAppMetadataKey,
  generateAuthorityMetadataExpiresAt: () => generateAuthorityMetadataExpiresAt,
  generateCredentialKey: () => generateCredentialKey,
  isAccessTokenEntity: () => isAccessTokenEntity,
  isAppMetadataEntity: () => isAppMetadataEntity,
  isAuthorityMetadataEntity: () => isAuthorityMetadataEntity,
  isAuthorityMetadataExpired: () => isAuthorityMetadataExpired,
  isCredentialEntity: () => isCredentialEntity,
  isIdTokenEntity: () => isIdTokenEntity,
  isRefreshTokenEntity: () => isRefreshTokenEntity,
  isServerTelemetryEntity: () => isServerTelemetryEntity,
  isThrottlingEntity: () => isThrottlingEntity,
  updateAuthorityEndpointMetadata: () => updateAuthorityEndpointMetadata,
  updateCloudDiscoveryMetadata: () => updateCloudDiscoveryMetadata
});
function generateCredentialKey(credentialEntity) {
  const credentialKey = [
    generateAccountId(credentialEntity),
    generateCredentialId(credentialEntity),
    generateTarget(credentialEntity),
    generateClaimsHash(credentialEntity),
    generateScheme(credentialEntity)
  ];
  return credentialKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
}
function createIdTokenEntity(homeAccountId, environment, idToken, clientId, tenantId) {
  const idTokenEntity = {
    credentialType: CredentialType.ID_TOKEN,
    homeAccountId,
    environment,
    clientId,
    secret: idToken,
    realm: tenantId
  };
  return idTokenEntity;
}
function createAccessTokenEntity(homeAccountId, environment, accessToken, clientId, tenantId, scopes, expiresOn, extExpiresOn, base64Decode2, refreshOn, tokenType, userAssertionHash, keyId, requestedClaims, requestedClaimsHash) {
  var _a3, _b2;
  const atEntity = {
    homeAccountId,
    credentialType: CredentialType.ACCESS_TOKEN,
    secret: accessToken,
    cachedAt: nowSeconds().toString(),
    expiresOn: expiresOn.toString(),
    extendedExpiresOn: extExpiresOn.toString(),
    environment,
    clientId,
    realm: tenantId,
    target: scopes,
    tokenType: tokenType || AuthenticationScheme.BEARER
  };
  if (userAssertionHash) {
    atEntity.userAssertionHash = userAssertionHash;
  }
  if (refreshOn) {
    atEntity.refreshOn = refreshOn.toString();
  }
  if (requestedClaims) {
    atEntity.requestedClaims = requestedClaims;
    atEntity.requestedClaimsHash = requestedClaimsHash;
  }
  if (((_a3 = atEntity.tokenType) == null ? void 0 : _a3.toLowerCase()) !== AuthenticationScheme.BEARER.toLowerCase()) {
    atEntity.credentialType = CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;
    switch (atEntity.tokenType) {
      case AuthenticationScheme.POP:
        const tokenClaims = extractTokenClaims(accessToken, base64Decode2);
        if (!((_b2 = tokenClaims == null ? void 0 : tokenClaims.cnf) == null ? void 0 : _b2.kid)) {
          throw createClientAuthError(tokenClaimsCnfRequiredForSignedJwt);
        }
        atEntity.keyId = tokenClaims.cnf.kid;
        break;
      case AuthenticationScheme.SSH:
        atEntity.keyId = keyId;
    }
  }
  return atEntity;
}
function createRefreshTokenEntity(homeAccountId, environment, refreshToken, clientId, familyId, userAssertionHash, expiresOn) {
  const rtEntity = {
    credentialType: CredentialType.REFRESH_TOKEN,
    homeAccountId,
    environment,
    clientId,
    secret: refreshToken
  };
  if (userAssertionHash) {
    rtEntity.userAssertionHash = userAssertionHash;
  }
  if (familyId) {
    rtEntity.familyId = familyId;
  }
  if (expiresOn) {
    rtEntity.expiresOn = expiresOn.toString();
  }
  return rtEntity;
}
function isCredentialEntity(entity) {
  return entity.hasOwnProperty("homeAccountId") && entity.hasOwnProperty("environment") && entity.hasOwnProperty("credentialType") && entity.hasOwnProperty("clientId") && entity.hasOwnProperty("secret");
}
function isAccessTokenEntity(entity) {
  if (!entity) {
    return false;
  }
  return isCredentialEntity(entity) && entity.hasOwnProperty("realm") && entity.hasOwnProperty("target") && (entity["credentialType"] === CredentialType.ACCESS_TOKEN || entity["credentialType"] === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME);
}
function isIdTokenEntity(entity) {
  if (!entity) {
    return false;
  }
  return isCredentialEntity(entity) && entity.hasOwnProperty("realm") && entity["credentialType"] === CredentialType.ID_TOKEN;
}
function isRefreshTokenEntity(entity) {
  if (!entity) {
    return false;
  }
  return isCredentialEntity(entity) && entity["credentialType"] === CredentialType.REFRESH_TOKEN;
}
function generateAccountId(credentialEntity) {
  const accountId = [
    credentialEntity.homeAccountId,
    credentialEntity.environment
  ];
  return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
}
function generateCredentialId(credentialEntity) {
  const clientOrFamilyId = credentialEntity.credentialType === CredentialType.REFRESH_TOKEN ? credentialEntity.familyId || credentialEntity.clientId : credentialEntity.clientId;
  const credentialId = [
    credentialEntity.credentialType,
    clientOrFamilyId,
    credentialEntity.realm || ""
  ];
  return credentialId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
}
function generateTarget(credentialEntity) {
  return (credentialEntity.target || "").toLowerCase();
}
function generateClaimsHash(credentialEntity) {
  return (credentialEntity.requestedClaimsHash || "").toLowerCase();
}
function generateScheme(credentialEntity) {
  return credentialEntity.tokenType && credentialEntity.tokenType.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? credentialEntity.tokenType.toLowerCase() : "";
}
function isServerTelemetryEntity(key, entity) {
  const validateKey = key.indexOf(SERVER_TELEM_CONSTANTS.CACHE_KEY) === 0;
  let validateEntity = true;
  if (entity) {
    validateEntity = entity.hasOwnProperty("failedRequests") && entity.hasOwnProperty("errors") && entity.hasOwnProperty("cacheHits");
  }
  return validateKey && validateEntity;
}
function isThrottlingEntity(key, entity) {
  let validateKey = false;
  if (key) {
    validateKey = key.indexOf(ThrottlingConstants.THROTTLING_PREFIX) === 0;
  }
  let validateEntity = true;
  if (entity) {
    validateEntity = entity.hasOwnProperty("throttleTime");
  }
  return validateKey && validateEntity;
}
function generateAppMetadataKey({ environment, clientId }) {
  const appMetaDataKeyArray = [
    APP_METADATA,
    environment,
    clientId
  ];
  return appMetaDataKeyArray.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
}
function isAppMetadataEntity(key, entity) {
  if (!entity) {
    return false;
  }
  return key.indexOf(APP_METADATA) === 0 && entity.hasOwnProperty("clientId") && entity.hasOwnProperty("environment");
}
function isAuthorityMetadataEntity(key, entity) {
  if (!entity) {
    return false;
  }
  return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) === 0 && entity.hasOwnProperty("aliases") && entity.hasOwnProperty("preferred_cache") && entity.hasOwnProperty("preferred_network") && entity.hasOwnProperty("canonical_authority") && entity.hasOwnProperty("authorization_endpoint") && entity.hasOwnProperty("token_endpoint") && entity.hasOwnProperty("issuer") && entity.hasOwnProperty("aliasesFromNetwork") && entity.hasOwnProperty("endpointsFromNetwork") && entity.hasOwnProperty("expiresAt") && entity.hasOwnProperty("jwks_uri");
}
function generateAuthorityMetadataExpiresAt() {
  return nowSeconds() + AUTHORITY_METADATA_CONSTANTS.REFRESH_TIME_SECONDS;
}
function updateAuthorityEndpointMetadata(authorityMetadata, updatedValues, fromNetwork) {
  authorityMetadata.authorization_endpoint = updatedValues.authorization_endpoint;
  authorityMetadata.token_endpoint = updatedValues.token_endpoint;
  authorityMetadata.end_session_endpoint = updatedValues.end_session_endpoint;
  authorityMetadata.issuer = updatedValues.issuer;
  authorityMetadata.endpointsFromNetwork = fromNetwork;
  authorityMetadata.jwks_uri = updatedValues.jwks_uri;
}
function updateCloudDiscoveryMetadata(authorityMetadata, updatedValues, fromNetwork) {
  authorityMetadata.aliases = updatedValues.aliases;
  authorityMetadata.preferred_cache = updatedValues.preferred_cache;
  authorityMetadata.preferred_network = updatedValues.preferred_network;
  authorityMetadata.aliasesFromNetwork = fromNetwork;
}
function isAuthorityMetadataExpired(metadata) {
  return metadata.expiresAt <= nowSeconds();
}
var init_CacheHelpers = __esm({
  "node_modules/@azure/msal-common/dist/cache/utils/CacheHelpers.mjs"() {
    "use strict";
    init_AuthToken();
    init_ClientAuthError();
    init_Constants();
    init_TimeUtils();
    init_ClientAuthErrorCodes();
  }
});

// node_modules/@azure/msal-common/dist/error/ClientConfigurationErrorCodes.mjs
var ClientConfigurationErrorCodes_exports = {};
__export(ClientConfigurationErrorCodes_exports, {
  authorityMismatch: () => authorityMismatch,
  authorityUriInsecure: () => authorityUriInsecure,
  cannotAllowPlatformBroker: () => cannotAllowPlatformBroker,
  cannotSetOIDCOptions: () => cannotSetOIDCOptions,
  claimsRequestParsingError: () => claimsRequestParsingError,
  emptyInputScopesError: () => emptyInputScopesError,
  invalidAuthenticationHeader: () => invalidAuthenticationHeader,
  invalidAuthorityMetadata: () => invalidAuthorityMetadata,
  invalidAuthorizePostBodyParameters: () => invalidAuthorizePostBodyParameters,
  invalidClaims: () => invalidClaims,
  invalidCloudDiscoveryMetadata: () => invalidCloudDiscoveryMetadata,
  invalidCodeChallengeMethod: () => invalidCodeChallengeMethod,
  invalidRequestMethodForEAR: () => invalidRequestMethodForEAR,
  logoutRequestEmpty: () => logoutRequestEmpty,
  missingNonceAuthenticationHeader: () => missingNonceAuthenticationHeader,
  missingSshJwk: () => missingSshJwk,
  missingSshKid: () => missingSshKid,
  pkceParamsMissing: () => pkceParamsMissing,
  redirectUriEmpty: () => redirectUriEmpty,
  tokenRequestEmpty: () => tokenRequestEmpty,
  untrustedAuthority: () => untrustedAuthority,
  urlEmptyError: () => urlEmptyError,
  urlParseError: () => urlParseError
});
var redirectUriEmpty, claimsRequestParsingError, authorityUriInsecure, urlParseError, urlEmptyError, emptyInputScopesError, invalidClaims, tokenRequestEmpty, logoutRequestEmpty, invalidCodeChallengeMethod, pkceParamsMissing, invalidCloudDiscoveryMetadata, invalidAuthorityMetadata, untrustedAuthority, missingSshJwk, missingSshKid, missingNonceAuthenticationHeader, invalidAuthenticationHeader, cannotSetOIDCOptions, cannotAllowPlatformBroker, authorityMismatch, invalidRequestMethodForEAR, invalidAuthorizePostBodyParameters;
var init_ClientConfigurationErrorCodes = __esm({
  "node_modules/@azure/msal-common/dist/error/ClientConfigurationErrorCodes.mjs"() {
    "use strict";
    redirectUriEmpty = "redirect_uri_empty";
    claimsRequestParsingError = "claims_request_parsing_error";
    authorityUriInsecure = "authority_uri_insecure";
    urlParseError = "url_parse_error";
    urlEmptyError = "empty_url_error";
    emptyInputScopesError = "empty_input_scopes_error";
    invalidClaims = "invalid_claims";
    tokenRequestEmpty = "token_request_empty";
    logoutRequestEmpty = "logout_request_empty";
    invalidCodeChallengeMethod = "invalid_code_challenge_method";
    pkceParamsMissing = "pkce_params_missing";
    invalidCloudDiscoveryMetadata = "invalid_cloud_discovery_metadata";
    invalidAuthorityMetadata = "invalid_authority_metadata";
    untrustedAuthority = "untrusted_authority";
    missingSshJwk = "missing_ssh_jwk";
    missingSshKid = "missing_ssh_kid";
    missingNonceAuthenticationHeader = "missing_nonce_authentication_header";
    invalidAuthenticationHeader = "invalid_authentication_header";
    cannotSetOIDCOptions = "cannot_set_OIDCOptions";
    cannotAllowPlatformBroker = "cannot_allow_platform_broker";
    authorityMismatch = "authority_mismatch";
    invalidRequestMethodForEAR = "invalid_request_method_for_EAR";
    invalidAuthorizePostBodyParameters = "invalid_authorize_post_body_parameters";
  }
});

// node_modules/@azure/msal-common/dist/error/ClientConfigurationError.mjs
function createClientConfigurationError(errorCode) {
  return new ClientConfigurationError(errorCode);
}
var ClientConfigurationErrorMessages, ClientConfigurationErrorMessage, ClientConfigurationError;
var init_ClientConfigurationError = __esm({
  "node_modules/@azure/msal-common/dist/error/ClientConfigurationError.mjs"() {
    "use strict";
    init_AuthError();
    init_ClientConfigurationErrorCodes();
    init_ClientConfigurationErrorCodes();
    ClientConfigurationErrorMessages = {
      [redirectUriEmpty]: "A redirect URI is required for all calls, and none has been set.",
      [claimsRequestParsingError]: "Could not parse the given claims request object.",
      [authorityUriInsecure]: "Authority URIs must use https.  Please see here for valid authority configuration options: https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-js-initializing-client-applications#configuration-options",
      [urlParseError]: "URL could not be parsed into appropriate segments.",
      [urlEmptyError]: "URL was empty or null.",
      [emptyInputScopesError]: "Scopes cannot be passed as null, undefined or empty array because they are required to obtain an access token.",
      [invalidClaims]: "Given claims parameter must be a stringified JSON object.",
      [tokenRequestEmpty]: "Token request was empty and not found in cache.",
      [logoutRequestEmpty]: "The logout request was null or undefined.",
      [invalidCodeChallengeMethod]: 'code_challenge_method passed is invalid. Valid values are "plain" and "S256".',
      [pkceParamsMissing]: "Both params: code_challenge and code_challenge_method are to be passed if to be sent in the request",
      [invalidCloudDiscoveryMetadata]: "Invalid cloudDiscoveryMetadata provided. Must be a stringified JSON object containing tenant_discovery_endpoint and metadata fields",
      [invalidAuthorityMetadata]: "Invalid authorityMetadata provided. Must by a stringified JSON object containing authorization_endpoint, token_endpoint, issuer fields.",
      [untrustedAuthority]: "The provided authority is not a trusted authority. Please include this authority in the knownAuthorities config parameter.",
      [missingSshJwk]: "Missing sshJwk in SSH certificate request. A stringified JSON Web Key is required when using the SSH authentication scheme.",
      [missingSshKid]: "Missing sshKid in SSH certificate request. A string that uniquely identifies the public SSH key is required when using the SSH authentication scheme.",
      [missingNonceAuthenticationHeader]: "Unable to find an authentication header containing server nonce. Either the Authentication-Info or WWW-Authenticate headers must be present in order to obtain a server nonce.",
      [invalidAuthenticationHeader]: "Invalid authentication header provided",
      [cannotSetOIDCOptions]: "Cannot set OIDCOptions parameter. Please change the protocol mode to OIDC or use a non-Microsoft authority.",
      [cannotAllowPlatformBroker]: "Cannot set allowPlatformBroker parameter to true when not in AAD protocol mode.",
      [authorityMismatch]: "Authority mismatch error. Authority provided in login request or PublicClientApplication config does not match the environment of the provided account. Please use a matching account or make an interactive request to login to this authority.",
      [invalidAuthorizePostBodyParameters]: "Invalid authorize post body parameters provided. If you are using authorizePostBodyParameters, the request method must be POST. Please check the request method and parameters.",
      [invalidRequestMethodForEAR]: "Invalid request method for EAR protocol mode. The request method cannot be GET when using EAR protocol mode. Please change the request method to POST."
    };
    ClientConfigurationErrorMessage = {
      redirectUriNotSet: {
        code: redirectUriEmpty,
        desc: ClientConfigurationErrorMessages[redirectUriEmpty]
      },
      claimsRequestParsingError: {
        code: claimsRequestParsingError,
        desc: ClientConfigurationErrorMessages[claimsRequestParsingError]
      },
      authorityUriInsecure: {
        code: authorityUriInsecure,
        desc: ClientConfigurationErrorMessages[authorityUriInsecure]
      },
      urlParseError: {
        code: urlParseError,
        desc: ClientConfigurationErrorMessages[urlParseError]
      },
      urlEmptyError: {
        code: urlEmptyError,
        desc: ClientConfigurationErrorMessages[urlEmptyError]
      },
      emptyScopesError: {
        code: emptyInputScopesError,
        desc: ClientConfigurationErrorMessages[emptyInputScopesError]
      },
      invalidClaimsRequest: {
        code: invalidClaims,
        desc: ClientConfigurationErrorMessages[invalidClaims]
      },
      tokenRequestEmptyError: {
        code: tokenRequestEmpty,
        desc: ClientConfigurationErrorMessages[tokenRequestEmpty]
      },
      logoutRequestEmptyError: {
        code: logoutRequestEmpty,
        desc: ClientConfigurationErrorMessages[logoutRequestEmpty]
      },
      invalidCodeChallengeMethod: {
        code: invalidCodeChallengeMethod,
        desc: ClientConfigurationErrorMessages[invalidCodeChallengeMethod]
      },
      invalidCodeChallengeParams: {
        code: pkceParamsMissing,
        desc: ClientConfigurationErrorMessages[pkceParamsMissing]
      },
      invalidCloudDiscoveryMetadata: {
        code: invalidCloudDiscoveryMetadata,
        desc: ClientConfigurationErrorMessages[invalidCloudDiscoveryMetadata]
      },
      invalidAuthorityMetadata: {
        code: invalidAuthorityMetadata,
        desc: ClientConfigurationErrorMessages[invalidAuthorityMetadata]
      },
      untrustedAuthority: {
        code: untrustedAuthority,
        desc: ClientConfigurationErrorMessages[untrustedAuthority]
      },
      missingSshJwk: {
        code: missingSshJwk,
        desc: ClientConfigurationErrorMessages[missingSshJwk]
      },
      missingSshKid: {
        code: missingSshKid,
        desc: ClientConfigurationErrorMessages[missingSshKid]
      },
      missingNonceAuthenticationHeader: {
        code: missingNonceAuthenticationHeader,
        desc: ClientConfigurationErrorMessages[missingNonceAuthenticationHeader]
      },
      invalidAuthenticationHeader: {
        code: invalidAuthenticationHeader,
        desc: ClientConfigurationErrorMessages[invalidAuthenticationHeader]
      },
      cannotSetOIDCOptions: {
        code: cannotSetOIDCOptions,
        desc: ClientConfigurationErrorMessages[cannotSetOIDCOptions]
      },
      cannotAllowPlatformBroker: {
        code: cannotAllowPlatformBroker,
        desc: ClientConfigurationErrorMessages[cannotAllowPlatformBroker]
      },
      authorityMismatch: {
        code: authorityMismatch,
        desc: ClientConfigurationErrorMessages[authorityMismatch]
      },
      invalidAuthorizePostBodyParameters: {
        code: invalidAuthorizePostBodyParameters,
        desc: ClientConfigurationErrorMessages[invalidAuthorizePostBodyParameters]
      },
      invalidRequestMethodForEAR: {
        code: invalidRequestMethodForEAR,
        desc: ClientConfigurationErrorMessages[invalidRequestMethodForEAR]
      }
    };
    ClientConfigurationError = class _ClientConfigurationError extends AuthError {
      constructor(errorCode) {
        super(errorCode, ClientConfigurationErrorMessages[errorCode]);
        this.name = "ClientConfigurationError";
        Object.setPrototypeOf(this, _ClientConfigurationError.prototype);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/utils/StringUtils.mjs
var StringUtils;
var init_StringUtils = __esm({
  "node_modules/@azure/msal-common/dist/utils/StringUtils.mjs"() {
    "use strict";
    StringUtils = class {
      /**
       * Check if stringified object is empty
       * @param strObj
       */
      static isEmptyObj(strObj) {
        if (strObj) {
          try {
            const obj = JSON.parse(strObj);
            return Object.keys(obj).length === 0;
          } catch (e) {
          }
        }
        return true;
      }
      static startsWith(str, search) {
        return str.indexOf(search) === 0;
      }
      static endsWith(str, search) {
        return str.length >= search.length && str.lastIndexOf(search) === str.length - search.length;
      }
      /**
       * Parses string into an object.
       *
       * @param query
       */
      static queryStringToObject(query) {
        const obj = {};
        const params = query.split("&");
        const decode = (s) => decodeURIComponent(s.replace(/\+/g, " "));
        params.forEach((pair) => {
          if (pair.trim()) {
            const [key, value] = pair.split(/=(.+)/g, 2);
            if (key && value) {
              obj[decode(key)] = decode(value);
            }
          }
        });
        return obj;
      }
      /**
       * Trims entries in an array.
       *
       * @param arr
       */
      static trimArrayEntries(arr) {
        return arr.map((entry) => entry.trim());
      }
      /**
       * Removes empty strings from array
       * @param arr
       */
      static removeEmptyStringsFromArray(arr) {
        return arr.filter((entry) => {
          return !!entry;
        });
      }
      /**
       * Attempts to parse a string into JSON
       * @param str
       */
      static jsonParseHelper(str) {
        try {
          return JSON.parse(str);
        } catch (e) {
          return null;
        }
      }
      /**
       * Tests if a given string matches a given pattern, with support for wildcards and queries.
       * @param pattern Wildcard pattern to string match. Supports "*" for wildcards and "?" for queries
       * @param input String to match against
       */
      static matchPattern(pattern, input) {
        const regex = new RegExp(pattern.replace(/\\/g, "\\\\").replace(/\*/g, "[^ ]*").replace(/\?/g, "\\?"));
        return regex.test(input);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/request/ScopeSet.mjs
var ScopeSet;
var init_ScopeSet = __esm({
  "node_modules/@azure/msal-common/dist/request/ScopeSet.mjs"() {
    "use strict";
    init_ClientConfigurationError();
    init_StringUtils();
    init_ClientAuthError();
    init_Constants();
    init_ClientConfigurationErrorCodes();
    init_ClientAuthErrorCodes();
    ScopeSet = class _ScopeSet {
      constructor(inputScopes) {
        const scopeArr = inputScopes ? StringUtils.trimArrayEntries([...inputScopes]) : [];
        const filteredInput = scopeArr ? StringUtils.removeEmptyStringsFromArray(scopeArr) : [];
        if (!filteredInput || !filteredInput.length) {
          throw createClientConfigurationError(emptyInputScopesError);
        }
        this.scopes = /* @__PURE__ */ new Set();
        filteredInput.forEach((scope) => this.scopes.add(scope));
      }
      /**
       * Factory method to create ScopeSet from space-delimited string
       * @param inputScopeString
       * @param appClientId
       * @param scopesRequired
       */
      static fromString(inputScopeString) {
        const scopeString = inputScopeString || Constants.EMPTY_STRING;
        const inputScopes = scopeString.split(" ");
        return new _ScopeSet(inputScopes);
      }
      /**
       * Creates the set of scopes to search for in cache lookups
       * @param inputScopeString
       * @returns
       */
      static createSearchScopes(inputScopeString) {
        const scopeSet = new _ScopeSet(inputScopeString);
        if (!scopeSet.containsOnlyOIDCScopes()) {
          scopeSet.removeOIDCScopes();
        } else {
          scopeSet.removeScope(Constants.OFFLINE_ACCESS_SCOPE);
        }
        return scopeSet;
      }
      /**
       * Check if a given scope is present in this set of scopes.
       * @param scope
       */
      containsScope(scope) {
        const lowerCaseScopes = this.printScopesLowerCase().split(" ");
        const lowerCaseScopesSet = new _ScopeSet(lowerCaseScopes);
        return scope ? lowerCaseScopesSet.scopes.has(scope.toLowerCase()) : false;
      }
      /**
       * Check if a set of scopes is present in this set of scopes.
       * @param scopeSet
       */
      containsScopeSet(scopeSet) {
        if (!scopeSet || scopeSet.scopes.size <= 0) {
          return false;
        }
        return this.scopes.size >= scopeSet.scopes.size && scopeSet.asArray().every((scope) => this.containsScope(scope));
      }
      /**
       * Check if set of scopes contains only the defaults
       */
      containsOnlyOIDCScopes() {
        let defaultScopeCount = 0;
        OIDC_SCOPES.forEach((defaultScope) => {
          if (this.containsScope(defaultScope)) {
            defaultScopeCount += 1;
          }
        });
        return this.scopes.size === defaultScopeCount;
      }
      /**
       * Appends single scope if passed
       * @param newScope
       */
      appendScope(newScope) {
        if (newScope) {
          this.scopes.add(newScope.trim());
        }
      }
      /**
       * Appends multiple scopes if passed
       * @param newScopes
       */
      appendScopes(newScopes) {
        try {
          newScopes.forEach((newScope) => this.appendScope(newScope));
        } catch (e) {
          throw createClientAuthError(cannotAppendScopeSet);
        }
      }
      /**
       * Removes element from set of scopes.
       * @param scope
       */
      removeScope(scope) {
        if (!scope) {
          throw createClientAuthError(cannotRemoveEmptyScope);
        }
        this.scopes.delete(scope.trim());
      }
      /**
       * Removes default scopes from set of scopes
       * Primarily used to prevent cache misses if the default scopes are not returned from the server
       */
      removeOIDCScopes() {
        OIDC_SCOPES.forEach((defaultScope) => {
          this.scopes.delete(defaultScope);
        });
      }
      /**
       * Combines an array of scopes with the current set of scopes.
       * @param otherScopes
       */
      unionScopeSets(otherScopes) {
        if (!otherScopes) {
          throw createClientAuthError(emptyInputScopeSet);
        }
        const unionScopes = /* @__PURE__ */ new Set();
        otherScopes.scopes.forEach((scope) => unionScopes.add(scope.toLowerCase()));
        this.scopes.forEach((scope) => unionScopes.add(scope.toLowerCase()));
        return unionScopes;
      }
      /**
       * Check if scopes intersect between this set and another.
       * @param otherScopes
       */
      intersectingScopeSets(otherScopes) {
        if (!otherScopes) {
          throw createClientAuthError(emptyInputScopeSet);
        }
        if (!otherScopes.containsOnlyOIDCScopes()) {
          otherScopes.removeOIDCScopes();
        }
        const unionScopes = this.unionScopeSets(otherScopes);
        const sizeOtherScopes = otherScopes.getScopeCount();
        const sizeThisScopes = this.getScopeCount();
        const sizeUnionScopes = unionScopes.size;
        return sizeUnionScopes < sizeThisScopes + sizeOtherScopes;
      }
      /**
       * Returns size of set of scopes.
       */
      getScopeCount() {
        return this.scopes.size;
      }
      /**
       * Returns the scopes as an array of string values
       */
      asArray() {
        const array = [];
        this.scopes.forEach((val) => array.push(val));
        return array;
      }
      /**
       * Prints scopes into a space-delimited string
       */
      printScopes() {
        if (this.scopes) {
          const scopeArr = this.asArray();
          return scopeArr.join(" ");
        }
        return Constants.EMPTY_STRING;
      }
      /**
       * Prints scopes into a space-delimited lower-case string (used for caching)
       */
      printScopesLowerCase() {
        return this.printScopes().toLowerCase();
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/account/ClientInfo.mjs
function buildClientInfo(rawClientInfo, base64Decode2) {
  if (!rawClientInfo) {
    throw createClientAuthError(clientInfoEmptyError);
  }
  try {
    const decodedClientInfo = base64Decode2(rawClientInfo);
    return JSON.parse(decodedClientInfo);
  } catch (e) {
    throw createClientAuthError(clientInfoDecodingError);
  }
}
function buildClientInfoFromHomeAccountId(homeAccountId) {
  if (!homeAccountId) {
    throw createClientAuthError(clientInfoDecodingError);
  }
  const clientInfoParts = homeAccountId.split(Separators.CLIENT_INFO_SEPARATOR, 2);
  return {
    uid: clientInfoParts[0],
    utid: clientInfoParts.length < 2 ? Constants.EMPTY_STRING : clientInfoParts[1]
  };
}
var init_ClientInfo = __esm({
  "node_modules/@azure/msal-common/dist/account/ClientInfo.mjs"() {
    "use strict";
    init_ClientAuthError();
    init_Constants();
    init_ClientAuthErrorCodes();
  }
});

// node_modules/@azure/msal-common/dist/account/AccountInfo.mjs
function tenantIdMatchesHomeTenant(tenantId, homeAccountId) {
  return !!tenantId && !!homeAccountId && tenantId === homeAccountId.split(".")[1];
}
function buildTenantProfile(homeAccountId, localAccountId, tenantId, idTokenClaims) {
  if (idTokenClaims) {
    const { oid, sub, tid, name: name3, tfp, acr } = idTokenClaims;
    const tenantId2 = tid || tfp || acr || "";
    return {
      tenantId: tenantId2,
      localAccountId: oid || sub || "",
      name: name3,
      isHomeTenant: tenantIdMatchesHomeTenant(tenantId2, homeAccountId)
    };
  } else {
    return {
      tenantId,
      localAccountId,
      isHomeTenant: tenantIdMatchesHomeTenant(tenantId, homeAccountId)
    };
  }
}
function updateAccountTenantProfileData(baseAccountInfo, tenantProfile, idTokenClaims, idTokenSecret) {
  let updatedAccountInfo = baseAccountInfo;
  if (tenantProfile) {
    const { isHomeTenant, ...tenantProfileOverride } = tenantProfile;
    updatedAccountInfo = { ...baseAccountInfo, ...tenantProfileOverride };
  }
  if (idTokenClaims) {
    const { isHomeTenant, ...claimsSourcedTenantProfile } = buildTenantProfile(baseAccountInfo.homeAccountId, baseAccountInfo.localAccountId, baseAccountInfo.tenantId, idTokenClaims);
    updatedAccountInfo = {
      ...updatedAccountInfo,
      ...claimsSourcedTenantProfile,
      idTokenClaims,
      idToken: idTokenSecret
    };
    return updatedAccountInfo;
  }
  return updatedAccountInfo;
}
var init_AccountInfo = __esm({
  "node_modules/@azure/msal-common/dist/account/AccountInfo.mjs"() {
    "use strict";
  }
});

// node_modules/@azure/msal-common/dist/authority/AuthorityType.mjs
var AuthorityType;
var init_AuthorityType = __esm({
  "node_modules/@azure/msal-common/dist/authority/AuthorityType.mjs"() {
    "use strict";
    AuthorityType = {
      Default: 0,
      Adfs: 1,
      Dsts: 2,
      Ciam: 3
    };
  }
});

// node_modules/@azure/msal-common/dist/account/TokenClaims.mjs
function getTenantIdFromIdTokenClaims(idTokenClaims) {
  if (idTokenClaims) {
    const tenantId = idTokenClaims.tid || idTokenClaims.tfp || idTokenClaims.acr;
    return tenantId || null;
  }
  return null;
}
var init_TokenClaims = __esm({
  "node_modules/@azure/msal-common/dist/account/TokenClaims.mjs"() {
    "use strict";
  }
});

// node_modules/@azure/msal-common/dist/authority/ProtocolMode.mjs
var ProtocolMode;
var init_ProtocolMode = __esm({
  "node_modules/@azure/msal-common/dist/authority/ProtocolMode.mjs"() {
    "use strict";
    ProtocolMode = {
      /**
       * Auth Code + PKCE with Entra ID (formerly AAD) specific optimizations and features
       */
      AAD: "AAD",
      /**
       * Auth Code + PKCE without Entra ID specific optimizations and features. For use only with non-Microsoft owned authorities.
       * Support is limited for this mode.
       */
      OIDC: "OIDC",
      /**
       * Encrypted Authorize Response (EAR) with Entra ID specific optimizations and features
       */
      EAR: "EAR"
    };
  }
});

// node_modules/@azure/msal-common/dist/cache/entities/AccountEntity.mjs
var AccountEntity;
var init_AccountEntity = __esm({
  "node_modules/@azure/msal-common/dist/cache/entities/AccountEntity.mjs"() {
    "use strict";
    init_Constants();
    init_ClientInfo();
    init_AccountInfo();
    init_ClientAuthError();
    init_AuthorityType();
    init_TokenClaims();
    init_ProtocolMode();
    init_ClientAuthErrorCodes();
    AccountEntity = class _AccountEntity {
      /**
       * Generate Account Id key component as per the schema: <home_account_id>-<environment>
       */
      generateAccountId() {
        const accountId = [this.homeAccountId, this.environment];
        return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
      }
      /**
       * Generate Account Cache Key as per the schema: <home_account_id>-<environment>-<realm*>
       */
      generateAccountKey() {
        return _AccountEntity.generateAccountCacheKey({
          homeAccountId: this.homeAccountId,
          environment: this.environment,
          tenantId: this.realm,
          username: this.username,
          localAccountId: this.localAccountId
        });
      }
      /**
       * Returns the AccountInfo interface for this account.
       */
      getAccountInfo() {
        return {
          homeAccountId: this.homeAccountId,
          environment: this.environment,
          tenantId: this.realm,
          username: this.username,
          localAccountId: this.localAccountId,
          name: this.name,
          nativeAccountId: this.nativeAccountId,
          authorityType: this.authorityType,
          // Deserialize tenant profiles array into a Map
          tenantProfiles: new Map((this.tenantProfiles || []).map((tenantProfile) => {
            return [tenantProfile.tenantId, tenantProfile];
          }))
        };
      }
      /**
       * Returns true if the account entity is in single tenant format (outdated), false otherwise
       */
      isSingleTenant() {
        return !this.tenantProfiles;
      }
      /**
       * Generates account key from interface
       * @param accountInterface
       */
      static generateAccountCacheKey(accountInterface) {
        const homeTenantId = accountInterface.homeAccountId.split(".")[1];
        const accountKey = [
          accountInterface.homeAccountId,
          accountInterface.environment || "",
          homeTenantId || accountInterface.tenantId || ""
        ];
        return accountKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
      }
      /**
       * Build Account cache from IdToken, clientInfo and authority/policy. Associated with AAD.
       * @param accountDetails
       */
      static createAccount(accountDetails, authority, base64Decode2) {
        var _a3, _b2, _c2, _d2, _e, _f;
        const account = new _AccountEntity();
        if (authority.authorityType === AuthorityType.Adfs) {
          account.authorityType = CacheAccountType.ADFS_ACCOUNT_TYPE;
        } else if (authority.protocolMode === ProtocolMode.OIDC) {
          account.authorityType = CacheAccountType.GENERIC_ACCOUNT_TYPE;
        } else {
          account.authorityType = CacheAccountType.MSSTS_ACCOUNT_TYPE;
        }
        let clientInfo;
        if (accountDetails.clientInfo && base64Decode2) {
          clientInfo = buildClientInfo(accountDetails.clientInfo, base64Decode2);
        }
        account.clientInfo = accountDetails.clientInfo;
        account.homeAccountId = accountDetails.homeAccountId;
        account.nativeAccountId = accountDetails.nativeAccountId;
        const env = accountDetails.environment || authority && authority.getPreferredCache();
        if (!env) {
          throw createClientAuthError(invalidCacheEnvironment);
        }
        account.environment = env;
        account.realm = (clientInfo == null ? void 0 : clientInfo.utid) || getTenantIdFromIdTokenClaims(accountDetails.idTokenClaims) || "";
        account.localAccountId = (clientInfo == null ? void 0 : clientInfo.uid) || ((_a3 = accountDetails.idTokenClaims) == null ? void 0 : _a3.oid) || ((_b2 = accountDetails.idTokenClaims) == null ? void 0 : _b2.sub) || "";
        const preferredUsername = ((_c2 = accountDetails.idTokenClaims) == null ? void 0 : _c2.preferred_username) || ((_d2 = accountDetails.idTokenClaims) == null ? void 0 : _d2.upn);
        const email = ((_e = accountDetails.idTokenClaims) == null ? void 0 : _e.emails) ? accountDetails.idTokenClaims.emails[0] : null;
        account.username = preferredUsername || email || "";
        account.name = ((_f = accountDetails.idTokenClaims) == null ? void 0 : _f.name) || "";
        account.cloudGraphHostName = accountDetails.cloudGraphHostName;
        account.msGraphHost = accountDetails.msGraphHost;
        if (accountDetails.tenantProfiles) {
          account.tenantProfiles = accountDetails.tenantProfiles;
        } else {
          const tenantProfile = buildTenantProfile(accountDetails.homeAccountId, account.localAccountId, account.realm, accountDetails.idTokenClaims);
          account.tenantProfiles = [tenantProfile];
        }
        return account;
      }
      /**
       * Creates an AccountEntity object from AccountInfo
       * @param accountInfo
       * @param cloudGraphHostName
       * @param msGraphHost
       * @returns
       */
      static createFromAccountInfo(accountInfo, cloudGraphHostName, msGraphHost) {
        var _a3;
        const account = new _AccountEntity();
        account.authorityType = accountInfo.authorityType || CacheAccountType.GENERIC_ACCOUNT_TYPE;
        account.homeAccountId = accountInfo.homeAccountId;
        account.localAccountId = accountInfo.localAccountId;
        account.nativeAccountId = accountInfo.nativeAccountId;
        account.realm = accountInfo.tenantId;
        account.environment = accountInfo.environment;
        account.username = accountInfo.username;
        account.name = accountInfo.name;
        account.cloudGraphHostName = cloudGraphHostName;
        account.msGraphHost = msGraphHost;
        account.tenantProfiles = Array.from(((_a3 = accountInfo.tenantProfiles) == null ? void 0 : _a3.values()) || []);
        return account;
      }
      /**
       * Generate HomeAccountId from server response
       * @param serverClientInfo
       * @param authType
       */
      static generateHomeAccountId(serverClientInfo, authType, logger24, cryptoObj, idTokenClaims) {
        if (!(authType === AuthorityType.Adfs || authType === AuthorityType.Dsts)) {
          if (serverClientInfo) {
            try {
              const clientInfo = buildClientInfo(serverClientInfo, cryptoObj.base64Decode);
              if (clientInfo.uid && clientInfo.utid) {
                return `${clientInfo.uid}.${clientInfo.utid}`;
              }
            } catch (e) {
            }
          }
          logger24.warning("No client info in response");
        }
        return (idTokenClaims == null ? void 0 : idTokenClaims.sub) || "";
      }
      /**
       * Validates an entity: checks for all expected params
       * @param entity
       */
      static isAccountEntity(entity) {
        if (!entity) {
          return false;
        }
        return entity.hasOwnProperty("homeAccountId") && entity.hasOwnProperty("environment") && entity.hasOwnProperty("realm") && entity.hasOwnProperty("localAccountId") && entity.hasOwnProperty("username") && entity.hasOwnProperty("authorityType");
      }
      /**
       * Helper function to determine whether 2 accountInfo objects represent the same account
       * @param accountA
       * @param accountB
       * @param compareClaims - If set to true idTokenClaims will also be compared to determine account equality
       */
      static accountInfoIsEqual(accountA, accountB, compareClaims) {
        if (!accountA || !accountB) {
          return false;
        }
        let claimsMatch = true;
        if (compareClaims) {
          const accountAClaims = accountA.idTokenClaims || {};
          const accountBClaims = accountB.idTokenClaims || {};
          claimsMatch = accountAClaims.iat === accountBClaims.iat && accountAClaims.nonce === accountBClaims.nonce;
        }
        return accountA.homeAccountId === accountB.homeAccountId && accountA.localAccountId === accountB.localAccountId && accountA.username === accountB.username && accountA.tenantId === accountB.tenantId && accountA.environment === accountB.environment && accountA.nativeAccountId === accountB.nativeAccountId && claimsMatch;
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/utils/UrlUtils.mjs
var UrlUtils_exports = {};
__export(UrlUtils_exports, {
  getDeserializedResponse: () => getDeserializedResponse,
  mapToQueryString: () => mapToQueryString,
  stripLeadingHashOrQuery: () => stripLeadingHashOrQuery
});
function stripLeadingHashOrQuery(responseString) {
  if (responseString.startsWith("#/")) {
    return responseString.substring(2);
  } else if (responseString.startsWith("#") || responseString.startsWith("?")) {
    return responseString.substring(1);
  }
  return responseString;
}
function getDeserializedResponse(responseString) {
  if (!responseString || responseString.indexOf("=") < 0) {
    return null;
  }
  try {
    const normalizedResponse = stripLeadingHashOrQuery(responseString);
    const deserializedHash = Object.fromEntries(new URLSearchParams(normalizedResponse));
    if (deserializedHash.code || deserializedHash.ear_jwe || deserializedHash.error || deserializedHash.error_description || deserializedHash.state) {
      return deserializedHash;
    }
  } catch (e) {
    throw createClientAuthError(hashNotDeserialized);
  }
  return null;
}
function mapToQueryString(parameters, encodeExtraParams = true, extraQueryParameters) {
  const queryParameterArray = new Array();
  parameters.forEach((value, key) => {
    if (!encodeExtraParams && extraQueryParameters && key in extraQueryParameters) {
      queryParameterArray.push(`${key}=${value}`);
    } else {
      queryParameterArray.push(`${key}=${encodeURIComponent(value)}`);
    }
  });
  return queryParameterArray.join("&");
}
var init_UrlUtils = __esm({
  "node_modules/@azure/msal-common/dist/utils/UrlUtils.mjs"() {
    "use strict";
    init_ClientAuthError();
    init_ClientAuthErrorCodes();
  }
});

// node_modules/@azure/msal-common/dist/url/UrlString.mjs
var UrlString;
var init_UrlString = __esm({
  "node_modules/@azure/msal-common/dist/url/UrlString.mjs"() {
    "use strict";
    init_ClientConfigurationError();
    init_StringUtils();
    init_Constants();
    init_UrlUtils();
    init_ClientConfigurationErrorCodes();
    UrlString = class _UrlString {
      get urlString() {
        return this._urlString;
      }
      constructor(url) {
        this._urlString = url;
        if (!this._urlString) {
          throw createClientConfigurationError(urlEmptyError);
        }
        if (!url.includes("#")) {
          this._urlString = _UrlString.canonicalizeUri(url);
        }
      }
      /**
       * Ensure urls are lower case and end with a / character.
       * @param url
       */
      static canonicalizeUri(url) {
        if (url) {
          let lowerCaseUrl = url.toLowerCase();
          if (StringUtils.endsWith(lowerCaseUrl, "?")) {
            lowerCaseUrl = lowerCaseUrl.slice(0, -1);
          } else if (StringUtils.endsWith(lowerCaseUrl, "?/")) {
            lowerCaseUrl = lowerCaseUrl.slice(0, -2);
          }
          if (!StringUtils.endsWith(lowerCaseUrl, "/")) {
            lowerCaseUrl += "/";
          }
          return lowerCaseUrl;
        }
        return url;
      }
      /**
       * Throws if urlString passed is not a valid authority URI string.
       */
      validateAsUri() {
        let components;
        try {
          components = this.getUrlComponents();
        } catch (e) {
          throw createClientConfigurationError(urlParseError);
        }
        if (!components.HostNameAndPort || !components.PathSegments) {
          throw createClientConfigurationError(urlParseError);
        }
        if (!components.Protocol || components.Protocol.toLowerCase() !== "https:") {
          throw createClientConfigurationError(authorityUriInsecure);
        }
      }
      /**
       * Given a url and a query string return the url with provided query string appended
       * @param url
       * @param queryString
       */
      static appendQueryString(url, queryString) {
        if (!queryString) {
          return url;
        }
        return url.indexOf("?") < 0 ? `${url}?${queryString}` : `${url}&${queryString}`;
      }
      /**
       * Returns a url with the hash removed
       * @param url
       */
      static removeHashFromUrl(url) {
        return _UrlString.canonicalizeUri(url.split("#")[0]);
      }
      /**
       * Given a url like https://a:b/common/d?e=f#g, and a tenantId, returns https://a:b/tenantId/d
       * @param href The url
       * @param tenantId The tenant id to replace
       */
      replaceTenantPath(tenantId) {
        const urlObject = this.getUrlComponents();
        const pathArray = urlObject.PathSegments;
        if (tenantId && pathArray.length !== 0 && (pathArray[0] === AADAuthorityConstants.COMMON || pathArray[0] === AADAuthorityConstants.ORGANIZATIONS)) {
          pathArray[0] = tenantId;
        }
        return _UrlString.constructAuthorityUriFromObject(urlObject);
      }
      /**
       * Parses out the components from a url string.
       * @returns An object with the various components. Please cache this value insted of calling this multiple times on the same url.
       */
      getUrlComponents() {
        const regEx = RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?");
        const match = this.urlString.match(regEx);
        if (!match) {
          throw createClientConfigurationError(urlParseError);
        }
        const urlComponents = {
          Protocol: match[1],
          HostNameAndPort: match[4],
          AbsolutePath: match[5],
          QueryString: match[7]
        };
        let pathSegments = urlComponents.AbsolutePath.split("/");
        pathSegments = pathSegments.filter((val) => val && val.length > 0);
        urlComponents.PathSegments = pathSegments;
        if (urlComponents.QueryString && urlComponents.QueryString.endsWith("/")) {
          urlComponents.QueryString = urlComponents.QueryString.substring(0, urlComponents.QueryString.length - 1);
        }
        return urlComponents;
      }
      static getDomainFromUrl(url) {
        const regEx = RegExp("^([^:/?#]+://)?([^/?#]*)");
        const match = url.match(regEx);
        if (!match) {
          throw createClientConfigurationError(urlParseError);
        }
        return match[2];
      }
      static getAbsoluteUrl(relativeUrl, baseUrl) {
        if (relativeUrl[0] === Constants.FORWARD_SLASH) {
          const url = new _UrlString(baseUrl);
          const baseComponents = url.getUrlComponents();
          return baseComponents.Protocol + "//" + baseComponents.HostNameAndPort + relativeUrl;
        }
        return relativeUrl;
      }
      static constructAuthorityUriFromObject(urlObject) {
        return new _UrlString(urlObject.Protocol + "//" + urlObject.HostNameAndPort + "/" + urlObject.PathSegments.join("/"));
      }
      /**
       * Check if the hash of the URL string contains known properties
       * @deprecated This API will be removed in a future version
       */
      static hashContainsKnownProperties(response) {
        return !!getDeserializedResponse(response);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/authority/AuthorityMetadata.mjs
function getAliasesFromStaticSources(staticAuthorityOptions, logger24) {
  var _a3;
  let staticAliases;
  const canonicalAuthority = staticAuthorityOptions.canonicalAuthority;
  if (canonicalAuthority) {
    const authorityHost = new UrlString(canonicalAuthority).getUrlComponents().HostNameAndPort;
    staticAliases = getAliasesFromMetadata(authorityHost, (_a3 = staticAuthorityOptions.cloudDiscoveryMetadata) == null ? void 0 : _a3.metadata, AuthorityMetadataSource.CONFIG, logger24) || getAliasesFromMetadata(authorityHost, InstanceDiscoveryMetadata.metadata, AuthorityMetadataSource.HARDCODED_VALUES, logger24) || staticAuthorityOptions.knownAuthorities;
  }
  return staticAliases || [];
}
function getAliasesFromMetadata(authorityHost, cloudDiscoveryMetadata, source, logger24) {
  logger24 == null ? void 0 : logger24.trace(`getAliasesFromMetadata called with source: ${source}`);
  if (authorityHost && cloudDiscoveryMetadata) {
    const metadata = getCloudDiscoveryMetadataFromNetworkResponse(cloudDiscoveryMetadata, authorityHost);
    if (metadata) {
      logger24 == null ? void 0 : logger24.trace(`getAliasesFromMetadata: found cloud discovery metadata in ${source}, returning aliases`);
      return metadata.aliases;
    } else {
      logger24 == null ? void 0 : logger24.trace(`getAliasesFromMetadata: did not find cloud discovery metadata in ${source}`);
    }
  }
  return null;
}
function getCloudDiscoveryMetadataFromHardcodedValues(authorityHost) {
  const metadata = getCloudDiscoveryMetadataFromNetworkResponse(InstanceDiscoveryMetadata.metadata, authorityHost);
  return metadata;
}
function getCloudDiscoveryMetadataFromNetworkResponse(response, authorityHost) {
  for (let i = 0; i < response.length; i++) {
    const metadata = response[i];
    if (metadata.aliases.includes(authorityHost)) {
      return metadata;
    }
  }
  return null;
}
var rawMetdataJSON, EndpointMetadata, InstanceDiscoveryMetadata, InstanceDiscoveryMetadataAliases;
var init_AuthorityMetadata = __esm({
  "node_modules/@azure/msal-common/dist/authority/AuthorityMetadata.mjs"() {
    "use strict";
    init_UrlString();
    init_Constants();
    rawMetdataJSON = {
      endpointMetadata: {
        "login.microsoftonline.com": {
          token_endpoint: "https://login.microsoftonline.com/{tenantid}/oauth2/v2.0/token",
          jwks_uri: "https://login.microsoftonline.com/{tenantid}/discovery/v2.0/keys",
          issuer: "https://login.microsoftonline.com/{tenantid}/v2.0",
          authorization_endpoint: "https://login.microsoftonline.com/{tenantid}/oauth2/v2.0/authorize",
          end_session_endpoint: "https://login.microsoftonline.com/{tenantid}/oauth2/v2.0/logout"
        },
        "login.chinacloudapi.cn": {
          token_endpoint: "https://login.chinacloudapi.cn/{tenantid}/oauth2/v2.0/token",
          jwks_uri: "https://login.chinacloudapi.cn/{tenantid}/discovery/v2.0/keys",
          issuer: "https://login.partner.microsoftonline.cn/{tenantid}/v2.0",
          authorization_endpoint: "https://login.chinacloudapi.cn/{tenantid}/oauth2/v2.0/authorize",
          end_session_endpoint: "https://login.chinacloudapi.cn/{tenantid}/oauth2/v2.0/logout"
        },
        "login.microsoftonline.us": {
          token_endpoint: "https://login.microsoftonline.us/{tenantid}/oauth2/v2.0/token",
          jwks_uri: "https://login.microsoftonline.us/{tenantid}/discovery/v2.0/keys",
          issuer: "https://login.microsoftonline.us/{tenantid}/v2.0",
          authorization_endpoint: "https://login.microsoftonline.us/{tenantid}/oauth2/v2.0/authorize",
          end_session_endpoint: "https://login.microsoftonline.us/{tenantid}/oauth2/v2.0/logout"
        }
      },
      instanceDiscoveryMetadata: {
        metadata: [
          {
            preferred_network: "login.microsoftonline.com",
            preferred_cache: "login.windows.net",
            aliases: [
              "login.microsoftonline.com",
              "login.windows.net",
              "login.microsoft.com",
              "sts.windows.net"
            ]
          },
          {
            preferred_network: "login.partner.microsoftonline.cn",
            preferred_cache: "login.partner.microsoftonline.cn",
            aliases: [
              "login.partner.microsoftonline.cn",
              "login.chinacloudapi.cn"
            ]
          },
          {
            preferred_network: "login.microsoftonline.de",
            preferred_cache: "login.microsoftonline.de",
            aliases: ["login.microsoftonline.de"]
          },
          {
            preferred_network: "login.microsoftonline.us",
            preferred_cache: "login.microsoftonline.us",
            aliases: [
              "login.microsoftonline.us",
              "login.usgovcloudapi.net"
            ]
          },
          {
            preferred_network: "login-us.microsoftonline.com",
            preferred_cache: "login-us.microsoftonline.com",
            aliases: ["login-us.microsoftonline.com"]
          }
        ]
      }
    };
    EndpointMetadata = rawMetdataJSON.endpointMetadata;
    InstanceDiscoveryMetadata = rawMetdataJSON.instanceDiscoveryMetadata;
    InstanceDiscoveryMetadataAliases = /* @__PURE__ */ new Set();
    InstanceDiscoveryMetadata.metadata.forEach((metadataEntry) => {
      metadataEntry.aliases.forEach((alias) => {
        InstanceDiscoveryMetadataAliases.add(alias);
      });
    });
  }
});

// node_modules/@azure/msal-common/dist/error/CacheErrorCodes.mjs
var CacheErrorCodes_exports = {};
__export(CacheErrorCodes_exports, {
  cacheErrorUnknown: () => cacheErrorUnknown,
  cacheQuotaExceeded: () => cacheQuotaExceeded
});
var cacheQuotaExceeded, cacheErrorUnknown;
var init_CacheErrorCodes = __esm({
  "node_modules/@azure/msal-common/dist/error/CacheErrorCodes.mjs"() {
    "use strict";
    cacheQuotaExceeded = "cache_quota_exceeded";
    cacheErrorUnknown = "cache_error_unknown";
  }
});

// node_modules/@azure/msal-common/dist/error/CacheError.mjs
function createCacheError(e) {
  if (!(e instanceof Error)) {
    return new CacheError(cacheErrorUnknown);
  }
  if (e.name === "QuotaExceededError" || e.name === "NS_ERROR_DOM_QUOTA_REACHED" || e.message.includes("exceeded the quota")) {
    return new CacheError(cacheQuotaExceeded);
  } else {
    return new CacheError(e.name, e.message);
  }
}
var CacheErrorMessages, CacheError;
var init_CacheError = __esm({
  "node_modules/@azure/msal-common/dist/error/CacheError.mjs"() {
    "use strict";
    init_AuthError();
    init_CacheErrorCodes();
    init_CacheErrorCodes();
    CacheErrorMessages = {
      [cacheQuotaExceeded]: "Exceeded cache storage capacity.",
      [cacheErrorUnknown]: "Unexpected error occurred when using cache storage."
    };
    CacheError = class _CacheError extends AuthError {
      constructor(errorCode, errorMessage2) {
        const message = errorMessage2 || (CacheErrorMessages[errorCode] ? CacheErrorMessages[errorCode] : CacheErrorMessages[cacheErrorUnknown]);
        super(`${errorCode}: ${message}`);
        Object.setPrototypeOf(this, _CacheError.prototype);
        this.name = "CacheError";
        this.errorCode = errorCode;
        this.errorMessage = message;
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/cache/CacheManager.mjs
var CacheManager, DefaultStorageClass;
var init_CacheManager = __esm({
  "node_modules/@azure/msal-common/dist/cache/CacheManager.mjs"() {
    "use strict";
    init_Constants();
    init_CacheHelpers();
    init_ScopeSet();
    init_AccountEntity();
    init_ClientAuthError();
    init_AccountInfo();
    init_AuthToken();
    init_packageMetadata();
    init_AuthorityMetadata();
    init_CacheError();
    init_AuthError();
    init_ClientAuthErrorCodes();
    CacheManager = class {
      constructor(clientId, cryptoImpl, logger24, performanceClient, staticAuthorityOptions) {
        this.clientId = clientId;
        this.cryptoImpl = cryptoImpl;
        this.commonLogger = logger24.clone(name, version);
        this.staticAuthorityOptions = staticAuthorityOptions;
        this.performanceClient = performanceClient;
      }
      /**
       * Returns all the accounts in the cache that match the optional filter. If no filter is provided, all accounts are returned.
       * @param accountFilter - (Optional) filter to narrow down the accounts returned
       * @returns Array of AccountInfo objects in cache
       */
      getAllAccounts(accountFilter, correlationId) {
        return this.buildTenantProfiles(this.getAccountsFilteredBy(accountFilter, correlationId), correlationId, accountFilter);
      }
      /**
       * Gets first tenanted AccountInfo object found based on provided filters
       */
      getAccountInfoFilteredBy(accountFilter, correlationId) {
        const allAccounts = this.getAllAccounts(accountFilter, correlationId);
        if (allAccounts.length > 1) {
          const sortedAccounts = allAccounts.sort((account) => {
            return account.idTokenClaims ? -1 : 1;
          });
          return sortedAccounts[0];
        } else if (allAccounts.length === 1) {
          return allAccounts[0];
        } else {
          return null;
        }
      }
      /**
       * Returns a single matching
       * @param accountFilter
       * @returns
       */
      getBaseAccountInfo(accountFilter, correlationId) {
        const accountEntities = this.getAccountsFilteredBy(accountFilter, correlationId);
        if (accountEntities.length > 0) {
          return accountEntities[0].getAccountInfo();
        } else {
          return null;
        }
      }
      /**
       * Matches filtered account entities with cached ID tokens that match the tenant profile-specific account filters
       * and builds the account info objects from the matching ID token's claims
       * @param cachedAccounts
       * @param accountFilter
       * @returns Array of AccountInfo objects that match account and tenant profile filters
       */
      buildTenantProfiles(cachedAccounts, correlationId, accountFilter) {
        return cachedAccounts.flatMap((accountEntity) => {
          return this.getTenantProfilesFromAccountEntity(accountEntity, correlationId, accountFilter == null ? void 0 : accountFilter.tenantId, accountFilter);
        });
      }
      getTenantedAccountInfoByFilter(accountInfo, tokenKeys, tenantProfile, correlationId, tenantProfileFilter) {
        let tenantedAccountInfo = null;
        let idTokenClaims;
        if (tenantProfileFilter) {
          if (!this.tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter)) {
            return null;
          }
        }
        const idToken = this.getIdToken(accountInfo, correlationId, tokenKeys, tenantProfile.tenantId);
        if (idToken) {
          idTokenClaims = extractTokenClaims(idToken.secret, this.cryptoImpl.base64Decode);
          if (!this.idTokenClaimsMatchTenantProfileFilter(idTokenClaims, tenantProfileFilter)) {
            return null;
          }
        }
        tenantedAccountInfo = updateAccountTenantProfileData(accountInfo, tenantProfile, idTokenClaims, idToken == null ? void 0 : idToken.secret);
        return tenantedAccountInfo;
      }
      getTenantProfilesFromAccountEntity(accountEntity, correlationId, targetTenantId, tenantProfileFilter) {
        const accountInfo = accountEntity.getAccountInfo();
        let searchTenantProfiles = accountInfo.tenantProfiles || /* @__PURE__ */ new Map();
        const tokenKeys = this.getTokenKeys();
        if (targetTenantId) {
          const tenantProfile = searchTenantProfiles.get(targetTenantId);
          if (tenantProfile) {
            searchTenantProfiles = /* @__PURE__ */ new Map([
              [targetTenantId, tenantProfile]
            ]);
          } else {
            return [];
          }
        }
        const matchingTenantProfiles = [];
        searchTenantProfiles.forEach((tenantProfile) => {
          const tenantedAccountInfo = this.getTenantedAccountInfoByFilter(accountInfo, tokenKeys, tenantProfile, correlationId, tenantProfileFilter);
          if (tenantedAccountInfo) {
            matchingTenantProfiles.push(tenantedAccountInfo);
          }
        });
        return matchingTenantProfiles;
      }
      tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter) {
        if (!!tenantProfileFilter.localAccountId && !this.matchLocalAccountIdFromTenantProfile(tenantProfile, tenantProfileFilter.localAccountId)) {
          return false;
        }
        if (!!tenantProfileFilter.name && !(tenantProfile.name === tenantProfileFilter.name)) {
          return false;
        }
        if (tenantProfileFilter.isHomeTenant !== void 0 && !(tenantProfile.isHomeTenant === tenantProfileFilter.isHomeTenant)) {
          return false;
        }
        return true;
      }
      idTokenClaimsMatchTenantProfileFilter(idTokenClaims, tenantProfileFilter) {
        if (tenantProfileFilter) {
          if (!!tenantProfileFilter.localAccountId && !this.matchLocalAccountIdFromTokenClaims(idTokenClaims, tenantProfileFilter.localAccountId)) {
            return false;
          }
          if (!!tenantProfileFilter.loginHint && !this.matchLoginHintFromTokenClaims(idTokenClaims, tenantProfileFilter.loginHint)) {
            return false;
          }
          if (!!tenantProfileFilter.username && !this.matchUsername(idTokenClaims.preferred_username, tenantProfileFilter.username)) {
            return false;
          }
          if (!!tenantProfileFilter.name && !this.matchName(idTokenClaims, tenantProfileFilter.name)) {
            return false;
          }
          if (!!tenantProfileFilter.sid && !this.matchSid(idTokenClaims, tenantProfileFilter.sid)) {
            return false;
          }
        }
        return true;
      }
      /**
       * saves a cache record
       * @param cacheRecord {CacheRecord}
       * @param storeInCache {?StoreInCache}
       * @param correlationId {?string} correlation id
       */
      async saveCacheRecord(cacheRecord, correlationId, storeInCache) {
        var _a3;
        if (!cacheRecord) {
          throw createClientAuthError(invalidCacheRecord);
        }
        try {
          if (!!cacheRecord.account) {
            await this.setAccount(cacheRecord.account, correlationId);
          }
          if (!!cacheRecord.idToken && (storeInCache == null ? void 0 : storeInCache.idToken) !== false) {
            await this.setIdTokenCredential(cacheRecord.idToken, correlationId);
          }
          if (!!cacheRecord.accessToken && (storeInCache == null ? void 0 : storeInCache.accessToken) !== false) {
            await this.saveAccessToken(cacheRecord.accessToken, correlationId);
          }
          if (!!cacheRecord.refreshToken && (storeInCache == null ? void 0 : storeInCache.refreshToken) !== false) {
            await this.setRefreshTokenCredential(cacheRecord.refreshToken, correlationId);
          }
          if (!!cacheRecord.appMetadata) {
            this.setAppMetadata(cacheRecord.appMetadata, correlationId);
          }
        } catch (e) {
          (_a3 = this.commonLogger) == null ? void 0 : _a3.error(`CacheManager.saveCacheRecord: failed`);
          if (e instanceof AuthError) {
            throw e;
          } else {
            throw createCacheError(e);
          }
        }
      }
      /**
       * saves access token credential
       * @param credential
       */
      async saveAccessToken(credential, correlationId) {
        const accessTokenFilter = {
          clientId: credential.clientId,
          credentialType: credential.credentialType,
          environment: credential.environment,
          homeAccountId: credential.homeAccountId,
          realm: credential.realm,
          tokenType: credential.tokenType,
          requestedClaimsHash: credential.requestedClaimsHash
        };
        const tokenKeys = this.getTokenKeys();
        const currentScopes = ScopeSet.fromString(credential.target);
        tokenKeys.accessToken.forEach((key) => {
          if (!this.accessTokenKeyMatchesFilter(key, accessTokenFilter, false)) {
            return;
          }
          const tokenEntity = this.getAccessTokenCredential(key, correlationId);
          if (tokenEntity && this.credentialMatchesFilter(tokenEntity, accessTokenFilter)) {
            const tokenScopeSet = ScopeSet.fromString(tokenEntity.target);
            if (tokenScopeSet.intersectingScopeSets(currentScopes)) {
              this.removeAccessToken(key, correlationId);
            }
          }
        });
        await this.setAccessTokenCredential(credential, correlationId);
      }
      /**
       * Retrieve account entities matching all provided tenant-agnostic filters; if no filter is set, get all account entities in the cache
       * Not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared
       * @param accountFilter - An object containing Account properties to filter by
       */
      getAccountsFilteredBy(accountFilter, correlationId) {
        const allAccountKeys = this.getAccountKeys();
        const matchingAccounts = [];
        allAccountKeys.forEach((cacheKey) => {
          var _a3;
          if (!this.isAccountKey(cacheKey, accountFilter.homeAccountId)) {
            return;
          }
          const entity = this.getAccount(cacheKey, correlationId);
          if (!entity) {
            return;
          }
          if (!!accountFilter.homeAccountId && !this.matchHomeAccountId(entity, accountFilter.homeAccountId)) {
            return;
          }
          if (!!accountFilter.username && !this.matchUsername(entity.username, accountFilter.username)) {
            return;
          }
          if (!!accountFilter.environment && !this.matchEnvironment(entity, accountFilter.environment)) {
            return;
          }
          if (!!accountFilter.realm && !this.matchRealm(entity, accountFilter.realm)) {
            return;
          }
          if (!!accountFilter.nativeAccountId && !this.matchNativeAccountId(entity, accountFilter.nativeAccountId)) {
            return;
          }
          if (!!accountFilter.authorityType && !this.matchAuthorityType(entity, accountFilter.authorityType)) {
            return;
          }
          const tenantProfileFilter = {
            localAccountId: accountFilter == null ? void 0 : accountFilter.localAccountId,
            name: accountFilter == null ? void 0 : accountFilter.name
          };
          const matchingTenantProfiles = (_a3 = entity.tenantProfiles) == null ? void 0 : _a3.filter((tenantProfile) => {
            return this.tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter);
          });
          if (matchingTenantProfiles && matchingTenantProfiles.length === 0) {
            return;
          }
          matchingAccounts.push(entity);
        });
        return matchingAccounts;
      }
      /**
       * Returns true if the given key matches our account key schema. Also matches homeAccountId and/or tenantId if provided
       * @param key
       * @param homeAccountId
       * @param tenantId
       * @returns
       */
      isAccountKey(key, homeAccountId, tenantId) {
        if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 3) {
          return false;
        }
        if (homeAccountId && !key.toLowerCase().includes(homeAccountId.toLowerCase())) {
          return false;
        }
        if (tenantId && !key.toLowerCase().includes(tenantId.toLowerCase())) {
          return false;
        }
        return true;
      }
      /**
       * Returns true if the given key matches our credential key schema.
       * @param key
       */
      isCredentialKey(key) {
        if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 6) {
          return false;
        }
        const lowerCaseKey = key.toLowerCase();
        if (lowerCaseKey.indexOf(CredentialType.ID_TOKEN.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) === -1) {
          return false;
        }
        if (lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) > -1) {
          const clientIdValidation = `${CredentialType.REFRESH_TOKEN}${Separators.CACHE_KEY_SEPARATOR}${this.clientId}${Separators.CACHE_KEY_SEPARATOR}`;
          const familyIdValidation = `${CredentialType.REFRESH_TOKEN}${Separators.CACHE_KEY_SEPARATOR}${THE_FAMILY_ID}${Separators.CACHE_KEY_SEPARATOR}`;
          if (lowerCaseKey.indexOf(clientIdValidation.toLowerCase()) === -1 && lowerCaseKey.indexOf(familyIdValidation.toLowerCase()) === -1) {
            return false;
          }
        } else if (lowerCaseKey.indexOf(this.clientId.toLowerCase()) === -1) {
          return false;
        }
        return true;
      }
      /**
       * Returns whether or not the given credential entity matches the filter
       * @param entity
       * @param filter
       * @returns
       */
      credentialMatchesFilter(entity, filter) {
        if (!!filter.clientId && !this.matchClientId(entity, filter.clientId)) {
          return false;
        }
        if (!!filter.userAssertionHash && !this.matchUserAssertionHash(entity, filter.userAssertionHash)) {
          return false;
        }
        if (typeof filter.homeAccountId === "string" && !this.matchHomeAccountId(entity, filter.homeAccountId)) {
          return false;
        }
        if (!!filter.environment && !this.matchEnvironment(entity, filter.environment)) {
          return false;
        }
        if (!!filter.realm && !this.matchRealm(entity, filter.realm)) {
          return false;
        }
        if (!!filter.credentialType && !this.matchCredentialType(entity, filter.credentialType)) {
          return false;
        }
        if (!!filter.familyId && !this.matchFamilyId(entity, filter.familyId)) {
          return false;
        }
        if (!!filter.target && !this.matchTarget(entity, filter.target)) {
          return false;
        }
        if (filter.requestedClaimsHash || entity.requestedClaimsHash) {
          if (entity.requestedClaimsHash !== filter.requestedClaimsHash) {
            return false;
          }
        }
        if (entity.credentialType === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {
          if (!!filter.tokenType && !this.matchTokenType(entity, filter.tokenType)) {
            return false;
          }
          if (filter.tokenType === AuthenticationScheme.SSH) {
            if (filter.keyId && !this.matchKeyId(entity, filter.keyId)) {
              return false;
            }
          }
        }
        return true;
      }
      /**
       * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata
       * @param filter
       */
      getAppMetadataFilteredBy(filter) {
        const allCacheKeys = this.getKeys();
        const matchingAppMetadata = {};
        allCacheKeys.forEach((cacheKey) => {
          if (!this.isAppMetadata(cacheKey)) {
            return;
          }
          const entity = this.getAppMetadata(cacheKey);
          if (!entity) {
            return;
          }
          if (!!filter.environment && !this.matchEnvironment(entity, filter.environment)) {
            return;
          }
          if (!!filter.clientId && !this.matchClientId(entity, filter.clientId)) {
            return;
          }
          matchingAppMetadata[cacheKey] = entity;
        });
        return matchingAppMetadata;
      }
      /**
       * retrieve authorityMetadata that contains a matching alias
       * @param filter
       */
      getAuthorityMetadataByAlias(host) {
        const allCacheKeys = this.getAuthorityMetadataKeys();
        let matchedEntity = null;
        allCacheKeys.forEach((cacheKey) => {
          if (!this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(this.clientId) === -1) {
            return;
          }
          const entity = this.getAuthorityMetadata(cacheKey);
          if (!entity) {
            return;
          }
          if (entity.aliases.indexOf(host) === -1) {
            return;
          }
          matchedEntity = entity;
        });
        return matchedEntity;
      }
      /**
       * Removes all accounts and related tokens from cache.
       */
      removeAllAccounts(correlationId) {
        const allAccountKeys = this.getAccountKeys();
        allAccountKeys.forEach((cacheKey) => {
          this.removeAccount(cacheKey, correlationId);
        });
      }
      /**
       * Removes the account and related tokens for a given account key
       * @param account
       */
      removeAccount(accountKey, correlationId) {
        const account = this.getAccount(accountKey, correlationId);
        if (!account) {
          return;
        }
        this.removeAccountContext(account, correlationId);
        this.removeItem(accountKey, correlationId);
      }
      /**
       * Removes credentials associated with the provided account
       * @param account
       */
      removeAccountContext(account, correlationId) {
        const allTokenKeys = this.getTokenKeys();
        const accountId = account.generateAccountId();
        allTokenKeys.idToken.forEach((key) => {
          if (key.indexOf(accountId) === 0) {
            this.removeIdToken(key, correlationId);
          }
        });
        allTokenKeys.accessToken.forEach((key) => {
          if (key.indexOf(accountId) === 0) {
            this.removeAccessToken(key, correlationId);
          }
        });
        allTokenKeys.refreshToken.forEach((key) => {
          if (key.indexOf(accountId) === 0) {
            this.removeRefreshToken(key, correlationId);
          }
        });
      }
      /**
       * Removes accessToken from the cache
       * @param key
       * @param correlationId
       */
      removeAccessToken(key, correlationId) {
        const credential = this.getAccessTokenCredential(key, correlationId);
        this.removeItem(key, correlationId);
        this.performanceClient.incrementFields({ accessTokensRemoved: 1 }, correlationId);
        if (!credential || credential.credentialType.toLowerCase() !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase() || credential.tokenType !== AuthenticationScheme.POP) {
          return;
        }
        const kid = credential.keyId;
        if (kid) {
          void this.cryptoImpl.removeTokenBindingKey(kid).catch(() => {
            var _a3;
            this.commonLogger.error(`Failed to remove token binding key ${kid}`, correlationId);
            (_a3 = this.performanceClient) == null ? void 0 : _a3.incrementFields({ removeTokenBindingKeyFailure: 1 }, correlationId);
          });
        }
      }
      /**
       * Removes all app metadata objects from cache.
       */
      removeAppMetadata(correlationId) {
        const allCacheKeys = this.getKeys();
        allCacheKeys.forEach((cacheKey) => {
          if (this.isAppMetadata(cacheKey)) {
            this.removeItem(cacheKey, correlationId);
          }
        });
        return true;
      }
      /**
       * Retrieve AccountEntity from cache
       * @param account
       */
      readAccountFromCache(account, correlationId) {
        const accountKey = AccountEntity.generateAccountCacheKey(account);
        return this.getAccount(accountKey, correlationId);
      }
      /**
       * Retrieve IdTokenEntity from cache
       * @param account {AccountInfo}
       * @param tokenKeys {?TokenKeys}
       * @param targetRealm {?string}
       * @param performanceClient {?IPerformanceClient}
       * @param correlationId {?string}
       */
      getIdToken(account, correlationId, tokenKeys, targetRealm, performanceClient) {
        this.commonLogger.trace("CacheManager - getIdToken called");
        const idTokenFilter = {
          homeAccountId: account.homeAccountId,
          environment: account.environment,
          credentialType: CredentialType.ID_TOKEN,
          clientId: this.clientId,
          realm: targetRealm
        };
        const idTokenMap = this.getIdTokensByFilter(idTokenFilter, correlationId, tokenKeys);
        const numIdTokens = idTokenMap.size;
        if (numIdTokens < 1) {
          this.commonLogger.info("CacheManager:getIdToken - No token found");
          return null;
        } else if (numIdTokens > 1) {
          let tokensToBeRemoved = idTokenMap;
          if (!targetRealm) {
            const homeIdTokenMap = /* @__PURE__ */ new Map();
            idTokenMap.forEach((idToken, key) => {
              if (idToken.realm === account.tenantId) {
                homeIdTokenMap.set(key, idToken);
              }
            });
            const numHomeIdTokens = homeIdTokenMap.size;
            if (numHomeIdTokens < 1) {
              this.commonLogger.info("CacheManager:getIdToken - Multiple ID tokens found for account but none match account entity tenant id, returning first result");
              return idTokenMap.values().next().value;
            } else if (numHomeIdTokens === 1) {
              this.commonLogger.info("CacheManager:getIdToken - Multiple ID tokens found for account, defaulting to home tenant profile");
              return homeIdTokenMap.values().next().value;
            } else {
              tokensToBeRemoved = homeIdTokenMap;
            }
          }
          this.commonLogger.info("CacheManager:getIdToken - Multiple matching ID tokens found, clearing them");
          tokensToBeRemoved.forEach((idToken, key) => {
            this.removeIdToken(key, correlationId);
          });
          if (performanceClient && correlationId) {
            performanceClient.addFields({ multiMatchedID: idTokenMap.size }, correlationId);
          }
          return null;
        }
        this.commonLogger.info("CacheManager:getIdToken - Returning ID token");
        return idTokenMap.values().next().value;
      }
      /**
       * Gets all idTokens matching the given filter
       * @param filter
       * @returns
       */
      getIdTokensByFilter(filter, correlationId, tokenKeys) {
        const idTokenKeys = tokenKeys && tokenKeys.idToken || this.getTokenKeys().idToken;
        const idTokens = /* @__PURE__ */ new Map();
        idTokenKeys.forEach((key) => {
          if (!this.idTokenKeyMatchesFilter(key, {
            clientId: this.clientId,
            ...filter
          })) {
            return;
          }
          const idToken = this.getIdTokenCredential(key, correlationId);
          if (idToken && this.credentialMatchesFilter(idToken, filter)) {
            idTokens.set(key, idToken);
          }
        });
        return idTokens;
      }
      /**
       * Validate the cache key against filter before retrieving and parsing cache value
       * @param key
       * @param filter
       * @returns
       */
      idTokenKeyMatchesFilter(inputKey, filter) {
        const key = inputKey.toLowerCase();
        if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {
          return false;
        }
        if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {
          return false;
        }
        return true;
      }
      /**
       * Removes idToken from the cache
       * @param key
       */
      removeIdToken(key, correlationId) {
        this.removeItem(key, correlationId);
      }
      /**
       * Removes refresh token from the cache
       * @param key
       */
      removeRefreshToken(key, correlationId) {
        this.removeItem(key, correlationId);
      }
      /**
       * Retrieve AccessTokenEntity from cache
       * @param account {AccountInfo}
       * @param request {BaseAuthRequest}
       * @param correlationId {?string}
       * @param tokenKeys {?TokenKeys}
       * @param performanceClient {?IPerformanceClient}
       */
      getAccessToken(account, request, tokenKeys, targetRealm) {
        const correlationId = request.correlationId;
        this.commonLogger.trace("CacheManager - getAccessToken called", correlationId);
        const scopes = ScopeSet.createSearchScopes(request.scopes);
        const authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;
        const credentialType = authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;
        const accessTokenFilter = {
          homeAccountId: account.homeAccountId,
          environment: account.environment,
          credentialType,
          clientId: this.clientId,
          realm: targetRealm || account.tenantId,
          target: scopes,
          tokenType: authScheme,
          keyId: request.sshKid,
          requestedClaimsHash: request.requestedClaimsHash
        };
        const accessTokenKeys = tokenKeys && tokenKeys.accessToken || this.getTokenKeys().accessToken;
        const accessTokens = [];
        accessTokenKeys.forEach((key) => {
          if (this.accessTokenKeyMatchesFilter(key, accessTokenFilter, true)) {
            const accessToken = this.getAccessTokenCredential(key, correlationId);
            if (accessToken && this.credentialMatchesFilter(accessToken, accessTokenFilter)) {
              accessTokens.push(accessToken);
            }
          }
        });
        const numAccessTokens = accessTokens.length;
        if (numAccessTokens < 1) {
          this.commonLogger.info("CacheManager:getAccessToken - No token found", correlationId);
          return null;
        } else if (numAccessTokens > 1) {
          this.commonLogger.info("CacheManager:getAccessToken - Multiple access tokens found, clearing them", correlationId);
          accessTokens.forEach((accessToken) => {
            this.removeAccessToken(generateCredentialKey(accessToken), correlationId);
          });
          this.performanceClient.addFields({ multiMatchedAT: accessTokens.length }, correlationId);
          return null;
        }
        this.commonLogger.info("CacheManager:getAccessToken - Returning access token", correlationId);
        return accessTokens[0];
      }
      /**
       * Validate the cache key against filter before retrieving and parsing cache value
       * @param key
       * @param filter
       * @param keyMustContainAllScopes
       * @returns
       */
      accessTokenKeyMatchesFilter(inputKey, filter, keyMustContainAllScopes) {
        const key = inputKey.toLowerCase();
        if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {
          return false;
        }
        if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {
          return false;
        }
        if (filter.realm && key.indexOf(filter.realm.toLowerCase()) === -1) {
          return false;
        }
        if (filter.requestedClaimsHash && key.indexOf(filter.requestedClaimsHash.toLowerCase()) === -1) {
          return false;
        }
        if (filter.target) {
          const scopes = filter.target.asArray();
          for (let i = 0; i < scopes.length; i++) {
            if (keyMustContainAllScopes && !key.includes(scopes[i].toLowerCase())) {
              return false;
            } else if (!keyMustContainAllScopes && key.includes(scopes[i].toLowerCase())) {
              return true;
            }
          }
        }
        return true;
      }
      /**
       * Gets all access tokens matching the filter
       * @param filter
       * @returns
       */
      getAccessTokensByFilter(filter, correlationId) {
        const tokenKeys = this.getTokenKeys();
        const accessTokens = [];
        tokenKeys.accessToken.forEach((key) => {
          if (!this.accessTokenKeyMatchesFilter(key, filter, true)) {
            return;
          }
          const accessToken = this.getAccessTokenCredential(key, correlationId);
          if (accessToken && this.credentialMatchesFilter(accessToken, filter)) {
            accessTokens.push(accessToken);
          }
        });
        return accessTokens;
      }
      /**
       * Helper to retrieve the appropriate refresh token from cache
       * @param account {AccountInfo}
       * @param familyRT {boolean}
       * @param correlationId {?string}
       * @param tokenKeys {?TokenKeys}
       * @param performanceClient {?IPerformanceClient}
       */
      getRefreshToken(account, familyRT, correlationId, tokenKeys, performanceClient) {
        this.commonLogger.trace("CacheManager - getRefreshToken called");
        const id = familyRT ? THE_FAMILY_ID : void 0;
        const refreshTokenFilter = {
          homeAccountId: account.homeAccountId,
          environment: account.environment,
          credentialType: CredentialType.REFRESH_TOKEN,
          clientId: this.clientId,
          familyId: id
        };
        const refreshTokenKeys = tokenKeys && tokenKeys.refreshToken || this.getTokenKeys().refreshToken;
        const refreshTokens = [];
        refreshTokenKeys.forEach((key) => {
          if (this.refreshTokenKeyMatchesFilter(key, refreshTokenFilter)) {
            const refreshToken = this.getRefreshTokenCredential(key, correlationId);
            if (refreshToken && this.credentialMatchesFilter(refreshToken, refreshTokenFilter)) {
              refreshTokens.push(refreshToken);
            }
          }
        });
        const numRefreshTokens = refreshTokens.length;
        if (numRefreshTokens < 1) {
          this.commonLogger.info("CacheManager:getRefreshToken - No refresh token found.");
          return null;
        }
        if (numRefreshTokens > 1 && performanceClient && correlationId) {
          performanceClient.addFields({ multiMatchedRT: numRefreshTokens }, correlationId);
        }
        this.commonLogger.info("CacheManager:getRefreshToken - returning refresh token");
        return refreshTokens[0];
      }
      /**
       * Validate the cache key against filter before retrieving and parsing cache value
       * @param key
       * @param filter
       */
      refreshTokenKeyMatchesFilter(inputKey, filter) {
        const key = inputKey.toLowerCase();
        if (filter.familyId && key.indexOf(filter.familyId.toLowerCase()) === -1) {
          return false;
        }
        if (!filter.familyId && filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {
          return false;
        }
        if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {
          return false;
        }
        return true;
      }
      /**
       * Retrieve AppMetadataEntity from cache
       */
      readAppMetadataFromCache(environment) {
        const appMetadataFilter = {
          environment,
          clientId: this.clientId
        };
        const appMetadata = this.getAppMetadataFilteredBy(appMetadataFilter);
        const appMetadataEntries = Object.keys(appMetadata).map((key) => appMetadata[key]);
        const numAppMetadata = appMetadataEntries.length;
        if (numAppMetadata < 1) {
          return null;
        } else if (numAppMetadata > 1) {
          throw createClientAuthError(multipleMatchingAppMetadata);
        }
        return appMetadataEntries[0];
      }
      /**
       * Return the family_id value associated  with FOCI
       * @param environment
       * @param clientId
       */
      isAppMetadataFOCI(environment) {
        const appMetadata = this.readAppMetadataFromCache(environment);
        return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);
      }
      /**
       * helper to match account ids
       * @param value
       * @param homeAccountId
       */
      matchHomeAccountId(entity, homeAccountId) {
        return !!(typeof entity.homeAccountId === "string" && homeAccountId === entity.homeAccountId);
      }
      /**
       * helper to match account ids
       * @param entity
       * @param localAccountId
       * @returns
       */
      matchLocalAccountIdFromTokenClaims(tokenClaims, localAccountId) {
        const idTokenLocalAccountId = tokenClaims.oid || tokenClaims.sub;
        return localAccountId === idTokenLocalAccountId;
      }
      matchLocalAccountIdFromTenantProfile(tenantProfile, localAccountId) {
        return tenantProfile.localAccountId === localAccountId;
      }
      /**
       * helper to match names
       * @param entity
       * @param name
       * @returns true if the downcased name properties are present and match in the filter and the entity
       */
      matchName(claims, name3) {
        var _a3;
        return !!(name3.toLowerCase() === ((_a3 = claims.name) == null ? void 0 : _a3.toLowerCase()));
      }
      /**
       * helper to match usernames
       * @param entity
       * @param username
       * @returns
       */
      matchUsername(cachedUsername, filterUsername) {
        return !!(cachedUsername && typeof cachedUsername === "string" && (filterUsername == null ? void 0 : filterUsername.toLowerCase()) === cachedUsername.toLowerCase());
      }
      /**
       * helper to match assertion
       * @param value
       * @param oboAssertion
       */
      matchUserAssertionHash(entity, userAssertionHash) {
        return !!(entity.userAssertionHash && userAssertionHash === entity.userAssertionHash);
      }
      /**
       * helper to match environment
       * @param value
       * @param environment
       */
      matchEnvironment(entity, environment) {
        if (this.staticAuthorityOptions) {
          const staticAliases = getAliasesFromStaticSources(this.staticAuthorityOptions, this.commonLogger);
          if (staticAliases.includes(environment) && staticAliases.includes(entity.environment)) {
            return true;
          }
        }
        const cloudMetadata = this.getAuthorityMetadataByAlias(environment);
        if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {
          return true;
        }
        return false;
      }
      /**
       * helper to match credential type
       * @param entity
       * @param credentialType
       */
      matchCredentialType(entity, credentialType) {
        return entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase();
      }
      /**
       * helper to match client ids
       * @param entity
       * @param clientId
       */
      matchClientId(entity, clientId) {
        return !!(entity.clientId && clientId === entity.clientId);
      }
      /**
       * helper to match family ids
       * @param entity
       * @param familyId
       */
      matchFamilyId(entity, familyId) {
        return !!(entity.familyId && familyId === entity.familyId);
      }
      /**
       * helper to match realm
       * @param entity
       * @param realm
       */
      matchRealm(entity, realm) {
        var _a3;
        return !!(((_a3 = entity.realm) == null ? void 0 : _a3.toLowerCase()) === realm.toLowerCase());
      }
      /**
       * helper to match nativeAccountId
       * @param entity
       * @param nativeAccountId
       * @returns boolean indicating the match result
       */
      matchNativeAccountId(entity, nativeAccountId) {
        return !!(entity.nativeAccountId && nativeAccountId === entity.nativeAccountId);
      }
      /**
       * helper to match loginHint which can be either:
       * 1. login_hint ID token claim
       * 2. username in cached account object
       * 3. upn in ID token claims
       * @param entity
       * @param loginHint
       * @returns
       */
      matchLoginHintFromTokenClaims(tokenClaims, loginHint) {
        if (tokenClaims.login_hint === loginHint) {
          return true;
        }
        if (tokenClaims.preferred_username === loginHint) {
          return true;
        }
        if (tokenClaims.upn === loginHint) {
          return true;
        }
        return false;
      }
      /**
       * Helper to match sid
       * @param entity
       * @param sid
       * @returns true if the sid claim is present and matches the filter
       */
      matchSid(idTokenClaims, sid) {
        return idTokenClaims.sid === sid;
      }
      matchAuthorityType(entity, authorityType) {
        return !!(entity.authorityType && authorityType.toLowerCase() === entity.authorityType.toLowerCase());
      }
      /**
       * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.
       * @param entity
       * @param target
       */
      matchTarget(entity, target) {
        const isNotAccessTokenCredential = entity.credentialType !== CredentialType.ACCESS_TOKEN && entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;
        if (isNotAccessTokenCredential || !entity.target) {
          return false;
        }
        const entityScopeSet = ScopeSet.fromString(entity.target);
        return entityScopeSet.containsScopeSet(target);
      }
      /**
       * Returns true if the credential's tokenType or Authentication Scheme matches the one in the request, false otherwise
       * @param entity
       * @param tokenType
       */
      matchTokenType(entity, tokenType) {
        return !!(entity.tokenType && entity.tokenType === tokenType);
      }
      /**
       * Returns true if the credential's keyId matches the one in the request, false otherwise
       * @param entity
       * @param keyId
       */
      matchKeyId(entity, keyId) {
        return !!(entity.keyId && entity.keyId === keyId);
      }
      /**
       * returns if a given cache entity is of the type appmetadata
       * @param key
       */
      isAppMetadata(key) {
        return key.indexOf(APP_METADATA) !== -1;
      }
      /**
       * returns if a given cache entity is of the type authoritymetadata
       * @param key
       */
      isAuthorityMetadata(key) {
        return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;
      }
      /**
       * returns cache key used for cloud instance metadata
       */
      generateAuthorityMetadataCacheKey(authority) {
        return `${AUTHORITY_METADATA_CONSTANTS.CACHE_KEY}-${this.clientId}-${authority}`;
      }
      /**
       * Helper to convert serialized data to object
       * @param obj
       * @param json
       */
      static toObject(obj, json) {
        for (const propertyName in json) {
          obj[propertyName] = json[propertyName];
        }
        return obj;
      }
    };
    DefaultStorageClass = class extends CacheManager {
      async setAccount() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAccount() {
        throw createClientAuthError(methodNotImplemented);
      }
      async setIdTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      getIdTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      async setAccessTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAccessTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      async setRefreshTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      getRefreshTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      setAppMetadata() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAppMetadata() {
        throw createClientAuthError(methodNotImplemented);
      }
      setServerTelemetry() {
        throw createClientAuthError(methodNotImplemented);
      }
      getServerTelemetry() {
        throw createClientAuthError(methodNotImplemented);
      }
      setAuthorityMetadata() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAuthorityMetadata() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAuthorityMetadataKeys() {
        throw createClientAuthError(methodNotImplemented);
      }
      setThrottlingCache() {
        throw createClientAuthError(methodNotImplemented);
      }
      getThrottlingCache() {
        throw createClientAuthError(methodNotImplemented);
      }
      removeItem() {
        throw createClientAuthError(methodNotImplemented);
      }
      getKeys() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAccountKeys() {
        throw createClientAuthError(methodNotImplemented);
      }
      getTokenKeys() {
        throw createClientAuthError(methodNotImplemented);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/telemetry/performance/PerformanceEvent.mjs
var PerformanceEvents, PerformanceEventAbbreviations, PerformanceEventStatus, IntFields;
var init_PerformanceEvent = __esm({
  "node_modules/@azure/msal-common/dist/telemetry/performance/PerformanceEvent.mjs"() {
    "use strict";
    PerformanceEvents = {
      /**
       * acquireTokenByCode API (msal-browser and msal-node).
       * Used to acquire tokens by trading an authorization code against the token endpoint.
       */
      AcquireTokenByCode: "acquireTokenByCode",
      /**
       * acquireTokenByRefreshToken API (msal-browser and msal-node).
       * Used to renew an access token using a refresh token against the token endpoint.
       */
      AcquireTokenByRefreshToken: "acquireTokenByRefreshToken",
      /**
       * acquireTokenSilent API (msal-browser and msal-node).
       * Used to silently acquire a new access token (from the cache or the network).
       */
      AcquireTokenSilent: "acquireTokenSilent",
      /**
       * acquireTokenSilentAsync (msal-browser).
       * Internal API for acquireTokenSilent.
       */
      AcquireTokenSilentAsync: "acquireTokenSilentAsync",
      /**
       * acquireTokenPopup (msal-browser).
       * Used to acquire a new access token interactively through pop ups
       */
      AcquireTokenPopup: "acquireTokenPopup",
      /**
       * acquireTokenPreRedirect (msal-browser).
       * First part of the redirect flow.
       * Used to acquire a new access token interactively through redirects.
       */
      AcquireTokenPreRedirect: "acquireTokenPreRedirect",
      /**
       * acquireTokenRedirect (msal-browser).
       * Second part of the redirect flow.
       * Used to acquire a new access token interactively through redirects.
       */
      AcquireTokenRedirect: "acquireTokenRedirect",
      /**
       * getPublicKeyThumbprint API in CryptoOpts class (msal-browser).
       * Used to generate a public/private keypair and generate a public key thumbprint for pop requests.
       */
      CryptoOptsGetPublicKeyThumbprint: "cryptoOptsGetPublicKeyThumbprint",
      /**
       * signJwt API in CryptoOpts class (msal-browser).
       * Used to signed a pop token.
       */
      CryptoOptsSignJwt: "cryptoOptsSignJwt",
      /**
       * acquireToken API in the SilentCacheClient class (msal-browser).
       * Used to read access tokens from the cache.
       */
      SilentCacheClientAcquireToken: "silentCacheClientAcquireToken",
      /**
       * acquireToken API in the SilentIframeClient class (msal-browser).
       * Used to acquire a new set of tokens from the authorize endpoint in a hidden iframe.
       */
      SilentIframeClientAcquireToken: "silentIframeClientAcquireToken",
      AwaitConcurrentIframe: "awaitConcurrentIframe",
      /**
       * acquireToken API in SilentRereshClient (msal-browser).
       * Used to acquire a new set of tokens from the token endpoint using a refresh token.
       */
      SilentRefreshClientAcquireToken: "silentRefreshClientAcquireToken",
      /**
       * ssoSilent API (msal-browser).
       * Used to silently acquire an authorization code and set of tokens using a hidden iframe.
       */
      SsoSilent: "ssoSilent",
      /**
       * getDiscoveredAuthority API in StandardInteractionClient class (msal-browser).
       * Used to load authority metadata for a request.
       */
      StandardInteractionClientGetDiscoveredAuthority: "standardInteractionClientGetDiscoveredAuthority",
      /**
       * acquireToken APIs in msal-browser.
       * Used to make an /authorize endpoint call with native brokering enabled.
       */
      FetchAccountIdWithNativeBroker: "fetchAccountIdWithNativeBroker",
      /**
       * acquireToken API in NativeInteractionClient class (msal-browser).
       * Used to acquire a token from Native component when native brokering is enabled.
       */
      NativeInteractionClientAcquireToken: "nativeInteractionClientAcquireToken",
      /**
       * Time spent creating default headers for requests to token endpoint
       */
      BaseClientCreateTokenRequestHeaders: "baseClientCreateTokenRequestHeaders",
      /**
       * Time spent sending/waiting for the response of a request to the token endpoint
       */
      NetworkClientSendPostRequestAsync: "networkClientSendPostRequestAsync",
      RefreshTokenClientExecutePostToTokenEndpoint: "refreshTokenClientExecutePostToTokenEndpoint",
      AuthorizationCodeClientExecutePostToTokenEndpoint: "authorizationCodeClientExecutePostToTokenEndpoint",
      /**
       * Used to measure the time taken for completing embedded-broker handshake (PW-Broker).
       */
      BrokerHandhshake: "brokerHandshake",
      /**
       * acquireTokenByRefreshToken API in BrokerClientApplication (PW-Broker) .
       */
      AcquireTokenByRefreshTokenInBroker: "acquireTokenByRefreshTokenInBroker",
      /**
       * Time taken for token acquisition by broker
       */
      AcquireTokenByBroker: "acquireTokenByBroker",
      /**
       * Time spent on the network for refresh token acquisition
       */
      RefreshTokenClientExecuteTokenRequest: "refreshTokenClientExecuteTokenRequest",
      /**
       * Time taken for acquiring refresh token , records RT size
       */
      RefreshTokenClientAcquireToken: "refreshTokenClientAcquireToken",
      /**
       * Time taken for acquiring cached refresh token
       */
      RefreshTokenClientAcquireTokenWithCachedRefreshToken: "refreshTokenClientAcquireTokenWithCachedRefreshToken",
      /**
       * acquireTokenByRefreshToken API in RefreshTokenClient (msal-common).
       */
      RefreshTokenClientAcquireTokenByRefreshToken: "refreshTokenClientAcquireTokenByRefreshToken",
      /**
       * Helper function to create token request body in RefreshTokenClient (msal-common).
       */
      RefreshTokenClientCreateTokenRequestBody: "refreshTokenClientCreateTokenRequestBody",
      /**
       * acquireTokenFromCache (msal-browser).
       * Internal API for acquiring token from cache
       */
      AcquireTokenFromCache: "acquireTokenFromCache",
      SilentFlowClientAcquireCachedToken: "silentFlowClientAcquireCachedToken",
      SilentFlowClientGenerateResultFromCacheRecord: "silentFlowClientGenerateResultFromCacheRecord",
      /**
       * acquireTokenBySilentIframe (msal-browser).
       * Internal API for acquiring token by silent Iframe
       */
      AcquireTokenBySilentIframe: "acquireTokenBySilentIframe",
      /**
       * Internal API for initializing base request in BaseInteractionClient (msal-browser)
       */
      InitializeBaseRequest: "initializeBaseRequest",
      /**
       * Internal API for initializing silent request in SilentCacheClient (msal-browser)
       */
      InitializeSilentRequest: "initializeSilentRequest",
      InitializeClientApplication: "initializeClientApplication",
      InitializeCache: "initializeCache",
      /**
       * Helper function in SilentIframeClient class (msal-browser).
       */
      SilentIframeClientTokenHelper: "silentIframeClientTokenHelper",
      /**
       * SilentHandler
       */
      SilentHandlerInitiateAuthRequest: "silentHandlerInitiateAuthRequest",
      SilentHandlerMonitorIframeForHash: "silentHandlerMonitorIframeForHash",
      SilentHandlerLoadFrame: "silentHandlerLoadFrame",
      SilentHandlerLoadFrameSync: "silentHandlerLoadFrameSync",
      /**
       * Helper functions in StandardInteractionClient class (msal-browser)
       */
      StandardInteractionClientCreateAuthCodeClient: "standardInteractionClientCreateAuthCodeClient",
      StandardInteractionClientGetClientConfiguration: "standardInteractionClientGetClientConfiguration",
      StandardInteractionClientInitializeAuthorizationRequest: "standardInteractionClientInitializeAuthorizationRequest",
      /**
       * getAuthCodeUrl API (msal-browser and msal-node).
       */
      GetAuthCodeUrl: "getAuthCodeUrl",
      GetStandardParams: "getStandardParams",
      /**
       * Functions from InteractionHandler (msal-browser)
       */
      HandleCodeResponseFromServer: "handleCodeResponseFromServer",
      HandleCodeResponse: "handleCodeResponse",
      HandleResponseEar: "handleResponseEar",
      HandleResponsePlatformBroker: "handleResponsePlatformBroker",
      HandleResponseCode: "handleResponseCode",
      UpdateTokenEndpointAuthority: "updateTokenEndpointAuthority",
      /**
       * APIs in Authorization Code Client (msal-common)
       */
      AuthClientAcquireToken: "authClientAcquireToken",
      AuthClientExecuteTokenRequest: "authClientExecuteTokenRequest",
      AuthClientCreateTokenRequestBody: "authClientCreateTokenRequestBody",
      /**
       * Generate functions in PopTokenGenerator (msal-common)
       */
      PopTokenGenerateCnf: "popTokenGenerateCnf",
      PopTokenGenerateKid: "popTokenGenerateKid",
      /**
       * handleServerTokenResponse API in ResponseHandler (msal-common)
       */
      HandleServerTokenResponse: "handleServerTokenResponse",
      DeserializeResponse: "deserializeResponse",
      /**
       * Authority functions
       */
      AuthorityFactoryCreateDiscoveredInstance: "authorityFactoryCreateDiscoveredInstance",
      AuthorityResolveEndpointsAsync: "authorityResolveEndpointsAsync",
      AuthorityResolveEndpointsFromLocalSources: "authorityResolveEndpointsFromLocalSources",
      AuthorityGetCloudDiscoveryMetadataFromNetwork: "authorityGetCloudDiscoveryMetadataFromNetwork",
      AuthorityUpdateCloudDiscoveryMetadata: "authorityUpdateCloudDiscoveryMetadata",
      AuthorityGetEndpointMetadataFromNetwork: "authorityGetEndpointMetadataFromNetwork",
      AuthorityUpdateEndpointMetadata: "authorityUpdateEndpointMetadata",
      AuthorityUpdateMetadataWithRegionalInformation: "authorityUpdateMetadataWithRegionalInformation",
      /**
       * Region Discovery functions
       */
      RegionDiscoveryDetectRegion: "regionDiscoveryDetectRegion",
      RegionDiscoveryGetRegionFromIMDS: "regionDiscoveryGetRegionFromIMDS",
      RegionDiscoveryGetCurrentVersion: "regionDiscoveryGetCurrentVersion",
      AcquireTokenByCodeAsync: "acquireTokenByCodeAsync",
      GetEndpointMetadataFromNetwork: "getEndpointMetadataFromNetwork",
      GetCloudDiscoveryMetadataFromNetworkMeasurement: "getCloudDiscoveryMetadataFromNetworkMeasurement",
      HandleRedirectPromiseMeasurement: "handleRedirectPromise",
      HandleNativeRedirectPromiseMeasurement: "handleNativeRedirectPromise",
      UpdateCloudDiscoveryMetadataMeasurement: "updateCloudDiscoveryMetadataMeasurement",
      UsernamePasswordClientAcquireToken: "usernamePasswordClientAcquireToken",
      NativeMessageHandlerHandshake: "nativeMessageHandlerHandshake",
      NativeGenerateAuthResult: "nativeGenerateAuthResult",
      RemoveHiddenIframe: "removeHiddenIframe",
      /**
       * Cache operations
       */
      ClearTokensAndKeysWithClaims: "clearTokensAndKeysWithClaims",
      CacheManagerGetRefreshToken: "cacheManagerGetRefreshToken",
      ImportExistingCache: "importExistingCache",
      SetUserData: "setUserData",
      LocalStorageUpdated: "localStorageUpdated",
      /**
       * Crypto Operations
       */
      GeneratePkceCodes: "generatePkceCodes",
      GenerateCodeVerifier: "generateCodeVerifier",
      GenerateCodeChallengeFromVerifier: "generateCodeChallengeFromVerifier",
      Sha256Digest: "sha256Digest",
      GetRandomValues: "getRandomValues",
      GenerateHKDF: "generateHKDF",
      GenerateBaseKey: "generateBaseKey",
      Base64Decode: "base64Decode",
      UrlEncodeArr: "urlEncodeArr",
      Encrypt: "encrypt",
      Decrypt: "decrypt",
      GenerateEarKey: "generateEarKey",
      DecryptEarResponse: "decryptEarResponse"
    };
    PerformanceEventAbbreviations = /* @__PURE__ */ new Map([
      [PerformanceEvents.AcquireTokenByCode, "ATByCode"],
      [PerformanceEvents.AcquireTokenByRefreshToken, "ATByRT"],
      [PerformanceEvents.AcquireTokenSilent, "ATS"],
      [PerformanceEvents.AcquireTokenSilentAsync, "ATSAsync"],
      [PerformanceEvents.AcquireTokenPopup, "ATPopup"],
      [PerformanceEvents.AcquireTokenRedirect, "ATRedirect"],
      [
        PerformanceEvents.CryptoOptsGetPublicKeyThumbprint,
        "CryptoGetPKThumb"
      ],
      [PerformanceEvents.CryptoOptsSignJwt, "CryptoSignJwt"],
      [PerformanceEvents.SilentCacheClientAcquireToken, "SltCacheClientAT"],
      [PerformanceEvents.SilentIframeClientAcquireToken, "SltIframeClientAT"],
      [PerformanceEvents.SilentRefreshClientAcquireToken, "SltRClientAT"],
      [PerformanceEvents.SsoSilent, "SsoSlt"],
      [
        PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority,
        "StdIntClientGetDiscAuth"
      ],
      [
        PerformanceEvents.FetchAccountIdWithNativeBroker,
        "FetchAccIdWithNtvBroker"
      ],
      [
        PerformanceEvents.NativeInteractionClientAcquireToken,
        "NtvIntClientAT"
      ],
      [
        PerformanceEvents.BaseClientCreateTokenRequestHeaders,
        "BaseClientCreateTReqHead"
      ],
      [
        PerformanceEvents.NetworkClientSendPostRequestAsync,
        "NetClientSendPost"
      ],
      [
        PerformanceEvents.RefreshTokenClientExecutePostToTokenEndpoint,
        "RTClientExecPost"
      ],
      [
        PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint,
        "AuthCodeClientExecPost"
      ],
      [PerformanceEvents.BrokerHandhshake, "BrokerHandshake"],
      [
        PerformanceEvents.AcquireTokenByRefreshTokenInBroker,
        "ATByRTInBroker"
      ],
      [PerformanceEvents.AcquireTokenByBroker, "ATByBroker"],
      [
        PerformanceEvents.RefreshTokenClientExecuteTokenRequest,
        "RTClientExecTReq"
      ],
      [PerformanceEvents.RefreshTokenClientAcquireToken, "RTClientAT"],
      [
        PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken,
        "RTClientATWithCachedRT"
      ],
      [
        PerformanceEvents.RefreshTokenClientAcquireTokenByRefreshToken,
        "RTClientATByRT"
      ],
      [
        PerformanceEvents.RefreshTokenClientCreateTokenRequestBody,
        "RTClientCreateTReqBody"
      ],
      [PerformanceEvents.AcquireTokenFromCache, "ATFromCache"],
      [
        PerformanceEvents.SilentFlowClientAcquireCachedToken,
        "SltFlowClientATCached"
      ],
      [
        PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord,
        "SltFlowClientGenResFromCache"
      ],
      [PerformanceEvents.AcquireTokenBySilentIframe, "ATBySltIframe"],
      [PerformanceEvents.InitializeBaseRequest, "InitBaseReq"],
      [PerformanceEvents.InitializeSilentRequest, "InitSltReq"],
      [
        PerformanceEvents.InitializeClientApplication,
        "InitClientApplication"
      ],
      [PerformanceEvents.InitializeCache, "InitCache"],
      [PerformanceEvents.ImportExistingCache, "importCache"],
      [PerformanceEvents.SetUserData, "setUserData"],
      [PerformanceEvents.LocalStorageUpdated, "localStorageUpdated"],
      [PerformanceEvents.SilentIframeClientTokenHelper, "SIClientTHelper"],
      [
        PerformanceEvents.SilentHandlerInitiateAuthRequest,
        "SHandlerInitAuthReq"
      ],
      [
        PerformanceEvents.SilentHandlerMonitorIframeForHash,
        "SltHandlerMonitorIframeForHash"
      ],
      [PerformanceEvents.SilentHandlerLoadFrame, "SHandlerLoadFrame"],
      [PerformanceEvents.SilentHandlerLoadFrameSync, "SHandlerLoadFrameSync"],
      [
        PerformanceEvents.StandardInteractionClientCreateAuthCodeClient,
        "StdIntClientCreateAuthCodeClient"
      ],
      [
        PerformanceEvents.StandardInteractionClientGetClientConfiguration,
        "StdIntClientGetClientConf"
      ],
      [
        PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest,
        "StdIntClientInitAuthReq"
      ],
      [PerformanceEvents.GetAuthCodeUrl, "GetAuthCodeUrl"],
      [
        PerformanceEvents.HandleCodeResponseFromServer,
        "HandleCodeResFromServer"
      ],
      [PerformanceEvents.HandleCodeResponse, "HandleCodeResp"],
      [PerformanceEvents.HandleResponseEar, "HandleRespEar"],
      [PerformanceEvents.HandleResponseCode, "HandleRespCode"],
      [
        PerformanceEvents.HandleResponsePlatformBroker,
        "HandleRespPlatBroker"
      ],
      [PerformanceEvents.UpdateTokenEndpointAuthority, "UpdTEndpointAuth"],
      [PerformanceEvents.AuthClientAcquireToken, "AuthClientAT"],
      [PerformanceEvents.AuthClientExecuteTokenRequest, "AuthClientExecTReq"],
      [
        PerformanceEvents.AuthClientCreateTokenRequestBody,
        "AuthClientCreateTReqBody"
      ],
      [PerformanceEvents.PopTokenGenerateCnf, "PopTGenCnf"],
      [PerformanceEvents.PopTokenGenerateKid, "PopTGenKid"],
      [PerformanceEvents.HandleServerTokenResponse, "HandleServerTRes"],
      [PerformanceEvents.DeserializeResponse, "DeserializeRes"],
      [
        PerformanceEvents.AuthorityFactoryCreateDiscoveredInstance,
        "AuthFactCreateDiscInst"
      ],
      [
        PerformanceEvents.AuthorityResolveEndpointsAsync,
        "AuthResolveEndpointsAsync"
      ],
      [
        PerformanceEvents.AuthorityResolveEndpointsFromLocalSources,
        "AuthResolveEndpointsFromLocal"
      ],
      [
        PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork,
        "AuthGetCDMetaFromNet"
      ],
      [
        PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata,
        "AuthUpdCDMeta"
      ],
      [
        PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork,
        "AuthUpdCDMetaFromNet"
      ],
      [
        PerformanceEvents.AuthorityUpdateEndpointMetadata,
        "AuthUpdEndpointMeta"
      ],
      [
        PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation,
        "AuthUpdMetaWithRegInfo"
      ],
      [PerformanceEvents.RegionDiscoveryDetectRegion, "RegDiscDetectReg"],
      [
        PerformanceEvents.RegionDiscoveryGetRegionFromIMDS,
        "RegDiscGetRegFromIMDS"
      ],
      [
        PerformanceEvents.RegionDiscoveryGetCurrentVersion,
        "RegDiscGetCurrentVer"
      ],
      [PerformanceEvents.AcquireTokenByCodeAsync, "ATByCodeAsync"],
      [
        PerformanceEvents.GetEndpointMetadataFromNetwork,
        "GetEndpointMetaFromNet"
      ],
      [
        PerformanceEvents.GetCloudDiscoveryMetadataFromNetworkMeasurement,
        "GetCDMetaFromNet"
      ],
      [
        PerformanceEvents.HandleRedirectPromiseMeasurement,
        "HandleRedirectPromise"
      ],
      [
        PerformanceEvents.HandleNativeRedirectPromiseMeasurement,
        "HandleNtvRedirectPromise"
      ],
      [
        PerformanceEvents.UpdateCloudDiscoveryMetadataMeasurement,
        "UpdateCDMeta"
      ],
      [
        PerformanceEvents.UsernamePasswordClientAcquireToken,
        "UserPassClientAT"
      ],
      [
        PerformanceEvents.NativeMessageHandlerHandshake,
        "NtvMsgHandlerHandshake"
      ],
      [PerformanceEvents.NativeGenerateAuthResult, "NtvGenAuthRes"],
      [PerformanceEvents.RemoveHiddenIframe, "RemoveHiddenIframe"],
      [
        PerformanceEvents.ClearTokensAndKeysWithClaims,
        "ClearTAndKeysWithClaims"
      ],
      [PerformanceEvents.CacheManagerGetRefreshToken, "CacheManagerGetRT"],
      [PerformanceEvents.GeneratePkceCodes, "GenPkceCodes"],
      [PerformanceEvents.GenerateCodeVerifier, "GenCodeVerifier"],
      [
        PerformanceEvents.GenerateCodeChallengeFromVerifier,
        "GenCodeChallengeFromVerifier"
      ],
      [PerformanceEvents.Sha256Digest, "Sha256Digest"],
      [PerformanceEvents.GetRandomValues, "GetRandomValues"],
      [PerformanceEvents.GenerateHKDF, "genHKDF"],
      [PerformanceEvents.GenerateBaseKey, "genBaseKey"],
      [PerformanceEvents.Base64Decode, "b64Decode"],
      [PerformanceEvents.UrlEncodeArr, "urlEncArr"],
      [PerformanceEvents.Encrypt, "encrypt"],
      [PerformanceEvents.Decrypt, "decrypt"],
      [PerformanceEvents.GenerateEarKey, "genEarKey"],
      [PerformanceEvents.DecryptEarResponse, "decryptEarResp"]
    ]);
    PerformanceEventStatus = {
      NotStarted: 0,
      InProgress: 1,
      Completed: 2
    };
    IntFields = /* @__PURE__ */ new Set([
      "accessTokenSize",
      "durationMs",
      "idTokenSize",
      "matsSilentStatus",
      "matsHttpStatus",
      "refreshTokenSize",
      "queuedTimeMs",
      "startTimeMs",
      "status",
      "multiMatchedAT",
      "multiMatchedID",
      "multiMatchedRT",
      "unencryptedCacheCount",
      "encryptedCacheExpiredCount"
    ]);
  }
});

// node_modules/@azure/msal-common/dist/telemetry/performance/StubPerformanceClient.mjs
var StubPerformanceMeasurement, StubPerformanceClient;
var init_StubPerformanceClient = __esm({
  "node_modules/@azure/msal-common/dist/telemetry/performance/StubPerformanceClient.mjs"() {
    "use strict";
    init_PerformanceEvent();
    StubPerformanceMeasurement = class {
      startMeasurement() {
        return;
      }
      endMeasurement() {
        return;
      }
      flushMeasurement() {
        return null;
      }
    };
    StubPerformanceClient = class {
      generateId() {
        return "callback-id";
      }
      startMeasurement(measureName, correlationId) {
        return {
          end: () => null,
          discard: () => {
          },
          add: () => {
          },
          increment: () => {
          },
          event: {
            eventId: this.generateId(),
            status: PerformanceEventStatus.InProgress,
            authority: "",
            libraryName: "",
            libraryVersion: "",
            clientId: "",
            name: measureName,
            startTimeMs: Date.now(),
            correlationId: correlationId || ""
          },
          measurement: new StubPerformanceMeasurement()
        };
      }
      startPerformanceMeasurement() {
        return new StubPerformanceMeasurement();
      }
      calculateQueuedTime() {
        return 0;
      }
      addQueueMeasurement() {
        return;
      }
      setPreQueueTime() {
        return;
      }
      endMeasurement() {
        return null;
      }
      discardMeasurements() {
        return;
      }
      removePerformanceCallback() {
        return true;
      }
      addPerformanceCallback() {
        return "";
      }
      emitEvents() {
        return;
      }
      addFields() {
        return;
      }
      incrementFields() {
        return;
      }
      cacheEventByCorrelationId() {
        return;
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/config/ClientConfiguration.mjs
function buildClientConfiguration({ authOptions: userAuthOptions, systemOptions: userSystemOptions, loggerOptions: userLoggerOption, cacheOptions: userCacheOptions, storageInterface: storageImplementation, networkInterface: networkImplementation, cryptoInterface: cryptoImplementation, clientCredentials, libraryInfo, telemetry, serverTelemetryManager, persistencePlugin, serializableCache }) {
  const loggerOptions = {
    ...DEFAULT_LOGGER_IMPLEMENTATION,
    ...userLoggerOption
  };
  return {
    authOptions: buildAuthOptions(userAuthOptions),
    systemOptions: { ...DEFAULT_SYSTEM_OPTIONS, ...userSystemOptions },
    loggerOptions,
    cacheOptions: { ...DEFAULT_CACHE_OPTIONS, ...userCacheOptions },
    storageInterface: storageImplementation || new DefaultStorageClass(userAuthOptions.clientId, DEFAULT_CRYPTO_IMPLEMENTATION, new Logger(loggerOptions), new StubPerformanceClient()),
    networkInterface: networkImplementation || DEFAULT_NETWORK_IMPLEMENTATION,
    cryptoInterface: cryptoImplementation || DEFAULT_CRYPTO_IMPLEMENTATION,
    clientCredentials: clientCredentials || DEFAULT_CLIENT_CREDENTIALS,
    libraryInfo: { ...DEFAULT_LIBRARY_INFO, ...libraryInfo },
    telemetry: { ...DEFAULT_TELEMETRY_OPTIONS, ...telemetry },
    serverTelemetryManager: serverTelemetryManager || null,
    persistencePlugin: persistencePlugin || null,
    serializableCache: serializableCache || null
  };
}
function buildAuthOptions(authOptions) {
  return {
    clientCapabilities: [],
    azureCloudOptions: DEFAULT_AZURE_CLOUD_OPTIONS,
    skipAuthorityMetadataCache: false,
    instanceAware: false,
    encodeExtraQueryParams: false,
    ...authOptions
  };
}
function isOidcProtocolMode(config) {
  return config.authOptions.authority.options.protocolMode === ProtocolMode.OIDC;
}
var DEFAULT_SYSTEM_OPTIONS, DEFAULT_LOGGER_IMPLEMENTATION, DEFAULT_CACHE_OPTIONS, DEFAULT_NETWORK_IMPLEMENTATION, DEFAULT_LIBRARY_INFO, DEFAULT_CLIENT_CREDENTIALS, DEFAULT_AZURE_CLOUD_OPTIONS, DEFAULT_TELEMETRY_OPTIONS;
var init_ClientConfiguration = __esm({
  "node_modules/@azure/msal-common/dist/config/ClientConfiguration.mjs"() {
    "use strict";
    init_ICrypto();
    init_Logger();
    init_Constants();
    init_packageMetadata();
    init_AuthorityOptions();
    init_CacheManager();
    init_ProtocolMode();
    init_ClientAuthError();
    init_StubPerformanceClient();
    init_ClientAuthErrorCodes();
    DEFAULT_SYSTEM_OPTIONS = {
      tokenRenewalOffsetSeconds: DEFAULT_TOKEN_RENEWAL_OFFSET_SEC,
      preventCorsPreflight: false
    };
    DEFAULT_LOGGER_IMPLEMENTATION = {
      loggerCallback: () => {
      },
      piiLoggingEnabled: false,
      logLevel: LogLevel.Info,
      correlationId: Constants.EMPTY_STRING
    };
    DEFAULT_CACHE_OPTIONS = {
      claimsBasedCachingEnabled: false
    };
    DEFAULT_NETWORK_IMPLEMENTATION = {
      async sendGetRequestAsync() {
        throw createClientAuthError(methodNotImplemented);
      },
      async sendPostRequestAsync() {
        throw createClientAuthError(methodNotImplemented);
      }
    };
    DEFAULT_LIBRARY_INFO = {
      sku: Constants.SKU,
      version,
      cpu: Constants.EMPTY_STRING,
      os: Constants.EMPTY_STRING
    };
    DEFAULT_CLIENT_CREDENTIALS = {
      clientSecret: Constants.EMPTY_STRING,
      clientAssertion: void 0
    };
    DEFAULT_AZURE_CLOUD_OPTIONS = {
      azureCloudInstance: AzureCloudInstance.None,
      tenant: `${Constants.DEFAULT_COMMON_TENANT}`
    };
    DEFAULT_TELEMETRY_OPTIONS = {
      application: {
        appName: "",
        appVersion: ""
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/account/CcsCredential.mjs
var CcsCredentialType;
var init_CcsCredential = __esm({
  "node_modules/@azure/msal-common/dist/account/CcsCredential.mjs"() {
    "use strict";
    CcsCredentialType = {
      HOME_ACCOUNT_ID: "home_account_id",
      UPN: "UPN"
    };
  }
});

// node_modules/@azure/msal-common/dist/constants/AADServerParamKeys.mjs
var AADServerParamKeys_exports = {};
__export(AADServerParamKeys_exports, {
  ACCESS_TOKEN: () => ACCESS_TOKEN,
  BROKER_CLIENT_ID: () => BROKER_CLIENT_ID,
  BROKER_REDIRECT_URI: () => BROKER_REDIRECT_URI,
  CCS_HEADER: () => CCS_HEADER,
  CLAIMS: () => CLAIMS,
  CLIENT_ASSERTION: () => CLIENT_ASSERTION,
  CLIENT_ASSERTION_TYPE: () => CLIENT_ASSERTION_TYPE,
  CLIENT_ID: () => CLIENT_ID,
  CLIENT_INFO: () => CLIENT_INFO2,
  CLIENT_REQUEST_ID: () => CLIENT_REQUEST_ID,
  CLIENT_SECRET: () => CLIENT_SECRET,
  CODE: () => CODE,
  CODE_CHALLENGE: () => CODE_CHALLENGE,
  CODE_CHALLENGE_METHOD: () => CODE_CHALLENGE_METHOD,
  CODE_VERIFIER: () => CODE_VERIFIER,
  DEVICE_CODE: () => DEVICE_CODE,
  DOMAIN_HINT: () => DOMAIN_HINT,
  EAR_JWE_CRYPTO: () => EAR_JWE_CRYPTO,
  EAR_JWK: () => EAR_JWK,
  ERROR: () => ERROR,
  ERROR_DESCRIPTION: () => ERROR_DESCRIPTION,
  EXPIRES_IN: () => EXPIRES_IN,
  FOCI: () => FOCI,
  GRANT_TYPE: () => GRANT_TYPE,
  ID_TOKEN: () => ID_TOKEN,
  ID_TOKEN_HINT: () => ID_TOKEN_HINT,
  INSTANCE_AWARE: () => INSTANCE_AWARE,
  LOGIN_HINT: () => LOGIN_HINT,
  LOGOUT_HINT: () => LOGOUT_HINT,
  NATIVE_BROKER: () => NATIVE_BROKER,
  NONCE: () => NONCE,
  OBO_ASSERTION: () => OBO_ASSERTION,
  ON_BEHALF_OF: () => ON_BEHALF_OF,
  POST_LOGOUT_URI: () => POST_LOGOUT_URI,
  PROMPT: () => PROMPT,
  REDIRECT_URI: () => REDIRECT_URI,
  REFRESH_TOKEN: () => REFRESH_TOKEN,
  REFRESH_TOKEN_EXPIRES_IN: () => REFRESH_TOKEN_EXPIRES_IN,
  REQUESTED_TOKEN_USE: () => REQUESTED_TOKEN_USE,
  REQ_CNF: () => REQ_CNF,
  RESPONSE_MODE: () => RESPONSE_MODE,
  RESPONSE_TYPE: () => RESPONSE_TYPE,
  RETURN_SPA_CODE: () => RETURN_SPA_CODE,
  SCOPE: () => SCOPE,
  SESSION_STATE: () => SESSION_STATE,
  SID: () => SID,
  STATE: () => STATE,
  TOKEN_TYPE: () => TOKEN_TYPE,
  X_APP_NAME: () => X_APP_NAME,
  X_APP_VER: () => X_APP_VER,
  X_CLIENT_CPU: () => X_CLIENT_CPU,
  X_CLIENT_CURR_TELEM: () => X_CLIENT_CURR_TELEM,
  X_CLIENT_EXTRA_SKU: () => X_CLIENT_EXTRA_SKU,
  X_CLIENT_LAST_TELEM: () => X_CLIENT_LAST_TELEM,
  X_CLIENT_OS: () => X_CLIENT_OS,
  X_CLIENT_SKU: () => X_CLIENT_SKU,
  X_CLIENT_VER: () => X_CLIENT_VER,
  X_MS_LIB_CAPABILITY: () => X_MS_LIB_CAPABILITY
});
var CLIENT_ID, REDIRECT_URI, RESPONSE_TYPE, RESPONSE_MODE, GRANT_TYPE, CLAIMS, SCOPE, ERROR, ERROR_DESCRIPTION, ACCESS_TOKEN, ID_TOKEN, REFRESH_TOKEN, EXPIRES_IN, REFRESH_TOKEN_EXPIRES_IN, STATE, NONCE, PROMPT, SESSION_STATE, CLIENT_INFO2, CODE, CODE_CHALLENGE, CODE_CHALLENGE_METHOD, CODE_VERIFIER, CLIENT_REQUEST_ID, X_CLIENT_SKU, X_CLIENT_VER, X_CLIENT_OS, X_CLIENT_CPU, X_CLIENT_CURR_TELEM, X_CLIENT_LAST_TELEM, X_MS_LIB_CAPABILITY, X_APP_NAME, X_APP_VER, POST_LOGOUT_URI, ID_TOKEN_HINT, DEVICE_CODE, CLIENT_SECRET, CLIENT_ASSERTION, CLIENT_ASSERTION_TYPE, TOKEN_TYPE, REQ_CNF, OBO_ASSERTION, REQUESTED_TOKEN_USE, ON_BEHALF_OF, FOCI, CCS_HEADER, RETURN_SPA_CODE, NATIVE_BROKER, LOGOUT_HINT, SID, LOGIN_HINT, DOMAIN_HINT, X_CLIENT_EXTRA_SKU, BROKER_CLIENT_ID, BROKER_REDIRECT_URI, INSTANCE_AWARE, EAR_JWK, EAR_JWE_CRYPTO;
var init_AADServerParamKeys = __esm({
  "node_modules/@azure/msal-common/dist/constants/AADServerParamKeys.mjs"() {
    "use strict";
    CLIENT_ID = "client_id";
    REDIRECT_URI = "redirect_uri";
    RESPONSE_TYPE = "response_type";
    RESPONSE_MODE = "response_mode";
    GRANT_TYPE = "grant_type";
    CLAIMS = "claims";
    SCOPE = "scope";
    ERROR = "error";
    ERROR_DESCRIPTION = "error_description";
    ACCESS_TOKEN = "access_token";
    ID_TOKEN = "id_token";
    REFRESH_TOKEN = "refresh_token";
    EXPIRES_IN = "expires_in";
    REFRESH_TOKEN_EXPIRES_IN = "refresh_token_expires_in";
    STATE = "state";
    NONCE = "nonce";
    PROMPT = "prompt";
    SESSION_STATE = "session_state";
    CLIENT_INFO2 = "client_info";
    CODE = "code";
    CODE_CHALLENGE = "code_challenge";
    CODE_CHALLENGE_METHOD = "code_challenge_method";
    CODE_VERIFIER = "code_verifier";
    CLIENT_REQUEST_ID = "client-request-id";
    X_CLIENT_SKU = "x-client-SKU";
    X_CLIENT_VER = "x-client-VER";
    X_CLIENT_OS = "x-client-OS";
    X_CLIENT_CPU = "x-client-CPU";
    X_CLIENT_CURR_TELEM = "x-client-current-telemetry";
    X_CLIENT_LAST_TELEM = "x-client-last-telemetry";
    X_MS_LIB_CAPABILITY = "x-ms-lib-capability";
    X_APP_NAME = "x-app-name";
    X_APP_VER = "x-app-ver";
    POST_LOGOUT_URI = "post_logout_redirect_uri";
    ID_TOKEN_HINT = "id_token_hint";
    DEVICE_CODE = "device_code";
    CLIENT_SECRET = "client_secret";
    CLIENT_ASSERTION = "client_assertion";
    CLIENT_ASSERTION_TYPE = "client_assertion_type";
    TOKEN_TYPE = "token_type";
    REQ_CNF = "req_cnf";
    OBO_ASSERTION = "assertion";
    REQUESTED_TOKEN_USE = "requested_token_use";
    ON_BEHALF_OF = "on_behalf_of";
    FOCI = "foci";
    CCS_HEADER = "X-AnchorMailbox";
    RETURN_SPA_CODE = "return_spa_code";
    NATIVE_BROKER = "nativebroker";
    LOGOUT_HINT = "logout_hint";
    SID = "sid";
    LOGIN_HINT = "login_hint";
    DOMAIN_HINT = "domain_hint";
    X_CLIENT_EXTRA_SKU = "x-client-xtra-sku";
    BROKER_CLIENT_ID = "brk_client_id";
    BROKER_REDIRECT_URI = "brk_redirect_uri";
    INSTANCE_AWARE = "instance_aware";
    EAR_JWK = "ear_jwk";
    EAR_JWE_CRYPTO = "ear_jwe_crypto";
  }
});

// node_modules/@azure/msal-common/dist/request/RequestParameterBuilder.mjs
var RequestParameterBuilder_exports = {};
__export(RequestParameterBuilder_exports, {
  addApplicationTelemetry: () => addApplicationTelemetry,
  addAuthorizationCode: () => addAuthorizationCode,
  addBrokerParameters: () => addBrokerParameters,
  addCcsOid: () => addCcsOid,
  addCcsUpn: () => addCcsUpn,
  addClaims: () => addClaims,
  addClientAssertion: () => addClientAssertion,
  addClientAssertionType: () => addClientAssertionType,
  addClientCapabilitiesToClaims: () => addClientCapabilitiesToClaims,
  addClientId: () => addClientId,
  addClientInfo: () => addClientInfo,
  addClientSecret: () => addClientSecret,
  addCodeChallengeParams: () => addCodeChallengeParams,
  addCodeVerifier: () => addCodeVerifier,
  addCorrelationId: () => addCorrelationId,
  addDeviceCode: () => addDeviceCode,
  addDomainHint: () => addDomainHint,
  addEARParameters: () => addEARParameters,
  addExtraQueryParameters: () => addExtraQueryParameters,
  addGrantType: () => addGrantType,
  addIdTokenHint: () => addIdTokenHint,
  addInstanceAware: () => addInstanceAware,
  addLibraryInfo: () => addLibraryInfo,
  addLoginHint: () => addLoginHint,
  addLogoutHint: () => addLogoutHint,
  addNativeBroker: () => addNativeBroker,
  addNonce: () => addNonce,
  addOboAssertion: () => addOboAssertion,
  addPassword: () => addPassword,
  addPopToken: () => addPopToken,
  addPostBodyParameters: () => addPostBodyParameters,
  addPostLogoutRedirectUri: () => addPostLogoutRedirectUri,
  addPrompt: () => addPrompt,
  addRedirectUri: () => addRedirectUri,
  addRefreshToken: () => addRefreshToken,
  addRequestTokenUse: () => addRequestTokenUse,
  addResponseMode: () => addResponseMode,
  addResponseType: () => addResponseType,
  addScopes: () => addScopes,
  addServerTelemetry: () => addServerTelemetry,
  addSid: () => addSid,
  addSshJwk: () => addSshJwk,
  addState: () => addState,
  addThrottling: () => addThrottling,
  addUsername: () => addUsername,
  instrumentBrokerParams: () => instrumentBrokerParams
});
function instrumentBrokerParams(parameters, correlationId, performanceClient) {
  if (!correlationId) {
    return;
  }
  const clientId = parameters.get(CLIENT_ID);
  if (clientId && parameters.has(BROKER_CLIENT_ID)) {
    performanceClient == null ? void 0 : performanceClient.addFields({
      embeddedClientId: clientId,
      embeddedRedirectUri: parameters.get(REDIRECT_URI)
    }, correlationId);
  }
}
function addResponseType(parameters, responseType) {
  parameters.set(RESPONSE_TYPE, responseType);
}
function addResponseMode(parameters, responseMode) {
  parameters.set(RESPONSE_MODE, responseMode ? responseMode : ResponseMode.QUERY);
}
function addNativeBroker(parameters) {
  parameters.set(NATIVE_BROKER, "1");
}
function addScopes(parameters, scopes, addOidcScopes = true, defaultScopes = OIDC_DEFAULT_SCOPES) {
  if (addOidcScopes && !defaultScopes.includes("openid") && !scopes.includes("openid")) {
    defaultScopes.push("openid");
  }
  const requestScopes = addOidcScopes ? [...scopes || [], ...defaultScopes] : scopes || [];
  const scopeSet = new ScopeSet(requestScopes);
  parameters.set(SCOPE, scopeSet.printScopes());
}
function addClientId(parameters, clientId) {
  parameters.set(CLIENT_ID, clientId);
}
function addRedirectUri(parameters, redirectUri) {
  parameters.set(REDIRECT_URI, redirectUri);
}
function addPostLogoutRedirectUri(parameters, redirectUri) {
  parameters.set(POST_LOGOUT_URI, redirectUri);
}
function addIdTokenHint(parameters, idTokenHint) {
  parameters.set(ID_TOKEN_HINT, idTokenHint);
}
function addDomainHint(parameters, domainHint) {
  parameters.set(DOMAIN_HINT, domainHint);
}
function addLoginHint(parameters, loginHint) {
  parameters.set(LOGIN_HINT, loginHint);
}
function addCcsUpn(parameters, loginHint) {
  parameters.set(HeaderNames.CCS_HEADER, `UPN:${loginHint}`);
}
function addCcsOid(parameters, clientInfo) {
  parameters.set(HeaderNames.CCS_HEADER, `Oid:${clientInfo.uid}@${clientInfo.utid}`);
}
function addSid(parameters, sid) {
  parameters.set(SID, sid);
}
function addClaims(parameters, claims, clientCapabilities) {
  const mergedClaims = addClientCapabilitiesToClaims(claims, clientCapabilities);
  try {
    JSON.parse(mergedClaims);
  } catch (e) {
    throw createClientConfigurationError(invalidClaims);
  }
  parameters.set(CLAIMS, mergedClaims);
}
function addCorrelationId(parameters, correlationId) {
  parameters.set(CLIENT_REQUEST_ID, correlationId);
}
function addLibraryInfo(parameters, libraryInfo) {
  parameters.set(X_CLIENT_SKU, libraryInfo.sku);
  parameters.set(X_CLIENT_VER, libraryInfo.version);
  if (libraryInfo.os) {
    parameters.set(X_CLIENT_OS, libraryInfo.os);
  }
  if (libraryInfo.cpu) {
    parameters.set(X_CLIENT_CPU, libraryInfo.cpu);
  }
}
function addApplicationTelemetry(parameters, appTelemetry) {
  if (appTelemetry == null ? void 0 : appTelemetry.appName) {
    parameters.set(X_APP_NAME, appTelemetry.appName);
  }
  if (appTelemetry == null ? void 0 : appTelemetry.appVersion) {
    parameters.set(X_APP_VER, appTelemetry.appVersion);
  }
}
function addPrompt(parameters, prompt) {
  parameters.set(PROMPT, prompt);
}
function addState(parameters, state3) {
  if (state3) {
    parameters.set(STATE, state3);
  }
}
function addNonce(parameters, nonce) {
  parameters.set(NONCE, nonce);
}
function addCodeChallengeParams(parameters, codeChallenge, codeChallengeMethod) {
  if (codeChallenge && codeChallengeMethod) {
    parameters.set(CODE_CHALLENGE, codeChallenge);
    parameters.set(CODE_CHALLENGE_METHOD, codeChallengeMethod);
  } else {
    throw createClientConfigurationError(pkceParamsMissing);
  }
}
function addAuthorizationCode(parameters, code) {
  parameters.set(CODE, code);
}
function addDeviceCode(parameters, code) {
  parameters.set(DEVICE_CODE, code);
}
function addRefreshToken(parameters, refreshToken) {
  parameters.set(REFRESH_TOKEN, refreshToken);
}
function addCodeVerifier(parameters, codeVerifier) {
  parameters.set(CODE_VERIFIER, codeVerifier);
}
function addClientSecret(parameters, clientSecret) {
  parameters.set(CLIENT_SECRET, clientSecret);
}
function addClientAssertion(parameters, clientAssertion) {
  if (clientAssertion) {
    parameters.set(CLIENT_ASSERTION, clientAssertion);
  }
}
function addClientAssertionType(parameters, clientAssertionType) {
  if (clientAssertionType) {
    parameters.set(CLIENT_ASSERTION_TYPE, clientAssertionType);
  }
}
function addOboAssertion(parameters, oboAssertion) {
  parameters.set(OBO_ASSERTION, oboAssertion);
}
function addRequestTokenUse(parameters, tokenUse) {
  parameters.set(REQUESTED_TOKEN_USE, tokenUse);
}
function addGrantType(parameters, grantType) {
  parameters.set(GRANT_TYPE, grantType);
}
function addClientInfo(parameters) {
  parameters.set(CLIENT_INFO, "1");
}
function addInstanceAware(parameters) {
  if (!parameters.has(INSTANCE_AWARE)) {
    parameters.set(INSTANCE_AWARE, "true");
  }
}
function addExtraQueryParameters(parameters, eQParams) {
  Object.entries(eQParams).forEach(([key, value]) => {
    if (!parameters.has(key) && value) {
      parameters.set(key, value);
    }
  });
}
function addClientCapabilitiesToClaims(claims, clientCapabilities) {
  let mergedClaims;
  if (!claims) {
    mergedClaims = {};
  } else {
    try {
      mergedClaims = JSON.parse(claims);
    } catch (e) {
      throw createClientConfigurationError(invalidClaims);
    }
  }
  if (clientCapabilities && clientCapabilities.length > 0) {
    if (!mergedClaims.hasOwnProperty(ClaimsRequestKeys.ACCESS_TOKEN)) {
      mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN] = {};
    }
    mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN][ClaimsRequestKeys.XMS_CC] = {
      values: clientCapabilities
    };
  }
  return JSON.stringify(mergedClaims);
}
function addUsername(parameters, username) {
  parameters.set(PasswordGrantConstants.username, username);
}
function addPassword(parameters, password) {
  parameters.set(PasswordGrantConstants.password, password);
}
function addPopToken(parameters, cnfString) {
  if (cnfString) {
    parameters.set(TOKEN_TYPE, AuthenticationScheme.POP);
    parameters.set(REQ_CNF, cnfString);
  }
}
function addSshJwk(parameters, sshJwkString) {
  if (sshJwkString) {
    parameters.set(TOKEN_TYPE, AuthenticationScheme.SSH);
    parameters.set(REQ_CNF, sshJwkString);
  }
}
function addServerTelemetry(parameters, serverTelemetryManager) {
  parameters.set(X_CLIENT_CURR_TELEM, serverTelemetryManager.generateCurrentRequestHeaderValue());
  parameters.set(X_CLIENT_LAST_TELEM, serverTelemetryManager.generateLastRequestHeaderValue());
}
function addThrottling(parameters) {
  parameters.set(X_MS_LIB_CAPABILITY, ThrottlingConstants.X_MS_LIB_CAPABILITY_VALUE);
}
function addLogoutHint(parameters, logoutHint) {
  parameters.set(LOGOUT_HINT, logoutHint);
}
function addBrokerParameters(parameters, brokerClientId, brokerRedirectUri) {
  if (!parameters.has(BROKER_CLIENT_ID)) {
    parameters.set(BROKER_CLIENT_ID, brokerClientId);
  }
  if (!parameters.has(BROKER_REDIRECT_URI)) {
    parameters.set(BROKER_REDIRECT_URI, brokerRedirectUri);
  }
}
function addEARParameters(parameters, jwk) {
  parameters.set(EAR_JWK, encodeURIComponent(jwk));
  const jweCryptoB64Encoded = "eyJhbGciOiJkaXIiLCJlbmMiOiJBMjU2R0NNIn0";
  parameters.set(EAR_JWE_CRYPTO, jweCryptoB64Encoded);
}
function addPostBodyParameters(parameters, bodyParameters) {
  Object.entries(bodyParameters).forEach(([key, value]) => {
    if (value) {
      parameters.set(key, value);
    }
  });
}
var init_RequestParameterBuilder = __esm({
  "node_modules/@azure/msal-common/dist/request/RequestParameterBuilder.mjs"() {
    "use strict";
    init_Constants();
    init_AADServerParamKeys();
    init_ScopeSet();
    init_ClientConfigurationError();
    init_ClientConfigurationErrorCodes();
  }
});

// node_modules/@azure/msal-common/dist/authority/OpenIdConfigResponse.mjs
function isOpenIdConfigResponse(response) {
  return response.hasOwnProperty("authorization_endpoint") && response.hasOwnProperty("token_endpoint") && response.hasOwnProperty("issuer") && response.hasOwnProperty("jwks_uri");
}
var init_OpenIdConfigResponse = __esm({
  "node_modules/@azure/msal-common/dist/authority/OpenIdConfigResponse.mjs"() {
    "use strict";
  }
});

// node_modules/@azure/msal-common/dist/authority/CloudInstanceDiscoveryResponse.mjs
function isCloudInstanceDiscoveryResponse(response) {
  return response.hasOwnProperty("tenant_discovery_endpoint") && response.hasOwnProperty("metadata");
}
var init_CloudInstanceDiscoveryResponse = __esm({
  "node_modules/@azure/msal-common/dist/authority/CloudInstanceDiscoveryResponse.mjs"() {
    "use strict";
  }
});

// node_modules/@azure/msal-common/dist/authority/CloudInstanceDiscoveryErrorResponse.mjs
function isCloudInstanceDiscoveryErrorResponse(response) {
  return response.hasOwnProperty("error") && response.hasOwnProperty("error_description");
}
var init_CloudInstanceDiscoveryErrorResponse = __esm({
  "node_modules/@azure/msal-common/dist/authority/CloudInstanceDiscoveryErrorResponse.mjs"() {
    "use strict";
  }
});

// node_modules/@azure/msal-common/dist/utils/FunctionWrappers.mjs
var invoke, invokeAsync;
var init_FunctionWrappers = __esm({
  "node_modules/@azure/msal-common/dist/utils/FunctionWrappers.mjs"() {
    "use strict";
    invoke = (callback, eventName, logger24, telemetryClient, correlationId) => {
      return (...args) => {
        logger24.trace(`Executing function ${eventName}`);
        const inProgressEvent = telemetryClient == null ? void 0 : telemetryClient.startMeasurement(eventName, correlationId);
        if (correlationId) {
          const eventCount = eventName + "CallCount";
          telemetryClient == null ? void 0 : telemetryClient.incrementFields({ [eventCount]: 1 }, correlationId);
        }
        try {
          const result = callback(...args);
          inProgressEvent == null ? void 0 : inProgressEvent.end({
            success: true
          });
          logger24.trace(`Returning result from ${eventName}`);
          return result;
        } catch (e) {
          logger24.trace(`Error occurred in ${eventName}`);
          try {
            logger24.trace(JSON.stringify(e));
          } catch (e2) {
            logger24.trace("Unable to print error message.");
          }
          inProgressEvent == null ? void 0 : inProgressEvent.end({
            success: false
          }, e);
          throw e;
        }
      };
    };
    invokeAsync = (callback, eventName, logger24, telemetryClient, correlationId) => {
      return (...args) => {
        logger24.trace(`Executing function ${eventName}`);
        const inProgressEvent = telemetryClient == null ? void 0 : telemetryClient.startMeasurement(eventName, correlationId);
        if (correlationId) {
          const eventCount = eventName + "CallCount";
          telemetryClient == null ? void 0 : telemetryClient.incrementFields({ [eventCount]: 1 }, correlationId);
        }
        telemetryClient == null ? void 0 : telemetryClient.setPreQueueTime(eventName, correlationId);
        return callback(...args).then((response) => {
          logger24.trace(`Returning result from ${eventName}`);
          inProgressEvent == null ? void 0 : inProgressEvent.end({
            success: true
          });
          return response;
        }).catch((e) => {
          logger24.trace(`Error occurred in ${eventName}`);
          try {
            logger24.trace(JSON.stringify(e));
          } catch (e2) {
            logger24.trace("Unable to print error message.");
          }
          inProgressEvent == null ? void 0 : inProgressEvent.end({
            success: false
          }, e);
          throw e;
        });
      };
    };
  }
});

// node_modules/@azure/msal-common/dist/authority/RegionDiscovery.mjs
var RegionDiscovery;
var init_RegionDiscovery = __esm({
  "node_modules/@azure/msal-common/dist/authority/RegionDiscovery.mjs"() {
    "use strict";
    init_Constants();
    init_PerformanceEvent();
    init_FunctionWrappers();
    RegionDiscovery = class _RegionDiscovery {
      constructor(networkInterface, logger24, performanceClient, correlationId) {
        this.networkInterface = networkInterface;
        this.logger = logger24;
        this.performanceClient = performanceClient;
        this.correlationId = correlationId;
      }
      /**
       * Detect the region from the application's environment.
       *
       * @returns Promise<string | null>
       */
      async detectRegion(environmentRegion, regionDiscoveryMetadata) {
        var _a3;
        (_a3 = this.performanceClient) == null ? void 0 : _a3.addQueueMeasurement(PerformanceEvents.RegionDiscoveryDetectRegion, this.correlationId);
        let autodetectedRegionName = environmentRegion;
        if (!autodetectedRegionName) {
          const options = _RegionDiscovery.IMDS_OPTIONS;
          try {
            const localIMDSVersionResponse = await invokeAsync(this.getRegionFromIMDS.bind(this), PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.logger, this.performanceClient, this.correlationId)(Constants.IMDS_VERSION, options);
            if (localIMDSVersionResponse.status === HttpStatus.SUCCESS) {
              autodetectedRegionName = localIMDSVersionResponse.body;
              regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;
            }
            if (localIMDSVersionResponse.status === HttpStatus.BAD_REQUEST) {
              const currentIMDSVersion = await invokeAsync(this.getCurrentVersion.bind(this), PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.logger, this.performanceClient, this.correlationId)(options);
              if (!currentIMDSVersion) {
                regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
                return null;
              }
              const currentIMDSVersionResponse = await invokeAsync(this.getRegionFromIMDS.bind(this), PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.logger, this.performanceClient, this.correlationId)(currentIMDSVersion, options);
              if (currentIMDSVersionResponse.status === HttpStatus.SUCCESS) {
                autodetectedRegionName = currentIMDSVersionResponse.body;
                regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;
              }
            }
          } catch (e) {
            regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
            return null;
          }
        } else {
          regionDiscoveryMetadata.region_source = RegionDiscoverySources.ENVIRONMENT_VARIABLE;
        }
        if (!autodetectedRegionName) {
          regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
        }
        return autodetectedRegionName || null;
      }
      /**
       * Make the call to the IMDS endpoint
       *
       * @param imdsEndpointUrl
       * @returns Promise<NetworkResponse<string>>
       */
      async getRegionFromIMDS(version3, options) {
        var _a3;
        (_a3 = this.performanceClient) == null ? void 0 : _a3.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId);
        return this.networkInterface.sendGetRequestAsync(`${Constants.IMDS_ENDPOINT}?api-version=${version3}&format=text`, options, Constants.IMDS_TIMEOUT);
      }
      /**
       * Get the most recent version of the IMDS endpoint available
       *
       * @returns Promise<string | null>
       */
      async getCurrentVersion(options) {
        var _a3;
        (_a3 = this.performanceClient) == null ? void 0 : _a3.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.correlationId);
        try {
          const response = await this.networkInterface.sendGetRequestAsync(`${Constants.IMDS_ENDPOINT}?format=json`, options);
          if (response.status === HttpStatus.BAD_REQUEST && response.body && response.body["newest-versions"] && response.body["newest-versions"].length > 0) {
            return response.body["newest-versions"][0];
          }
          return null;
        } catch (e) {
          return null;
        }
      }
    };
    RegionDiscovery.IMDS_OPTIONS = {
      headers: {
        Metadata: "true"
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/authority/Authority.mjs
function getTenantFromAuthorityString(authority) {
  var _a3;
  const authorityUrl = new UrlString(authority);
  const authorityUrlComponents = authorityUrl.getUrlComponents();
  const tenantId = (_a3 = authorityUrlComponents.PathSegments.slice(-1)[0]) == null ? void 0 : _a3.toLowerCase();
  switch (tenantId) {
    case AADAuthorityConstants.COMMON:
    case AADAuthorityConstants.ORGANIZATIONS:
    case AADAuthorityConstants.CONSUMERS:
      return void 0;
    default:
      return tenantId;
  }
}
function formatAuthorityUri(authorityUri) {
  return authorityUri.endsWith(Constants.FORWARD_SLASH) ? authorityUri : `${authorityUri}${Constants.FORWARD_SLASH}`;
}
function buildStaticAuthorityOptions(authOptions) {
  const rawCloudDiscoveryMetadata = authOptions.cloudDiscoveryMetadata;
  let cloudDiscoveryMetadata = void 0;
  if (rawCloudDiscoveryMetadata) {
    try {
      cloudDiscoveryMetadata = JSON.parse(rawCloudDiscoveryMetadata);
    } catch (e) {
      throw createClientConfigurationError(invalidCloudDiscoveryMetadata);
    }
  }
  return {
    canonicalAuthority: authOptions.authority ? formatAuthorityUri(authOptions.authority) : void 0,
    knownAuthorities: authOptions.knownAuthorities,
    cloudDiscoveryMetadata
  };
}
var Authority;
var init_Authority = __esm({
  "node_modules/@azure/msal-common/dist/authority/Authority.mjs"() {
    "use strict";
    init_AuthorityType();
    init_OpenIdConfigResponse();
    init_UrlString();
    init_ClientAuthError();
    init_Constants();
    init_AuthorityMetadata();
    init_ClientConfigurationError();
    init_ProtocolMode();
    init_AuthorityOptions();
    init_CloudInstanceDiscoveryResponse();
    init_CloudInstanceDiscoveryErrorResponse();
    init_RegionDiscovery();
    init_AuthError();
    init_PerformanceEvent();
    init_FunctionWrappers();
    init_CacheHelpers();
    init_ClientAuthErrorCodes();
    init_ClientConfigurationErrorCodes();
    Authority = class _Authority {
      constructor(authority, networkInterface, cacheManager, authorityOptions, logger24, correlationId, performanceClient, managedIdentity) {
        this.canonicalAuthority = authority;
        this._canonicalAuthority.validateAsUri();
        this.networkInterface = networkInterface;
        this.cacheManager = cacheManager;
        this.authorityOptions = authorityOptions;
        this.regionDiscoveryMetadata = {
          region_used: void 0,
          region_source: void 0,
          region_outcome: void 0
        };
        this.logger = logger24;
        this.performanceClient = performanceClient;
        this.correlationId = correlationId;
        this.managedIdentity = managedIdentity || false;
        this.regionDiscovery = new RegionDiscovery(networkInterface, this.logger, this.performanceClient, this.correlationId);
      }
      /**
       * Get {@link AuthorityType}
       * @param authorityUri {@link IUri}
       * @private
       */
      getAuthorityType(authorityUri) {
        if (authorityUri.HostNameAndPort.endsWith(Constants.CIAM_AUTH_URL)) {
          return AuthorityType.Ciam;
        }
        const pathSegments = authorityUri.PathSegments;
        if (pathSegments.length) {
          switch (pathSegments[0].toLowerCase()) {
            case Constants.ADFS:
              return AuthorityType.Adfs;
            case Constants.DSTS:
              return AuthorityType.Dsts;
          }
        }
        return AuthorityType.Default;
      }
      // See above for AuthorityType
      get authorityType() {
        return this.getAuthorityType(this.canonicalAuthorityUrlComponents);
      }
      /**
       * ProtocolMode enum representing the way endpoints are constructed.
       */
      get protocolMode() {
        return this.authorityOptions.protocolMode;
      }
      /**
       * Returns authorityOptions which can be used to reinstantiate a new authority instance
       */
      get options() {
        return this.authorityOptions;
      }
      /**
       * A URL that is the authority set by the developer
       */
      get canonicalAuthority() {
        return this._canonicalAuthority.urlString;
      }
      /**
       * Sets canonical authority.
       */
      set canonicalAuthority(url) {
        this._canonicalAuthority = new UrlString(url);
        this._canonicalAuthority.validateAsUri();
        this._canonicalAuthorityUrlComponents = null;
      }
      /**
       * Get authority components.
       */
      get canonicalAuthorityUrlComponents() {
        if (!this._canonicalAuthorityUrlComponents) {
          this._canonicalAuthorityUrlComponents = this._canonicalAuthority.getUrlComponents();
        }
        return this._canonicalAuthorityUrlComponents;
      }
      /**
       * Get hostname and port i.e. login.microsoftonline.com
       */
      get hostnameAndPort() {
        return this.canonicalAuthorityUrlComponents.HostNameAndPort.toLowerCase();
      }
      /**
       * Get tenant for authority.
       */
      get tenant() {
        return this.canonicalAuthorityUrlComponents.PathSegments[0];
      }
      /**
       * OAuth /authorize endpoint for requests
       */
      get authorizationEndpoint() {
        if (this.discoveryComplete()) {
          return this.replacePath(this.metadata.authorization_endpoint);
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * OAuth /token endpoint for requests
       */
      get tokenEndpoint() {
        if (this.discoveryComplete()) {
          return this.replacePath(this.metadata.token_endpoint);
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      get deviceCodeEndpoint() {
        if (this.discoveryComplete()) {
          return this.replacePath(this.metadata.token_endpoint.replace("/token", "/devicecode"));
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * OAuth logout endpoint for requests
       */
      get endSessionEndpoint() {
        if (this.discoveryComplete()) {
          if (!this.metadata.end_session_endpoint) {
            throw createClientAuthError(endSessionEndpointNotSupported);
          }
          return this.replacePath(this.metadata.end_session_endpoint);
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * OAuth issuer for requests
       */
      get selfSignedJwtAudience() {
        if (this.discoveryComplete()) {
          return this.replacePath(this.metadata.issuer);
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * Jwks_uri for token signing keys
       */
      get jwksUri() {
        if (this.discoveryComplete()) {
          return this.replacePath(this.metadata.jwks_uri);
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * Returns a flag indicating that tenant name can be replaced in authority {@link IUri}
       * @param authorityUri {@link IUri}
       * @private
       */
      canReplaceTenant(authorityUri) {
        return authorityUri.PathSegments.length === 1 && !_Authority.reservedTenantDomains.has(authorityUri.PathSegments[0]) && this.getAuthorityType(authorityUri) === AuthorityType.Default && this.protocolMode !== ProtocolMode.OIDC;
      }
      /**
       * Replaces tenant in url path with current tenant. Defaults to common.
       * @param urlString
       */
      replaceTenant(urlString) {
        return urlString.replace(/{tenant}|{tenantid}/g, this.tenant);
      }
      /**
       * Replaces path such as tenant or policy with the current tenant or policy.
       * @param urlString
       */
      replacePath(urlString) {
        let endpoint = urlString;
        const cachedAuthorityUrl = new UrlString(this.metadata.canonical_authority);
        const cachedAuthorityUrlComponents = cachedAuthorityUrl.getUrlComponents();
        const cachedAuthorityParts = cachedAuthorityUrlComponents.PathSegments;
        const currentAuthorityParts = this.canonicalAuthorityUrlComponents.PathSegments;
        currentAuthorityParts.forEach((currentPart, index) => {
          let cachedPart = cachedAuthorityParts[index];
          if (index === 0 && this.canReplaceTenant(cachedAuthorityUrlComponents)) {
            const tenantId = new UrlString(this.metadata.authorization_endpoint).getUrlComponents().PathSegments[0];
            if (cachedPart !== tenantId) {
              this.logger.verbose(`Replacing tenant domain name ${cachedPart} with id ${tenantId}`);
              cachedPart = tenantId;
            }
          }
          if (currentPart !== cachedPart) {
            endpoint = endpoint.replace(`/${cachedPart}/`, `/${currentPart}/`);
          }
        });
        return this.replaceTenant(endpoint);
      }
      /**
       * The default open id configuration endpoint for any canonical authority.
       */
      get defaultOpenIdConfigurationEndpoint() {
        const canonicalAuthorityHost = this.hostnameAndPort;
        if (this.canonicalAuthority.endsWith("v2.0/") || this.authorityType === AuthorityType.Adfs || this.protocolMode === ProtocolMode.OIDC && !this.isAliasOfKnownMicrosoftAuthority(canonicalAuthorityHost)) {
          return `${this.canonicalAuthority}.well-known/openid-configuration`;
        }
        return `${this.canonicalAuthority}v2.0/.well-known/openid-configuration`;
      }
      /**
       * Boolean that returns whether or not tenant discovery has been completed.
       */
      discoveryComplete() {
        return !!this.metadata;
      }
      /**
       * Perform endpoint discovery to discover aliases, preferred_cache, preferred_network
       * and the /authorize, /token and logout endpoints.
       */
      async resolveEndpointsAsync() {
        var _a3, _b2;
        (_a3 = this.performanceClient) == null ? void 0 : _a3.addQueueMeasurement(PerformanceEvents.AuthorityResolveEndpointsAsync, this.correlationId);
        const metadataEntity = this.getCurrentMetadataEntity();
        const cloudDiscoverySource = await invokeAsync(this.updateCloudDiscoveryMetadata.bind(this), PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata, this.logger, this.performanceClient, this.correlationId)(metadataEntity);
        this.canonicalAuthority = this.canonicalAuthority.replace(this.hostnameAndPort, metadataEntity.preferred_network);
        const endpointSource = await invokeAsync(this.updateEndpointMetadata.bind(this), PerformanceEvents.AuthorityUpdateEndpointMetadata, this.logger, this.performanceClient, this.correlationId)(metadataEntity);
        this.updateCachedMetadata(metadataEntity, cloudDiscoverySource, {
          source: endpointSource
        });
        (_b2 = this.performanceClient) == null ? void 0 : _b2.addFields({
          cloudDiscoverySource,
          authorityEndpointSource: endpointSource
        }, this.correlationId);
      }
      /**
       * Returns metadata entity from cache if it exists, otherwiser returns a new metadata entity built
       * from the configured canonical authority
       * @returns
       */
      getCurrentMetadataEntity() {
        let metadataEntity = this.cacheManager.getAuthorityMetadataByAlias(this.hostnameAndPort);
        if (!metadataEntity) {
          metadataEntity = {
            aliases: [],
            preferred_cache: this.hostnameAndPort,
            preferred_network: this.hostnameAndPort,
            canonical_authority: this.canonicalAuthority,
            authorization_endpoint: "",
            token_endpoint: "",
            end_session_endpoint: "",
            issuer: "",
            aliasesFromNetwork: false,
            endpointsFromNetwork: false,
            expiresAt: generateAuthorityMetadataExpiresAt(),
            jwks_uri: ""
          };
        }
        return metadataEntity;
      }
      /**
       * Updates cached metadata based on metadata source and sets the instance's metadata
       * property to the same value
       * @param metadataEntity
       * @param cloudDiscoverySource
       * @param endpointMetadataResult
       */
      updateCachedMetadata(metadataEntity, cloudDiscoverySource, endpointMetadataResult) {
        if (cloudDiscoverySource !== AuthorityMetadataSource.CACHE && (endpointMetadataResult == null ? void 0 : endpointMetadataResult.source) !== AuthorityMetadataSource.CACHE) {
          metadataEntity.expiresAt = generateAuthorityMetadataExpiresAt();
          metadataEntity.canonical_authority = this.canonicalAuthority;
        }
        const cacheKey = this.cacheManager.generateAuthorityMetadataCacheKey(metadataEntity.preferred_cache);
        this.cacheManager.setAuthorityMetadata(cacheKey, metadataEntity);
        this.metadata = metadataEntity;
      }
      /**
       * Update AuthorityMetadataEntity with new endpoints and return where the information came from
       * @param metadataEntity
       */
      async updateEndpointMetadata(metadataEntity) {
        var _a3, _b2, _c2;
        (_a3 = this.performanceClient) == null ? void 0 : _a3.addQueueMeasurement(PerformanceEvents.AuthorityUpdateEndpointMetadata, this.correlationId);
        const localMetadata = this.updateEndpointMetadataFromLocalSources(metadataEntity);
        if (localMetadata) {
          if (localMetadata.source === AuthorityMetadataSource.HARDCODED_VALUES) {
            if ((_b2 = this.authorityOptions.azureRegionConfiguration) == null ? void 0 : _b2.azureRegion) {
              if (localMetadata.metadata) {
                const hardcodedMetadata = await invokeAsync(this.updateMetadataWithRegionalInformation.bind(this), PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.logger, this.performanceClient, this.correlationId)(localMetadata.metadata);
                updateAuthorityEndpointMetadata(metadataEntity, hardcodedMetadata, false);
                metadataEntity.canonical_authority = this.canonicalAuthority;
              }
            }
          }
          return localMetadata.source;
        }
        let metadata = await invokeAsync(this.getEndpointMetadataFromNetwork.bind(this), PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork, this.logger, this.performanceClient, this.correlationId)();
        if (metadata) {
          if ((_c2 = this.authorityOptions.azureRegionConfiguration) == null ? void 0 : _c2.azureRegion) {
            metadata = await invokeAsync(this.updateMetadataWithRegionalInformation.bind(this), PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.logger, this.performanceClient, this.correlationId)(metadata);
          }
          updateAuthorityEndpointMetadata(metadataEntity, metadata, true);
          return AuthorityMetadataSource.NETWORK;
        } else {
          throw createClientAuthError(openIdConfigError, this.defaultOpenIdConfigurationEndpoint);
        }
      }
      /**
       * Updates endpoint metadata from local sources and returns where the information was retrieved from and the metadata config
       * response if the source is hardcoded metadata
       * @param metadataEntity
       * @returns
       */
      updateEndpointMetadataFromLocalSources(metadataEntity) {
        this.logger.verbose("Attempting to get endpoint metadata from authority configuration");
        const configMetadata = this.getEndpointMetadataFromConfig();
        if (configMetadata) {
          this.logger.verbose("Found endpoint metadata in authority configuration");
          updateAuthorityEndpointMetadata(metadataEntity, configMetadata, false);
          return {
            source: AuthorityMetadataSource.CONFIG
          };
        }
        this.logger.verbose("Did not find endpoint metadata in the config... Attempting to get endpoint metadata from the hardcoded values.");
        if (this.authorityOptions.skipAuthorityMetadataCache) {
          this.logger.verbose("Skipping hardcoded metadata cache since skipAuthorityMetadataCache is set to true. Attempting to get endpoint metadata from the network metadata cache.");
        } else {
          const hardcodedMetadata = this.getEndpointMetadataFromHardcodedValues();
          if (hardcodedMetadata) {
            updateAuthorityEndpointMetadata(metadataEntity, hardcodedMetadata, false);
            return {
              source: AuthorityMetadataSource.HARDCODED_VALUES,
              metadata: hardcodedMetadata
            };
          } else {
            this.logger.verbose("Did not find endpoint metadata in hardcoded values... Attempting to get endpoint metadata from the network metadata cache.");
          }
        }
        const metadataEntityExpired = isAuthorityMetadataExpired(metadataEntity);
        if (this.isAuthoritySameType(metadataEntity) && metadataEntity.endpointsFromNetwork && !metadataEntityExpired) {
          this.logger.verbose("Found endpoint metadata in the cache.");
          return { source: AuthorityMetadataSource.CACHE };
        } else if (metadataEntityExpired) {
          this.logger.verbose("The metadata entity is expired.");
        }
        return null;
      }
      /**
       * Compares the number of url components after the domain to determine if the cached
       * authority metadata can be used for the requested authority. Protects against same domain different
       * authority such as login.microsoftonline.com/tenant and login.microsoftonline.com/tfp/tenant/policy
       * @param metadataEntity
       */
      isAuthoritySameType(metadataEntity) {
        const cachedAuthorityUrl = new UrlString(metadataEntity.canonical_authority);
        const cachedParts = cachedAuthorityUrl.getUrlComponents().PathSegments;
        return cachedParts.length === this.canonicalAuthorityUrlComponents.PathSegments.length;
      }
      /**
       * Parse authorityMetadata config option
       */
      getEndpointMetadataFromConfig() {
        if (this.authorityOptions.authorityMetadata) {
          try {
            return JSON.parse(this.authorityOptions.authorityMetadata);
          } catch (e) {
            throw createClientConfigurationError(invalidAuthorityMetadata);
          }
        }
        return null;
      }
      /**
       * Gets OAuth endpoints from the given OpenID configuration endpoint.
       *
       * @param hasHardcodedMetadata boolean
       */
      async getEndpointMetadataFromNetwork() {
        var _a3;
        (_a3 = this.performanceClient) == null ? void 0 : _a3.addQueueMeasurement(PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork, this.correlationId);
        const options = {};
        const openIdConfigurationEndpoint = this.defaultOpenIdConfigurationEndpoint;
        this.logger.verbose(`Authority.getEndpointMetadataFromNetwork: attempting to retrieve OAuth endpoints from ${openIdConfigurationEndpoint}`);
        try {
          const response = await this.networkInterface.sendGetRequestAsync(openIdConfigurationEndpoint, options);
          const isValidResponse = isOpenIdConfigResponse(response.body);
          if (isValidResponse) {
            return response.body;
          } else {
            this.logger.verbose(`Authority.getEndpointMetadataFromNetwork: could not parse response as OpenID configuration`);
            return null;
          }
        } catch (e) {
          this.logger.verbose(`Authority.getEndpointMetadataFromNetwork: ${e}`);
          return null;
        }
      }
      /**
       * Get OAuth endpoints for common authorities.
       */
      getEndpointMetadataFromHardcodedValues() {
        if (this.hostnameAndPort in EndpointMetadata) {
          return EndpointMetadata[this.hostnameAndPort];
        }
        return null;
      }
      /**
       * Update the retrieved metadata with regional information.
       * User selected Azure region will be used if configured.
       */
      async updateMetadataWithRegionalInformation(metadata) {
        var _a3, _b2, _c2;
        (_a3 = this.performanceClient) == null ? void 0 : _a3.addQueueMeasurement(PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.correlationId);
        const userConfiguredAzureRegion = (_b2 = this.authorityOptions.azureRegionConfiguration) == null ? void 0 : _b2.azureRegion;
        if (userConfiguredAzureRegion) {
          if (userConfiguredAzureRegion !== Constants.AZURE_REGION_AUTO_DISCOVER_FLAG) {
            this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.CONFIGURED_NO_AUTO_DETECTION;
            this.regionDiscoveryMetadata.region_used = userConfiguredAzureRegion;
            return _Authority.replaceWithRegionalInformation(metadata, userConfiguredAzureRegion);
          }
          const autodetectedRegionName = await invokeAsync(this.regionDiscovery.detectRegion.bind(this.regionDiscovery), PerformanceEvents.RegionDiscoveryDetectRegion, this.logger, this.performanceClient, this.correlationId)((_c2 = this.authorityOptions.azureRegionConfiguration) == null ? void 0 : _c2.environmentRegion, this.regionDiscoveryMetadata);
          if (autodetectedRegionName) {
            this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_SUCCESSFUL;
            this.regionDiscoveryMetadata.region_used = autodetectedRegionName;
            return _Authority.replaceWithRegionalInformation(metadata, autodetectedRegionName);
          }
          this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_FAILED;
        }
        return metadata;
      }
      /**
       * Updates the AuthorityMetadataEntity with new aliases, preferred_network and preferred_cache
       * and returns where the information was retrieved from
       * @param metadataEntity
       * @returns AuthorityMetadataSource
       */
      async updateCloudDiscoveryMetadata(metadataEntity) {
        var _a3;
        (_a3 = this.performanceClient) == null ? void 0 : _a3.addQueueMeasurement(PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata, this.correlationId);
        const localMetadataSource = this.updateCloudDiscoveryMetadataFromLocalSources(metadataEntity);
        if (localMetadataSource) {
          return localMetadataSource;
        }
        const metadata = await invokeAsync(this.getCloudDiscoveryMetadataFromNetwork.bind(this), PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork, this.logger, this.performanceClient, this.correlationId)();
        if (metadata) {
          updateCloudDiscoveryMetadata(metadataEntity, metadata, true);
          return AuthorityMetadataSource.NETWORK;
        }
        throw createClientConfigurationError(untrustedAuthority);
      }
      updateCloudDiscoveryMetadataFromLocalSources(metadataEntity) {
        this.logger.verbose("Attempting to get cloud discovery metadata  from authority configuration");
        this.logger.verbosePii(`Known Authorities: ${this.authorityOptions.knownAuthorities || Constants.NOT_APPLICABLE}`);
        this.logger.verbosePii(`Authority Metadata: ${this.authorityOptions.authorityMetadata || Constants.NOT_APPLICABLE}`);
        this.logger.verbosePii(`Canonical Authority: ${metadataEntity.canonical_authority || Constants.NOT_APPLICABLE}`);
        const metadata = this.getCloudDiscoveryMetadataFromConfig();
        if (metadata) {
          this.logger.verbose("Found cloud discovery metadata in authority configuration");
          updateCloudDiscoveryMetadata(metadataEntity, metadata, false);
          return AuthorityMetadataSource.CONFIG;
        }
        this.logger.verbose("Did not find cloud discovery metadata in the config... Attempting to get cloud discovery metadata from the hardcoded values.");
        if (this.options.skipAuthorityMetadataCache) {
          this.logger.verbose("Skipping hardcoded cloud discovery metadata cache since skipAuthorityMetadataCache is set to true. Attempting to get cloud discovery metadata from the network metadata cache.");
        } else {
          const hardcodedMetadata = getCloudDiscoveryMetadataFromHardcodedValues(this.hostnameAndPort);
          if (hardcodedMetadata) {
            this.logger.verbose("Found cloud discovery metadata from hardcoded values.");
            updateCloudDiscoveryMetadata(metadataEntity, hardcodedMetadata, false);
            return AuthorityMetadataSource.HARDCODED_VALUES;
          }
          this.logger.verbose("Did not find cloud discovery metadata in hardcoded values... Attempting to get cloud discovery metadata from the network metadata cache.");
        }
        const metadataEntityExpired = isAuthorityMetadataExpired(metadataEntity);
        if (this.isAuthoritySameType(metadataEntity) && metadataEntity.aliasesFromNetwork && !metadataEntityExpired) {
          this.logger.verbose("Found cloud discovery metadata in the cache.");
          return AuthorityMetadataSource.CACHE;
        } else if (metadataEntityExpired) {
          this.logger.verbose("The metadata entity is expired.");
        }
        return null;
      }
      /**
       * Parse cloudDiscoveryMetadata config or check knownAuthorities
       */
      getCloudDiscoveryMetadataFromConfig() {
        if (this.authorityType === AuthorityType.Ciam) {
          this.logger.verbose("CIAM authorities do not support cloud discovery metadata, generate the aliases from authority host.");
          return _Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
        }
        if (this.authorityOptions.cloudDiscoveryMetadata) {
          this.logger.verbose("The cloud discovery metadata has been provided as a network response, in the config.");
          try {
            this.logger.verbose("Attempting to parse the cloud discovery metadata.");
            const parsedResponse = JSON.parse(this.authorityOptions.cloudDiscoveryMetadata);
            const metadata = getCloudDiscoveryMetadataFromNetworkResponse(parsedResponse.metadata, this.hostnameAndPort);
            this.logger.verbose("Parsed the cloud discovery metadata.");
            if (metadata) {
              this.logger.verbose("There is returnable metadata attached to the parsed cloud discovery metadata.");
              return metadata;
            } else {
              this.logger.verbose("There is no metadata attached to the parsed cloud discovery metadata.");
            }
          } catch (e) {
            this.logger.verbose("Unable to parse the cloud discovery metadata. Throwing Invalid Cloud Discovery Metadata Error.");
            throw createClientConfigurationError(invalidCloudDiscoveryMetadata);
          }
        }
        if (this.isInKnownAuthorities()) {
          this.logger.verbose("The host is included in knownAuthorities. Creating new cloud discovery metadata from the host.");
          return _Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
        }
        return null;
      }
      /**
       * Called to get metadata from network if CloudDiscoveryMetadata was not populated by config
       *
       * @param hasHardcodedMetadata boolean
       */
      async getCloudDiscoveryMetadataFromNetwork() {
        var _a3;
        (_a3 = this.performanceClient) == null ? void 0 : _a3.addQueueMeasurement(PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork, this.correlationId);
        const instanceDiscoveryEndpoint = `${Constants.AAD_INSTANCE_DISCOVERY_ENDPT}${this.canonicalAuthority}oauth2/v2.0/authorize`;
        const options = {};
        let match = null;
        try {
          const response = await this.networkInterface.sendGetRequestAsync(instanceDiscoveryEndpoint, options);
          let typedResponseBody;
          let metadata;
          if (isCloudInstanceDiscoveryResponse(response.body)) {
            typedResponseBody = response.body;
            metadata = typedResponseBody.metadata;
            this.logger.verbosePii(`tenant_discovery_endpoint is: ${typedResponseBody.tenant_discovery_endpoint}`);
          } else if (isCloudInstanceDiscoveryErrorResponse(response.body)) {
            this.logger.warning(`A CloudInstanceDiscoveryErrorResponse was returned. The cloud instance discovery network request's status code is: ${response.status}`);
            typedResponseBody = response.body;
            if (typedResponseBody.error === Constants.INVALID_INSTANCE) {
              this.logger.error("The CloudInstanceDiscoveryErrorResponse error is invalid_instance.");
              return null;
            }
            this.logger.warning(`The CloudInstanceDiscoveryErrorResponse error is ${typedResponseBody.error}`);
            this.logger.warning(`The CloudInstanceDiscoveryErrorResponse error description is ${typedResponseBody.error_description}`);
            this.logger.warning("Setting the value of the CloudInstanceDiscoveryMetadata (returned from the network) to []");
            metadata = [];
          } else {
            this.logger.error("AAD did not return a CloudInstanceDiscoveryResponse or CloudInstanceDiscoveryErrorResponse");
            return null;
          }
          this.logger.verbose("Attempting to find a match between the developer's authority and the CloudInstanceDiscoveryMetadata returned from the network request.");
          match = getCloudDiscoveryMetadataFromNetworkResponse(metadata, this.hostnameAndPort);
        } catch (error) {
          if (error instanceof AuthError) {
            this.logger.error(`There was a network error while attempting to get the cloud discovery instance metadata.
Error: ${error.errorCode}
Error Description: ${error.errorMessage}`);
          } else {
            const typedError = error;
            this.logger.error(`A non-MSALJS error was thrown while attempting to get the cloud instance discovery metadata.
Error: ${typedError.name}
Error Description: ${typedError.message}`);
          }
          return null;
        }
        if (!match) {
          this.logger.warning("The developer's authority was not found within the CloudInstanceDiscoveryMetadata returned from the network request.");
          this.logger.verbose("Creating custom Authority for custom domain scenario.");
          match = _Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
        }
        return match;
      }
      /**
       * Helper function to determine if this host is included in the knownAuthorities config option
       */
      isInKnownAuthorities() {
        const matches = this.authorityOptions.knownAuthorities.filter((authority) => {
          return authority && UrlString.getDomainFromUrl(authority).toLowerCase() === this.hostnameAndPort;
        });
        return matches.length > 0;
      }
      /**
       * helper function to populate the authority based on azureCloudOptions
       * @param authorityString
       * @param azureCloudOptions
       */
      static generateAuthority(authorityString, azureCloudOptions) {
        let authorityAzureCloudInstance;
        if (azureCloudOptions && azureCloudOptions.azureCloudInstance !== AzureCloudInstance.None) {
          const tenant = azureCloudOptions.tenant ? azureCloudOptions.tenant : Constants.DEFAULT_COMMON_TENANT;
          authorityAzureCloudInstance = `${azureCloudOptions.azureCloudInstance}/${tenant}/`;
        }
        return authorityAzureCloudInstance ? authorityAzureCloudInstance : authorityString;
      }
      /**
       * Creates cloud discovery metadata object from a given host
       * @param host
       */
      static createCloudDiscoveryMetadataFromHost(host) {
        return {
          preferred_network: host,
          preferred_cache: host,
          aliases: [host]
        };
      }
      /**
       * helper function to generate environment from authority object
       */
      getPreferredCache() {
        if (this.managedIdentity) {
          return Constants.DEFAULT_AUTHORITY_HOST;
        } else if (this.discoveryComplete()) {
          return this.metadata.preferred_cache;
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * Returns whether or not the provided host is an alias of this authority instance
       * @param host
       */
      isAlias(host) {
        return this.metadata.aliases.indexOf(host) > -1;
      }
      /**
       * Returns whether or not the provided host is an alias of a known Microsoft authority for purposes of endpoint discovery
       * @param host
       */
      isAliasOfKnownMicrosoftAuthority(host) {
        return InstanceDiscoveryMetadataAliases.has(host);
      }
      /**
       * Checks whether the provided host is that of a public cloud authority
       *
       * @param authority string
       * @returns bool
       */
      static isPublicCloudAuthority(host) {
        return Constants.KNOWN_PUBLIC_CLOUDS.indexOf(host) >= 0;
      }
      /**
       * Rebuild the authority string with the region
       *
       * @param host string
       * @param region string
       */
      static buildRegionalAuthorityString(host, region, queryString) {
        const authorityUrlInstance = new UrlString(host);
        authorityUrlInstance.validateAsUri();
        const authorityUrlParts = authorityUrlInstance.getUrlComponents();
        let hostNameAndPort = `${region}.${authorityUrlParts.HostNameAndPort}`;
        if (this.isPublicCloudAuthority(authorityUrlParts.HostNameAndPort)) {
          hostNameAndPort = `${region}.${Constants.REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX}`;
        }
        const url = UrlString.constructAuthorityUriFromObject({
          ...authorityUrlInstance.getUrlComponents(),
          HostNameAndPort: hostNameAndPort
        }).urlString;
        if (queryString)
          return `${url}?${queryString}`;
        return url;
      }
      /**
       * Replace the endpoints in the metadata object with their regional equivalents.
       *
       * @param metadata OpenIdConfigResponse
       * @param azureRegion string
       */
      static replaceWithRegionalInformation(metadata, azureRegion) {
        const regionalMetadata = { ...metadata };
        regionalMetadata.authorization_endpoint = _Authority.buildRegionalAuthorityString(regionalMetadata.authorization_endpoint, azureRegion);
        regionalMetadata.token_endpoint = _Authority.buildRegionalAuthorityString(regionalMetadata.token_endpoint, azureRegion);
        if (regionalMetadata.end_session_endpoint) {
          regionalMetadata.end_session_endpoint = _Authority.buildRegionalAuthorityString(regionalMetadata.end_session_endpoint, azureRegion);
        }
        return regionalMetadata;
      }
      /**
       * Transform CIAM_AUTHORIY as per the below rules:
       * If no path segments found and it is a CIAM authority (hostname ends with .ciamlogin.com), then transform it
       *
       * NOTE: The transformation path should go away once STS supports CIAM with the format: `tenantIdorDomain.ciamlogin.com`
       * `ciamlogin.com` can also change in the future and we should accommodate the same
       *
       * @param authority
       */
      static transformCIAMAuthority(authority) {
        let ciamAuthority = authority;
        const authorityUrl = new UrlString(authority);
        const authorityUrlComponents = authorityUrl.getUrlComponents();
        if (authorityUrlComponents.PathSegments.length === 0 && authorityUrlComponents.HostNameAndPort.endsWith(Constants.CIAM_AUTH_URL)) {
          const tenantIdOrDomain = authorityUrlComponents.HostNameAndPort.split(".")[0];
          ciamAuthority = `${ciamAuthority}${tenantIdOrDomain}${Constants.AAD_TENANT_DOMAIN_SUFFIX}`;
        }
        return ciamAuthority;
      }
    };
    Authority.reservedTenantDomains = /* @__PURE__ */ new Set([
      "{tenant}",
      "{tenantid}",
      AADAuthorityConstants.COMMON,
      AADAuthorityConstants.CONSUMERS,
      AADAuthorityConstants.ORGANIZATIONS
    ]);
  }
});

// node_modules/@azure/msal-common/dist/authority/AuthorityFactory.mjs
var AuthorityFactory_exports = {};
__export(AuthorityFactory_exports, {
  createDiscoveredInstance: () => createDiscoveredInstance
});
async function createDiscoveredInstance(authorityUri, networkClient, cacheManager, authorityOptions, logger24, correlationId, performanceClient) {
  performanceClient == null ? void 0 : performanceClient.addQueueMeasurement(PerformanceEvents.AuthorityFactoryCreateDiscoveredInstance, correlationId);
  const authorityUriFinal = Authority.transformCIAMAuthority(formatAuthorityUri(authorityUri));
  const acquireTokenAuthority = new Authority(authorityUriFinal, networkClient, cacheManager, authorityOptions, logger24, correlationId, performanceClient);
  try {
    await invokeAsync(acquireTokenAuthority.resolveEndpointsAsync.bind(acquireTokenAuthority), PerformanceEvents.AuthorityResolveEndpointsAsync, logger24, performanceClient, correlationId)();
    return acquireTokenAuthority;
  } catch (e) {
    throw createClientAuthError(endpointResolutionError);
  }
}
var init_AuthorityFactory = __esm({
  "node_modules/@azure/msal-common/dist/authority/AuthorityFactory.mjs"() {
    "use strict";
    init_Authority();
    init_ClientAuthError();
    init_PerformanceEvent();
    init_FunctionWrappers();
    init_ClientAuthErrorCodes();
  }
});

// node_modules/@azure/msal-common/dist/error/ServerError.mjs
var ServerError;
var init_ServerError = __esm({
  "node_modules/@azure/msal-common/dist/error/ServerError.mjs"() {
    "use strict";
    init_AuthError();
    ServerError = class _ServerError extends AuthError {
      constructor(errorCode, errorMessage2, subError, errorNo, status) {
        super(errorCode, errorMessage2, subError);
        this.name = "ServerError";
        this.errorNo = errorNo;
        this.status = status;
        Object.setPrototypeOf(this, _ServerError.prototype);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/network/RequestThumbprint.mjs
function getRequestThumbprint(clientId, request, homeAccountId) {
  var _a3;
  return {
    clientId,
    authority: request.authority,
    scopes: request.scopes,
    homeAccountIdentifier: homeAccountId,
    claims: request.claims,
    authenticationScheme: request.authenticationScheme,
    resourceRequestMethod: request.resourceRequestMethod,
    resourceRequestUri: request.resourceRequestUri,
    shrClaims: request.shrClaims,
    sshKid: request.sshKid,
    embeddedClientId: request.embeddedClientId || ((_a3 = request.tokenBodyParameters) == null ? void 0 : _a3.clientId)
  };
}
var init_RequestThumbprint = __esm({
  "node_modules/@azure/msal-common/dist/network/RequestThumbprint.mjs"() {
    "use strict";
  }
});

// node_modules/@azure/msal-common/dist/network/ThrottlingUtils.mjs
var ThrottlingUtils;
var init_ThrottlingUtils = __esm({
  "node_modules/@azure/msal-common/dist/network/ThrottlingUtils.mjs"() {
    "use strict";
    init_Constants();
    init_ServerError();
    init_RequestThumbprint();
    ThrottlingUtils = class _ThrottlingUtils {
      /**
       * Prepares a RequestThumbprint to be stored as a key.
       * @param thumbprint
       */
      static generateThrottlingStorageKey(thumbprint) {
        return `${ThrottlingConstants.THROTTLING_PREFIX}.${JSON.stringify(thumbprint)}`;
      }
      /**
       * Performs necessary throttling checks before a network request.
       * @param cacheManager
       * @param thumbprint
       */
      static preProcess(cacheManager, thumbprint, correlationId) {
        var _a3;
        const key = _ThrottlingUtils.generateThrottlingStorageKey(thumbprint);
        const value = cacheManager.getThrottlingCache(key);
        if (value) {
          if (value.throttleTime < Date.now()) {
            cacheManager.removeItem(key, correlationId);
            return;
          }
          throw new ServerError(((_a3 = value.errorCodes) == null ? void 0 : _a3.join(" ")) || Constants.EMPTY_STRING, value.errorMessage, value.subError);
        }
      }
      /**
       * Performs necessary throttling checks after a network request.
       * @param cacheManager
       * @param thumbprint
       * @param response
       */
      static postProcess(cacheManager, thumbprint, response, correlationId) {
        if (_ThrottlingUtils.checkResponseStatus(response) || _ThrottlingUtils.checkResponseForRetryAfter(response)) {
          const thumbprintValue = {
            throttleTime: _ThrottlingUtils.calculateThrottleTime(parseInt(response.headers[HeaderNames.RETRY_AFTER])),
            error: response.body.error,
            errorCodes: response.body.error_codes,
            errorMessage: response.body.error_description,
            subError: response.body.suberror
          };
          cacheManager.setThrottlingCache(_ThrottlingUtils.generateThrottlingStorageKey(thumbprint), thumbprintValue, correlationId);
        }
      }
      /**
       * Checks a NetworkResponse object's status codes against 429 or 5xx
       * @param response
       */
      static checkResponseStatus(response) {
        return response.status === 429 || response.status >= 500 && response.status < 600;
      }
      /**
       * Checks a NetworkResponse object's RetryAfter header
       * @param response
       */
      static checkResponseForRetryAfter(response) {
        if (response.headers) {
          return response.headers.hasOwnProperty(HeaderNames.RETRY_AFTER) && (response.status < 200 || response.status >= 300);
        }
        return false;
      }
      /**
       * Calculates the Unix-time value for a throttle to expire given throttleTime in seconds.
       * @param throttleTime
       */
      static calculateThrottleTime(throttleTime) {
        const time = throttleTime <= 0 ? 0 : throttleTime;
        const currentSeconds = Date.now() / 1e3;
        return Math.floor(Math.min(currentSeconds + (time || ThrottlingConstants.DEFAULT_THROTTLE_TIME_SECONDS), currentSeconds + ThrottlingConstants.DEFAULT_MAX_THROTTLE_TIME_SECONDS) * 1e3);
      }
      static removeThrottle(cacheManager, clientId, request, homeAccountIdentifier) {
        const thumbprint = getRequestThumbprint(clientId, request, homeAccountIdentifier);
        const key = this.generateThrottlingStorageKey(thumbprint);
        cacheManager.removeItem(key, request.correlationId);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/error/NetworkError.mjs
function createNetworkError(error, httpStatus, responseHeaders, additionalError) {
  error.errorMessage = `${error.errorMessage}, additionalErrorInfo: error.name:${additionalError == null ? void 0 : additionalError.name}, error.message:${additionalError == null ? void 0 : additionalError.message}`;
  return new NetworkError(error, httpStatus, responseHeaders);
}
var NetworkError;
var init_NetworkError = __esm({
  "node_modules/@azure/msal-common/dist/error/NetworkError.mjs"() {
    "use strict";
    init_AuthError();
    NetworkError = class _NetworkError extends AuthError {
      constructor(error, httpStatus, responseHeaders) {
        super(error.errorCode, error.errorMessage, error.subError);
        Object.setPrototypeOf(this, _NetworkError.prototype);
        this.name = "NetworkError";
        this.error = error;
        this.httpStatus = httpStatus;
        this.responseHeaders = responseHeaders;
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/client/BaseClient.mjs
var BaseClient;
var init_BaseClient = __esm({
  "node_modules/@azure/msal-common/dist/client/BaseClient.mjs"() {
    "use strict";
    init_ClientConfiguration();
    init_Logger();
    init_Constants();
    init_packageMetadata();
    init_CcsCredential();
    init_ClientInfo();
    init_RequestParameterBuilder();
    init_UrlUtils();
    init_AuthorityFactory();
    init_PerformanceEvent();
    init_ThrottlingUtils();
    init_AuthError();
    init_ClientAuthError();
    init_NetworkError();
    init_FunctionWrappers();
    init_ClientAuthErrorCodes();
    BaseClient = class {
      constructor(configuration, performanceClient) {
        this.config = buildClientConfiguration(configuration);
        this.logger = new Logger(this.config.loggerOptions, name, version);
        this.cryptoUtils = this.config.cryptoInterface;
        this.cacheManager = this.config.storageInterface;
        this.networkClient = this.config.networkInterface;
        this.serverTelemetryManager = this.config.serverTelemetryManager;
        this.authority = this.config.authOptions.authority;
        this.performanceClient = performanceClient;
      }
      /**
       * Creates default headers for requests to token endpoint
       */
      createTokenRequestHeaders(ccsCred) {
        const headers = {};
        headers[HeaderNames.CONTENT_TYPE] = Constants.URL_FORM_CONTENT_TYPE;
        if (!this.config.systemOptions.preventCorsPreflight && ccsCred) {
          switch (ccsCred.type) {
            case CcsCredentialType.HOME_ACCOUNT_ID:
              try {
                const clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);
                headers[HeaderNames.CCS_HEADER] = `Oid:${clientInfo.uid}@${clientInfo.utid}`;
              } catch (e) {
                this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
              }
              break;
            case CcsCredentialType.UPN:
              headers[HeaderNames.CCS_HEADER] = `UPN: ${ccsCred.credential}`;
              break;
          }
        }
        return headers;
      }
      /**
       * Http post to token endpoint
       * @param tokenEndpoint
       * @param queryString
       * @param headers
       * @param thumbprint
       */
      async executePostToTokenEndpoint(tokenEndpoint, queryString, headers, thumbprint, correlationId, queuedEvent) {
        var _a3;
        if (queuedEvent) {
          (_a3 = this.performanceClient) == null ? void 0 : _a3.addQueueMeasurement(queuedEvent, correlationId);
        }
        const response = await this.sendPostRequest(thumbprint, tokenEndpoint, { body: queryString, headers }, correlationId);
        if (this.config.serverTelemetryManager && response.status < 500 && response.status !== 429) {
          this.config.serverTelemetryManager.clearTelemetryCache();
        }
        return response;
      }
      /**
       * Wraps sendPostRequestAsync with necessary preflight and postflight logic
       * @param thumbprint - Request thumbprint for throttling
       * @param tokenEndpoint - Endpoint to make the POST to
       * @param options - Body and Headers to include on the POST request
       * @param correlationId - CorrelationId for telemetry
       */
      async sendPostRequest(thumbprint, tokenEndpoint, options, correlationId) {
        var _a3, _b2, _c2;
        ThrottlingUtils.preProcess(this.cacheManager, thumbprint, correlationId);
        let response;
        try {
          response = await invokeAsync(this.networkClient.sendPostRequestAsync.bind(this.networkClient), PerformanceEvents.NetworkClientSendPostRequestAsync, this.logger, this.performanceClient, correlationId)(tokenEndpoint, options);
          const responseHeaders = response.headers || {};
          (_b2 = this.performanceClient) == null ? void 0 : _b2.addFields({
            refreshTokenSize: ((_a3 = response.body.refresh_token) == null ? void 0 : _a3.length) || 0,
            httpVerToken: responseHeaders[HeaderNames.X_MS_HTTP_VERSION] || "",
            requestId: responseHeaders[HeaderNames.X_MS_REQUEST_ID] || ""
          }, correlationId);
        } catch (e) {
          if (e instanceof NetworkError) {
            const responseHeaders = e.responseHeaders;
            if (responseHeaders) {
              (_c2 = this.performanceClient) == null ? void 0 : _c2.addFields({
                httpVerToken: responseHeaders[HeaderNames.X_MS_HTTP_VERSION] || "",
                requestId: responseHeaders[HeaderNames.X_MS_REQUEST_ID] || "",
                contentTypeHeader: responseHeaders[HeaderNames.CONTENT_TYPE] || void 0,
                contentLengthHeader: responseHeaders[HeaderNames.CONTENT_LENGTH] || void 0,
                httpStatus: e.httpStatus
              }, correlationId);
            }
            throw e.error;
          }
          if (e instanceof AuthError) {
            throw e;
          } else {
            throw createClientAuthError(networkError);
          }
        }
        ThrottlingUtils.postProcess(this.cacheManager, thumbprint, response, correlationId);
        return response;
      }
      /**
       * Updates the authority object of the client. Endpoint discovery must be completed.
       * @param updatedAuthority
       */
      async updateAuthority(cloudInstanceHostname, correlationId) {
        var _a3;
        (_a3 = this.performanceClient) == null ? void 0 : _a3.addQueueMeasurement(PerformanceEvents.UpdateTokenEndpointAuthority, correlationId);
        const cloudInstanceAuthorityUri = `https://${cloudInstanceHostname}/${this.authority.tenant}/`;
        const cloudInstanceAuthority = await createDiscoveredInstance(cloudInstanceAuthorityUri, this.networkClient, this.cacheManager, this.authority.options, this.logger, correlationId, this.performanceClient);
        this.authority = cloudInstanceAuthority;
      }
      /**
       * Creates query string for the /token request
       * @param request
       */
      createTokenQueryParameters(request) {
        const parameters = /* @__PURE__ */ new Map();
        if (request.embeddedClientId) {
          addBrokerParameters(parameters, this.config.authOptions.clientId, this.config.authOptions.redirectUri);
        }
        if (request.tokenQueryParameters) {
          addExtraQueryParameters(parameters, request.tokenQueryParameters);
        }
        addCorrelationId(parameters, request.correlationId);
        instrumentBrokerParams(parameters, request.correlationId, this.performanceClient);
        return mapToQueryString(parameters);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/error/InteractionRequiredAuthErrorCodes.mjs
var InteractionRequiredAuthErrorCodes_exports = {};
__export(InteractionRequiredAuthErrorCodes_exports, {
  badToken: () => badToken,
  consentRequired: () => consentRequired,
  interactionRequired: () => interactionRequired,
  loginRequired: () => loginRequired,
  nativeAccountUnavailable: () => nativeAccountUnavailable,
  noTokensFound: () => noTokensFound,
  refreshTokenExpired: () => refreshTokenExpired,
  uxNotAllowed: () => uxNotAllowed
});
var noTokensFound, nativeAccountUnavailable, refreshTokenExpired, uxNotAllowed, interactionRequired, consentRequired, loginRequired, badToken;
var init_InteractionRequiredAuthErrorCodes = __esm({
  "node_modules/@azure/msal-common/dist/error/InteractionRequiredAuthErrorCodes.mjs"() {
    "use strict";
    noTokensFound = "no_tokens_found";
    nativeAccountUnavailable = "native_account_unavailable";
    refreshTokenExpired = "refresh_token_expired";
    uxNotAllowed = "ux_not_allowed";
    interactionRequired = "interaction_required";
    consentRequired = "consent_required";
    loginRequired = "login_required";
    badToken = "bad_token";
  }
});

// node_modules/@azure/msal-common/dist/error/InteractionRequiredAuthError.mjs
function isInteractionRequiredError(errorCode, errorString, subError) {
  const isInteractionRequiredErrorCode = !!errorCode && InteractionRequiredServerErrorMessage.indexOf(errorCode) > -1;
  const isInteractionRequiredSubError = !!subError && InteractionRequiredAuthSubErrorMessage.indexOf(subError) > -1;
  const isInteractionRequiredErrorDesc = !!errorString && InteractionRequiredServerErrorMessage.some((irErrorCode) => {
    return errorString.indexOf(irErrorCode) > -1;
  });
  return isInteractionRequiredErrorCode || isInteractionRequiredErrorDesc || isInteractionRequiredSubError;
}
function createInteractionRequiredAuthError(errorCode) {
  return new InteractionRequiredAuthError(errorCode, InteractionRequiredAuthErrorMessages[errorCode]);
}
var InteractionRequiredServerErrorMessage, InteractionRequiredAuthSubErrorMessage, InteractionRequiredAuthErrorMessages, InteractionRequiredAuthErrorMessage, InteractionRequiredAuthError;
var init_InteractionRequiredAuthError = __esm({
  "node_modules/@azure/msal-common/dist/error/InteractionRequiredAuthError.mjs"() {
    "use strict";
    init_Constants();
    init_AuthError();
    init_InteractionRequiredAuthErrorCodes();
    init_InteractionRequiredAuthErrorCodes();
    InteractionRequiredServerErrorMessage = [
      interactionRequired,
      consentRequired,
      loginRequired,
      badToken,
      uxNotAllowed
    ];
    InteractionRequiredAuthSubErrorMessage = [
      "message_only",
      "additional_action",
      "basic_action",
      "user_password_expired",
      "consent_required",
      "bad_token"
    ];
    InteractionRequiredAuthErrorMessages = {
      [noTokensFound]: "No refresh token found in the cache. Please sign-in.",
      [nativeAccountUnavailable]: "The requested account is not available in the native broker. It may have been deleted or logged out. Please sign-in again using an interactive API.",
      [refreshTokenExpired]: "Refresh token has expired.",
      [badToken]: "Identity provider returned bad_token due to an expired or invalid refresh token. Please invoke an interactive API to resolve.",
      [uxNotAllowed]: "`canShowUI` flag in Edge was set to false. User interaction required on web page. Please invoke an interactive API to resolve."
    };
    InteractionRequiredAuthErrorMessage = {
      noTokensFoundError: {
        code: noTokensFound,
        desc: InteractionRequiredAuthErrorMessages[noTokensFound]
      },
      native_account_unavailable: {
        code: nativeAccountUnavailable,
        desc: InteractionRequiredAuthErrorMessages[nativeAccountUnavailable]
      },
      bad_token: {
        code: badToken,
        desc: InteractionRequiredAuthErrorMessages[badToken]
      }
    };
    InteractionRequiredAuthError = class _InteractionRequiredAuthError extends AuthError {
      constructor(errorCode, errorMessage2, subError, timestamp, traceId, correlationId, claims, errorNo) {
        super(errorCode, errorMessage2, subError);
        Object.setPrototypeOf(this, _InteractionRequiredAuthError.prototype);
        this.timestamp = timestamp || Constants.EMPTY_STRING;
        this.traceId = traceId || Constants.EMPTY_STRING;
        this.correlationId = correlationId || Constants.EMPTY_STRING;
        this.claims = claims || Constants.EMPTY_STRING;
        this.name = "InteractionRequiredAuthError";
        this.errorNo = errorNo;
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/utils/ProtocolUtils.mjs
var ProtocolUtils;
var init_ProtocolUtils = __esm({
  "node_modules/@azure/msal-common/dist/utils/ProtocolUtils.mjs"() {
    "use strict";
    init_Constants();
    init_ClientAuthError();
    init_ClientAuthErrorCodes();
    ProtocolUtils = class _ProtocolUtils {
      /**
       * Appends user state with random guid, or returns random guid.
       * @param userState
       * @param randomGuid
       */
      static setRequestState(cryptoObj, userState, meta) {
        const libraryState = _ProtocolUtils.generateLibraryState(cryptoObj, meta);
        return userState ? `${libraryState}${Constants.RESOURCE_DELIM}${userState}` : libraryState;
      }
      /**
       * Generates the state value used by the common library.
       * @param randomGuid
       * @param cryptoObj
       */
      static generateLibraryState(cryptoObj, meta) {
        if (!cryptoObj) {
          throw createClientAuthError(noCryptoObject);
        }
        const stateObj = {
          id: cryptoObj.createNewGuid()
        };
        if (meta) {
          stateObj.meta = meta;
        }
        const stateString = JSON.stringify(stateObj);
        return cryptoObj.base64Encode(stateString);
      }
      /**
       * Parses the state into the RequestStateObject, which contains the LibraryState info and the state passed by the user.
       * @param state
       * @param cryptoObj
       */
      static parseRequestState(cryptoObj, state3) {
        if (!cryptoObj) {
          throw createClientAuthError(noCryptoObject);
        }
        if (!state3) {
          throw createClientAuthError(invalidState);
        }
        try {
          const splitState = state3.split(Constants.RESOURCE_DELIM);
          const libraryState = splitState[0];
          const userState = splitState.length > 1 ? splitState.slice(1).join(Constants.RESOURCE_DELIM) : Constants.EMPTY_STRING;
          const libraryStateString = cryptoObj.base64Decode(libraryState);
          const libraryStateObj = JSON.parse(libraryStateString);
          return {
            userRequestState: userState || Constants.EMPTY_STRING,
            libraryState: libraryStateObj
          };
        } catch (e) {
          throw createClientAuthError(invalidState);
        }
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/crypto/PopTokenGenerator.mjs
var KeyLocation, PopTokenGenerator;
var init_PopTokenGenerator = __esm({
  "node_modules/@azure/msal-common/dist/crypto/PopTokenGenerator.mjs"() {
    "use strict";
    init_TimeUtils();
    init_UrlString();
    init_PerformanceEvent();
    init_FunctionWrappers();
    KeyLocation = {
      SW: "sw"
    };
    PopTokenGenerator = class {
      constructor(cryptoUtils, performanceClient) {
        this.cryptoUtils = cryptoUtils;
        this.performanceClient = performanceClient;
      }
      /**
       * Generates the req_cnf validated at the RP in the POP protocol for SHR parameters
       * and returns an object containing the keyid, the full req_cnf string and the req_cnf string hash
       * @param request
       * @returns
       */
      async generateCnf(request, logger24) {
        var _a3;
        (_a3 = this.performanceClient) == null ? void 0 : _a3.addQueueMeasurement(PerformanceEvents.PopTokenGenerateCnf, request.correlationId);
        const reqCnf = await invokeAsync(this.generateKid.bind(this), PerformanceEvents.PopTokenGenerateCnf, logger24, this.performanceClient, request.correlationId)(request);
        const reqCnfString = this.cryptoUtils.base64UrlEncode(JSON.stringify(reqCnf));
        return {
          kid: reqCnf.kid,
          reqCnfString
        };
      }
      /**
       * Generates key_id for a SHR token request
       * @param request
       * @returns
       */
      async generateKid(request) {
        var _a3;
        (_a3 = this.performanceClient) == null ? void 0 : _a3.addQueueMeasurement(PerformanceEvents.PopTokenGenerateKid, request.correlationId);
        const kidThumbprint = await this.cryptoUtils.getPublicKeyThumbprint(request);
        return {
          kid: kidThumbprint,
          xms_ksl: KeyLocation.SW
        };
      }
      /**
       * Signs the POP access_token with the local generated key-pair
       * @param accessToken
       * @param request
       * @returns
       */
      async signPopToken(accessToken, keyId, request) {
        return this.signPayload(accessToken, keyId, request);
      }
      /**
       * Utility function to generate the signed JWT for an access_token
       * @param payload
       * @param kid
       * @param request
       * @param claims
       * @returns
       */
      async signPayload(payload, keyId, request, claims) {
        const { resourceRequestMethod, resourceRequestUri, shrClaims, shrNonce, shrOptions } = request;
        const resourceUrlString = resourceRequestUri ? new UrlString(resourceRequestUri) : void 0;
        const resourceUrlComponents = resourceUrlString == null ? void 0 : resourceUrlString.getUrlComponents();
        return this.cryptoUtils.signJwt({
          at: payload,
          ts: nowSeconds(),
          m: resourceRequestMethod == null ? void 0 : resourceRequestMethod.toUpperCase(),
          u: resourceUrlComponents == null ? void 0 : resourceUrlComponents.HostNameAndPort,
          nonce: shrNonce || this.cryptoUtils.createNewGuid(),
          p: resourceUrlComponents == null ? void 0 : resourceUrlComponents.AbsolutePath,
          q: (resourceUrlComponents == null ? void 0 : resourceUrlComponents.QueryString) ? [[], resourceUrlComponents.QueryString] : void 0,
          client_claims: shrClaims || void 0,
          ...claims
        }, keyId, shrOptions, request.correlationId);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/cache/persistence/TokenCacheContext.mjs
var TokenCacheContext;
var init_TokenCacheContext = __esm({
  "node_modules/@azure/msal-common/dist/cache/persistence/TokenCacheContext.mjs"() {
    "use strict";
    TokenCacheContext = class {
      constructor(tokenCache, hasChanged) {
        this.cache = tokenCache;
        this.hasChanged = hasChanged;
      }
      /**
       * boolean which indicates the changes in cache
       */
      get cacheHasChanged() {
        return this.hasChanged;
      }
      /**
       * function to retrieve the token cache
       */
      get tokenCache() {
        return this.cache;
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/response/ResponseHandler.mjs
function buildAccountToCache(cacheStorage, authority, homeAccountId, base64Decode2, correlationId, idTokenClaims, clientInfo, environment, claimsTenantId, authCodePayload, nativeAccountId, logger24) {
  logger24 == null ? void 0 : logger24.verbose("setCachedAccount called");
  const accountKeys = cacheStorage.getAccountKeys();
  const baseAccountKey = accountKeys.find((accountKey) => {
    return accountKey.startsWith(homeAccountId);
  });
  let cachedAccount = null;
  if (baseAccountKey) {
    cachedAccount = cacheStorage.getAccount(baseAccountKey, correlationId);
  }
  const baseAccount = cachedAccount || AccountEntity.createAccount({
    homeAccountId,
    idTokenClaims,
    clientInfo,
    environment,
    cloudGraphHostName: authCodePayload == null ? void 0 : authCodePayload.cloud_graph_host_name,
    msGraphHost: authCodePayload == null ? void 0 : authCodePayload.msgraph_host,
    nativeAccountId
  }, authority, base64Decode2);
  const tenantProfiles = baseAccount.tenantProfiles || [];
  const tenantId = claimsTenantId || baseAccount.realm;
  if (tenantId && !tenantProfiles.find((tenantProfile) => {
    return tenantProfile.tenantId === tenantId;
  })) {
    const newTenantProfile = buildTenantProfile(homeAccountId, baseAccount.localAccountId, tenantId, idTokenClaims);
    tenantProfiles.push(newTenantProfile);
  }
  baseAccount.tenantProfiles = tenantProfiles;
  return baseAccount;
}
var ResponseHandler;
var init_ResponseHandler = __esm({
  "node_modules/@azure/msal-common/dist/response/ResponseHandler.mjs"() {
    "use strict";
    init_ClientAuthError();
    init_ServerError();
    init_ScopeSet();
    init_AccountEntity();
    init_InteractionRequiredAuthError();
    init_ProtocolUtils();
    init_Constants();
    init_PopTokenGenerator();
    init_TokenCacheContext();
    init_PerformanceEvent();
    init_AuthToken();
    init_TokenClaims();
    init_AccountInfo();
    init_CacheHelpers();
    init_TimeUtils();
    init_ClientAuthErrorCodes();
    ResponseHandler = class _ResponseHandler {
      constructor(clientId, cacheStorage, cryptoObj, logger24, serializableCache, persistencePlugin, performanceClient) {
        this.clientId = clientId;
        this.cacheStorage = cacheStorage;
        this.cryptoObj = cryptoObj;
        this.logger = logger24;
        this.serializableCache = serializableCache;
        this.persistencePlugin = persistencePlugin;
        this.performanceClient = performanceClient;
      }
      /**
       * Function which validates server authorization token response.
       * @param serverResponse
       * @param refreshAccessToken
       */
      validateTokenResponse(serverResponse, refreshAccessToken) {
        var _a3;
        if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {
          const errString = `Error(s): ${serverResponse.error_codes || Constants.NOT_AVAILABLE} - Timestamp: ${serverResponse.timestamp || Constants.NOT_AVAILABLE} - Description: ${serverResponse.error_description || Constants.NOT_AVAILABLE} - Correlation ID: ${serverResponse.correlation_id || Constants.NOT_AVAILABLE} - Trace ID: ${serverResponse.trace_id || Constants.NOT_AVAILABLE}`;
          const serverErrorNo = ((_a3 = serverResponse.error_codes) == null ? void 0 : _a3.length) ? serverResponse.error_codes[0] : void 0;
          const serverError = new ServerError(serverResponse.error, errString, serverResponse.suberror, serverErrorNo, serverResponse.status);
          if (refreshAccessToken && serverResponse.status && serverResponse.status >= HttpStatus.SERVER_ERROR_RANGE_START && serverResponse.status <= HttpStatus.SERVER_ERROR_RANGE_END) {
            this.logger.warning(`executeTokenRequest:validateTokenResponse - AAD is currently unavailable and the access token is unable to be refreshed.
${serverError}`);
            return;
          } else if (refreshAccessToken && serverResponse.status && serverResponse.status >= HttpStatus.CLIENT_ERROR_RANGE_START && serverResponse.status <= HttpStatus.CLIENT_ERROR_RANGE_END) {
            this.logger.warning(`executeTokenRequest:validateTokenResponse - AAD is currently available but is unable to refresh the access token.
${serverError}`);
            return;
          }
          if (isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {
            throw new InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || Constants.EMPTY_STRING, serverResponse.trace_id || Constants.EMPTY_STRING, serverResponse.correlation_id || Constants.EMPTY_STRING, serverResponse.claims || Constants.EMPTY_STRING, serverErrorNo);
          }
          throw serverError;
        }
      }
      /**
       * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.
       * @param serverTokenResponse
       * @param authority
       */
      async handleServerTokenResponse(serverTokenResponse, authority, reqTimestamp, request, authCodePayload, userAssertionHash, handlingRefreshTokenResponse, forceCacheRefreshTokenResponse, serverRequestId) {
        var _a3;
        (_a3 = this.performanceClient) == null ? void 0 : _a3.addQueueMeasurement(PerformanceEvents.HandleServerTokenResponse, serverTokenResponse.correlation_id);
        let idTokenClaims;
        if (serverTokenResponse.id_token) {
          idTokenClaims = extractTokenClaims(serverTokenResponse.id_token || Constants.EMPTY_STRING, this.cryptoObj.base64Decode);
          if (authCodePayload && authCodePayload.nonce) {
            if (idTokenClaims.nonce !== authCodePayload.nonce) {
              throw createClientAuthError(nonceMismatch);
            }
          }
          if (request.maxAge || request.maxAge === 0) {
            const authTime = idTokenClaims.auth_time;
            if (!authTime) {
              throw createClientAuthError(authTimeNotFound);
            }
            checkMaxAge(authTime, request.maxAge);
          }
        }
        this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenClaims);
        let requestStateObj;
        if (!!authCodePayload && !!authCodePayload.state) {
          requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);
        }
        serverTokenResponse.key_id = serverTokenResponse.key_id || request.sshKid || void 0;
        const cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenClaims, userAssertionHash, authCodePayload);
        let cacheContext;
        try {
          if (this.persistencePlugin && this.serializableCache) {
            this.logger.verbose("Persistence enabled, calling beforeCacheAccess");
            cacheContext = new TokenCacheContext(this.serializableCache, true);
            await this.persistencePlugin.beforeCacheAccess(cacheContext);
          }
          if (handlingRefreshTokenResponse && !forceCacheRefreshTokenResponse && cacheRecord.account) {
            const key = cacheRecord.account.generateAccountKey();
            const account = this.cacheStorage.getAccount(key, request.correlationId);
            if (!account) {
              this.logger.warning("Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache");
              return await _ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenClaims, requestStateObj, void 0, serverRequestId);
            }
          }
          await this.cacheStorage.saveCacheRecord(cacheRecord, request.correlationId, request.storeInCache);
        } finally {
          if (this.persistencePlugin && this.serializableCache && cacheContext) {
            this.logger.verbose("Persistence enabled, calling afterCacheAccess");
            await this.persistencePlugin.afterCacheAccess(cacheContext);
          }
        }
        return _ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenClaims, requestStateObj, serverTokenResponse, serverRequestId);
      }
      /**
       * Generates CacheRecord
       * @param serverTokenResponse
       * @param idTokenObj
       * @param authority
       */
      generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenClaims, userAssertionHash, authCodePayload) {
        const env = authority.getPreferredCache();
        if (!env) {
          throw createClientAuthError(invalidCacheEnvironment);
        }
        const claimsTenantId = getTenantIdFromIdTokenClaims(idTokenClaims);
        let cachedIdToken;
        let cachedAccount;
        if (serverTokenResponse.id_token && !!idTokenClaims) {
          cachedIdToken = createIdTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.id_token, this.clientId, claimsTenantId || "");
          cachedAccount = buildAccountToCache(
            this.cacheStorage,
            authority,
            this.homeAccountIdentifier,
            this.cryptoObj.base64Decode,
            request.correlationId,
            idTokenClaims,
            serverTokenResponse.client_info,
            env,
            claimsTenantId,
            authCodePayload,
            void 0,
            // nativeAccountId
            this.logger
          );
        }
        let cachedAccessToken = null;
        if (serverTokenResponse.access_token) {
          const responseScopes = serverTokenResponse.scope ? ScopeSet.fromString(serverTokenResponse.scope) : new ScopeSet(request.scopes || []);
          const expiresIn = (typeof serverTokenResponse.expires_in === "string" ? parseInt(serverTokenResponse.expires_in, 10) : serverTokenResponse.expires_in) || 0;
          const extExpiresIn = (typeof serverTokenResponse.ext_expires_in === "string" ? parseInt(serverTokenResponse.ext_expires_in, 10) : serverTokenResponse.ext_expires_in) || 0;
          const refreshIn = (typeof serverTokenResponse.refresh_in === "string" ? parseInt(serverTokenResponse.refresh_in, 10) : serverTokenResponse.refresh_in) || void 0;
          const tokenExpirationSeconds = reqTimestamp + expiresIn;
          const extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;
          const refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : void 0;
          cachedAccessToken = createAccessTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.access_token, this.clientId, claimsTenantId || authority.tenant || "", responseScopes.printScopes(), tokenExpirationSeconds, extendedTokenExpirationSeconds, this.cryptoObj.base64Decode, refreshOnSeconds, serverTokenResponse.token_type, userAssertionHash, serverTokenResponse.key_id, request.claims, request.requestedClaimsHash);
        }
        let cachedRefreshToken = null;
        if (serverTokenResponse.refresh_token) {
          let rtExpiresOn;
          if (serverTokenResponse.refresh_token_expires_in) {
            const rtExpiresIn = typeof serverTokenResponse.refresh_token_expires_in === "string" ? parseInt(serverTokenResponse.refresh_token_expires_in, 10) : serverTokenResponse.refresh_token_expires_in;
            rtExpiresOn = reqTimestamp + rtExpiresIn;
          }
          cachedRefreshToken = createRefreshTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.refresh_token, this.clientId, serverTokenResponse.foci, userAssertionHash, rtExpiresOn);
        }
        let cachedAppMetadata = null;
        if (serverTokenResponse.foci) {
          cachedAppMetadata = {
            clientId: this.clientId,
            environment: env,
            familyId: serverTokenResponse.foci
          };
        }
        return {
          account: cachedAccount,
          idToken: cachedIdToken,
          accessToken: cachedAccessToken,
          refreshToken: cachedRefreshToken,
          appMetadata: cachedAppMetadata
        };
      }
      /**
       * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.
       *
       * Optionally takes a state string that is set as-is in the response.
       *
       * @param cacheRecord
       * @param idTokenObj
       * @param fromTokenCache
       * @param stateString
       */
      static async generateAuthenticationResult(cryptoObj, authority, cacheRecord, fromTokenCache, request, idTokenClaims, requestState, serverTokenResponse, requestId) {
        var _a3, _b2, _c2, _d2, _e;
        let accessToken = Constants.EMPTY_STRING;
        let responseScopes = [];
        let expiresOn = null;
        let extExpiresOn;
        let refreshOn;
        let familyId = Constants.EMPTY_STRING;
        if (cacheRecord.accessToken) {
          if (cacheRecord.accessToken.tokenType === AuthenticationScheme.POP && !request.popKid) {
            const popTokenGenerator = new PopTokenGenerator(cryptoObj);
            const { secret, keyId } = cacheRecord.accessToken;
            if (!keyId) {
              throw createClientAuthError(keyIdMissing);
            }
            accessToken = await popTokenGenerator.signPopToken(secret, keyId, request);
          } else {
            accessToken = cacheRecord.accessToken.secret;
          }
          responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();
          expiresOn = toDateFromSeconds(cacheRecord.accessToken.expiresOn);
          extExpiresOn = toDateFromSeconds(cacheRecord.accessToken.extendedExpiresOn);
          if (cacheRecord.accessToken.refreshOn) {
            refreshOn = toDateFromSeconds(cacheRecord.accessToken.refreshOn);
          }
        }
        if (cacheRecord.appMetadata) {
          familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : "";
        }
        const uid = (idTokenClaims == null ? void 0 : idTokenClaims.oid) || (idTokenClaims == null ? void 0 : idTokenClaims.sub) || "";
        const tid = (idTokenClaims == null ? void 0 : idTokenClaims.tid) || "";
        if ((serverTokenResponse == null ? void 0 : serverTokenResponse.spa_accountid) && !!cacheRecord.account) {
          cacheRecord.account.nativeAccountId = serverTokenResponse == null ? void 0 : serverTokenResponse.spa_accountid;
        }
        const accountInfo = cacheRecord.account ? updateAccountTenantProfileData(
          cacheRecord.account.getAccountInfo(),
          void 0,
          // tenantProfile optional
          idTokenClaims,
          (_a3 = cacheRecord.idToken) == null ? void 0 : _a3.secret
        ) : null;
        return {
          authority: authority.canonicalAuthority,
          uniqueId: uid,
          tenantId: tid,
          scopes: responseScopes,
          account: accountInfo,
          idToken: ((_b2 = cacheRecord == null ? void 0 : cacheRecord.idToken) == null ? void 0 : _b2.secret) || "",
          idTokenClaims: idTokenClaims || {},
          accessToken,
          fromCache: fromTokenCache,
          expiresOn,
          extExpiresOn,
          refreshOn,
          correlationId: request.correlationId,
          requestId: requestId || Constants.EMPTY_STRING,
          familyId,
          tokenType: ((_c2 = cacheRecord.accessToken) == null ? void 0 : _c2.tokenType) || Constants.EMPTY_STRING,
          state: requestState ? requestState.userRequestState : Constants.EMPTY_STRING,
          cloudGraphHostName: ((_d2 = cacheRecord.account) == null ? void 0 : _d2.cloudGraphHostName) || Constants.EMPTY_STRING,
          msGraphHost: ((_e = cacheRecord.account) == null ? void 0 : _e.msGraphHost) || Constants.EMPTY_STRING,
          code: serverTokenResponse == null ? void 0 : serverTokenResponse.spa_code,
          fromNativeBroker: false
        };
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/utils/ClientAssertionUtils.mjs
async function getClientAssertion(clientAssertion, clientId, tokenEndpoint) {
  if (typeof clientAssertion === "string") {
    return clientAssertion;
  } else {
    const config = {
      clientId,
      tokenEndpoint
    };
    return clientAssertion(config);
  }
}
var init_ClientAssertionUtils = __esm({
  "node_modules/@azure/msal-common/dist/utils/ClientAssertionUtils.mjs"() {
    "use strict";
  }
});

// node_modules/@azure/msal-common/dist/client/AuthorizationCodeClient.mjs
var AuthorizationCodeClient;
var init_AuthorizationCodeClient = __esm({
  "node_modules/@azure/msal-common/dist/client/AuthorizationCodeClient.mjs"() {
    "use strict";
    init_BaseClient();
    init_RequestParameterBuilder();
    init_UrlUtils();
    init_Constants();
    init_AADServerParamKeys();
    init_ClientConfiguration();
    init_ResponseHandler();
    init_StringUtils();
    init_ClientAuthError();
    init_UrlString();
    init_PopTokenGenerator();
    init_TimeUtils();
    init_ClientInfo();
    init_CcsCredential();
    init_ClientConfigurationError();
    init_PerformanceEvent();
    init_FunctionWrappers();
    init_ClientAssertionUtils();
    init_RequestThumbprint();
    init_ClientAuthErrorCodes();
    init_ClientConfigurationErrorCodes();
    AuthorizationCodeClient = class extends BaseClient {
      constructor(configuration, performanceClient) {
        var _a3;
        super(configuration, performanceClient);
        this.includeRedirectUri = true;
        this.oidcDefaultScopes = (_a3 = this.config.authOptions.authority.options.OIDCOptions) == null ? void 0 : _a3.defaultScopes;
      }
      /**
       * API to acquire a token in exchange of 'authorization_code` acquired by the user in the first leg of the
       * authorization_code_grant
       * @param request
       */
      async acquireToken(request, authCodePayload) {
        var _a3, _b2;
        (_a3 = this.performanceClient) == null ? void 0 : _a3.addQueueMeasurement(PerformanceEvents.AuthClientAcquireToken, request.correlationId);
        if (!request.code) {
          throw createClientAuthError(requestCannotBeMade);
        }
        const reqTimestamp = nowSeconds();
        const response = await invokeAsync(this.executeTokenRequest.bind(this), PerformanceEvents.AuthClientExecuteTokenRequest, this.logger, this.performanceClient, request.correlationId)(this.authority, request);
        const requestId = (_b2 = response.headers) == null ? void 0 : _b2[HeaderNames.X_MS_REQUEST_ID];
        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin, this.performanceClient);
        responseHandler.validateTokenResponse(response.body);
        return invokeAsync(responseHandler.handleServerTokenResponse.bind(responseHandler), PerformanceEvents.HandleServerTokenResponse, this.logger, this.performanceClient, request.correlationId)(response.body, this.authority, reqTimestamp, request, authCodePayload, void 0, void 0, void 0, requestId);
      }
      /**
       * Used to log out the current user, and redirect the user to the postLogoutRedirectUri.
       * Default behaviour is to redirect the user to `window.location.href`.
       * @param authorityUri
       */
      getLogoutUri(logoutRequest) {
        if (!logoutRequest) {
          throw createClientConfigurationError(logoutRequestEmpty);
        }
        const queryString = this.createLogoutUrlQueryString(logoutRequest);
        return UrlString.appendQueryString(this.authority.endSessionEndpoint, queryString);
      }
      /**
       * Executes POST request to token endpoint
       * @param authority
       * @param request
       */
      async executeTokenRequest(authority, request) {
        var _a3;
        (_a3 = this.performanceClient) == null ? void 0 : _a3.addQueueMeasurement(PerformanceEvents.AuthClientExecuteTokenRequest, request.correlationId);
        const queryParametersString = this.createTokenQueryParameters(request);
        const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
        const requestBody = await invokeAsync(this.createTokenRequestBody.bind(this), PerformanceEvents.AuthClientCreateTokenRequestBody, this.logger, this.performanceClient, request.correlationId)(request);
        let ccsCredential = void 0;
        if (request.clientInfo) {
          try {
            const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils.base64Decode);
            ccsCredential = {
              credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,
              type: CcsCredentialType.HOME_ACCOUNT_ID
            };
          } catch (e) {
            this.logger.verbose("Could not parse client info for CCS Header: " + e);
          }
        }
        const headers = this.createTokenRequestHeaders(ccsCredential || request.ccsCredential);
        const thumbprint = getRequestThumbprint(this.config.authOptions.clientId, request);
        return invokeAsync(this.executePostToTokenEndpoint.bind(this), PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint, this.logger, this.performanceClient, request.correlationId)(endpoint, requestBody, headers, thumbprint, request.correlationId, PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint);
      }
      /**
       * Generates a map for all the params to be sent to the service
       * @param request
       */
      async createTokenRequestBody(request) {
        var _a3, _b2;
        (_a3 = this.performanceClient) == null ? void 0 : _a3.addQueueMeasurement(PerformanceEvents.AuthClientCreateTokenRequestBody, request.correlationId);
        const parameters = /* @__PURE__ */ new Map();
        addClientId(parameters, request.embeddedClientId || ((_b2 = request.tokenBodyParameters) == null ? void 0 : _b2[CLIENT_ID]) || this.config.authOptions.clientId);
        if (!this.includeRedirectUri) {
          if (!request.redirectUri) {
            throw createClientConfigurationError(redirectUriEmpty);
          }
        } else {
          addRedirectUri(parameters, request.redirectUri);
        }
        addScopes(parameters, request.scopes, true, this.oidcDefaultScopes);
        addAuthorizationCode(parameters, request.code);
        addLibraryInfo(parameters, this.config.libraryInfo);
        addApplicationTelemetry(parameters, this.config.telemetry.application);
        addThrottling(parameters);
        if (this.serverTelemetryManager && !isOidcProtocolMode(this.config)) {
          addServerTelemetry(parameters, this.serverTelemetryManager);
        }
        if (request.codeVerifier) {
          addCodeVerifier(parameters, request.codeVerifier);
        }
        if (this.config.clientCredentials.clientSecret) {
          addClientSecret(parameters, this.config.clientCredentials.clientSecret);
        }
        if (this.config.clientCredentials.clientAssertion) {
          const clientAssertion = this.config.clientCredentials.clientAssertion;
          addClientAssertion(parameters, await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request.resourceRequestUri));
          addClientAssertionType(parameters, clientAssertion.assertionType);
        }
        addGrantType(parameters, GrantType.AUTHORIZATION_CODE_GRANT);
        addClientInfo(parameters);
        if (request.authenticationScheme === AuthenticationScheme.POP) {
          const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);
          let reqCnfData;
          if (!request.popKid) {
            const generatedReqCnfData = await invokeAsync(popTokenGenerator.generateCnf.bind(popTokenGenerator), PerformanceEvents.PopTokenGenerateCnf, this.logger, this.performanceClient, request.correlationId)(request, this.logger);
            reqCnfData = generatedReqCnfData.reqCnfString;
          } else {
            reqCnfData = this.cryptoUtils.encodeKid(request.popKid);
          }
          addPopToken(parameters, reqCnfData);
        } else if (request.authenticationScheme === AuthenticationScheme.SSH) {
          if (request.sshJwk) {
            addSshJwk(parameters, request.sshJwk);
          } else {
            throw createClientConfigurationError(missingSshJwk);
          }
        }
        if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
          addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);
        }
        let ccsCred = void 0;
        if (request.clientInfo) {
          try {
            const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils.base64Decode);
            ccsCred = {
              credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,
              type: CcsCredentialType.HOME_ACCOUNT_ID
            };
          } catch (e) {
            this.logger.verbose("Could not parse client info for CCS Header: " + e);
          }
        } else {
          ccsCred = request.ccsCredential;
        }
        if (this.config.systemOptions.preventCorsPreflight && ccsCred) {
          switch (ccsCred.type) {
            case CcsCredentialType.HOME_ACCOUNT_ID:
              try {
                const clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);
                addCcsOid(parameters, clientInfo);
              } catch (e) {
                this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
              }
              break;
            case CcsCredentialType.UPN:
              addCcsUpn(parameters, ccsCred.credential);
              break;
          }
        }
        if (request.embeddedClientId) {
          addBrokerParameters(parameters, this.config.authOptions.clientId, this.config.authOptions.redirectUri);
        }
        if (request.tokenBodyParameters) {
          addExtraQueryParameters(parameters, request.tokenBodyParameters);
        }
        if (request.enableSpaAuthorizationCode && (!request.tokenBodyParameters || !request.tokenBodyParameters[RETURN_SPA_CODE])) {
          addExtraQueryParameters(parameters, {
            [RETURN_SPA_CODE]: "1"
          });
        }
        instrumentBrokerParams(parameters, request.correlationId, this.performanceClient);
        return mapToQueryString(parameters);
      }
      /**
       * This API validates the `EndSessionRequest` and creates a URL
       * @param request
       */
      createLogoutUrlQueryString(request) {
        const parameters = /* @__PURE__ */ new Map();
        if (request.postLogoutRedirectUri) {
          addPostLogoutRedirectUri(parameters, request.postLogoutRedirectUri);
        }
        if (request.correlationId) {
          addCorrelationId(parameters, request.correlationId);
        }
        if (request.idTokenHint) {
          addIdTokenHint(parameters, request.idTokenHint);
        }
        if (request.state) {
          addState(parameters, request.state);
        }
        if (request.logoutHint) {
          addLogoutHint(parameters, request.logoutHint);
        }
        if (request.extraQueryParameters) {
          addExtraQueryParameters(parameters, request.extraQueryParameters);
        }
        if (this.config.authOptions.instanceAware) {
          addInstanceAware(parameters);
        }
        return mapToQueryString(parameters, this.config.authOptions.encodeExtraQueryParams, request.extraQueryParameters);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/client/RefreshTokenClient.mjs
var DEFAULT_REFRESH_TOKEN_EXPIRATION_OFFSET_SECONDS, RefreshTokenClient;
var init_RefreshTokenClient = __esm({
  "node_modules/@azure/msal-common/dist/client/RefreshTokenClient.mjs"() {
    "use strict";
    init_ClientConfiguration();
    init_BaseClient();
    init_RequestParameterBuilder();
    init_UrlUtils();
    init_Constants();
    init_AADServerParamKeys();
    init_ResponseHandler();
    init_PopTokenGenerator();
    init_StringUtils();
    init_ClientConfigurationError();
    init_ClientAuthError();
    init_ServerError();
    init_TimeUtils();
    init_UrlString();
    init_CcsCredential();
    init_ClientInfo();
    init_InteractionRequiredAuthError();
    init_PerformanceEvent();
    init_FunctionWrappers();
    init_CacheHelpers();
    init_ClientAssertionUtils();
    init_RequestThumbprint();
    init_InteractionRequiredAuthErrorCodes();
    init_ClientConfigurationErrorCodes();
    init_ClientAuthErrorCodes();
    DEFAULT_REFRESH_TOKEN_EXPIRATION_OFFSET_SECONDS = 300;
    RefreshTokenClient = class extends BaseClient {
      constructor(configuration, performanceClient) {
        super(configuration, performanceClient);
      }
      async acquireToken(request) {
        var _a3, _b2;
        (_a3 = this.performanceClient) == null ? void 0 : _a3.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireToken, request.correlationId);
        const reqTimestamp = nowSeconds();
        const response = await invokeAsync(this.executeTokenRequest.bind(this), PerformanceEvents.RefreshTokenClientExecuteTokenRequest, this.logger, this.performanceClient, request.correlationId)(request, this.authority);
        const requestId = (_b2 = response.headers) == null ? void 0 : _b2[HeaderNames.X_MS_REQUEST_ID];
        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
        responseHandler.validateTokenResponse(response.body);
        return invokeAsync(responseHandler.handleServerTokenResponse.bind(responseHandler), PerformanceEvents.HandleServerTokenResponse, this.logger, this.performanceClient, request.correlationId)(response.body, this.authority, reqTimestamp, request, void 0, void 0, true, request.forceCache, requestId);
      }
      /**
       * Gets cached refresh token and attaches to request, then calls acquireToken API
       * @param request
       */
      async acquireTokenByRefreshToken(request) {
        var _a3;
        if (!request) {
          throw createClientConfigurationError(tokenRequestEmpty);
        }
        (_a3 = this.performanceClient) == null ? void 0 : _a3.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenByRefreshToken, request.correlationId);
        if (!request.account) {
          throw createClientAuthError(noAccountInSilentRequest);
        }
        const isFOCI = this.cacheManager.isAppMetadataFOCI(request.account.environment);
        if (isFOCI) {
          try {
            return await invokeAsync(this.acquireTokenWithCachedRefreshToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, this.logger, this.performanceClient, request.correlationId)(request, true);
          } catch (e) {
            const noFamilyRTInCache = e instanceof InteractionRequiredAuthError && e.errorCode === noTokensFound;
            const clientMismatchErrorWithFamilyRT = e instanceof ServerError && e.errorCode === Errors.INVALID_GRANT_ERROR && e.subError === Errors.CLIENT_MISMATCH_ERROR;
            if (noFamilyRTInCache || clientMismatchErrorWithFamilyRT) {
              return invokeAsync(this.acquireTokenWithCachedRefreshToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, this.logger, this.performanceClient, request.correlationId)(request, false);
            } else {
              throw e;
            }
          }
        }
        return invokeAsync(this.acquireTokenWithCachedRefreshToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, this.logger, this.performanceClient, request.correlationId)(request, false);
      }
      /**
       * makes a network call to acquire tokens by exchanging RefreshToken available in userCache; throws if refresh token is not cached
       * @param request
       */
      async acquireTokenWithCachedRefreshToken(request, foci) {
        var _a3, _b2, _c2;
        (_a3 = this.performanceClient) == null ? void 0 : _a3.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, request.correlationId);
        const refreshToken = invoke(this.cacheManager.getRefreshToken.bind(this.cacheManager), PerformanceEvents.CacheManagerGetRefreshToken, this.logger, this.performanceClient, request.correlationId)(request.account, foci, request.correlationId, void 0, this.performanceClient);
        if (!refreshToken) {
          throw createInteractionRequiredAuthError(noTokensFound);
        }
        if (refreshToken.expiresOn && isTokenExpired(refreshToken.expiresOn, request.refreshTokenExpirationOffsetSeconds || DEFAULT_REFRESH_TOKEN_EXPIRATION_OFFSET_SECONDS)) {
          (_b2 = this.performanceClient) == null ? void 0 : _b2.addFields({ rtExpiresOnMs: Number(refreshToken.expiresOn) }, request.correlationId);
          throw createInteractionRequiredAuthError(refreshTokenExpired);
        }
        const refreshTokenRequest = {
          ...request,
          refreshToken: refreshToken.secret,
          authenticationScheme: request.authenticationScheme || AuthenticationScheme.BEARER,
          ccsCredential: {
            credential: request.account.homeAccountId,
            type: CcsCredentialType.HOME_ACCOUNT_ID
          }
        };
        try {
          return await invokeAsync(this.acquireToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireToken, this.logger, this.performanceClient, request.correlationId)(refreshTokenRequest);
        } catch (e) {
          if (e instanceof InteractionRequiredAuthError) {
            (_c2 = this.performanceClient) == null ? void 0 : _c2.addFields({ rtExpiresOnMs: Number(refreshToken.expiresOn) }, request.correlationId);
            if (e.subError === badToken) {
              this.logger.verbose("acquireTokenWithRefreshToken: bad refresh token, removing from cache");
              const badRefreshTokenKey = generateCredentialKey(refreshToken);
              this.cacheManager.removeRefreshToken(badRefreshTokenKey, request.correlationId);
            }
          }
          throw e;
        }
      }
      /**
       * Constructs the network message and makes a NW call to the underlying secure token service
       * @param request
       * @param authority
       */
      async executeTokenRequest(request, authority) {
        var _a3;
        (_a3 = this.performanceClient) == null ? void 0 : _a3.addQueueMeasurement(PerformanceEvents.RefreshTokenClientExecuteTokenRequest, request.correlationId);
        const queryParametersString = this.createTokenQueryParameters(request);
        const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
        const requestBody = await invokeAsync(this.createTokenRequestBody.bind(this), PerformanceEvents.RefreshTokenClientCreateTokenRequestBody, this.logger, this.performanceClient, request.correlationId)(request);
        const headers = this.createTokenRequestHeaders(request.ccsCredential);
        const thumbprint = getRequestThumbprint(this.config.authOptions.clientId, request);
        return invokeAsync(this.executePostToTokenEndpoint.bind(this), PerformanceEvents.RefreshTokenClientExecutePostToTokenEndpoint, this.logger, this.performanceClient, request.correlationId)(endpoint, requestBody, headers, thumbprint, request.correlationId, PerformanceEvents.RefreshTokenClientExecutePostToTokenEndpoint);
      }
      /**
       * Helper function to create the token request body
       * @param request
       */
      async createTokenRequestBody(request) {
        var _a3, _b2, _c2;
        (_a3 = this.performanceClient) == null ? void 0 : _a3.addQueueMeasurement(PerformanceEvents.RefreshTokenClientCreateTokenRequestBody, request.correlationId);
        const parameters = /* @__PURE__ */ new Map();
        addClientId(parameters, request.embeddedClientId || ((_b2 = request.tokenBodyParameters) == null ? void 0 : _b2[CLIENT_ID]) || this.config.authOptions.clientId);
        if (request.redirectUri) {
          addRedirectUri(parameters, request.redirectUri);
        }
        addScopes(parameters, request.scopes, true, (_c2 = this.config.authOptions.authority.options.OIDCOptions) == null ? void 0 : _c2.defaultScopes);
        addGrantType(parameters, GrantType.REFRESH_TOKEN_GRANT);
        addClientInfo(parameters);
        addLibraryInfo(parameters, this.config.libraryInfo);
        addApplicationTelemetry(parameters, this.config.telemetry.application);
        addThrottling(parameters);
        if (this.serverTelemetryManager && !isOidcProtocolMode(this.config)) {
          addServerTelemetry(parameters, this.serverTelemetryManager);
        }
        addRefreshToken(parameters, request.refreshToken);
        if (this.config.clientCredentials.clientSecret) {
          addClientSecret(parameters, this.config.clientCredentials.clientSecret);
        }
        if (this.config.clientCredentials.clientAssertion) {
          const clientAssertion = this.config.clientCredentials.clientAssertion;
          addClientAssertion(parameters, await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request.resourceRequestUri));
          addClientAssertionType(parameters, clientAssertion.assertionType);
        }
        if (request.authenticationScheme === AuthenticationScheme.POP) {
          const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);
          let reqCnfData;
          if (!request.popKid) {
            const generatedReqCnfData = await invokeAsync(popTokenGenerator.generateCnf.bind(popTokenGenerator), PerformanceEvents.PopTokenGenerateCnf, this.logger, this.performanceClient, request.correlationId)(request, this.logger);
            reqCnfData = generatedReqCnfData.reqCnfString;
          } else {
            reqCnfData = this.cryptoUtils.encodeKid(request.popKid);
          }
          addPopToken(parameters, reqCnfData);
        } else if (request.authenticationScheme === AuthenticationScheme.SSH) {
          if (request.sshJwk) {
            addSshJwk(parameters, request.sshJwk);
          } else {
            throw createClientConfigurationError(missingSshJwk);
          }
        }
        if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
          addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);
        }
        if (this.config.systemOptions.preventCorsPreflight && request.ccsCredential) {
          switch (request.ccsCredential.type) {
            case CcsCredentialType.HOME_ACCOUNT_ID:
              try {
                const clientInfo = buildClientInfoFromHomeAccountId(request.ccsCredential.credential);
                addCcsOid(parameters, clientInfo);
              } catch (e) {
                this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
              }
              break;
            case CcsCredentialType.UPN:
              addCcsUpn(parameters, request.ccsCredential.credential);
              break;
          }
        }
        if (request.embeddedClientId) {
          addBrokerParameters(parameters, this.config.authOptions.clientId, this.config.authOptions.redirectUri);
        }
        if (request.tokenBodyParameters) {
          addExtraQueryParameters(parameters, request.tokenBodyParameters);
        }
        instrumentBrokerParams(parameters, request.correlationId, this.performanceClient);
        return mapToQueryString(parameters);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/client/SilentFlowClient.mjs
var SilentFlowClient;
var init_SilentFlowClient = __esm({
  "node_modules/@azure/msal-common/dist/client/SilentFlowClient.mjs"() {
    "use strict";
    init_BaseClient();
    init_TimeUtils();
    init_ClientAuthError();
    init_ResponseHandler();
    init_Constants();
    init_StringUtils();
    init_AuthToken();
    init_PerformanceEvent();
    init_FunctionWrappers();
    init_Authority();
    init_ClientAuthErrorCodes();
    SilentFlowClient = class extends BaseClient {
      constructor(configuration, performanceClient) {
        super(configuration, performanceClient);
      }
      /**
       * Retrieves token from cache or throws an error if it must be refreshed.
       * @param request
       */
      async acquireCachedToken(request) {
        var _a3;
        (_a3 = this.performanceClient) == null ? void 0 : _a3.addQueueMeasurement(PerformanceEvents.SilentFlowClientAcquireCachedToken, request.correlationId);
        let lastCacheOutcome = CacheOutcome.NOT_APPLICABLE;
        if (request.forceRefresh || !this.config.cacheOptions.claimsBasedCachingEnabled && !StringUtils.isEmptyObj(request.claims)) {
          this.setCacheOutcome(CacheOutcome.FORCE_REFRESH_OR_CLAIMS, request.correlationId);
          throw createClientAuthError(tokenRefreshRequired);
        }
        if (!request.account) {
          throw createClientAuthError(noAccountInSilentRequest);
        }
        const requestTenantId = request.account.tenantId || getTenantFromAuthorityString(request.authority);
        const tokenKeys = this.cacheManager.getTokenKeys();
        const cachedAccessToken = this.cacheManager.getAccessToken(request.account, request, tokenKeys, requestTenantId);
        if (!cachedAccessToken) {
          this.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN, request.correlationId);
          throw createClientAuthError(tokenRefreshRequired);
        } else if (wasClockTurnedBack(cachedAccessToken.cachedAt) || isTokenExpired(cachedAccessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {
          this.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED, request.correlationId);
          throw createClientAuthError(tokenRefreshRequired);
        } else if (cachedAccessToken.refreshOn && isTokenExpired(cachedAccessToken.refreshOn, 0)) {
          lastCacheOutcome = CacheOutcome.PROACTIVELY_REFRESHED;
        }
        const environment = request.authority || this.authority.getPreferredCache();
        const cacheRecord = {
          account: this.cacheManager.readAccountFromCache(request.account, request.correlationId),
          accessToken: cachedAccessToken,
          idToken: this.cacheManager.getIdToken(request.account, request.correlationId, tokenKeys, requestTenantId, this.performanceClient),
          refreshToken: null,
          appMetadata: this.cacheManager.readAppMetadataFromCache(environment)
        };
        this.setCacheOutcome(lastCacheOutcome, request.correlationId);
        if (this.config.serverTelemetryManager) {
          this.config.serverTelemetryManager.incrementCacheHits();
        }
        return [
          await invokeAsync(this.generateResultFromCacheRecord.bind(this), PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord, this.logger, this.performanceClient, request.correlationId)(cacheRecord, request),
          lastCacheOutcome
        ];
      }
      setCacheOutcome(cacheOutcome, correlationId) {
        var _a3, _b2;
        (_a3 = this.serverTelemetryManager) == null ? void 0 : _a3.setCacheOutcome(cacheOutcome);
        (_b2 = this.performanceClient) == null ? void 0 : _b2.addFields({
          cacheOutcome
        }, correlationId);
        if (cacheOutcome !== CacheOutcome.NOT_APPLICABLE) {
          this.logger.info(`Token refresh is required due to cache outcome: ${cacheOutcome}`);
        }
      }
      /**
       * Helper function to build response object from the CacheRecord
       * @param cacheRecord
       */
      async generateResultFromCacheRecord(cacheRecord, request) {
        var _a3;
        (_a3 = this.performanceClient) == null ? void 0 : _a3.addQueueMeasurement(PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord, request.correlationId);
        let idTokenClaims;
        if (cacheRecord.idToken) {
          idTokenClaims = extractTokenClaims(cacheRecord.idToken.secret, this.config.cryptoInterface.base64Decode);
        }
        if (request.maxAge || request.maxAge === 0) {
          const authTime = idTokenClaims == null ? void 0 : idTokenClaims.auth_time;
          if (!authTime) {
            throw createClientAuthError(authTimeNotFound);
          }
          checkMaxAge(authTime, request.maxAge);
        }
        return ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, cacheRecord, true, request, idTokenClaims);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/network/INetworkModule.mjs
var StubbedNetworkModule;
var init_INetworkModule = __esm({
  "node_modules/@azure/msal-common/dist/network/INetworkModule.mjs"() {
    "use strict";
    init_ClientAuthError();
    init_ClientAuthErrorCodes();
    StubbedNetworkModule = {
      sendGetRequestAsync: () => {
        return Promise.reject(createClientAuthError(methodNotImplemented));
      },
      sendPostRequestAsync: () => {
        return Promise.reject(createClientAuthError(methodNotImplemented));
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/protocol/Authorize.mjs
var Authorize_exports = {};
__export(Authorize_exports, {
  getAuthorizationCodePayload: () => getAuthorizationCodePayload,
  getAuthorizeUrl: () => getAuthorizeUrl,
  getStandardAuthorizeRequestParameters: () => getStandardAuthorizeRequestParameters,
  validateAuthorizationResponse: () => validateAuthorizationResponse
});
function getStandardAuthorizeRequestParameters(authOptions, request, logger24, performanceClient) {
  var _a3, _b2;
  const correlationId = request.correlationId;
  const parameters = /* @__PURE__ */ new Map();
  addClientId(parameters, request.embeddedClientId || ((_a3 = request.extraQueryParameters) == null ? void 0 : _a3[CLIENT_ID]) || authOptions.clientId);
  const requestScopes = [
    ...request.scopes || [],
    ...request.extraScopesToConsent || []
  ];
  addScopes(parameters, requestScopes, true, (_b2 = authOptions.authority.options.OIDCOptions) == null ? void 0 : _b2.defaultScopes);
  addRedirectUri(parameters, request.redirectUri);
  addCorrelationId(parameters, correlationId);
  addResponseMode(parameters, request.responseMode);
  addClientInfo(parameters);
  if (request.prompt) {
    addPrompt(parameters, request.prompt);
    performanceClient == null ? void 0 : performanceClient.addFields({ prompt: request.prompt }, correlationId);
  }
  if (request.domainHint) {
    addDomainHint(parameters, request.domainHint);
    performanceClient == null ? void 0 : performanceClient.addFields({ domainHintFromRequest: true }, correlationId);
  }
  if (request.prompt !== PromptValue.SELECT_ACCOUNT) {
    if (request.sid && request.prompt === PromptValue.NONE) {
      logger24.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from request");
      addSid(parameters, request.sid);
      performanceClient == null ? void 0 : performanceClient.addFields({ sidFromRequest: true }, correlationId);
    } else if (request.account) {
      const accountSid = extractAccountSid(request.account);
      let accountLoginHintClaim = extractLoginHint(request.account);
      if (accountLoginHintClaim && request.domainHint) {
        logger24.warning(`AuthorizationCodeClient.createAuthCodeUrlQueryString: "domainHint" param is set, skipping opaque "login_hint" claim. Please consider not passing domainHint`);
        accountLoginHintClaim = null;
      }
      if (accountLoginHintClaim) {
        logger24.verbose("createAuthCodeUrlQueryString: login_hint claim present on account");
        addLoginHint(parameters, accountLoginHintClaim);
        performanceClient == null ? void 0 : performanceClient.addFields({ loginHintFromClaim: true }, correlationId);
        try {
          const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
          addCcsOid(parameters, clientInfo);
        } catch (e) {
          logger24.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
        }
      } else if (accountSid && request.prompt === PromptValue.NONE) {
        logger24.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from account");
        addSid(parameters, accountSid);
        performanceClient == null ? void 0 : performanceClient.addFields({ sidFromClaim: true }, correlationId);
        try {
          const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
          addCcsOid(parameters, clientInfo);
        } catch (e) {
          logger24.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
        }
      } else if (request.loginHint) {
        logger24.verbose("createAuthCodeUrlQueryString: Adding login_hint from request");
        addLoginHint(parameters, request.loginHint);
        addCcsUpn(parameters, request.loginHint);
        performanceClient == null ? void 0 : performanceClient.addFields({ loginHintFromRequest: true }, correlationId);
      } else if (request.account.username) {
        logger24.verbose("createAuthCodeUrlQueryString: Adding login_hint from account");
        addLoginHint(parameters, request.account.username);
        performanceClient == null ? void 0 : performanceClient.addFields({ loginHintFromUpn: true }, correlationId);
        try {
          const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
          addCcsOid(parameters, clientInfo);
        } catch (e) {
          logger24.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
        }
      }
    } else if (request.loginHint) {
      logger24.verbose("createAuthCodeUrlQueryString: No account, adding login_hint from request");
      addLoginHint(parameters, request.loginHint);
      addCcsUpn(parameters, request.loginHint);
      performanceClient == null ? void 0 : performanceClient.addFields({ loginHintFromRequest: true }, correlationId);
    }
  } else {
    logger24.verbose("createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints");
  }
  if (request.nonce) {
    addNonce(parameters, request.nonce);
  }
  if (request.state) {
    addState(parameters, request.state);
  }
  if (request.claims || authOptions.clientCapabilities && authOptions.clientCapabilities.length > 0) {
    addClaims(parameters, request.claims, authOptions.clientCapabilities);
  }
  if (request.embeddedClientId) {
    addBrokerParameters(parameters, authOptions.clientId, authOptions.redirectUri);
  }
  if (authOptions.instanceAware && (!request.extraQueryParameters || !Object.keys(request.extraQueryParameters).includes(INSTANCE_AWARE))) {
    addInstanceAware(parameters);
  }
  return parameters;
}
function getAuthorizeUrl(authority, requestParameters, encodeParams, extraQueryParameters) {
  const queryString = mapToQueryString(requestParameters, encodeParams, extraQueryParameters);
  return UrlString.appendQueryString(authority.authorizationEndpoint, queryString);
}
function getAuthorizationCodePayload(serverParams, cachedState) {
  validateAuthorizationResponse(serverParams, cachedState);
  if (!serverParams.code) {
    throw createClientAuthError(authorizationCodeMissingFromServerResponse);
  }
  return serverParams;
}
function validateAuthorizationResponse(serverResponse, requestState) {
  if (!serverResponse.state || !requestState) {
    throw serverResponse.state ? createClientAuthError(stateNotFound, "Cached State") : createClientAuthError(stateNotFound, "Server State");
  }
  let decodedServerResponseState;
  let decodedRequestState;
  try {
    decodedServerResponseState = decodeURIComponent(serverResponse.state);
  } catch (e) {
    throw createClientAuthError(invalidState, serverResponse.state);
  }
  try {
    decodedRequestState = decodeURIComponent(requestState);
  } catch (e) {
    throw createClientAuthError(invalidState, serverResponse.state);
  }
  if (decodedServerResponseState !== decodedRequestState) {
    throw createClientAuthError(stateMismatch);
  }
  if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {
    const serverErrorNo = parseServerErrorNo(serverResponse);
    if (isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {
      throw new InteractionRequiredAuthError(serverResponse.error || "", serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || "", serverResponse.trace_id || "", serverResponse.correlation_id || "", serverResponse.claims || "", serverErrorNo);
    }
    throw new ServerError(serverResponse.error || "", serverResponse.error_description, serverResponse.suberror, serverErrorNo);
  }
}
function parseServerErrorNo(serverResponse) {
  var _a3, _b2;
  const errorCodePrefix = "code=";
  const errorCodePrefixIndex = (_a3 = serverResponse.error_uri) == null ? void 0 : _a3.lastIndexOf(errorCodePrefix);
  return errorCodePrefixIndex && errorCodePrefixIndex >= 0 ? (_b2 = serverResponse.error_uri) == null ? void 0 : _b2.substring(errorCodePrefixIndex + errorCodePrefix.length) : void 0;
}
function extractAccountSid(account) {
  var _a3;
  return ((_a3 = account.idTokenClaims) == null ? void 0 : _a3.sid) || null;
}
function extractLoginHint(account) {
  var _a3;
  return ((_a3 = account.idTokenClaims) == null ? void 0 : _a3.login_hint) || null;
}
var init_Authorize = __esm({
  "node_modules/@azure/msal-common/dist/protocol/Authorize.mjs"() {
    "use strict";
    init_RequestParameterBuilder();
    init_AADServerParamKeys();
    init_Constants();
    init_ClientInfo();
    init_UrlUtils();
    init_UrlString();
    init_ClientAuthError();
    init_InteractionRequiredAuthError();
    init_ServerError();
    init_ClientAuthErrorCodes();
  }
});

// node_modules/@azure/msal-common/dist/request/AuthenticationHeaderParser.mjs
var AuthenticationHeaderParser;
var init_AuthenticationHeaderParser = __esm({
  "node_modules/@azure/msal-common/dist/request/AuthenticationHeaderParser.mjs"() {
    "use strict";
    init_ClientConfigurationError();
    init_Constants();
    init_ClientConfigurationErrorCodes();
    AuthenticationHeaderParser = class {
      constructor(headers) {
        this.headers = headers;
      }
      /**
       * This method parses the SHR nonce value out of either the Authentication-Info or WWW-Authenticate authentication headers.
       * @returns
       */
      getShrNonce() {
        const authenticationInfo = this.headers[HeaderNames.AuthenticationInfo];
        if (authenticationInfo) {
          const authenticationInfoChallenges = this.parseChallenges(authenticationInfo);
          if (authenticationInfoChallenges.nextnonce) {
            return authenticationInfoChallenges.nextnonce;
          }
          throw createClientConfigurationError(invalidAuthenticationHeader);
        }
        const wwwAuthenticate = this.headers[HeaderNames.WWWAuthenticate];
        if (wwwAuthenticate) {
          const wwwAuthenticateChallenges = this.parseChallenges(wwwAuthenticate);
          if (wwwAuthenticateChallenges.nonce) {
            return wwwAuthenticateChallenges.nonce;
          }
          throw createClientConfigurationError(invalidAuthenticationHeader);
        }
        throw createClientConfigurationError(missingNonceAuthenticationHeader);
      }
      /**
       * Parses an HTTP header's challenge set into a key/value map.
       * @param header
       * @returns
       */
      parseChallenges(header) {
        const schemeSeparator = header.indexOf(" ");
        const challenges = header.substr(schemeSeparator + 1).split(",");
        const challengeMap = {};
        challenges.forEach((challenge) => {
          const [key, value] = challenge.split("=");
          challengeMap[key] = unescape(value.replace(/['"]+/g, Constants.EMPTY_STRING));
        });
        return challengeMap;
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/telemetry/server/ServerTelemetryManager.mjs
function makeExtraSkuString(params) {
  const { skus, libraryName, libraryVersion, extensionName, extensionVersion } = params;
  const skuMap = /* @__PURE__ */ new Map([
    [0, [libraryName, libraryVersion]],
    [2, [extensionName, extensionVersion]]
  ]);
  let skuArr = [];
  if (skus == null ? void 0 : skus.length) {
    skuArr = skus.split(skuGroupSeparator);
    if (skuArr.length < 4) {
      return skus;
    }
  } else {
    skuArr = Array.from({ length: 4 }, () => skuValueSeparator);
  }
  skuMap.forEach((value, key) => {
    var _a3, _b2;
    if (value.length === 2 && ((_a3 = value[0]) == null ? void 0 : _a3.length) && ((_b2 = value[1]) == null ? void 0 : _b2.length)) {
      setSku({
        skuArr,
        index: key,
        skuName: value[0],
        skuVersion: value[1]
      });
    }
  });
  return skuArr.join(skuGroupSeparator);
}
function setSku(params) {
  const { skuArr, index, skuName, skuVersion } = params;
  if (index >= skuArr.length) {
    return;
  }
  skuArr[index] = [skuName, skuVersion].join(skuValueSeparator);
}
var skuGroupSeparator, skuValueSeparator, ServerTelemetryManager;
var init_ServerTelemetryManager = __esm({
  "node_modules/@azure/msal-common/dist/telemetry/server/ServerTelemetryManager.mjs"() {
    "use strict";
    init_Constants();
    init_AuthError();
    skuGroupSeparator = ",";
    skuValueSeparator = "|";
    ServerTelemetryManager = class _ServerTelemetryManager {
      constructor(telemetryRequest, cacheManager) {
        this.cacheOutcome = CacheOutcome.NOT_APPLICABLE;
        this.cacheManager = cacheManager;
        this.apiId = telemetryRequest.apiId;
        this.correlationId = telemetryRequest.correlationId;
        this.wrapperSKU = telemetryRequest.wrapperSKU || Constants.EMPTY_STRING;
        this.wrapperVer = telemetryRequest.wrapperVer || Constants.EMPTY_STRING;
        this.telemetryCacheKey = SERVER_TELEM_CONSTANTS.CACHE_KEY + Separators.CACHE_KEY_SEPARATOR + telemetryRequest.clientId;
      }
      /**
       * API to add MSER Telemetry to request
       */
      generateCurrentRequestHeaderValue() {
        const request = `${this.apiId}${SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR}${this.cacheOutcome}`;
        const platformFieldsArr = [this.wrapperSKU, this.wrapperVer];
        const nativeBrokerErrorCode = this.getNativeBrokerErrorCode();
        if (nativeBrokerErrorCode == null ? void 0 : nativeBrokerErrorCode.length) {
          platformFieldsArr.push(`broker_error=${nativeBrokerErrorCode}`);
        }
        const platformFields = platformFieldsArr.join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        const regionDiscoveryFields = this.getRegionDiscoveryFields();
        const requestWithRegionDiscoveryFields = [
          request,
          regionDiscoveryFields
        ].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        return [
          SERVER_TELEM_CONSTANTS.SCHEMA_VERSION,
          requestWithRegionDiscoveryFields,
          platformFields
        ].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);
      }
      /**
       * API to add MSER Telemetry for the last failed request
       */
      generateLastRequestHeaderValue() {
        const lastRequests = this.getLastRequests();
        const maxErrors = _ServerTelemetryManager.maxErrorsToSend(lastRequests);
        const failedRequests = lastRequests.failedRequests.slice(0, 2 * maxErrors).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        const errors = lastRequests.errors.slice(0, maxErrors).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        const errorCount = lastRequests.errors.length;
        const overflow = maxErrors < errorCount ? SERVER_TELEM_CONSTANTS.OVERFLOW_TRUE : SERVER_TELEM_CONSTANTS.OVERFLOW_FALSE;
        const platformFields = [errorCount, overflow].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        return [
          SERVER_TELEM_CONSTANTS.SCHEMA_VERSION,
          lastRequests.cacheHits,
          failedRequests,
          errors,
          platformFields
        ].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);
      }
      /**
       * API to cache token failures for MSER data capture
       * @param error
       */
      cacheFailedRequest(error) {
        const lastRequests = this.getLastRequests();
        if (lastRequests.errors.length >= SERVER_TELEM_CONSTANTS.MAX_CACHED_ERRORS) {
          lastRequests.failedRequests.shift();
          lastRequests.failedRequests.shift();
          lastRequests.errors.shift();
        }
        lastRequests.failedRequests.push(this.apiId, this.correlationId);
        if (error instanceof Error && !!error && error.toString()) {
          if (error instanceof AuthError) {
            if (error.subError) {
              lastRequests.errors.push(error.subError);
            } else if (error.errorCode) {
              lastRequests.errors.push(error.errorCode);
            } else {
              lastRequests.errors.push(error.toString());
            }
          } else {
            lastRequests.errors.push(error.toString());
          }
        } else {
          lastRequests.errors.push(SERVER_TELEM_CONSTANTS.UNKNOWN_ERROR);
        }
        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests, this.correlationId);
        return;
      }
      /**
       * Update server telemetry cache entry by incrementing cache hit counter
       */
      incrementCacheHits() {
        const lastRequests = this.getLastRequests();
        lastRequests.cacheHits += 1;
        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests, this.correlationId);
        return lastRequests.cacheHits;
      }
      /**
       * Get the server telemetry entity from cache or initialize a new one
       */
      getLastRequests() {
        const initialValue = {
          failedRequests: [],
          errors: [],
          cacheHits: 0
        };
        const lastRequests = this.cacheManager.getServerTelemetry(this.telemetryCacheKey);
        return lastRequests || initialValue;
      }
      /**
       * Remove server telemetry cache entry
       */
      clearTelemetryCache() {
        const lastRequests = this.getLastRequests();
        const numErrorsFlushed = _ServerTelemetryManager.maxErrorsToSend(lastRequests);
        const errorCount = lastRequests.errors.length;
        if (numErrorsFlushed === errorCount) {
          this.cacheManager.removeItem(this.telemetryCacheKey, this.correlationId);
        } else {
          const serverTelemEntity = {
            failedRequests: lastRequests.failedRequests.slice(numErrorsFlushed * 2),
            errors: lastRequests.errors.slice(numErrorsFlushed),
            cacheHits: 0
          };
          this.cacheManager.setServerTelemetry(this.telemetryCacheKey, serverTelemEntity, this.correlationId);
        }
      }
      /**
       * Returns the maximum number of errors that can be flushed to the server in the next network request
       * @param serverTelemetryEntity
       */
      static maxErrorsToSend(serverTelemetryEntity) {
        let i;
        let maxErrors = 0;
        let dataSize = 0;
        const errorCount = serverTelemetryEntity.errors.length;
        for (i = 0; i < errorCount; i++) {
          const apiId = serverTelemetryEntity.failedRequests[2 * i] || Constants.EMPTY_STRING;
          const correlationId = serverTelemetryEntity.failedRequests[2 * i + 1] || Constants.EMPTY_STRING;
          const errorCode = serverTelemetryEntity.errors[i] || Constants.EMPTY_STRING;
          dataSize += apiId.toString().length + correlationId.toString().length + errorCode.length + 3;
          if (dataSize < SERVER_TELEM_CONSTANTS.MAX_LAST_HEADER_BYTES) {
            maxErrors += 1;
          } else {
            break;
          }
        }
        return maxErrors;
      }
      /**
       * Get the region discovery fields
       *
       * @returns string
       */
      getRegionDiscoveryFields() {
        const regionDiscoveryFields = [];
        regionDiscoveryFields.push(this.regionUsed || Constants.EMPTY_STRING);
        regionDiscoveryFields.push(this.regionSource || Constants.EMPTY_STRING);
        regionDiscoveryFields.push(this.regionOutcome || Constants.EMPTY_STRING);
        return regionDiscoveryFields.join(",");
      }
      /**
       * Update the region discovery metadata
       *
       * @param regionDiscoveryMetadata
       * @returns void
       */
      updateRegionDiscoveryMetadata(regionDiscoveryMetadata) {
        this.regionUsed = regionDiscoveryMetadata.region_used;
        this.regionSource = regionDiscoveryMetadata.region_source;
        this.regionOutcome = regionDiscoveryMetadata.region_outcome;
      }
      /**
       * Set cache outcome
       */
      setCacheOutcome(cacheOutcome) {
        this.cacheOutcome = cacheOutcome;
      }
      setNativeBrokerErrorCode(errorCode) {
        const lastRequests = this.getLastRequests();
        lastRequests.nativeBrokerErrorCode = errorCode;
        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests, this.correlationId);
      }
      getNativeBrokerErrorCode() {
        return this.getLastRequests().nativeBrokerErrorCode;
      }
      clearNativeBrokerErrorCode() {
        const lastRequests = this.getLastRequests();
        delete lastRequests.nativeBrokerErrorCode;
        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests, this.correlationId);
      }
      static makeExtraSkuString(params) {
        return makeExtraSkuString(params);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/error/JoseHeaderErrorCodes.mjs
var missingKidError, missingAlgError;
var init_JoseHeaderErrorCodes = __esm({
  "node_modules/@azure/msal-common/dist/error/JoseHeaderErrorCodes.mjs"() {
    "use strict";
    missingKidError = "missing_kid_error";
    missingAlgError = "missing_alg_error";
  }
});

// node_modules/@azure/msal-common/dist/error/JoseHeaderError.mjs
function createJoseHeaderError(code) {
  return new JoseHeaderError(code, JoseHeaderErrorMessages[code]);
}
var JoseHeaderErrorMessages, JoseHeaderError;
var init_JoseHeaderError = __esm({
  "node_modules/@azure/msal-common/dist/error/JoseHeaderError.mjs"() {
    "use strict";
    init_AuthError();
    init_JoseHeaderErrorCodes();
    JoseHeaderErrorMessages = {
      [missingKidError]: "The JOSE Header for the requested JWT, JWS or JWK object requires a keyId to be configured as the 'kid' header claim. No 'kid' value was provided.",
      [missingAlgError]: "The JOSE Header for the requested JWT, JWS or JWK object requires an algorithm to be specified as the 'alg' header claim. No 'alg' value was provided."
    };
    JoseHeaderError = class _JoseHeaderError extends AuthError {
      constructor(errorCode, errorMessage2) {
        super(errorCode, errorMessage2);
        this.name = "JoseHeaderError";
        Object.setPrototypeOf(this, _JoseHeaderError.prototype);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/crypto/JoseHeader.mjs
var JoseHeader;
var init_JoseHeader = __esm({
  "node_modules/@azure/msal-common/dist/crypto/JoseHeader.mjs"() {
    "use strict";
    init_JoseHeaderError();
    init_Constants();
    init_JoseHeaderErrorCodes();
    JoseHeader = class _JoseHeader {
      constructor(options) {
        this.typ = options.typ;
        this.alg = options.alg;
        this.kid = options.kid;
      }
      /**
       * Builds SignedHttpRequest formatted JOSE Header from the
       * JOSE Header options provided or previously set on the object and returns
       * the stringified header object.
       * Throws if keyId or algorithm aren't provided since they are required for Access Token Binding.
       * @param shrHeaderOptions
       * @returns
       */
      static getShrHeaderString(shrHeaderOptions) {
        if (!shrHeaderOptions.kid) {
          throw createJoseHeaderError(missingKidError);
        }
        if (!shrHeaderOptions.alg) {
          throw createJoseHeaderError(missingAlgError);
        }
        const shrHeader = new _JoseHeader({
          // Access Token PoP headers must have type pop, but the type header can be overriden for special cases
          typ: shrHeaderOptions.typ || JsonWebTokenTypes.Pop,
          kid: shrHeaderOptions.kid,
          alg: shrHeaderOptions.alg
        });
        return JSON.stringify(shrHeader);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/telemetry/performance/PerformanceClient.mjs
function startContext(event, abbreviations, stack) {
  if (!stack) {
    return;
  }
  stack.push({
    name: abbreviations.get(event.name) || event.name
  });
}
function endContext(event, abbreviations, stack, error) {
  if (!(stack == null ? void 0 : stack.length)) {
    return;
  }
  const peek = (stack2) => {
    return stack2.length ? stack2[stack2.length - 1] : void 0;
  };
  const abbrEventName = abbreviations.get(event.name) || event.name;
  const top = peek(stack);
  if ((top == null ? void 0 : top.name) !== abbrEventName) {
    return;
  }
  const current = stack == null ? void 0 : stack.pop();
  if (!current) {
    return;
  }
  const errorCode = error instanceof AuthError ? error.errorCode : error instanceof Error ? error.name : void 0;
  const subErr = error instanceof AuthError ? error.subError : void 0;
  if (errorCode && current.childErr !== errorCode) {
    current.err = errorCode;
    if (subErr) {
      current.subErr = subErr;
    }
  }
  delete current.name;
  delete current.childErr;
  const context3 = {
    ...current,
    dur: event.durationMs
  };
  if (!event.success) {
    context3.fail = 1;
  }
  const parent = peek(stack);
  if (!parent) {
    return { [abbrEventName]: context3 };
  }
  if (errorCode) {
    parent.childErr = errorCode;
  }
  let childName;
  if (!parent[abbrEventName]) {
    childName = abbrEventName;
  } else {
    const siblings = Object.keys(parent).filter((key) => key.startsWith(abbrEventName)).length;
    childName = `${abbrEventName}_${siblings + 1}`;
  }
  parent[childName] = context3;
  return parent;
}
function addError(error, logger24, event, stackMaxSize = 5) {
  var _a3, _b2;
  if (!(error instanceof Error)) {
    logger24.trace("PerformanceClient.addErrorStack: Input error is not instance of Error", event.correlationId);
    return;
  } else if (error instanceof AuthError) {
    event.errorCode = error.errorCode;
    event.subErrorCode = error.subError;
    if (error instanceof ServerError || error instanceof InteractionRequiredAuthError) {
      event.serverErrorNo = error.errorNo;
    }
    return;
  } else if (error instanceof CacheError) {
    event.errorCode = error.errorCode;
    return;
  } else if ((_a3 = event.errorStack) == null ? void 0 : _a3.length) {
    logger24.trace("PerformanceClient.addErrorStack: Stack already exist", event.correlationId);
    return;
  } else if (!((_b2 = error.stack) == null ? void 0 : _b2.length)) {
    logger24.trace("PerformanceClient.addErrorStack: Input stack is empty", event.correlationId);
    return;
  }
  if (error.stack) {
    event.errorStack = compactStack(error.stack, stackMaxSize);
  }
  event.errorName = error.name;
}
function compactStack(stack, stackMaxSize) {
  if (stackMaxSize < 0) {
    return [];
  }
  const stackArr = stack.split("\n") || [];
  const res = [];
  const firstLine = stackArr[0];
  if (firstLine.startsWith("TypeError: Cannot read property") || firstLine.startsWith("TypeError: Cannot read properties of") || firstLine.startsWith("TypeError: Cannot set property") || firstLine.startsWith("TypeError: Cannot set properties of") || firstLine.endsWith("is not a function")) {
    res.push(compactStackLine(firstLine));
  } else if (firstLine.startsWith("SyntaxError") || firstLine.startsWith("TypeError")) {
    res.push(compactStackLine(
      // Example: SyntaxError: Unexpected token 'e', "test" is not valid JSON -> SyntaxError: Unexpected token <redacted>, <redacted> is not valid JSON
      firstLine.replace(/['].*[']|["].*["]/g, "<redacted>")
    ));
  }
  for (let ix = 1; ix < stackArr.length; ix++) {
    if (res.length >= stackMaxSize) {
      break;
    }
    const line = stackArr[ix];
    res.push(compactStackLine(line));
  }
  return res;
}
function compactStackLine(line) {
  const filePathIx = line.lastIndexOf(" ") + 1;
  if (filePathIx < 1) {
    return line;
  }
  const filePath = line.substring(filePathIx);
  let fileNameIx = filePath.lastIndexOf("/");
  fileNameIx = fileNameIx < 0 ? filePath.lastIndexOf("\\") : fileNameIx;
  if (fileNameIx >= 0) {
    return (line.substring(0, filePathIx) + "(" + filePath.substring(fileNameIx + 1) + (filePath.charAt(filePath.length - 1) === ")" ? "" : ")")).trimStart();
  }
  return line.trimStart();
}
var PerformanceClient;
var init_PerformanceClient = __esm({
  "node_modules/@azure/msal-common/dist/telemetry/performance/PerformanceClient.mjs"() {
    "use strict";
    init_PerformanceEvent();
    init_StubPerformanceClient();
    init_AuthError();
    init_CacheError();
    init_ServerError();
    init_InteractionRequiredAuthError();
    PerformanceClient = class {
      /**
       * Creates an instance of PerformanceClient,
       * an abstract class containing core performance telemetry logic.
       *
       * @constructor
       * @param {string} clientId Client ID of the application
       * @param {string} authority Authority used by the application
       * @param {Logger} logger Logger used by the application
       * @param {string} libraryName Name of the library
       * @param {string} libraryVersion Version of the library
       * @param {ApplicationTelemetry} applicationTelemetry application name and version
       * @param {Set<String>} intFields integer fields to be truncated
       * @param {Map<string, string>} abbreviations event name abbreviations
       */
      constructor(clientId, authority, logger24, libraryName, libraryVersion, applicationTelemetry, intFields, abbreviations) {
        this.authority = authority;
        this.libraryName = libraryName;
        this.libraryVersion = libraryVersion;
        this.applicationTelemetry = applicationTelemetry;
        this.clientId = clientId;
        this.logger = logger24;
        this.callbacks = /* @__PURE__ */ new Map();
        this.eventsByCorrelationId = /* @__PURE__ */ new Map();
        this.eventStack = /* @__PURE__ */ new Map();
        this.queueMeasurements = /* @__PURE__ */ new Map();
        this.preQueueTimeByCorrelationId = /* @__PURE__ */ new Map();
        this.intFields = intFields || /* @__PURE__ */ new Set();
        for (const item of IntFields) {
          this.intFields.add(item);
        }
        this.abbreviations = abbreviations || /* @__PURE__ */ new Map();
        for (const [key, value] of PerformanceEventAbbreviations) {
          this.abbreviations.set(key, value);
        }
      }
      /**
       * Starts and returns an platform-specific implementation of IPerformanceMeasurement.
       * Note: this function can be changed to abstract at the next major version bump.
       *
       * @param {string} measureName
       * @param {string} correlationId
       * @returns {IPerformanceMeasurement}
       * @deprecated This method will be removed in the next major version
       */
      startPerformanceMeasurement(measureName, correlationId) {
        return {};
      }
      /**
       * Gets map of pre-queue times by correlation Id
       *
       * @param {PerformanceEvents} eventName
       * @param {string} correlationId
       * @returns {number}
       */
      getPreQueueTime(eventName, correlationId) {
        const preQueueEvent = this.preQueueTimeByCorrelationId.get(correlationId);
        if (!preQueueEvent) {
          this.logger.trace(`PerformanceClient.getPreQueueTime: no pre-queue times found for correlationId: ${correlationId}, unable to add queue measurement`);
          return;
        } else if (preQueueEvent.name !== eventName) {
          this.logger.trace(`PerformanceClient.getPreQueueTime: no pre-queue time found for ${eventName}, unable to add queue measurement`);
          return;
        }
        return preQueueEvent.time;
      }
      /**
       * Calculates the difference between current time and time when function was queued.
       * Note: It is possible to have 0 as the queue time if the current time and the queued time was the same.
       *
       * @param {number} preQueueTime
       * @param {number} currentTime
       * @returns {number}
       */
      calculateQueuedTime(preQueueTime, currentTime) {
        if (preQueueTime < 1) {
          this.logger.trace(`PerformanceClient: preQueueTime should be a positive integer and not ${preQueueTime}`);
          return 0;
        }
        if (currentTime < 1) {
          this.logger.trace(`PerformanceClient: currentTime should be a positive integer and not ${currentTime}`);
          return 0;
        }
        if (currentTime < preQueueTime) {
          this.logger.trace("PerformanceClient: currentTime is less than preQueueTime, check how time is being retrieved");
          return 0;
        }
        return currentTime - preQueueTime;
      }
      /**
       * Adds queue measurement time to QueueMeasurements array for given correlation ID.
       *
       * @param {PerformanceEvents} eventName
       * @param {?string} correlationId
       * @param {?number} queueTime
       * @param {?boolean} manuallyCompleted - indicator for manually completed queue measurements
       * @returns
       */
      addQueueMeasurement(eventName, correlationId, queueTime, manuallyCompleted) {
        if (!correlationId) {
          this.logger.trace(`PerformanceClient.addQueueMeasurement: correlationId not provided for ${eventName}, cannot add queue measurement`);
          return;
        }
        if (queueTime === 0) {
          this.logger.trace(`PerformanceClient.addQueueMeasurement: queue time provided for ${eventName} is ${queueTime}`);
        } else if (!queueTime) {
          this.logger.trace(`PerformanceClient.addQueueMeasurement: no queue time provided for ${eventName}`);
          return;
        }
        const queueMeasurement = {
          eventName,
          // Always default queue time to 0 for manually completed (improperly instrumented)
          queueTime: manuallyCompleted ? 0 : queueTime,
          manuallyCompleted
        };
        const existingMeasurements = this.queueMeasurements.get(correlationId);
        if (existingMeasurements) {
          existingMeasurements.push(queueMeasurement);
          this.queueMeasurements.set(correlationId, existingMeasurements);
        } else {
          this.logger.trace(`PerformanceClient.addQueueMeasurement: adding correlationId ${correlationId} to queue measurements`);
          const measurementArray = [queueMeasurement];
          this.queueMeasurements.set(correlationId, measurementArray);
        }
        this.preQueueTimeByCorrelationId.delete(correlationId);
      }
      /**
       * Starts measuring performance for a given operation. Returns a function that should be used to end the measurement.
       *
       * @param {PerformanceEvents} measureName
       * @param {?string} [correlationId]
       * @returns {InProgressPerformanceEvent}
       */
      startMeasurement(measureName, correlationId) {
        var _a3, _b2;
        const eventCorrelationId = correlationId || this.generateId();
        if (!correlationId) {
          this.logger.info(`PerformanceClient: No correlation id provided for ${measureName}, generating`, eventCorrelationId);
        }
        this.logger.trace(`PerformanceClient: Performance measurement started for ${measureName}`, eventCorrelationId);
        const inProgressEvent = {
          eventId: this.generateId(),
          status: PerformanceEventStatus.InProgress,
          authority: this.authority,
          libraryName: this.libraryName,
          libraryVersion: this.libraryVersion,
          clientId: this.clientId,
          name: measureName,
          startTimeMs: Date.now(),
          correlationId: eventCorrelationId,
          appName: (_a3 = this.applicationTelemetry) == null ? void 0 : _a3.appName,
          appVersion: (_b2 = this.applicationTelemetry) == null ? void 0 : _b2.appVersion
        };
        this.cacheEventByCorrelationId(inProgressEvent);
        startContext(inProgressEvent, this.abbreviations, this.eventStack.get(eventCorrelationId));
        return {
          end: (event, error) => {
            return this.endMeasurement({
              // Initial set of event properties
              ...inProgressEvent,
              // Properties set when event ends
              ...event
            }, error);
          },
          discard: () => {
            return this.discardMeasurements(inProgressEvent.correlationId);
          },
          add: (fields) => {
            return this.addFields(fields, inProgressEvent.correlationId);
          },
          increment: (fields) => {
            return this.incrementFields(fields, inProgressEvent.correlationId);
          },
          event: inProgressEvent,
          measurement: new StubPerformanceMeasurement()
        };
      }
      /**
       * Stops measuring the performance for an operation. Should only be called directly by PerformanceClient classes,
       * as consumers should instead use the function returned by startMeasurement.
       * Adds a new field named as "[event name]DurationMs" for sub-measurements, completes and emits an event
       * otherwise.
       *
       * @param {PerformanceEvent} event
       * @param {unknown} error
       * @returns {(PerformanceEvent | null)}
       */
      endMeasurement(event, error) {
        var _a3, _b2;
        const rootEvent = this.eventsByCorrelationId.get(event.correlationId);
        if (!rootEvent) {
          this.logger.trace(`PerformanceClient: Measurement not found for ${event.eventId}`, event.correlationId);
          return null;
        }
        const isRoot = event.eventId === rootEvent.eventId;
        let queueInfo = {
          totalQueueTime: 0,
          totalQueueCount: 0,
          manuallyCompletedCount: 0
        };
        event.durationMs = Math.round(event.durationMs || this.getDurationMs(event.startTimeMs));
        const context3 = JSON.stringify(endContext(event, this.abbreviations, this.eventStack.get(rootEvent.correlationId), error));
        if (isRoot) {
          queueInfo = this.getQueueInfo(event.correlationId);
          this.discardMeasurements(rootEvent.correlationId);
        } else {
          (_a3 = rootEvent.incompleteSubMeasurements) == null ? void 0 : _a3.delete(event.eventId);
        }
        this.logger.trace(`PerformanceClient: Performance measurement ended for ${event.name}: ${event.durationMs} ms`, event.correlationId);
        if (error) {
          addError(error, this.logger, rootEvent);
        }
        if (!isRoot) {
          rootEvent[event.name + "DurationMs"] = Math.floor(event.durationMs);
          return { ...rootEvent };
        }
        if (isRoot && !error && (rootEvent.errorCode || rootEvent.subErrorCode)) {
          this.logger.trace(`PerformanceClient: Remove error and sub-error codes for root event ${event.name} as intermediate error was successfully handled`, event.correlationId);
          rootEvent.errorCode = void 0;
          rootEvent.subErrorCode = void 0;
        }
        let finalEvent = { ...rootEvent, ...event };
        let incompleteSubsCount = 0;
        (_b2 = finalEvent.incompleteSubMeasurements) == null ? void 0 : _b2.forEach((subMeasurement) => {
          this.logger.trace(`PerformanceClient: Incomplete submeasurement ${subMeasurement.name} found for ${event.name}`, finalEvent.correlationId);
          incompleteSubsCount++;
        });
        finalEvent.incompleteSubMeasurements = void 0;
        finalEvent = {
          ...finalEvent,
          queuedTimeMs: queueInfo.totalQueueTime,
          queuedCount: queueInfo.totalQueueCount,
          queuedManuallyCompletedCount: queueInfo.manuallyCompletedCount,
          status: PerformanceEventStatus.Completed,
          incompleteSubsCount,
          context: context3
        };
        this.truncateIntegralFields(finalEvent);
        this.emitEvents([finalEvent], event.correlationId);
        return finalEvent;
      }
      /**
       * Saves extra information to be emitted when the measurements are flushed
       * @param fields
       * @param correlationId
       */
      addFields(fields, correlationId) {
        this.logger.trace("PerformanceClient: Updating static fields");
        const event = this.eventsByCorrelationId.get(correlationId);
        if (event) {
          this.eventsByCorrelationId.set(correlationId, {
            ...event,
            ...fields
          });
        } else {
          this.logger.trace("PerformanceClient: Event not found for", correlationId);
        }
      }
      /**
       * Increment counters to be emitted when the measurements are flushed
       * @param fields {string[]}
       * @param correlationId {string} correlation identifier
       */
      incrementFields(fields, correlationId) {
        this.logger.trace("PerformanceClient: Updating counters");
        const event = this.eventsByCorrelationId.get(correlationId);
        if (event) {
          for (const counter in fields) {
            if (!event.hasOwnProperty(counter)) {
              event[counter] = 0;
            } else if (isNaN(Number(event[counter]))) {
              return;
            }
            event[counter] += fields[counter];
          }
        } else {
          this.logger.trace("PerformanceClient: Event not found for", correlationId);
        }
      }
      /**
       * Upserts event into event cache.
       * First key is the correlation id, second key is the event id.
       * Allows for events to be grouped by correlation id,
       * and to easily allow for properties on them to be updated.
       *
       * @private
       * @param {PerformanceEvent} event
       */
      cacheEventByCorrelationId(event) {
        const rootEvent = this.eventsByCorrelationId.get(event.correlationId);
        if (rootEvent) {
          this.logger.trace(`PerformanceClient: Performance measurement for ${event.name} added/updated`, event.correlationId);
          rootEvent.incompleteSubMeasurements = rootEvent.incompleteSubMeasurements || /* @__PURE__ */ new Map();
          rootEvent.incompleteSubMeasurements.set(event.eventId, {
            name: event.name,
            startTimeMs: event.startTimeMs
          });
        } else {
          this.logger.trace(`PerformanceClient: Performance measurement for ${event.name} started`, event.correlationId);
          this.eventsByCorrelationId.set(event.correlationId, { ...event });
          this.eventStack.set(event.correlationId, []);
        }
      }
      getQueueInfo(correlationId) {
        const queueMeasurementForCorrelationId = this.queueMeasurements.get(correlationId);
        if (!queueMeasurementForCorrelationId) {
          this.logger.trace(`PerformanceClient: no queue measurements found for for correlationId: ${correlationId}`);
        }
        let totalQueueTime = 0;
        let totalQueueCount = 0;
        let manuallyCompletedCount = 0;
        queueMeasurementForCorrelationId == null ? void 0 : queueMeasurementForCorrelationId.forEach((measurement) => {
          totalQueueTime += measurement.queueTime;
          totalQueueCount++;
          manuallyCompletedCount += measurement.manuallyCompleted ? 1 : 0;
        });
        return {
          totalQueueTime,
          totalQueueCount,
          manuallyCompletedCount
        };
      }
      /**
       * Removes measurements and aux data for a given correlation id.
       *
       * @param {string} correlationId
       */
      discardMeasurements(correlationId) {
        this.logger.trace("PerformanceClient: Performance measurements discarded", correlationId);
        this.eventsByCorrelationId.delete(correlationId);
        this.logger.trace("PerformanceClient: QueueMeasurements discarded", correlationId);
        this.queueMeasurements.delete(correlationId);
        this.logger.trace("PerformanceClient: Pre-queue times discarded", correlationId);
        this.preQueueTimeByCorrelationId.delete(correlationId);
        this.logger.trace("PerformanceClient: Event stack discarded", correlationId);
        this.eventStack.delete(correlationId);
      }
      /**
       * Registers a callback function to receive performance events.
       *
       * @param {PerformanceCallbackFunction} callback
       * @returns {string}
       */
      addPerformanceCallback(callback) {
        for (const [id, cb] of this.callbacks) {
          if (cb.toString() === callback.toString()) {
            this.logger.warning(`PerformanceClient: Performance callback is already registered with id: ${id}`);
            return id;
          }
        }
        const callbackId = this.generateId();
        this.callbacks.set(callbackId, callback);
        this.logger.verbose(`PerformanceClient: Performance callback registered with id: ${callbackId}`);
        return callbackId;
      }
      /**
       * Removes a callback registered with addPerformanceCallback.
       *
       * @param {string} callbackId
       * @returns {boolean}
       */
      removePerformanceCallback(callbackId) {
        const result = this.callbacks.delete(callbackId);
        if (result) {
          this.logger.verbose(`PerformanceClient: Performance callback ${callbackId} removed.`);
        } else {
          this.logger.verbose(`PerformanceClient: Performance callback ${callbackId} not removed.`);
        }
        return result;
      }
      /**
       * Emits events to all registered callbacks.
       *
       * @param {PerformanceEvent[]} events
       * @param {?string} [correlationId]
       */
      emitEvents(events, correlationId) {
        this.logger.verbose("PerformanceClient: Emitting performance events", correlationId);
        this.callbacks.forEach((callback, callbackId) => {
          this.logger.trace(`PerformanceClient: Emitting event to callback ${callbackId}`, correlationId);
          callback.apply(null, [events]);
        });
      }
      /**
       * Enforce truncation of integral fields in performance event.
       * @param {PerformanceEvent} event performance event to update.
       */
      truncateIntegralFields(event) {
        this.intFields.forEach((key) => {
          if (key in event && typeof event[key] === "number") {
            event[key] = Math.floor(event[key]);
          }
        });
      }
      /**
       * Returns event duration in milliseconds
       * @param startTimeMs {number}
       * @returns {number}
       */
      getDurationMs(startTimeMs) {
        const durationMs = Date.now() - startTimeMs;
        return durationMs < 0 ? durationMs : 0;
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/index-browser.mjs
var init_index_browser = __esm({
  "node_modules/@azure/msal-common/dist/index-browser.mjs"() {
    "use strict";
    init_AuthorizationCodeClient();
    init_RefreshTokenClient();
    init_SilentFlowClient();
    init_BaseClient();
    init_ClientConfiguration();
    init_AccountInfo();
    init_TokenClaims();
    init_CcsCredential();
    init_ClientInfo();
    init_Authority();
    init_AuthorityOptions();
    init_AuthorityType();
    init_ProtocolMode();
    init_CacheManager();
    init_AccountEntity();
    init_INetworkModule();
    init_ThrottlingUtils();
    init_RequestThumbprint();
    init_UrlString();
    init_ICrypto();
    init_Authorize();
    init_RequestParameterBuilder();
    init_ResponseHandler();
    init_ScopeSet();
    init_AuthenticationHeaderParser();
    init_Logger();
    init_InteractionRequiredAuthError();
    init_InteractionRequiredAuthErrorCodes();
    init_AuthError();
    init_AuthErrorCodes();
    init_ServerError();
    init_NetworkError();
    init_CacheError();
    init_CacheErrorCodes();
    init_ClientAuthError();
    init_ClientAuthErrorCodes();
    init_ClientConfigurationError();
    init_ClientConfigurationErrorCodes();
    init_Constants();
    init_StringUtils();
    init_ProtocolUtils();
    init_ServerTelemetryManager();
    init_packageMetadata();
    init_FunctionWrappers();
    init_AuthToken();
    init_AuthorityFactory();
    init_CacheHelpers();
    init_TimeUtils();
    init_UrlUtils();
    init_AADServerParamKeys();
    init_JoseHeader();
    init_PerformanceEvent();
    init_PerformanceClient();
    init_StubPerformanceClient();
    init_PopTokenGenerator();
  }
});

// node_modules/@azure/msal-browser/dist/error/BrowserAuthErrorCodes.mjs
var BrowserAuthErrorCodes_exports = {};
__export(BrowserAuthErrorCodes_exports, {
  authCodeOrNativeAccountIdRequired: () => authCodeOrNativeAccountIdRequired,
  authCodeRequired: () => authCodeRequired,
  authRequestNotSetError: () => authRequestNotSetError,
  blockIframeReload: () => blockIframeReload,
  blockNestedPopups: () => blockNestedPopups,
  cryptoKeyNotFound: () => cryptoKeyNotFound,
  cryptoNonExistent: () => cryptoNonExistent,
  databaseNotOpen: () => databaseNotOpen,
  databaseUnavailable: () => databaseUnavailable,
  earJweEmpty: () => earJweEmpty,
  earJwkEmpty: () => earJwkEmpty,
  emptyNavigateUri: () => emptyNavigateUri,
  emptyWindowError: () => emptyWindowError,
  failedToBuildHeaders: () => failedToBuildHeaders,
  failedToDecryptEarResponse: () => failedToDecryptEarResponse,
  failedToParseHeaders: () => failedToParseHeaders,
  failedToParseResponse: () => failedToParseResponse,
  getRequestFailed: () => getRequestFailed,
  hashDoesNotContainKnownProperties: () => hashDoesNotContainKnownProperties,
  hashEmptyError: () => hashEmptyError,
  iframeClosedPrematurely: () => iframeClosedPrematurely,
  interactionInProgress: () => interactionInProgress,
  invalidBase64String: () => invalidBase64String,
  invalidCacheType: () => invalidCacheType,
  invalidPopTokenRequest: () => invalidPopTokenRequest,
  monitorPopupTimeout: () => monitorPopupTimeout,
  monitorWindowTimeout: () => monitorWindowTimeout,
  nativeConnectionNotEstablished: () => nativeConnectionNotEstablished,
  nativeExtensionNotInstalled: () => nativeExtensionNotInstalled,
  nativeHandshakeTimeout: () => nativeHandshakeTimeout,
  nativePromptNotSupported: () => nativePromptNotSupported,
  noAccountError: () => noAccountError,
  noNetworkConnectivity: () => noNetworkConnectivity2,
  noStateInHash: () => noStateInHash,
  noTokenRequestCacheError: () => noTokenRequestCacheError,
  nonBrowserEnvironment: () => nonBrowserEnvironment,
  pkceNotCreated: () => pkceNotCreated,
  popupWindowError: () => popupWindowError,
  postRequestFailed: () => postRequestFailed2,
  redirectInIframe: () => redirectInIframe,
  silentLogoutUnsupported: () => silentLogoutUnsupported,
  silentPromptValueError: () => silentPromptValueError,
  spaCodeAndNativeAccountIdPresent: () => spaCodeAndNativeAccountIdPresent,
  stateInteractionTypeMismatch: () => stateInteractionTypeMismatch,
  timedOut: () => timedOut,
  unableToAcquireTokenFromNativePlatform: () => unableToAcquireTokenFromNativePlatform,
  unableToLoadToken: () => unableToLoadToken,
  unableToParseState: () => unableToParseState,
  unableToParseTokenRequestCacheError: () => unableToParseTokenRequestCacheError,
  uninitializedPublicClientApplication: () => uninitializedPublicClientApplication,
  userCancelled: () => userCancelled
});
var pkceNotCreated, earJwkEmpty, earJweEmpty, cryptoNonExistent, emptyNavigateUri, hashEmptyError, noStateInHash, hashDoesNotContainKnownProperties, unableToParseState, stateInteractionTypeMismatch, interactionInProgress, popupWindowError, emptyWindowError, userCancelled, monitorPopupTimeout, monitorWindowTimeout, redirectInIframe, blockIframeReload, blockNestedPopups, iframeClosedPrematurely, silentLogoutUnsupported, noAccountError, silentPromptValueError, noTokenRequestCacheError, unableToParseTokenRequestCacheError, authRequestNotSetError, invalidCacheType, nonBrowserEnvironment, databaseNotOpen, noNetworkConnectivity2, postRequestFailed2, getRequestFailed, failedToParseResponse, unableToLoadToken, cryptoKeyNotFound, authCodeRequired, authCodeOrNativeAccountIdRequired, spaCodeAndNativeAccountIdPresent, databaseUnavailable, unableToAcquireTokenFromNativePlatform, nativeHandshakeTimeout, nativeExtensionNotInstalled, nativeConnectionNotEstablished, uninitializedPublicClientApplication, nativePromptNotSupported, invalidBase64String, invalidPopTokenRequest, failedToBuildHeaders, failedToParseHeaders, failedToDecryptEarResponse, timedOut;
var init_BrowserAuthErrorCodes = __esm({
  "node_modules/@azure/msal-browser/dist/error/BrowserAuthErrorCodes.mjs"() {
    "use strict";
    pkceNotCreated = "pkce_not_created";
    earJwkEmpty = "ear_jwk_empty";
    earJweEmpty = "ear_jwe_empty";
    cryptoNonExistent = "crypto_nonexistent";
    emptyNavigateUri = "empty_navigate_uri";
    hashEmptyError = "hash_empty_error";
    noStateInHash = "no_state_in_hash";
    hashDoesNotContainKnownProperties = "hash_does_not_contain_known_properties";
    unableToParseState = "unable_to_parse_state";
    stateInteractionTypeMismatch = "state_interaction_type_mismatch";
    interactionInProgress = "interaction_in_progress";
    popupWindowError = "popup_window_error";
    emptyWindowError = "empty_window_error";
    userCancelled = "user_cancelled";
    monitorPopupTimeout = "monitor_popup_timeout";
    monitorWindowTimeout = "monitor_window_timeout";
    redirectInIframe = "redirect_in_iframe";
    blockIframeReload = "block_iframe_reload";
    blockNestedPopups = "block_nested_popups";
    iframeClosedPrematurely = "iframe_closed_prematurely";
    silentLogoutUnsupported = "silent_logout_unsupported";
    noAccountError = "no_account_error";
    silentPromptValueError = "silent_prompt_value_error";
    noTokenRequestCacheError = "no_token_request_cache_error";
    unableToParseTokenRequestCacheError = "unable_to_parse_token_request_cache_error";
    authRequestNotSetError = "auth_request_not_set_error";
    invalidCacheType = "invalid_cache_type";
    nonBrowserEnvironment = "non_browser_environment";
    databaseNotOpen = "database_not_open";
    noNetworkConnectivity2 = "no_network_connectivity";
    postRequestFailed2 = "post_request_failed";
    getRequestFailed = "get_request_failed";
    failedToParseResponse = "failed_to_parse_response";
    unableToLoadToken = "unable_to_load_token";
    cryptoKeyNotFound = "crypto_key_not_found";
    authCodeRequired = "auth_code_required";
    authCodeOrNativeAccountIdRequired = "auth_code_or_nativeAccountId_required";
    spaCodeAndNativeAccountIdPresent = "spa_code_and_nativeAccountId_present";
    databaseUnavailable = "database_unavailable";
    unableToAcquireTokenFromNativePlatform = "unable_to_acquire_token_from_native_platform";
    nativeHandshakeTimeout = "native_handshake_timeout";
    nativeExtensionNotInstalled = "native_extension_not_installed";
    nativeConnectionNotEstablished = "native_connection_not_established";
    uninitializedPublicClientApplication = "uninitialized_public_client_application";
    nativePromptNotSupported = "native_prompt_not_supported";
    invalidBase64String = "invalid_base64_string";
    invalidPopTokenRequest = "invalid_pop_token_request";
    failedToBuildHeaders = "failed_to_build_headers";
    failedToParseHeaders = "failed_to_parse_headers";
    failedToDecryptEarResponse = "failed_to_decrypt_ear_response";
    timedOut = "timed_out";
  }
});

// node_modules/@azure/msal-browser/dist/error/BrowserAuthError.mjs
function createBrowserAuthError(errorCode, subError) {
  return new BrowserAuthError(errorCode, subError);
}
var ErrorLink, BrowserAuthErrorMessages, BrowserAuthErrorMessage, BrowserAuthError;
var init_BrowserAuthError = __esm({
  "node_modules/@azure/msal-browser/dist/error/BrowserAuthError.mjs"() {
    "use strict";
    init_index_browser();
    init_BrowserAuthErrorCodes();
    init_BrowserAuthErrorCodes();
    ErrorLink = "For more visit: aka.ms/msaljs/browser-errors";
    BrowserAuthErrorMessages = {
      [pkceNotCreated]: "The PKCE code challenge and verifier could not be generated.",
      [earJwkEmpty]: "No EAR encryption key provided. This is unexpected.",
      [earJweEmpty]: "Server response does not contain ear_jwe property. This is unexpected.",
      [cryptoNonExistent]: "The crypto object or function is not available.",
      [emptyNavigateUri]: "Navigation URI is empty. Please check stack trace for more info.",
      [hashEmptyError]: `Hash value cannot be processed because it is empty. Please verify that your redirectUri is not clearing the hash. ${ErrorLink}`,
      [noStateInHash]: "Hash does not contain state. Please verify that the request originated from msal.",
      [hashDoesNotContainKnownProperties]: `Hash does not contain known properites. Please verify that your redirectUri is not changing the hash.  ${ErrorLink}`,
      [unableToParseState]: "Unable to parse state. Please verify that the request originated from msal.",
      [stateInteractionTypeMismatch]: "Hash contains state but the interaction type does not match the caller.",
      [interactionInProgress]: `Interaction is currently in progress. Please ensure that this interaction has been completed before calling an interactive API.   ${ErrorLink}`,
      [popupWindowError]: "Error opening popup window. This can happen if you are using IE or if popups are blocked in the browser.",
      [emptyWindowError]: "window.open returned null or undefined window object.",
      [userCancelled]: "User cancelled the flow.",
      [monitorPopupTimeout]: `Token acquisition in popup failed due to timeout.  ${ErrorLink}`,
      [monitorWindowTimeout]: `Token acquisition in iframe failed due to timeout.  ${ErrorLink}`,
      [redirectInIframe]: "Redirects are not supported for iframed or brokered applications. Please ensure you are using MSAL.js in a top frame of the window if using the redirect APIs, or use the popup APIs.",
      [blockIframeReload]: `Request was blocked inside an iframe because MSAL detected an authentication response.  ${ErrorLink}`,
      [blockNestedPopups]: "Request was blocked inside a popup because MSAL detected it was running in a popup.",
      [iframeClosedPrematurely]: "The iframe being monitored was closed prematurely.",
      [silentLogoutUnsupported]: "Silent logout not supported. Please call logoutRedirect or logoutPopup instead.",
      [noAccountError]: "No account object provided to acquireTokenSilent and no active account has been set. Please call setActiveAccount or provide an account on the request.",
      [silentPromptValueError]: "The value given for the prompt value is not valid for silent requests - must be set to 'none' or 'no_session'.",
      [noTokenRequestCacheError]: "No token request found in cache.",
      [unableToParseTokenRequestCacheError]: "The cached token request could not be parsed.",
      [authRequestNotSetError]: "Auth Request not set. Please ensure initiateAuthRequest was called from the InteractionHandler",
      [invalidCacheType]: "Invalid cache type",
      [nonBrowserEnvironment]: "Login and token requests are not supported in non-browser environments.",
      [databaseNotOpen]: "Database is not open!",
      [noNetworkConnectivity2]: "No network connectivity. Check your internet connection.",
      [postRequestFailed2]: "Network request failed: If the browser threw a CORS error, check that the redirectUri is registered in the Azure App Portal as type 'SPA'",
      [getRequestFailed]: "Network request failed. Please check the network trace to determine root cause.",
      [failedToParseResponse]: "Failed to parse network response. Check network trace.",
      [unableToLoadToken]: "Error loading token to cache.",
      [cryptoKeyNotFound]: "Cryptographic Key or Keypair not found in browser storage.",
      [authCodeRequired]: "An authorization code must be provided (as the `code` property on the request) to this flow.",
      [authCodeOrNativeAccountIdRequired]: "An authorization code or nativeAccountId must be provided to this flow.",
      [spaCodeAndNativeAccountIdPresent]: "Request cannot contain both spa code and native account id.",
      [databaseUnavailable]: "IndexedDB, which is required for persistent cryptographic key storage, is unavailable. This may be caused by browser privacy features which block persistent storage in third-party contexts.",
      [unableToAcquireTokenFromNativePlatform]: `Unable to acquire token from native platform.  ${ErrorLink}`,
      [nativeHandshakeTimeout]: "Timed out while attempting to establish connection to browser extension",
      [nativeExtensionNotInstalled]: "Native extension is not installed. If you think this is a mistake call the initialize function.",
      [nativeConnectionNotEstablished]: `Connection to native platform has not been established. Please install a compatible browser extension and run initialize().  ${ErrorLink}`,
      [uninitializedPublicClientApplication]: `You must call and await the initialize function before attempting to call any other MSAL API.  ${ErrorLink}`,
      [nativePromptNotSupported]: "The provided prompt is not supported by the native platform. This request should be routed to the web based flow.",
      [invalidBase64String]: "Invalid base64 encoded string.",
      [invalidPopTokenRequest]: "Invalid PoP token request. The request should not have both a popKid value and signPopToken set to true.",
      [failedToBuildHeaders]: "Failed to build request headers object.",
      [failedToParseHeaders]: "Failed to parse response headers",
      [failedToDecryptEarResponse]: "Failed to decrypt ear response",
      [timedOut]: "The request timed out."
    };
    BrowserAuthErrorMessage = {
      pkceNotGenerated: {
        code: pkceNotCreated,
        desc: BrowserAuthErrorMessages[pkceNotCreated]
      },
      cryptoDoesNotExist: {
        code: cryptoNonExistent,
        desc: BrowserAuthErrorMessages[cryptoNonExistent]
      },
      emptyNavigateUriError: {
        code: emptyNavigateUri,
        desc: BrowserAuthErrorMessages[emptyNavigateUri]
      },
      hashEmptyError: {
        code: hashEmptyError,
        desc: BrowserAuthErrorMessages[hashEmptyError]
      },
      hashDoesNotContainStateError: {
        code: noStateInHash,
        desc: BrowserAuthErrorMessages[noStateInHash]
      },
      hashDoesNotContainKnownPropertiesError: {
        code: hashDoesNotContainKnownProperties,
        desc: BrowserAuthErrorMessages[hashDoesNotContainKnownProperties]
      },
      unableToParseStateError: {
        code: unableToParseState,
        desc: BrowserAuthErrorMessages[unableToParseState]
      },
      stateInteractionTypeMismatchError: {
        code: stateInteractionTypeMismatch,
        desc: BrowserAuthErrorMessages[stateInteractionTypeMismatch]
      },
      interactionInProgress: {
        code: interactionInProgress,
        desc: BrowserAuthErrorMessages[interactionInProgress]
      },
      popupWindowError: {
        code: popupWindowError,
        desc: BrowserAuthErrorMessages[popupWindowError]
      },
      emptyWindowError: {
        code: emptyWindowError,
        desc: BrowserAuthErrorMessages[emptyWindowError]
      },
      userCancelledError: {
        code: userCancelled,
        desc: BrowserAuthErrorMessages[userCancelled]
      },
      monitorPopupTimeoutError: {
        code: monitorPopupTimeout,
        desc: BrowserAuthErrorMessages[monitorPopupTimeout]
      },
      monitorIframeTimeoutError: {
        code: monitorWindowTimeout,
        desc: BrowserAuthErrorMessages[monitorWindowTimeout]
      },
      redirectInIframeError: {
        code: redirectInIframe,
        desc: BrowserAuthErrorMessages[redirectInIframe]
      },
      blockTokenRequestsInHiddenIframeError: {
        code: blockIframeReload,
        desc: BrowserAuthErrorMessages[blockIframeReload]
      },
      blockAcquireTokenInPopupsError: {
        code: blockNestedPopups,
        desc: BrowserAuthErrorMessages[blockNestedPopups]
      },
      iframeClosedPrematurelyError: {
        code: iframeClosedPrematurely,
        desc: BrowserAuthErrorMessages[iframeClosedPrematurely]
      },
      silentLogoutUnsupportedError: {
        code: silentLogoutUnsupported,
        desc: BrowserAuthErrorMessages[silentLogoutUnsupported]
      },
      noAccountError: {
        code: noAccountError,
        desc: BrowserAuthErrorMessages[noAccountError]
      },
      silentPromptValueError: {
        code: silentPromptValueError,
        desc: BrowserAuthErrorMessages[silentPromptValueError]
      },
      noTokenRequestCacheError: {
        code: noTokenRequestCacheError,
        desc: BrowserAuthErrorMessages[noTokenRequestCacheError]
      },
      unableToParseTokenRequestCacheError: {
        code: unableToParseTokenRequestCacheError,
        desc: BrowserAuthErrorMessages[unableToParseTokenRequestCacheError]
      },
      authRequestNotSet: {
        code: authRequestNotSetError,
        desc: BrowserAuthErrorMessages[authRequestNotSetError]
      },
      invalidCacheType: {
        code: invalidCacheType,
        desc: BrowserAuthErrorMessages[invalidCacheType]
      },
      notInBrowserEnvironment: {
        code: nonBrowserEnvironment,
        desc: BrowserAuthErrorMessages[nonBrowserEnvironment]
      },
      databaseNotOpen: {
        code: databaseNotOpen,
        desc: BrowserAuthErrorMessages[databaseNotOpen]
      },
      noNetworkConnectivity: {
        code: noNetworkConnectivity2,
        desc: BrowserAuthErrorMessages[noNetworkConnectivity2]
      },
      postRequestFailed: {
        code: postRequestFailed2,
        desc: BrowserAuthErrorMessages[postRequestFailed2]
      },
      getRequestFailed: {
        code: getRequestFailed,
        desc: BrowserAuthErrorMessages[getRequestFailed]
      },
      failedToParseNetworkResponse: {
        code: failedToParseResponse,
        desc: BrowserAuthErrorMessages[failedToParseResponse]
      },
      unableToLoadTokenError: {
        code: unableToLoadToken,
        desc: BrowserAuthErrorMessages[unableToLoadToken]
      },
      signingKeyNotFoundInStorage: {
        code: cryptoKeyNotFound,
        desc: BrowserAuthErrorMessages[cryptoKeyNotFound]
      },
      authCodeRequired: {
        code: authCodeRequired,
        desc: BrowserAuthErrorMessages[authCodeRequired]
      },
      authCodeOrNativeAccountRequired: {
        code: authCodeOrNativeAccountIdRequired,
        desc: BrowserAuthErrorMessages[authCodeOrNativeAccountIdRequired]
      },
      spaCodeAndNativeAccountPresent: {
        code: spaCodeAndNativeAccountIdPresent,
        desc: BrowserAuthErrorMessages[spaCodeAndNativeAccountIdPresent]
      },
      databaseUnavailable: {
        code: databaseUnavailable,
        desc: BrowserAuthErrorMessages[databaseUnavailable]
      },
      unableToAcquireTokenFromNativePlatform: {
        code: unableToAcquireTokenFromNativePlatform,
        desc: BrowserAuthErrorMessages[unableToAcquireTokenFromNativePlatform]
      },
      nativeHandshakeTimeout: {
        code: nativeHandshakeTimeout,
        desc: BrowserAuthErrorMessages[nativeHandshakeTimeout]
      },
      nativeExtensionNotInstalled: {
        code: nativeExtensionNotInstalled,
        desc: BrowserAuthErrorMessages[nativeExtensionNotInstalled]
      },
      nativeConnectionNotEstablished: {
        code: nativeConnectionNotEstablished,
        desc: BrowserAuthErrorMessages[nativeConnectionNotEstablished]
      },
      uninitializedPublicClientApplication: {
        code: uninitializedPublicClientApplication,
        desc: BrowserAuthErrorMessages[uninitializedPublicClientApplication]
      },
      nativePromptNotSupported: {
        code: nativePromptNotSupported,
        desc: BrowserAuthErrorMessages[nativePromptNotSupported]
      },
      invalidBase64StringError: {
        code: invalidBase64String,
        desc: BrowserAuthErrorMessages[invalidBase64String]
      },
      invalidPopTokenRequest: {
        code: invalidPopTokenRequest,
        desc: BrowserAuthErrorMessages[invalidPopTokenRequest]
      }
    };
    BrowserAuthError = class _BrowserAuthError extends AuthError {
      constructor(errorCode, subError) {
        super(errorCode, BrowserAuthErrorMessages[errorCode], subError);
        Object.setPrototypeOf(this, _BrowserAuthError.prototype);
        this.name = "BrowserAuthError";
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/utils/BrowserConstants.mjs
var BrowserConstants, PlatformAuthConstants, NativeExtensionMethod, BrowserCacheLocation, HTTP_REQUEST_TYPE, INTERACTION_TYPE, TemporaryCacheKeys, StaticCacheKeys, InMemoryCacheKeys, ApiId, InteractionType, InteractionStatus, DEFAULT_REQUEST, KEY_FORMAT_JWK, WrapperSKU, DB_NAME, DB_VERSION, DB_TABLE_NAME, CacheLookupPolicy, iFrameRenewalPolicies, LOG_LEVEL_CACHE_KEY, LOG_PII_CACHE_KEY, BROWSER_PERF_ENABLED_KEY, PLATFORM_AUTH_DOM_SUPPORT;
var init_BrowserConstants = __esm({
  "node_modules/@azure/msal-browser/dist/utils/BrowserConstants.mjs"() {
    "use strict";
    init_index_browser();
    BrowserConstants = {
      /**
       * Invalid grant error code
       */
      INVALID_GRANT_ERROR: "invalid_grant",
      /**
       * Default popup window width
       */
      POPUP_WIDTH: 483,
      /**
       * Default popup window height
       */
      POPUP_HEIGHT: 600,
      /**
       * Name of the popup window starts with
       */
      POPUP_NAME_PREFIX: "msal",
      /**
       * Default popup monitor poll interval in milliseconds
       */
      DEFAULT_POLL_INTERVAL_MS: 30,
      /**
       * Msal-browser SKU
       */
      MSAL_SKU: "msal.js.browser"
    };
    PlatformAuthConstants = {
      CHANNEL_ID: "53ee284d-920a-4b59-9d30-a60315b26836",
      PREFERRED_EXTENSION_ID: "ppnbnpeolgkicgegkbkbjmhlideopiji",
      MATS_TELEMETRY: "MATS",
      MICROSOFT_ENTRA_BROKERID: "MicrosoftEntra",
      DOM_API_NAME: "DOM API",
      PLATFORM_DOM_APIS: "get-token-and-sign-out",
      PLATFORM_DOM_PROVIDER: "PlatformAuthDOMHandler",
      PLATFORM_EXTENSION_PROVIDER: "PlatformAuthExtensionHandler"
    };
    NativeExtensionMethod = {
      HandshakeRequest: "Handshake",
      HandshakeResponse: "HandshakeResponse",
      GetToken: "GetToken",
      Response: "Response"
    };
    BrowserCacheLocation = {
      LocalStorage: "localStorage",
      SessionStorage: "sessionStorage",
      MemoryStorage: "memoryStorage"
    };
    HTTP_REQUEST_TYPE = {
      GET: "GET",
      POST: "POST"
    };
    INTERACTION_TYPE = {
      SIGNIN: "signin",
      SIGNOUT: "signout"
    };
    TemporaryCacheKeys = {
      ORIGIN_URI: "request.origin",
      URL_HASH: "urlHash",
      REQUEST_PARAMS: "request.params",
      VERIFIER: "code.verifier",
      INTERACTION_STATUS_KEY: "interaction.status",
      NATIVE_REQUEST: "request.native"
    };
    StaticCacheKeys = {
      ACCOUNT_KEYS: "msal.account.keys",
      TOKEN_KEYS: "msal.token.keys",
      VERSION: "msal.version"
    };
    InMemoryCacheKeys = {
      WRAPPER_SKU: "wrapper.sku",
      WRAPPER_VER: "wrapper.version"
    };
    ApiId = {
      acquireTokenRedirect: 861,
      acquireTokenPopup: 862,
      ssoSilent: 863,
      acquireTokenSilent_authCode: 864,
      handleRedirectPromise: 865,
      acquireTokenByCode: 866,
      acquireTokenSilent_silentFlow: 61,
      logout: 961,
      logoutPopup: 962
    };
    (function(InteractionType2) {
      InteractionType2["Redirect"] = "redirect";
      InteractionType2["Popup"] = "popup";
      InteractionType2["Silent"] = "silent";
      InteractionType2["None"] = "none";
    })(InteractionType || (InteractionType = {}));
    InteractionStatus = {
      /**
       * Initial status before interaction occurs
       */
      Startup: "startup",
      /**
       * Status set when all login calls occuring
       */
      Login: "login",
      /**
       * Status set when logout call occuring
       */
      Logout: "logout",
      /**
       * Status set for acquireToken calls
       */
      AcquireToken: "acquireToken",
      /**
       * Status set for ssoSilent calls
       */
      SsoSilent: "ssoSilent",
      /**
       * Status set when handleRedirect in progress
       */
      HandleRedirect: "handleRedirect",
      /**
       * Status set when interaction is complete
       */
      None: "none"
    };
    DEFAULT_REQUEST = {
      scopes: OIDC_DEFAULT_SCOPES
    };
    KEY_FORMAT_JWK = "jwk";
    WrapperSKU = {
      React: "@azure/msal-react",
      Angular: "@azure/msal-angular"
    };
    DB_NAME = "msal.db";
    DB_VERSION = 1;
    DB_TABLE_NAME = `${DB_NAME}.keys`;
    CacheLookupPolicy = {
      /*
       * acquireTokenSilent will attempt to retrieve an access token from the cache. If the access token is expired
       * or cannot be found the refresh token will be used to acquire a new one. Finally, if the refresh token
       * is expired acquireTokenSilent will attempt to acquire new access and refresh tokens.
       */
      Default: 0,
      /*
       * acquireTokenSilent will only look for access tokens in the cache. It will not attempt to renew access or
       * refresh tokens.
       */
      AccessToken: 1,
      /*
       * acquireTokenSilent will attempt to retrieve an access token from the cache. If the access token is expired or
       * cannot be found, the refresh token will be used to acquire a new one. If the refresh token is expired, it
       * will not be renewed and acquireTokenSilent will fail.
       */
      AccessTokenAndRefreshToken: 2,
      /*
       * acquireTokenSilent will not attempt to retrieve access tokens from the cache and will instead attempt to
       * exchange the cached refresh token for a new access token. If the refresh token is expired, it will not be
       * renewed and acquireTokenSilent will fail.
       */
      RefreshToken: 3,
      /*
       * acquireTokenSilent will not look in the cache for the access token. It will go directly to network with the
       * cached refresh token. If the refresh token is expired an attempt will be made to renew it. This is equivalent to
       * setting "forceRefresh: true".
       */
      RefreshTokenAndNetwork: 4,
      /*
       * acquireTokenSilent will attempt to renew both access and refresh tokens. It will not look in the cache. This will
       * always fail if 3rd party cookies are blocked by the browser.
       */
      Skip: 5
    };
    iFrameRenewalPolicies = [
      CacheLookupPolicy.Default,
      CacheLookupPolicy.Skip,
      CacheLookupPolicy.RefreshTokenAndNetwork
    ];
    LOG_LEVEL_CACHE_KEY = "msal.browser.log.level";
    LOG_PII_CACHE_KEY = "msal.browser.log.pii";
    BROWSER_PERF_ENABLED_KEY = "msal.browser.performance.enabled";
    PLATFORM_AUTH_DOM_SUPPORT = "msal.browser.platform.auth.dom";
  }
});

// node_modules/@azure/msal-browser/dist/encode/Base64Encode.mjs
function urlEncode(input) {
  return encodeURIComponent(base64Encode(input).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_"));
}
function urlEncodeArr(inputArr) {
  return base64EncArr(inputArr).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function base64Encode(input) {
  return base64EncArr(new TextEncoder().encode(input));
}
function base64EncArr(aBytes) {
  const binString = Array.from(aBytes, (x) => String.fromCodePoint(x)).join("");
  return btoa(binString);
}
var init_Base64Encode = __esm({
  "node_modules/@azure/msal-browser/dist/encode/Base64Encode.mjs"() {
    "use strict";
  }
});

// node_modules/@azure/msal-browser/dist/encode/Base64Decode.mjs
function base64Decode(input) {
  return new TextDecoder().decode(base64DecToArr(input));
}
function base64DecToArr(base64String) {
  let encodedString = base64String.replace(/-/g, "+").replace(/_/g, "/");
  switch (encodedString.length % 4) {
    case 0:
      break;
    case 2:
      encodedString += "==";
      break;
    case 3:
      encodedString += "=";
      break;
    default:
      throw createBrowserAuthError(invalidBase64String);
  }
  const binString = atob(encodedString);
  return Uint8Array.from(binString, (m) => m.codePointAt(0) || 0);
}
var init_Base64Decode = __esm({
  "node_modules/@azure/msal-browser/dist/encode/Base64Decode.mjs"() {
    "use strict";
    init_BrowserAuthError();
    init_BrowserAuthErrorCodes();
  }
});

// node_modules/@azure/msal-browser/dist/crypto/BrowserCrypto.mjs
function validateCryptoAvailable(skipValidateSubtleCrypto) {
  if (!window) {
    throw createBrowserAuthError(nonBrowserEnvironment);
  }
  if (!window.crypto) {
    throw createBrowserAuthError(cryptoNonExistent);
  }
  if (!skipValidateSubtleCrypto && !window.crypto.subtle) {
    throw createBrowserAuthError(cryptoNonExistent, SUBTLE_SUBERROR);
  }
}
async function sha256Digest(dataString, performanceClient, correlationId) {
  performanceClient == null ? void 0 : performanceClient.addQueueMeasurement(PerformanceEvents.Sha256Digest, correlationId);
  const encoder = new TextEncoder();
  const data = encoder.encode(dataString);
  return window.crypto.subtle.digest(S256_HASH_ALG, data);
}
function getRandomValues(dataBuffer) {
  return window.crypto.getRandomValues(dataBuffer);
}
function getRandomUint32() {
  window.crypto.getRandomValues(UINT32_ARR);
  return UINT32_ARR[0];
}
function createNewGuid() {
  const currentTimestamp = Date.now();
  const baseRand = getRandomUint32() * 1024 + (getRandomUint32() & 1023);
  const bytes = new Uint8Array(16);
  const randA = Math.trunc(baseRand / 2 ** 30);
  const randBHi = baseRand & 2 ** 30 - 1;
  const randBLo = getRandomUint32();
  bytes[0] = currentTimestamp / 2 ** 40;
  bytes[1] = currentTimestamp / 2 ** 32;
  bytes[2] = currentTimestamp / 2 ** 24;
  bytes[3] = currentTimestamp / 2 ** 16;
  bytes[4] = currentTimestamp / 2 ** 8;
  bytes[5] = currentTimestamp;
  bytes[6] = 112 | randA >>> 8;
  bytes[7] = randA;
  bytes[8] = 128 | randBHi >>> 24;
  bytes[9] = randBHi >>> 16;
  bytes[10] = randBHi >>> 8;
  bytes[11] = randBHi;
  bytes[12] = randBLo >>> 24;
  bytes[13] = randBLo >>> 16;
  bytes[14] = randBLo >>> 8;
  bytes[15] = randBLo;
  let text = "";
  for (let i = 0; i < bytes.length; i++) {
    text += UUID_CHARS.charAt(bytes[i] >>> 4);
    text += UUID_CHARS.charAt(bytes[i] & 15);
    if (i === 3 || i === 5 || i === 7 || i === 9) {
      text += "-";
    }
  }
  return text;
}
async function generateKeyPair(extractable, usages) {
  return window.crypto.subtle.generateKey(keygenAlgorithmOptions, extractable, usages);
}
async function exportJwk(key) {
  return window.crypto.subtle.exportKey(KEY_FORMAT_JWK, key);
}
async function importJwk(key, extractable, usages) {
  return window.crypto.subtle.importKey(KEY_FORMAT_JWK, key, keygenAlgorithmOptions, extractable, usages);
}
async function sign(key, data) {
  return window.crypto.subtle.sign(keygenAlgorithmOptions, key, data);
}
async function generateEarKey() {
  const key = await generateBaseKey();
  const keyStr = urlEncodeArr(new Uint8Array(key));
  const jwk = {
    alg: "dir",
    kty: "oct",
    k: keyStr
  };
  return base64Encode(JSON.stringify(jwk));
}
async function importEarKey(earJwk) {
  const b64DecodedJwk = base64Decode(earJwk);
  const jwkJson = JSON.parse(b64DecodedJwk);
  const rawKey = jwkJson.k;
  const keyBuffer = base64DecToArr(rawKey);
  return window.crypto.subtle.importKey(RAW, keyBuffer, AES_GCM, false, [
    DECRYPT
  ]);
}
async function decryptEarResponse(earJwk, earJwe) {
  const earJweParts = earJwe.split(".");
  if (earJweParts.length !== 5) {
    throw createBrowserAuthError(failedToDecryptEarResponse, "jwe_length");
  }
  const key = await importEarKey(earJwk).catch(() => {
    throw createBrowserAuthError(failedToDecryptEarResponse, "import_key");
  });
  try {
    const header = new TextEncoder().encode(earJweParts[0]);
    const iv = base64DecToArr(earJweParts[2]);
    const ciphertext = base64DecToArr(earJweParts[3]);
    const tag = base64DecToArr(earJweParts[4]);
    const tagLengthBits = tag.byteLength * 8;
    const encryptedData = new Uint8Array(ciphertext.length + tag.length);
    encryptedData.set(ciphertext);
    encryptedData.set(tag, ciphertext.length);
    const decryptedData = await window.crypto.subtle.decrypt({
      name: AES_GCM,
      iv,
      tagLength: tagLengthBits,
      additionalData: header
    }, key, encryptedData);
    return new TextDecoder().decode(decryptedData);
  } catch (e) {
    throw createBrowserAuthError(failedToDecryptEarResponse, "decrypt");
  }
}
async function generateBaseKey() {
  const key = await window.crypto.subtle.generateKey({
    name: AES_GCM,
    length: 256
  }, true, [ENCRYPT, DECRYPT]);
  return window.crypto.subtle.exportKey(RAW, key);
}
async function generateHKDF(baseKey) {
  return window.crypto.subtle.importKey(RAW, baseKey, HKDF, false, [
    DERIVE_KEY
  ]);
}
async function deriveKey(baseKey, nonce, context3) {
  return window.crypto.subtle.deriveKey({
    name: HKDF,
    salt: nonce,
    hash: S256_HASH_ALG,
    info: new TextEncoder().encode(context3)
  }, baseKey, { name: AES_GCM, length: 256 }, false, [ENCRYPT, DECRYPT]);
}
async function encrypt(baseKey, rawData, context3) {
  const encodedData = new TextEncoder().encode(rawData);
  const nonce = window.crypto.getRandomValues(new Uint8Array(16));
  const derivedKey = await deriveKey(baseKey, nonce, context3);
  const encryptedData = await window.crypto.subtle.encrypt({
    name: AES_GCM,
    iv: new Uint8Array(12)
    // New key is derived for every encrypt so we don't need a new nonce
  }, derivedKey, encodedData);
  return {
    data: urlEncodeArr(new Uint8Array(encryptedData)),
    nonce: urlEncodeArr(nonce)
  };
}
async function decrypt(baseKey, nonce, context3, encryptedData) {
  const encodedData = base64DecToArr(encryptedData);
  const derivedKey = await deriveKey(baseKey, base64DecToArr(nonce), context3);
  const decryptedData = await window.crypto.subtle.decrypt({
    name: AES_GCM,
    iv: new Uint8Array(12)
    // New key is derived for every encrypt so we don't need a new nonce
  }, derivedKey, encodedData);
  return new TextDecoder().decode(decryptedData);
}
async function hashString(plainText) {
  const hashBuffer = await sha256Digest(plainText);
  const hashBytes = new Uint8Array(hashBuffer);
  return urlEncodeArr(hashBytes);
}
var PKCS1_V15_KEYGEN_ALG, AES_GCM, HKDF, S256_HASH_ALG, MODULUS_LENGTH, PUBLIC_EXPONENT, UUID_CHARS, UINT32_ARR, RAW, ENCRYPT, DECRYPT, DERIVE_KEY, SUBTLE_SUBERROR, keygenAlgorithmOptions;
var init_BrowserCrypto = __esm({
  "node_modules/@azure/msal-browser/dist/crypto/BrowserCrypto.mjs"() {
    "use strict";
    init_BrowserAuthError();
    init_index_browser();
    init_BrowserConstants();
    init_Base64Encode();
    init_Base64Decode();
    init_BrowserAuthErrorCodes();
    PKCS1_V15_KEYGEN_ALG = "RSASSA-PKCS1-v1_5";
    AES_GCM = "AES-GCM";
    HKDF = "HKDF";
    S256_HASH_ALG = "SHA-256";
    MODULUS_LENGTH = 2048;
    PUBLIC_EXPONENT = new Uint8Array([1, 0, 1]);
    UUID_CHARS = "0123456789abcdef";
    UINT32_ARR = new Uint32Array(1);
    RAW = "raw";
    ENCRYPT = "encrypt";
    DECRYPT = "decrypt";
    DERIVE_KEY = "deriveKey";
    SUBTLE_SUBERROR = "crypto_subtle_undefined";
    keygenAlgorithmOptions = {
      name: PKCS1_V15_KEYGEN_ALG,
      hash: S256_HASH_ALG,
      modulusLength: MODULUS_LENGTH,
      publicExponent: PUBLIC_EXPONENT
    };
  }
});

// node_modules/@azure/msal-browser/dist/error/BrowserConfigurationAuthErrorCodes.mjs
var BrowserConfigurationAuthErrorCodes_exports = {};
__export(BrowserConfigurationAuthErrorCodes_exports, {
  inMemRedirectUnavailable: () => inMemRedirectUnavailable,
  storageNotSupported: () => storageNotSupported,
  stubbedPublicClientApplicationCalled: () => stubbedPublicClientApplicationCalled
});
var storageNotSupported, stubbedPublicClientApplicationCalled, inMemRedirectUnavailable;
var init_BrowserConfigurationAuthErrorCodes = __esm({
  "node_modules/@azure/msal-browser/dist/error/BrowserConfigurationAuthErrorCodes.mjs"() {
    "use strict";
    storageNotSupported = "storage_not_supported";
    stubbedPublicClientApplicationCalled = "stubbed_public_client_application_called";
    inMemRedirectUnavailable = "in_mem_redirect_unavailable";
  }
});

// node_modules/@azure/msal-browser/dist/error/BrowserConfigurationAuthError.mjs
function createBrowserConfigurationAuthError(errorCode) {
  return new BrowserConfigurationAuthError(errorCode, BrowserConfigurationAuthErrorMessages[errorCode]);
}
var BrowserConfigurationAuthErrorMessages, BrowserConfigurationAuthErrorMessage, BrowserConfigurationAuthError;
var init_BrowserConfigurationAuthError = __esm({
  "node_modules/@azure/msal-browser/dist/error/BrowserConfigurationAuthError.mjs"() {
    "use strict";
    init_index_browser();
    init_BrowserConfigurationAuthErrorCodes();
    init_BrowserConfigurationAuthErrorCodes();
    BrowserConfigurationAuthErrorMessages = {
      [storageNotSupported]: "Given storage configuration option was not supported.",
      [stubbedPublicClientApplicationCalled]: "Stub instance of Public Client Application was called. If using msal-react, please ensure context is not used without a provider. For more visit: aka.ms/msaljs/browser-errors",
      [inMemRedirectUnavailable]: "Redirect cannot be supported. In-memory storage was selected and storeAuthStateInCookie=false, which would cause the library to be unable to handle the incoming hash. If you would like to use the redirect API, please use session/localStorage or set storeAuthStateInCookie=true."
    };
    BrowserConfigurationAuthErrorMessage = {
      storageNotSupportedError: {
        code: storageNotSupported,
        desc: BrowserConfigurationAuthErrorMessages[storageNotSupported]
      },
      stubPcaInstanceCalled: {
        code: stubbedPublicClientApplicationCalled,
        desc: BrowserConfigurationAuthErrorMessages[stubbedPublicClientApplicationCalled]
      },
      inMemRedirectUnavailable: {
        code: inMemRedirectUnavailable,
        desc: BrowserConfigurationAuthErrorMessages[inMemRedirectUnavailable]
      }
    };
    BrowserConfigurationAuthError = class _BrowserConfigurationAuthError extends AuthError {
      constructor(errorCode, errorMessage2) {
        super(errorCode, errorMessage2);
        this.name = "BrowserConfigurationAuthError";
        Object.setPrototypeOf(this, _BrowserConfigurationAuthError.prototype);
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/utils/BrowserUtils.mjs
var BrowserUtils_exports = {};
__export(BrowserUtils_exports, {
  blockAPICallsBeforeInitialize: () => blockAPICallsBeforeInitialize,
  blockAcquireTokenInPopups: () => blockAcquireTokenInPopups,
  blockNonBrowserEnvironment: () => blockNonBrowserEnvironment,
  blockRedirectInIframe: () => blockRedirectInIframe,
  blockReloadInHiddenIframes: () => blockReloadInHiddenIframes,
  clearHash: () => clearHash,
  createGuid: () => createGuid,
  getCurrentUri: () => getCurrentUri,
  getHomepage: () => getHomepage,
  invoke: () => invoke,
  invokeAsync: () => invokeAsync,
  isInIframe: () => isInIframe,
  isInPopup: () => isInPopup,
  preconnect: () => preconnect,
  preflightCheck: () => preflightCheck,
  redirectPreflightCheck: () => redirectPreflightCheck,
  replaceHash: () => replaceHash
});
function clearHash(contentWindow) {
  contentWindow.location.hash = "";
  if (typeof contentWindow.history.replaceState === "function") {
    contentWindow.history.replaceState(null, "", `${contentWindow.location.origin}${contentWindow.location.pathname}${contentWindow.location.search}`);
  }
}
function replaceHash(url) {
  const urlParts = url.split("#");
  urlParts.shift();
  window.location.hash = urlParts.length > 0 ? urlParts.join("#") : "";
}
function isInIframe() {
  return window.parent !== window;
}
function isInPopup() {
  return typeof window !== "undefined" && !!window.opener && window.opener !== window && typeof window.name === "string" && window.name.indexOf(`${BrowserConstants.POPUP_NAME_PREFIX}.`) === 0;
}
function getCurrentUri() {
  return typeof window !== "undefined" && window.location ? window.location.href.split("?")[0].split("#")[0] : "";
}
function getHomepage() {
  const currentUrl = new UrlString(window.location.href);
  const urlComponents = currentUrl.getUrlComponents();
  return `${urlComponents.Protocol}//${urlComponents.HostNameAndPort}/`;
}
function blockReloadInHiddenIframes() {
  const isResponseHash = UrlString.hashContainsKnownProperties(window.location.hash);
  if (isResponseHash && isInIframe()) {
    throw createBrowserAuthError(blockIframeReload);
  }
}
function blockRedirectInIframe(allowRedirectInIframe) {
  if (isInIframe() && !allowRedirectInIframe) {
    throw createBrowserAuthError(redirectInIframe);
  }
}
function blockAcquireTokenInPopups() {
  if (isInPopup()) {
    throw createBrowserAuthError(blockNestedPopups);
  }
}
function blockNonBrowserEnvironment() {
  if (typeof window === "undefined") {
    throw createBrowserAuthError(nonBrowserEnvironment);
  }
}
function blockAPICallsBeforeInitialize(initialized) {
  if (!initialized) {
    throw createBrowserAuthError(uninitializedPublicClientApplication);
  }
}
function preflightCheck(initialized) {
  blockNonBrowserEnvironment();
  blockReloadInHiddenIframes();
  blockAcquireTokenInPopups();
  blockAPICallsBeforeInitialize(initialized);
}
function redirectPreflightCheck(initialized, config) {
  preflightCheck(initialized);
  blockRedirectInIframe(config.system.allowRedirectInIframe);
  if (config.cache.cacheLocation === BrowserCacheLocation.MemoryStorage && !config.cache.storeAuthStateInCookie) {
    throw createBrowserConfigurationAuthError(inMemRedirectUnavailable);
  }
}
function preconnect(authority) {
  const link = document.createElement("link");
  link.rel = "preconnect";
  link.href = new URL(authority).origin;
  link.crossOrigin = "anonymous";
  document.head.appendChild(link);
  window.setTimeout(() => {
    try {
      document.head.removeChild(link);
    } catch {
    }
  }, 1e4);
}
function createGuid() {
  return createNewGuid();
}
var init_BrowserUtils = __esm({
  "node_modules/@azure/msal-browser/dist/utils/BrowserUtils.mjs"() {
    "use strict";
    init_index_browser();
    init_index_browser();
    init_BrowserAuthError();
    init_BrowserConstants();
    init_BrowserCrypto();
    init_BrowserConfigurationAuthError();
    init_BrowserAuthErrorCodes();
    init_BrowserConfigurationAuthErrorCodes();
  }
});

// node_modules/@azure/msal-browser/dist/navigation/NavigationClient.mjs
var NavigationClient;
var init_NavigationClient = __esm({
  "node_modules/@azure/msal-browser/dist/navigation/NavigationClient.mjs"() {
    "use strict";
    init_BrowserAuthError();
    init_BrowserAuthErrorCodes();
    NavigationClient = class _NavigationClient {
      /**
       * Navigates to other pages within the same web application
       * @param url
       * @param options
       */
      navigateInternal(url, options) {
        return _NavigationClient.defaultNavigateWindow(url, options);
      }
      /**
       * Navigates to other pages outside the web application i.e. the Identity Provider
       * @param url
       * @param options
       */
      navigateExternal(url, options) {
        return _NavigationClient.defaultNavigateWindow(url, options);
      }
      /**
       * Default navigation implementation invoked by the internal and external functions
       * @param url
       * @param options
       */
      static defaultNavigateWindow(url, options) {
        if (options.noHistory) {
          window.location.replace(url);
        } else {
          window.location.assign(url);
        }
        return new Promise((resolve, reject) => {
          setTimeout(() => {
            reject(createBrowserAuthError(timedOut, "failed_to_redirect"));
          }, options.timeout);
        });
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/network/FetchClient.mjs
function getFetchHeaders(options) {
  try {
    const headers = new Headers();
    if (!(options && options.headers)) {
      return headers;
    }
    const optionsHeaders = options.headers;
    Object.entries(optionsHeaders).forEach(([key, value]) => {
      headers.append(key, value);
    });
    return headers;
  } catch (e) {
    throw createNetworkError(createBrowserAuthError(failedToBuildHeaders), void 0, void 0, e);
  }
}
function getHeaderDict(headers) {
  try {
    const headerDict = {};
    headers.forEach((value, key) => {
      headerDict[key] = value;
    });
    return headerDict;
  } catch (e) {
    throw createBrowserAuthError(failedToParseHeaders);
  }
}
var FetchClient;
var init_FetchClient = __esm({
  "node_modules/@azure/msal-browser/dist/network/FetchClient.mjs"() {
    "use strict";
    init_index_browser();
    init_BrowserAuthError();
    init_BrowserConstants();
    init_BrowserAuthErrorCodes();
    FetchClient = class {
      /**
       * Fetch Client for REST endpoints - Get request
       * @param url
       * @param headers
       * @param body
       */
      async sendGetRequestAsync(url, options) {
        let response;
        let responseHeaders = {};
        let responseStatus = 0;
        const reqHeaders = getFetchHeaders(options);
        try {
          response = await fetch(url, {
            method: HTTP_REQUEST_TYPE.GET,
            headers: reqHeaders
          });
        } catch (e) {
          throw createNetworkError(createBrowserAuthError(window.navigator.onLine ? getRequestFailed : noNetworkConnectivity2), void 0, void 0, e);
        }
        responseHeaders = getHeaderDict(response.headers);
        try {
          responseStatus = response.status;
          return {
            headers: responseHeaders,
            body: await response.json(),
            status: responseStatus
          };
        } catch (e) {
          throw createNetworkError(createBrowserAuthError(failedToParseResponse), responseStatus, responseHeaders, e);
        }
      }
      /**
       * Fetch Client for REST endpoints - Post request
       * @param url
       * @param headers
       * @param body
       */
      async sendPostRequestAsync(url, options) {
        const reqBody = options && options.body || "";
        const reqHeaders = getFetchHeaders(options);
        let response;
        let responseStatus = 0;
        let responseHeaders = {};
        try {
          response = await fetch(url, {
            method: HTTP_REQUEST_TYPE.POST,
            headers: reqHeaders,
            body: reqBody
          });
        } catch (e) {
          throw createNetworkError(createBrowserAuthError(window.navigator.onLine ? postRequestFailed2 : noNetworkConnectivity2), void 0, void 0, e);
        }
        responseHeaders = getHeaderDict(response.headers);
        try {
          responseStatus = response.status;
          return {
            headers: responseHeaders,
            body: await response.json(),
            status: responseStatus
          };
        } catch (e) {
          throw createNetworkError(createBrowserAuthError(failedToParseResponse), responseStatus, responseHeaders, e);
        }
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/config/Configuration.mjs
function buildConfiguration({ auth: userInputAuth, cache: userInputCache, system: userInputSystem, telemetry: userInputTelemetry }, isBrowserEnvironment) {
  const DEFAULT_AUTH_OPTIONS = {
    clientId: Constants.EMPTY_STRING,
    authority: `${Constants.DEFAULT_AUTHORITY}`,
    knownAuthorities: [],
    cloudDiscoveryMetadata: Constants.EMPTY_STRING,
    authorityMetadata: Constants.EMPTY_STRING,
    redirectUri: typeof window !== "undefined" ? getCurrentUri() : "",
    postLogoutRedirectUri: Constants.EMPTY_STRING,
    navigateToLoginRequestUrl: true,
    clientCapabilities: [],
    protocolMode: ProtocolMode.AAD,
    OIDCOptions: {
      serverResponseType: ServerResponseType.FRAGMENT,
      defaultScopes: [
        Constants.OPENID_SCOPE,
        Constants.PROFILE_SCOPE,
        Constants.OFFLINE_ACCESS_SCOPE
      ]
    },
    azureCloudOptions: {
      azureCloudInstance: AzureCloudInstance.None,
      tenant: Constants.EMPTY_STRING
    },
    skipAuthorityMetadataCache: false,
    supportsNestedAppAuth: false,
    instanceAware: false,
    encodeExtraQueryParams: false
  };
  const DEFAULT_CACHE_OPTIONS2 = {
    cacheLocation: BrowserCacheLocation.SessionStorage,
    temporaryCacheLocation: BrowserCacheLocation.SessionStorage,
    storeAuthStateInCookie: false,
    secureCookies: false,
    // Default cache migration to true if cache location is localStorage since entries are preserved across tabs/windows. Migration has little to no benefit in sessionStorage and memoryStorage
    cacheMigrationEnabled: userInputCache && userInputCache.cacheLocation === BrowserCacheLocation.LocalStorage ? true : false,
    claimsBasedCachingEnabled: false
  };
  const DEFAULT_LOGGER_OPTIONS = {
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    loggerCallback: () => {
    },
    logLevel: LogLevel.Info,
    piiLoggingEnabled: false
  };
  const DEFAULT_BROWSER_SYSTEM_OPTIONS = {
    ...DEFAULT_SYSTEM_OPTIONS,
    loggerOptions: DEFAULT_LOGGER_OPTIONS,
    networkClient: isBrowserEnvironment ? new FetchClient() : StubbedNetworkModule,
    navigationClient: new NavigationClient(),
    loadFrameTimeout: 0,
    // If loadFrameTimeout is provided, use that as default.
    windowHashTimeout: (userInputSystem == null ? void 0 : userInputSystem.loadFrameTimeout) || DEFAULT_POPUP_TIMEOUT_MS,
    iframeHashTimeout: (userInputSystem == null ? void 0 : userInputSystem.loadFrameTimeout) || DEFAULT_IFRAME_TIMEOUT_MS,
    navigateFrameWait: 0,
    redirectNavigationTimeout: DEFAULT_REDIRECT_TIMEOUT_MS,
    asyncPopups: false,
    allowRedirectInIframe: false,
    allowPlatformBroker: false,
    nativeBrokerHandshakeTimeout: (userInputSystem == null ? void 0 : userInputSystem.nativeBrokerHandshakeTimeout) || DEFAULT_NATIVE_BROKER_HANDSHAKE_TIMEOUT_MS,
    pollIntervalMilliseconds: BrowserConstants.DEFAULT_POLL_INTERVAL_MS
  };
  const providedSystemOptions = {
    ...DEFAULT_BROWSER_SYSTEM_OPTIONS,
    ...userInputSystem,
    loggerOptions: (userInputSystem == null ? void 0 : userInputSystem.loggerOptions) || DEFAULT_LOGGER_OPTIONS
  };
  const DEFAULT_TELEMETRY_OPTIONS2 = {
    application: {
      appName: Constants.EMPTY_STRING,
      appVersion: Constants.EMPTY_STRING
    },
    client: new StubPerformanceClient()
  };
  if ((userInputAuth == null ? void 0 : userInputAuth.protocolMode) !== ProtocolMode.OIDC && (userInputAuth == null ? void 0 : userInputAuth.OIDCOptions)) {
    const logger24 = new Logger(providedSystemOptions.loggerOptions);
    logger24.warning(JSON.stringify(createClientConfigurationError(ClientConfigurationErrorCodes_exports.cannotSetOIDCOptions)));
  }
  if ((userInputAuth == null ? void 0 : userInputAuth.protocolMode) && userInputAuth.protocolMode === ProtocolMode.OIDC && (providedSystemOptions == null ? void 0 : providedSystemOptions.allowPlatformBroker)) {
    throw createClientConfigurationError(ClientConfigurationErrorCodes_exports.cannotAllowPlatformBroker);
  }
  const overlayedConfig = {
    auth: {
      ...DEFAULT_AUTH_OPTIONS,
      ...userInputAuth,
      OIDCOptions: {
        ...DEFAULT_AUTH_OPTIONS.OIDCOptions,
        ...userInputAuth == null ? void 0 : userInputAuth.OIDCOptions
      }
    },
    cache: { ...DEFAULT_CACHE_OPTIONS2, ...userInputCache },
    system: providedSystemOptions,
    telemetry: { ...DEFAULT_TELEMETRY_OPTIONS2, ...userInputTelemetry }
  };
  return overlayedConfig;
}
var DEFAULT_POPUP_TIMEOUT_MS, DEFAULT_IFRAME_TIMEOUT_MS, DEFAULT_REDIRECT_TIMEOUT_MS, DEFAULT_NATIVE_BROKER_HANDSHAKE_TIMEOUT_MS;
var init_Configuration = __esm({
  "node_modules/@azure/msal-browser/dist/config/Configuration.mjs"() {
    "use strict";
    init_index_browser();
    init_BrowserConstants();
    init_NavigationClient();
    init_FetchClient();
    init_BrowserUtils();
    DEFAULT_POPUP_TIMEOUT_MS = 6e4;
    DEFAULT_IFRAME_TIMEOUT_MS = 1e4;
    DEFAULT_REDIRECT_TIMEOUT_MS = 3e4;
    DEFAULT_NATIVE_BROKER_HANDSHAKE_TIMEOUT_MS = 2e3;
  }
});

// node_modules/@azure/msal-browser/dist/packageMetadata.mjs
var name2, version2;
var init_packageMetadata2 = __esm({
  "node_modules/@azure/msal-browser/dist/packageMetadata.mjs"() {
    "use strict";
    name2 = "@azure/msal-browser";
    version2 = "4.18.0";
  }
});

// node_modules/@azure/msal-browser/dist/operatingcontext/BaseOperatingContext.mjs
var BaseOperatingContext;
var init_BaseOperatingContext = __esm({
  "node_modules/@azure/msal-browser/dist/operatingcontext/BaseOperatingContext.mjs"() {
    "use strict";
    init_index_browser();
    init_Configuration();
    init_packageMetadata2();
    init_BrowserConstants();
    BaseOperatingContext = class _BaseOperatingContext {
      static loggerCallback(level, message) {
        switch (level) {
          case LogLevel.Error:
            console.error(message);
            return;
          case LogLevel.Info:
            console.info(message);
            return;
          case LogLevel.Verbose:
            console.debug(message);
            return;
          case LogLevel.Warning:
            console.warn(message);
            return;
          default:
            console.log(message);
            return;
        }
      }
      constructor(config) {
        var _a3;
        this.browserEnvironment = typeof window !== "undefined";
        this.config = buildConfiguration(config, this.browserEnvironment);
        let sessionStorage;
        try {
          sessionStorage = window[BrowserCacheLocation.SessionStorage];
        } catch (e) {
        }
        const logLevelKey = sessionStorage == null ? void 0 : sessionStorage.getItem(LOG_LEVEL_CACHE_KEY);
        const piiLoggingKey = (_a3 = sessionStorage == null ? void 0 : sessionStorage.getItem(LOG_PII_CACHE_KEY)) == null ? void 0 : _a3.toLowerCase();
        const piiLoggingEnabled = piiLoggingKey === "true" ? true : piiLoggingKey === "false" ? false : void 0;
        const loggerOptions = { ...this.config.system.loggerOptions };
        const logLevel = logLevelKey && Object.keys(LogLevel).includes(logLevelKey) ? LogLevel[logLevelKey] : void 0;
        if (logLevel) {
          loggerOptions.loggerCallback = _BaseOperatingContext.loggerCallback;
          loggerOptions.logLevel = logLevel;
        }
        if (piiLoggingEnabled !== void 0) {
          loggerOptions.piiLoggingEnabled = piiLoggingEnabled;
        }
        this.logger = new Logger(loggerOptions, name2, version2);
        this.available = false;
      }
      /**
       * Return the MSAL config
       * @returns BrowserConfiguration
       */
      getConfig() {
        return this.config;
      }
      /**
       * Returns the MSAL Logger
       * @returns Logger
       */
      getLogger() {
        return this.logger;
      }
      isAvailable() {
        return this.available;
      }
      isBrowserEnvironment() {
        return this.browserEnvironment;
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/naa/BridgeStatusCode.mjs
var BridgeStatusCode;
var init_BridgeStatusCode = __esm({
  "node_modules/@azure/msal-browser/dist/naa/BridgeStatusCode.mjs"() {
    "use strict";
    BridgeStatusCode = {
      UserInteractionRequired: "USER_INTERACTION_REQUIRED",
      UserCancel: "USER_CANCEL",
      NoNetwork: "NO_NETWORK",
      TransientError: "TRANSIENT_ERROR",
      PersistentError: "PERSISTENT_ERROR",
      Disabled: "DISABLED",
      AccountUnavailable: "ACCOUNT_UNAVAILABLE",
      NestedAppAuthUnavailable: "NESTED_APP_AUTH_UNAVAILABLE"
      // NAA is unavailable in the current context, can retry with standard browser based auth
    };
  }
});

// node_modules/@azure/msal-browser/dist/naa/BridgeProxy.mjs
var BridgeProxy;
var init_BridgeProxy = __esm({
  "node_modules/@azure/msal-browser/dist/naa/BridgeProxy.mjs"() {
    "use strict";
    init_BridgeStatusCode();
    init_BrowserCrypto();
    init_BrowserConstants();
    init_packageMetadata2();
    BridgeProxy = class _BridgeProxy {
      /**
       * initializeNestedAppAuthBridge - Initializes the bridge to the host app
       * @returns a promise that resolves to an InitializeBridgeResponse or rejects with an Error
       * @remarks This method will be called by the create factory method
       * @remarks If the bridge is not available, this method will throw an error
       */
      static async initializeNestedAppAuthBridge() {
        if (window === void 0) {
          throw new Error("window is undefined");
        }
        if (window.nestedAppAuthBridge === void 0) {
          throw new Error("window.nestedAppAuthBridge is undefined");
        }
        try {
          window.nestedAppAuthBridge.addEventListener("message", (response) => {
            const responsePayload = typeof response === "string" ? response : response.data;
            const responseEnvelope = JSON.parse(responsePayload);
            const request = _BridgeProxy.bridgeRequests.find((element) => element.requestId === responseEnvelope.requestId);
            if (request !== void 0) {
              _BridgeProxy.bridgeRequests.splice(_BridgeProxy.bridgeRequests.indexOf(request), 1);
              if (responseEnvelope.success) {
                request.resolve(responseEnvelope);
              } else {
                request.reject(responseEnvelope.error);
              }
            }
          });
          const bridgeResponse = await new Promise((resolve, reject) => {
            const message = _BridgeProxy.buildRequest("GetInitContext");
            const request = {
              requestId: message.requestId,
              method: message.method,
              resolve,
              reject
            };
            _BridgeProxy.bridgeRequests.push(request);
            window.nestedAppAuthBridge.postMessage(JSON.stringify(message));
          });
          return _BridgeProxy.validateBridgeResultOrThrow(bridgeResponse.initContext);
        } catch (error) {
          window.console.log(error);
          throw error;
        }
      }
      /**
       * getTokenInteractive - Attempts to get a token interactively from the bridge
       * @param request A token request
       * @returns a promise that resolves to an auth result or rejects with a BridgeError
       */
      getTokenInteractive(request) {
        return this.getToken("GetTokenPopup", request);
      }
      /**
       * getTokenSilent Attempts to get a token silently from the bridge
       * @param request A token request
       * @returns a promise that resolves to an auth result or rejects with a BridgeError
       */
      getTokenSilent(request) {
        return this.getToken("GetToken", request);
      }
      async getToken(requestType, request) {
        const result = await this.sendRequest(requestType, {
          tokenParams: request
        });
        return {
          token: _BridgeProxy.validateBridgeResultOrThrow(result.token),
          account: _BridgeProxy.validateBridgeResultOrThrow(result.account)
        };
      }
      getHostCapabilities() {
        return this.capabilities ?? null;
      }
      getAccountContext() {
        return this.accountContext ? this.accountContext : null;
      }
      static buildRequest(method, requestParams) {
        return {
          messageType: "NestedAppAuthRequest",
          method,
          requestId: createNewGuid(),
          sendTime: Date.now(),
          clientLibrary: BrowserConstants.MSAL_SKU,
          clientLibraryVersion: version2,
          ...requestParams
        };
      }
      /**
       * A method used to send a request to the bridge
       * @param request A token request
       * @returns a promise that resolves to a response of provided type or rejects with a BridgeError
       */
      sendRequest(method, requestParams) {
        const message = _BridgeProxy.buildRequest(method, requestParams);
        const promise = new Promise((resolve, reject) => {
          const request = {
            requestId: message.requestId,
            method: message.method,
            resolve,
            reject
          };
          _BridgeProxy.bridgeRequests.push(request);
          window.nestedAppAuthBridge.postMessage(JSON.stringify(message));
        });
        return promise;
      }
      static validateBridgeResultOrThrow(input) {
        if (input === void 0) {
          const bridgeError = {
            status: BridgeStatusCode.NestedAppAuthUnavailable
          };
          throw bridgeError;
        }
        return input;
      }
      /**
       * Private constructor for BridgeProxy
       * @param sdkName The name of the SDK being used to make requests on behalf of the app
       * @param sdkVersion The version of the SDK being used to make requests on behalf of the app
       * @param capabilities The capabilities of the bridge / SDK / platform broker
       */
      constructor(sdkName, sdkVersion, accountContext, capabilities) {
        this.sdkName = sdkName;
        this.sdkVersion = sdkVersion;
        this.accountContext = accountContext;
        this.capabilities = capabilities;
      }
      /**
       * Factory method for creating an implementation of IBridgeProxy
       * @returns A promise that resolves to a BridgeProxy implementation
       */
      static async create() {
        const response = await _BridgeProxy.initializeNestedAppAuthBridge();
        return new _BridgeProxy(response.sdkName, response.sdkVersion, response.accountContext, response.capabilities);
      }
    };
    BridgeProxy.bridgeRequests = [];
  }
});

// node_modules/@azure/msal-browser/dist/operatingcontext/NestedAppOperatingContext.mjs
var NestedAppOperatingContext;
var init_NestedAppOperatingContext = __esm({
  "node_modules/@azure/msal-browser/dist/operatingcontext/NestedAppOperatingContext.mjs"() {
    "use strict";
    init_BaseOperatingContext();
    init_BridgeProxy();
    NestedAppOperatingContext = class _NestedAppOperatingContext extends BaseOperatingContext {
      constructor() {
        super(...arguments);
        this.bridgeProxy = void 0;
        this.accountContext = null;
      }
      /**
       * Return the module name.  Intended for use with import() to enable dynamic import
       * of the implementation associated with this operating context
       * @returns
       */
      getModuleName() {
        return _NestedAppOperatingContext.MODULE_NAME;
      }
      /**
       * Returns the unique identifier for this operating context
       * @returns string
       */
      getId() {
        return _NestedAppOperatingContext.ID;
      }
      /**
       * Returns the current BridgeProxy
       * @returns IBridgeProxy | undefined
       */
      getBridgeProxy() {
        return this.bridgeProxy;
      }
      /**
       * Checks whether the operating context is available.
       * Confirms that the code is running a browser rather.  This is required.
       * @returns Promise<boolean> indicating whether this operating context is currently available.
       */
      async initialize() {
        try {
          if (typeof window !== "undefined") {
            if (typeof window.__initializeNestedAppAuth === "function") {
              await window.__initializeNestedAppAuth();
            }
            const bridgeProxy = await BridgeProxy.create();
            this.accountContext = bridgeProxy.getAccountContext();
            this.bridgeProxy = bridgeProxy;
            this.available = bridgeProxy !== void 0;
          }
        } catch (ex) {
          this.logger.infoPii(`Could not initialize Nested App Auth bridge (${ex})`);
        }
        this.logger.info(`Nested App Auth Bridge available: ${this.available}`);
        return this.available;
      }
    };
    NestedAppOperatingContext.MODULE_NAME = "";
    NestedAppOperatingContext.ID = "NestedAppOperatingContext";
  }
});

// node_modules/@azure/msal-browser/dist/operatingcontext/StandardOperatingContext.mjs
var StandardOperatingContext;
var init_StandardOperatingContext = __esm({
  "node_modules/@azure/msal-browser/dist/operatingcontext/StandardOperatingContext.mjs"() {
    "use strict";
    init_BaseOperatingContext();
    StandardOperatingContext = class _StandardOperatingContext extends BaseOperatingContext {
      /**
       * Return the module name.  Intended for use with import() to enable dynamic import
       * of the implementation associated with this operating context
       * @returns
       */
      getModuleName() {
        return _StandardOperatingContext.MODULE_NAME;
      }
      /**
       * Returns the unique identifier for this operating context
       * @returns string
       */
      getId() {
        return _StandardOperatingContext.ID;
      }
      /**
       * Checks whether the operating context is available.
       * Confirms that the code is running a browser rather.  This is required.
       * @returns Promise<boolean> indicating whether this operating context is currently available.
       */
      async initialize() {
        this.available = typeof window !== "undefined";
        return this.available;
      }
    };
    StandardOperatingContext.MODULE_NAME = "";
    StandardOperatingContext.ID = "StandardOperatingContext";
  }
});

// node_modules/@azure/msal-browser/dist/cache/DatabaseStorage.mjs
var DatabaseStorage;
var init_DatabaseStorage = __esm({
  "node_modules/@azure/msal-browser/dist/cache/DatabaseStorage.mjs"() {
    "use strict";
    init_BrowserAuthError();
    init_BrowserConstants();
    init_BrowserAuthErrorCodes();
    DatabaseStorage = class {
      constructor() {
        this.dbName = DB_NAME;
        this.version = DB_VERSION;
        this.tableName = DB_TABLE_NAME;
        this.dbOpen = false;
      }
      /**
       * Opens IndexedDB instance.
       */
      async open() {
        return new Promise((resolve, reject) => {
          const openDB = window.indexedDB.open(this.dbName, this.version);
          openDB.addEventListener("upgradeneeded", (e) => {
            const event = e;
            event.target.result.createObjectStore(this.tableName);
          });
          openDB.addEventListener("success", (e) => {
            const event = e;
            this.db = event.target.result;
            this.dbOpen = true;
            resolve();
          });
          openDB.addEventListener("error", () => reject(createBrowserAuthError(databaseUnavailable)));
        });
      }
      /**
       * Closes the connection to IndexedDB database when all pending transactions
       * complete.
       */
      closeConnection() {
        const db = this.db;
        if (db && this.dbOpen) {
          db.close();
          this.dbOpen = false;
        }
      }
      /**
       * Opens database if it's not already open
       */
      async validateDbIsOpen() {
        if (!this.dbOpen) {
          return this.open();
        }
      }
      /**
       * Retrieves item from IndexedDB instance.
       * @param key
       */
      async getItem(key) {
        await this.validateDbIsOpen();
        return new Promise((resolve, reject) => {
          if (!this.db) {
            return reject(createBrowserAuthError(databaseNotOpen));
          }
          const transaction = this.db.transaction([this.tableName], "readonly");
          const objectStore = transaction.objectStore(this.tableName);
          const dbGet = objectStore.get(key);
          dbGet.addEventListener("success", (e) => {
            const event = e;
            this.closeConnection();
            resolve(event.target.result);
          });
          dbGet.addEventListener("error", (e) => {
            this.closeConnection();
            reject(e);
          });
        });
      }
      /**
       * Adds item to IndexedDB under given key
       * @param key
       * @param payload
       */
      async setItem(key, payload) {
        await this.validateDbIsOpen();
        return new Promise((resolve, reject) => {
          if (!this.db) {
            return reject(createBrowserAuthError(databaseNotOpen));
          }
          const transaction = this.db.transaction([this.tableName], "readwrite");
          const objectStore = transaction.objectStore(this.tableName);
          const dbPut = objectStore.put(payload, key);
          dbPut.addEventListener("success", () => {
            this.closeConnection();
            resolve();
          });
          dbPut.addEventListener("error", (e) => {
            this.closeConnection();
            reject(e);
          });
        });
      }
      /**
       * Removes item from IndexedDB under given key
       * @param key
       */
      async removeItem(key) {
        await this.validateDbIsOpen();
        return new Promise((resolve, reject) => {
          if (!this.db) {
            return reject(createBrowserAuthError(databaseNotOpen));
          }
          const transaction = this.db.transaction([this.tableName], "readwrite");
          const objectStore = transaction.objectStore(this.tableName);
          const dbDelete = objectStore.delete(key);
          dbDelete.addEventListener("success", () => {
            this.closeConnection();
            resolve();
          });
          dbDelete.addEventListener("error", (e) => {
            this.closeConnection();
            reject(e);
          });
        });
      }
      /**
       * Get all the keys from the storage object as an iterable array of strings.
       */
      async getKeys() {
        await this.validateDbIsOpen();
        return new Promise((resolve, reject) => {
          if (!this.db) {
            return reject(createBrowserAuthError(databaseNotOpen));
          }
          const transaction = this.db.transaction([this.tableName], "readonly");
          const objectStore = transaction.objectStore(this.tableName);
          const dbGetKeys = objectStore.getAllKeys();
          dbGetKeys.addEventListener("success", (e) => {
            const event = e;
            this.closeConnection();
            resolve(event.target.result);
          });
          dbGetKeys.addEventListener("error", (e) => {
            this.closeConnection();
            reject(e);
          });
        });
      }
      /**
       *
       * Checks whether there is an object under the search key in the object store
       */
      async containsKey(key) {
        await this.validateDbIsOpen();
        return new Promise((resolve, reject) => {
          if (!this.db) {
            return reject(createBrowserAuthError(databaseNotOpen));
          }
          const transaction = this.db.transaction([this.tableName], "readonly");
          const objectStore = transaction.objectStore(this.tableName);
          const dbContainsKey = objectStore.count(key);
          dbContainsKey.addEventListener("success", (e) => {
            const event = e;
            this.closeConnection();
            resolve(event.target.result === 1);
          });
          dbContainsKey.addEventListener("error", (e) => {
            this.closeConnection();
            reject(e);
          });
        });
      }
      /**
       * Deletes the MSAL database. The database is deleted rather than cleared to make it possible
       * for client applications to downgrade to a previous MSAL version without worrying about forward compatibility issues
       * with IndexedDB database versions.
       */
      async deleteDatabase() {
        if (this.db && this.dbOpen) {
          this.closeConnection();
        }
        return new Promise((resolve, reject) => {
          const deleteDbRequest = window.indexedDB.deleteDatabase(DB_NAME);
          const id = setTimeout(() => reject(false), 200);
          deleteDbRequest.addEventListener("success", () => {
            clearTimeout(id);
            return resolve(true);
          });
          deleteDbRequest.addEventListener("blocked", () => {
            clearTimeout(id);
            return resolve(true);
          });
          deleteDbRequest.addEventListener("error", () => {
            clearTimeout(id);
            return reject(false);
          });
        });
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/cache/MemoryStorage.mjs
var MemoryStorage;
var init_MemoryStorage = __esm({
  "node_modules/@azure/msal-browser/dist/cache/MemoryStorage.mjs"() {
    "use strict";
    MemoryStorage = class {
      constructor() {
        this.cache = /* @__PURE__ */ new Map();
      }
      async initialize() {
      }
      getItem(key) {
        return this.cache.get(key) || null;
      }
      getUserData(key) {
        return this.getItem(key);
      }
      setItem(key, value) {
        this.cache.set(key, value);
      }
      async setUserData(key, value) {
        this.setItem(key, value);
      }
      removeItem(key) {
        this.cache.delete(key);
      }
      getKeys() {
        const cacheKeys = [];
        this.cache.forEach((value, key) => {
          cacheKeys.push(key);
        });
        return cacheKeys;
      }
      containsKey(key) {
        return this.cache.has(key);
      }
      clear() {
        this.cache.clear();
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/cache/AsyncMemoryStorage.mjs
var AsyncMemoryStorage;
var init_AsyncMemoryStorage = __esm({
  "node_modules/@azure/msal-browser/dist/cache/AsyncMemoryStorage.mjs"() {
    "use strict";
    init_BrowserAuthError();
    init_DatabaseStorage();
    init_MemoryStorage();
    init_BrowserAuthErrorCodes();
    AsyncMemoryStorage = class {
      constructor(logger24) {
        this.inMemoryCache = new MemoryStorage();
        this.indexedDBCache = new DatabaseStorage();
        this.logger = logger24;
      }
      handleDatabaseAccessError(error) {
        if (error instanceof BrowserAuthError && error.errorCode === databaseUnavailable) {
          this.logger.error("Could not access persistent storage. This may be caused by browser privacy features which block persistent storage in third-party contexts.");
        } else {
          throw error;
        }
      }
      /**
       * Get the item matching the given key. Tries in-memory cache first, then in the asynchronous
       * storage object if item isn't found in-memory.
       * @param key
       */
      async getItem(key) {
        const item = this.inMemoryCache.getItem(key);
        if (!item) {
          try {
            this.logger.verbose("Queried item not found in in-memory cache, now querying persistent storage.");
            return await this.indexedDBCache.getItem(key);
          } catch (e) {
            this.handleDatabaseAccessError(e);
          }
        }
        return item;
      }
      /**
       * Sets the item in the in-memory cache and then tries to set it in the asynchronous
       * storage object with the given key.
       * @param key
       * @param value
       */
      async setItem(key, value) {
        this.inMemoryCache.setItem(key, value);
        try {
          await this.indexedDBCache.setItem(key, value);
        } catch (e) {
          this.handleDatabaseAccessError(e);
        }
      }
      /**
       * Removes the item matching the key from the in-memory cache, then tries to remove it from the asynchronous storage object.
       * @param key
       */
      async removeItem(key) {
        this.inMemoryCache.removeItem(key);
        try {
          await this.indexedDBCache.removeItem(key);
        } catch (e) {
          this.handleDatabaseAccessError(e);
        }
      }
      /**
       * Get all the keys from the in-memory cache as an iterable array of strings. If no keys are found, query the keys in the
       * asynchronous storage object.
       */
      async getKeys() {
        const cacheKeys = this.inMemoryCache.getKeys();
        if (cacheKeys.length === 0) {
          try {
            this.logger.verbose("In-memory cache is empty, now querying persistent storage.");
            return await this.indexedDBCache.getKeys();
          } catch (e) {
            this.handleDatabaseAccessError(e);
          }
        }
        return cacheKeys;
      }
      /**
       * Returns true or false if the given key is present in the cache.
       * @param key
       */
      async containsKey(key) {
        const containsKey = this.inMemoryCache.containsKey(key);
        if (!containsKey) {
          try {
            this.logger.verbose("Key not found in in-memory cache, now querying persistent storage.");
            return await this.indexedDBCache.containsKey(key);
          } catch (e) {
            this.handleDatabaseAccessError(e);
          }
        }
        return containsKey;
      }
      /**
       * Clears in-memory Map
       */
      clearInMemory() {
        this.logger.verbose(`Deleting in-memory keystore`);
        this.inMemoryCache.clear();
        this.logger.verbose(`In-memory keystore deleted`);
      }
      /**
       * Tries to delete the IndexedDB database
       * @returns
       */
      async clearPersistent() {
        try {
          this.logger.verbose("Deleting persistent keystore");
          const dbDeleted = await this.indexedDBCache.deleteDatabase();
          if (dbDeleted) {
            this.logger.verbose("Persistent keystore deleted");
          }
          return dbDeleted;
        } catch (e) {
          this.handleDatabaseAccessError(e);
          return false;
        }
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/crypto/CryptoOps.mjs
function getSortedObjectString(obj) {
  return JSON.stringify(obj, Object.keys(obj).sort());
}
var CryptoOps;
var init_CryptoOps = __esm({
  "node_modules/@azure/msal-browser/dist/crypto/CryptoOps.mjs"() {
    "use strict";
    init_index_browser();
    init_Base64Encode();
    init_Base64Decode();
    init_BrowserCrypto();
    init_BrowserAuthError();
    init_AsyncMemoryStorage();
    init_BrowserAuthErrorCodes();
    CryptoOps = class _CryptoOps {
      constructor(logger24, performanceClient, skipValidateSubtleCrypto) {
        this.logger = logger24;
        validateCryptoAvailable(skipValidateSubtleCrypto ?? false);
        this.cache = new AsyncMemoryStorage(this.logger);
        this.performanceClient = performanceClient;
      }
      /**
       * Creates a new random GUID - used to populate state and nonce.
       * @returns string (GUID)
       */
      createNewGuid() {
        return createNewGuid();
      }
      /**
       * Encodes input string to base64.
       * @param input
       */
      base64Encode(input) {
        return base64Encode(input);
      }
      /**
       * Decodes input string from base64.
       * @param input
       */
      base64Decode(input) {
        return base64Decode(input);
      }
      /**
       * Encodes input string to base64 URL safe string.
       * @param input
       */
      base64UrlEncode(input) {
        return urlEncode(input);
      }
      /**
       * Stringifies and base64Url encodes input public key
       * @param inputKid
       * @returns Base64Url encoded public key
       */
      encodeKid(inputKid) {
        return this.base64UrlEncode(JSON.stringify({ kid: inputKid }));
      }
      /**
       * Generates a keypair, stores it and returns a thumbprint
       * @param request
       */
      async getPublicKeyThumbprint(request) {
        var _a3;
        const publicKeyThumbMeasurement = (_a3 = this.performanceClient) == null ? void 0 : _a3.startMeasurement(PerformanceEvents.CryptoOptsGetPublicKeyThumbprint, request.correlationId);
        const keyPair = await generateKeyPair(_CryptoOps.EXTRACTABLE, _CryptoOps.POP_KEY_USAGES);
        const publicKeyJwk = await exportJwk(keyPair.publicKey);
        const pubKeyThumprintObj = {
          e: publicKeyJwk.e,
          kty: publicKeyJwk.kty,
          n: publicKeyJwk.n
        };
        const publicJwkString = getSortedObjectString(pubKeyThumprintObj);
        const publicJwkHash = await this.hashString(publicJwkString);
        const privateKeyJwk = await exportJwk(keyPair.privateKey);
        const unextractablePrivateKey = await importJwk(privateKeyJwk, false, ["sign"]);
        await this.cache.setItem(publicJwkHash, {
          privateKey: unextractablePrivateKey,
          publicKey: keyPair.publicKey,
          requestMethod: request.resourceRequestMethod,
          requestUri: request.resourceRequestUri
        });
        if (publicKeyThumbMeasurement) {
          publicKeyThumbMeasurement.end({
            success: true
          });
        }
        return publicJwkHash;
      }
      /**
       * Removes cryptographic keypair from key store matching the keyId passed in
       * @param kid
       */
      async removeTokenBindingKey(kid) {
        await this.cache.removeItem(kid);
        const keyFound = await this.cache.containsKey(kid);
        if (keyFound) {
          throw createClientAuthError(ClientAuthErrorCodes_exports.bindingKeyNotRemoved);
        }
      }
      /**
       * Removes all cryptographic keys from IndexedDB storage
       */
      async clearKeystore() {
        this.cache.clearInMemory();
        try {
          await this.cache.clearPersistent();
          return true;
        } catch (e) {
          if (e instanceof Error) {
            this.logger.error(`Clearing keystore failed with error: ${e.message}`);
          } else {
            this.logger.error("Clearing keystore failed with unknown error");
          }
          return false;
        }
      }
      /**
       * Signs the given object as a jwt payload with private key retrieved by given kid.
       * @param payload
       * @param kid
       */
      async signJwt(payload, kid, shrOptions, correlationId) {
        var _a3;
        const signJwtMeasurement = (_a3 = this.performanceClient) == null ? void 0 : _a3.startMeasurement(PerformanceEvents.CryptoOptsSignJwt, correlationId);
        const cachedKeyPair = await this.cache.getItem(kid);
        if (!cachedKeyPair) {
          throw createBrowserAuthError(cryptoKeyNotFound);
        }
        const publicKeyJwk = await exportJwk(cachedKeyPair.publicKey);
        const publicKeyJwkString = getSortedObjectString(publicKeyJwk);
        const encodedKeyIdThumbprint = urlEncode(JSON.stringify({ kid }));
        const shrHeader = JoseHeader.getShrHeaderString({
          ...shrOptions == null ? void 0 : shrOptions.header,
          alg: publicKeyJwk.alg,
          kid: encodedKeyIdThumbprint
        });
        const encodedShrHeader = urlEncode(shrHeader);
        payload.cnf = {
          jwk: JSON.parse(publicKeyJwkString)
        };
        const encodedPayload = urlEncode(JSON.stringify(payload));
        const tokenString = `${encodedShrHeader}.${encodedPayload}`;
        const encoder = new TextEncoder();
        const tokenBuffer = encoder.encode(tokenString);
        const signatureBuffer = await sign(cachedKeyPair.privateKey, tokenBuffer);
        const encodedSignature = urlEncodeArr(new Uint8Array(signatureBuffer));
        const signedJwt = `${tokenString}.${encodedSignature}`;
        if (signJwtMeasurement) {
          signJwtMeasurement.end({
            success: true
          });
        }
        return signedJwt;
      }
      /**
       * Returns the SHA-256 hash of an input string
       * @param plainText
       */
      async hashString(plainText) {
        return hashString(plainText);
      }
    };
    CryptoOps.POP_KEY_USAGES = ["sign", "verify"];
    CryptoOps.EXTRACTABLE = true;
  }
});

// node_modules/@azure/msal-browser/dist/cache/CookieStorage.mjs
function getCookieExpirationTime(cookieLifeDays) {
  const today = /* @__PURE__ */ new Date();
  const expr = new Date(today.getTime() + cookieLifeDays * COOKIE_LIFE_MULTIPLIER);
  return expr.toUTCString();
}
var COOKIE_LIFE_MULTIPLIER, SameSiteOptions, CookieStorage;
var init_CookieStorage = __esm({
  "node_modules/@azure/msal-browser/dist/cache/CookieStorage.mjs"() {
    "use strict";
    init_index_browser();
    COOKIE_LIFE_MULTIPLIER = 24 * 60 * 60 * 1e3;
    SameSiteOptions = {
      Lax: "Lax",
      None: "None"
    };
    CookieStorage = class {
      initialize() {
        return Promise.resolve();
      }
      getItem(key) {
        const name3 = `${encodeURIComponent(key)}`;
        const cookieList = document.cookie.split(";");
        for (let i = 0; i < cookieList.length; i++) {
          const cookie = cookieList[i];
          const [key2, ...rest] = decodeURIComponent(cookie).trim().split("=");
          const value = rest.join("=");
          if (key2 === name3) {
            return value;
          }
        }
        return "";
      }
      getUserData() {
        throw createClientAuthError(ClientAuthErrorCodes_exports.methodNotImplemented);
      }
      setItem(key, value, cookieLifeDays, secure = true, sameSite = SameSiteOptions.Lax) {
        let cookieStr = `${encodeURIComponent(key)}=${encodeURIComponent(value)};path=/;SameSite=${sameSite};`;
        if (cookieLifeDays) {
          const expireTime = getCookieExpirationTime(cookieLifeDays);
          cookieStr += `expires=${expireTime};`;
        }
        if (secure || sameSite === SameSiteOptions.None) {
          cookieStr += "Secure;";
        }
        document.cookie = cookieStr;
      }
      async setUserData() {
        return Promise.reject(createClientAuthError(ClientAuthErrorCodes_exports.methodNotImplemented));
      }
      removeItem(key) {
        this.setItem(key, "", -1);
      }
      getKeys() {
        const cookieList = document.cookie.split(";");
        const keys = [];
        cookieList.forEach((cookie) => {
          const cookieParts = decodeURIComponent(cookie).trim().split("=");
          keys.push(cookieParts[0]);
        });
        return keys;
      }
      containsKey(key) {
        return this.getKeys().includes(key);
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/cache/CacheHelpers.mjs
function getAccountKeys(storage) {
  const accountKeys = storage.getItem(StaticCacheKeys.ACCOUNT_KEYS);
  if (accountKeys) {
    return JSON.parse(accountKeys);
  }
  return [];
}
function getTokenKeys(clientId, storage) {
  const item = storage.getItem(`${StaticCacheKeys.TOKEN_KEYS}.${clientId}`);
  if (item) {
    const tokenKeys = JSON.parse(item);
    if (tokenKeys && tokenKeys.hasOwnProperty("idToken") && tokenKeys.hasOwnProperty("accessToken") && tokenKeys.hasOwnProperty("refreshToken")) {
      return tokenKeys;
    }
  }
  return {
    idToken: [],
    accessToken: [],
    refreshToken: []
  };
}
var init_CacheHelpers2 = __esm({
  "node_modules/@azure/msal-browser/dist/cache/CacheHelpers.mjs"() {
    "use strict";
    init_BrowserConstants();
  }
});

// node_modules/@azure/msal-browser/dist/cache/LocalStorage.mjs
var ENCRYPTION_KEY, BROADCAST_CHANNEL_NAME, LocalStorage;
var init_LocalStorage = __esm({
  "node_modules/@azure/msal-browser/dist/cache/LocalStorage.mjs"() {
    "use strict";
    init_index_browser();
    init_BrowserCrypto();
    init_Base64Decode();
    init_Base64Encode();
    init_BrowserAuthError();
    init_BrowserConfigurationAuthError();
    init_CookieStorage();
    init_MemoryStorage();
    init_CacheHelpers2();
    init_BrowserConstants();
    init_BrowserConfigurationAuthErrorCodes();
    init_BrowserAuthErrorCodes();
    ENCRYPTION_KEY = "msal.cache.encryption";
    BROADCAST_CHANNEL_NAME = "msal.broadcast.cache";
    LocalStorage = class {
      constructor(clientId, logger24, performanceClient) {
        if (!window.localStorage) {
          throw createBrowserConfigurationAuthError(storageNotSupported);
        }
        this.memoryStorage = new MemoryStorage();
        this.initialized = false;
        this.clientId = clientId;
        this.logger = logger24;
        this.performanceClient = performanceClient;
        this.broadcast = new BroadcastChannel(BROADCAST_CHANNEL_NAME);
      }
      async initialize(correlationId) {
        const cookies = new CookieStorage();
        const cookieString = cookies.getItem(ENCRYPTION_KEY);
        let parsedCookie = { key: "", id: "" };
        if (cookieString) {
          try {
            parsedCookie = JSON.parse(cookieString);
          } catch (e) {
          }
        }
        if (parsedCookie.key && parsedCookie.id) {
          const baseKey = invoke(base64DecToArr, PerformanceEvents.Base64Decode, this.logger, this.performanceClient, correlationId)(parsedCookie.key);
          this.encryptionCookie = {
            id: parsedCookie.id,
            key: await invokeAsync(generateHKDF, PerformanceEvents.GenerateHKDF, this.logger, this.performanceClient, correlationId)(baseKey)
          };
          await invokeAsync(this.importExistingCache.bind(this), PerformanceEvents.ImportExistingCache, this.logger, this.performanceClient, correlationId)(correlationId);
        } else {
          this.clear();
          const id = createNewGuid();
          const baseKey = await invokeAsync(generateBaseKey, PerformanceEvents.GenerateBaseKey, this.logger, this.performanceClient, correlationId)();
          const keyStr = invoke(urlEncodeArr, PerformanceEvents.UrlEncodeArr, this.logger, this.performanceClient, correlationId)(new Uint8Array(baseKey));
          this.encryptionCookie = {
            id,
            key: await invokeAsync(generateHKDF, PerformanceEvents.GenerateHKDF, this.logger, this.performanceClient, correlationId)(baseKey)
          };
          const cookieData = {
            id,
            key: keyStr
          };
          cookies.setItem(
            ENCRYPTION_KEY,
            JSON.stringify(cookieData),
            0,
            // Expiration - 0 means cookie will be cleared at the end of the browser session
            true,
            // Secure flag
            SameSiteOptions.None
            // SameSite must be None to support iframed apps
          );
        }
        this.broadcast.addEventListener("message", this.updateCache.bind(this));
        this.initialized = true;
      }
      getItem(key) {
        return window.localStorage.getItem(key);
      }
      getUserData(key) {
        if (!this.initialized) {
          throw createBrowserAuthError(uninitializedPublicClientApplication);
        }
        return this.memoryStorage.getItem(key);
      }
      setItem(key, value) {
        window.localStorage.setItem(key, value);
      }
      async setUserData(key, value, correlationId, timestamp) {
        if (!this.initialized || !this.encryptionCookie) {
          throw createBrowserAuthError(uninitializedPublicClientApplication);
        }
        const { data, nonce } = await invokeAsync(encrypt, PerformanceEvents.Encrypt, this.logger, this.performanceClient, correlationId)(this.encryptionCookie.key, value, this.getContext(key));
        const encryptedData = {
          id: this.encryptionCookie.id,
          nonce,
          data,
          lastUpdatedAt: timestamp
        };
        this.memoryStorage.setItem(key, value);
        this.setItem(key, JSON.stringify(encryptedData));
        this.broadcast.postMessage({
          key,
          value,
          context: this.getContext(key)
        });
      }
      removeItem(key) {
        if (this.memoryStorage.containsKey(key)) {
          this.memoryStorage.removeItem(key);
          this.broadcast.postMessage({
            key,
            value: null,
            context: this.getContext(key)
          });
        }
        window.localStorage.removeItem(key);
      }
      getKeys() {
        return Object.keys(window.localStorage);
      }
      containsKey(key) {
        return window.localStorage.hasOwnProperty(key);
      }
      /**
       * Removes all known MSAL keys from the cache
       */
      clear() {
        this.memoryStorage.clear();
        const accountKeys = getAccountKeys(this);
        accountKeys.forEach((key) => this.removeItem(key));
        const tokenKeys = getTokenKeys(this.clientId, this);
        tokenKeys.idToken.forEach((key) => this.removeItem(key));
        tokenKeys.accessToken.forEach((key) => this.removeItem(key));
        tokenKeys.refreshToken.forEach((key) => this.removeItem(key));
        this.getKeys().forEach((cacheKey) => {
          if (cacheKey.startsWith(Constants.CACHE_PREFIX) || cacheKey.indexOf(this.clientId) !== -1) {
            this.removeItem(cacheKey);
          }
        });
      }
      /**
       * Helper to decrypt all known MSAL keys in localStorage and save them to inMemory storage
       * @returns
       */
      async importExistingCache(correlationId) {
        if (!this.encryptionCookie) {
          return;
        }
        let accountKeys = getAccountKeys(this);
        accountKeys = await this.importArray(accountKeys, correlationId);
        this.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys));
        const tokenKeys = getTokenKeys(this.clientId, this);
        tokenKeys.idToken = await this.importArray(tokenKeys.idToken, correlationId);
        tokenKeys.accessToken = await this.importArray(tokenKeys.accessToken, correlationId);
        tokenKeys.refreshToken = await this.importArray(tokenKeys.refreshToken, correlationId);
        this.setItem(`${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`, JSON.stringify(tokenKeys));
      }
      /**
       * Helper to decrypt and save cache entries
       * @param key
       * @returns
       */
      async getItemFromEncryptedCache(key, correlationId) {
        if (!this.encryptionCookie) {
          return null;
        }
        const rawCache = this.getItem(key);
        if (!rawCache) {
          return null;
        }
        let encObj;
        try {
          encObj = JSON.parse(rawCache);
        } catch (e) {
          return null;
        }
        if (!encObj.id || !encObj.nonce || !encObj.data) {
          this.performanceClient.incrementFields({ unencryptedCacheCount: 1 }, correlationId);
          return null;
        }
        if (encObj.id !== this.encryptionCookie.id) {
          this.performanceClient.incrementFields({ encryptedCacheExpiredCount: 1 }, correlationId);
          return null;
        }
        return invokeAsync(decrypt, PerformanceEvents.Decrypt, this.logger, this.performanceClient, correlationId)(this.encryptionCookie.key, encObj.nonce, this.getContext(key), encObj.data);
      }
      /**
       * Helper to decrypt and save an array of cache keys
       * @param arr
       * @returns Array of keys successfully imported
       */
      async importArray(arr, correlationId) {
        const importedArr = [];
        const promiseArr = [];
        arr.forEach((key) => {
          const promise = this.getItemFromEncryptedCache(key, correlationId).then((value) => {
            if (value) {
              this.memoryStorage.setItem(key, value);
              importedArr.push(key);
            } else {
              this.removeItem(key);
            }
          });
          promiseArr.push(promise);
        });
        await Promise.all(promiseArr);
        return importedArr;
      }
      /**
       * Gets encryption context for a given cache entry. This is clientId for app specific entries, empty string for shared entries
       * @param key
       * @returns
       */
      getContext(key) {
        let context3 = "";
        if (key.includes(this.clientId)) {
          context3 = this.clientId;
        }
        return context3;
      }
      updateCache(event) {
        this.logger.trace("Updating internal cache from broadcast event");
        const perfMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.LocalStorageUpdated);
        perfMeasurement.add({ isBackground: true });
        const { key, value, context: context3 } = event.data;
        if (!key) {
          this.logger.error("Broadcast event missing key");
          perfMeasurement.end({ success: false, errorCode: "noKey" });
          return;
        }
        if (context3 && context3 !== this.clientId) {
          this.logger.trace(`Ignoring broadcast event from clientId: ${context3}`);
          perfMeasurement.end({
            success: false,
            errorCode: "contextMismatch"
          });
          return;
        }
        if (!value) {
          this.memoryStorage.removeItem(key);
          this.logger.verbose("Removed item from internal cache");
        } else {
          this.memoryStorage.setItem(key, value);
          this.logger.verbose("Updated item in internal cache");
        }
        perfMeasurement.end({ success: true });
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/cache/SessionStorage.mjs
var SessionStorage;
var init_SessionStorage = __esm({
  "node_modules/@azure/msal-browser/dist/cache/SessionStorage.mjs"() {
    "use strict";
    init_BrowserConfigurationAuthError();
    init_BrowserConfigurationAuthErrorCodes();
    SessionStorage = class {
      constructor() {
        if (!window.sessionStorage) {
          throw createBrowserConfigurationAuthError(storageNotSupported);
        }
      }
      async initialize() {
      }
      getItem(key) {
        return window.sessionStorage.getItem(key);
      }
      getUserData(key) {
        return this.getItem(key);
      }
      setItem(key, value) {
        window.sessionStorage.setItem(key, value);
      }
      async setUserData(key, value) {
        this.setItem(key, value);
      }
      removeItem(key) {
        window.sessionStorage.removeItem(key);
      }
      getKeys() {
        return Object.keys(window.sessionStorage);
      }
      containsKey(key) {
        return window.sessionStorage.hasOwnProperty(key);
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/event/EventType.mjs
var EventType;
var init_EventType = __esm({
  "node_modules/@azure/msal-browser/dist/event/EventType.mjs"() {
    "use strict";
    EventType = {
      INITIALIZE_START: "msal:initializeStart",
      INITIALIZE_END: "msal:initializeEnd",
      ACCOUNT_ADDED: "msal:accountAdded",
      ACCOUNT_REMOVED: "msal:accountRemoved",
      ACTIVE_ACCOUNT_CHANGED: "msal:activeAccountChanged",
      LOGIN_START: "msal:loginStart",
      LOGIN_SUCCESS: "msal:loginSuccess",
      LOGIN_FAILURE: "msal:loginFailure",
      ACQUIRE_TOKEN_START: "msal:acquireTokenStart",
      ACQUIRE_TOKEN_SUCCESS: "msal:acquireTokenSuccess",
      ACQUIRE_TOKEN_FAILURE: "msal:acquireTokenFailure",
      ACQUIRE_TOKEN_NETWORK_START: "msal:acquireTokenFromNetworkStart",
      SSO_SILENT_START: "msal:ssoSilentStart",
      SSO_SILENT_SUCCESS: "msal:ssoSilentSuccess",
      SSO_SILENT_FAILURE: "msal:ssoSilentFailure",
      ACQUIRE_TOKEN_BY_CODE_START: "msal:acquireTokenByCodeStart",
      ACQUIRE_TOKEN_BY_CODE_SUCCESS: "msal:acquireTokenByCodeSuccess",
      ACQUIRE_TOKEN_BY_CODE_FAILURE: "msal:acquireTokenByCodeFailure",
      HANDLE_REDIRECT_START: "msal:handleRedirectStart",
      HANDLE_REDIRECT_END: "msal:handleRedirectEnd",
      POPUP_OPENED: "msal:popupOpened",
      LOGOUT_START: "msal:logoutStart",
      LOGOUT_SUCCESS: "msal:logoutSuccess",
      LOGOUT_FAILURE: "msal:logoutFailure",
      LOGOUT_END: "msal:logoutEnd",
      RESTORE_FROM_BFCACHE: "msal:restoreFromBFCache",
      BROKER_CONNECTION_ESTABLISHED: "msal:brokerConnectionEstablished"
    };
  }
});

// node_modules/@azure/msal-browser/dist/cache/BrowserCacheManager.mjs
function getStorageImplementation(clientId, cacheLocation, logger24, performanceClient) {
  try {
    switch (cacheLocation) {
      case BrowserCacheLocation.LocalStorage:
        return new LocalStorage(clientId, logger24, performanceClient);
      case BrowserCacheLocation.SessionStorage:
        return new SessionStorage();
      case BrowserCacheLocation.MemoryStorage:
      default:
        break;
    }
  } catch (e) {
    logger24.error(e);
  }
  return new MemoryStorage();
}
var BrowserCacheManager, DEFAULT_BROWSER_CACHE_MANAGER;
var init_BrowserCacheManager = __esm({
  "node_modules/@azure/msal-browser/dist/cache/BrowserCacheManager.mjs"() {
    "use strict";
    init_index_browser();
    init_BrowserAuthError();
    init_BrowserConstants();
    init_LocalStorage();
    init_SessionStorage();
    init_MemoryStorage();
    init_Base64Decode();
    init_Base64Encode();
    init_CookieStorage();
    init_CacheHelpers2();
    init_EventType();
    init_BrowserUtils();
    init_packageMetadata2();
    init_BrowserAuthErrorCodes();
    BrowserCacheManager = class extends CacheManager {
      constructor(clientId, cacheConfig, cryptoImpl, logger24, performanceClient, eventHandler, staticAuthorityOptions) {
        super(clientId, cryptoImpl, logger24, performanceClient, staticAuthorityOptions);
        this.cacheConfig = cacheConfig;
        this.logger = logger24;
        this.internalStorage = new MemoryStorage();
        this.browserStorage = getStorageImplementation(clientId, cacheConfig.cacheLocation, logger24, performanceClient);
        this.temporaryCacheStorage = getStorageImplementation(clientId, cacheConfig.temporaryCacheLocation, logger24, performanceClient);
        this.cookieStorage = new CookieStorage();
        this.eventHandler = eventHandler;
      }
      async initialize(correlationId) {
        await this.browserStorage.initialize(correlationId);
        this.trackVersionChanges(correlationId);
      }
      /**
       * Tracks upgrades and downgrades for telemetry and debugging purposes
       */
      trackVersionChanges(correlationId) {
        const previousVersion = this.browserStorage.getItem(StaticCacheKeys.VERSION);
        if (previousVersion) {
          this.logger.info(`MSAL.js was last initialized by version: ${previousVersion}`);
          this.performanceClient.addFields({ previousLibraryVersion: previousVersion }, correlationId);
        }
        if (previousVersion !== version2) {
          this.setItem(StaticCacheKeys.VERSION, version2, correlationId);
        }
      }
      /**
       * Parses passed value as JSON object, JSON.parse() will throw an error.
       * @param input
       */
      validateAndParseJson(jsonValue) {
        try {
          const parsedJson = JSON.parse(jsonValue);
          return parsedJson && typeof parsedJson === "object" ? parsedJson : null;
        } catch (error) {
          return null;
        }
      }
      /**
       * Helper to setItem in browser storage, with cleanup in case of quota errors
       * @param key
       * @param value
       */
      setItem(key, value, correlationId) {
        let accessTokenKeys = [];
        const maxRetries = 20;
        for (let i = 0; i <= maxRetries; i++) {
          try {
            this.browserStorage.setItem(key, value);
            if (i > 0) {
              this.removeAccessTokenKeys(accessTokenKeys.slice(0, i), correlationId);
            }
            break;
          } catch (e) {
            const cacheError = createCacheError(e);
            if (cacheError.errorCode === CacheErrorCodes_exports.cacheQuotaExceeded && i < maxRetries) {
              if (!accessTokenKeys.length) {
                if (key === `${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`) {
                  accessTokenKeys = JSON.parse(value).accessToken;
                } else {
                  accessTokenKeys = this.getTokenKeys().accessToken;
                }
              }
              if (accessTokenKeys.length <= i) {
                throw cacheError;
              }
              this.removeAccessToken(
                accessTokenKeys[i],
                correlationId,
                false
                // Don't save token keys yet, do it at the end
              );
            } else {
              throw cacheError;
            }
          }
        }
      }
      /**
       * Helper to setUserData in browser storage, with cleanup in case of quota errors
       * @param key
       * @param value
       * @param correlationId
       */
      async setUserData(key, value, correlationId, timestamp) {
        let accessTokenKeys = [];
        const maxRetries = 20;
        for (let i = 0; i <= maxRetries; i++) {
          try {
            await invokeAsync(this.browserStorage.setUserData.bind(this.browserStorage), PerformanceEvents.SetUserData, this.logger, this.performanceClient)(key, value, correlationId, timestamp);
            if (i > 0) {
              this.removeAccessTokenKeys(accessTokenKeys.slice(0, i), correlationId);
            }
            break;
          } catch (e) {
            const cacheError = createCacheError(e);
            if (cacheError.errorCode === CacheErrorCodes_exports.cacheQuotaExceeded && i < maxRetries) {
              if (!accessTokenKeys.length) {
                accessTokenKeys = this.getTokenKeys().accessToken;
              }
              if (accessTokenKeys.length <= i) {
                throw cacheError;
              }
              this.removeAccessToken(
                accessTokenKeys[i],
                correlationId,
                false
                // Don't save token keys yet, do it at the end
              );
            } else {
              throw cacheError;
            }
          }
        }
      }
      /**
       * Reads account from cache, deserializes it into an account entity and returns it.
       * If account is not found from the key, returns null and removes key from map.
       * @param accountKey
       * @returns
       */
      getAccount(accountKey, correlationId) {
        this.logger.trace("BrowserCacheManager.getAccount called");
        const serializedAccount = this.browserStorage.getUserData(accountKey);
        if (!serializedAccount) {
          this.removeAccountKeyFromMap(accountKey, correlationId);
          return null;
        }
        const parsedAccount = this.validateAndParseJson(serializedAccount);
        if (!parsedAccount || !AccountEntity.isAccountEntity(parsedAccount)) {
          return null;
        }
        return CacheManager.toObject(new AccountEntity(), parsedAccount);
      }
      /**
       * set account entity in the platform cache
       * @param account
       */
      async setAccount(account, correlationId) {
        this.logger.trace("BrowserCacheManager.setAccount called");
        const key = account.generateAccountKey();
        const timestamp = Date.now().toString();
        account.lastUpdatedAt = timestamp;
        await this.setUserData(key, JSON.stringify(account), correlationId, timestamp);
        const wasAdded = this.addAccountKeyToMap(key, correlationId);
        if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage && wasAdded) {
          this.eventHandler.emitEvent(EventType.ACCOUNT_ADDED, void 0, account.getAccountInfo());
        }
      }
      /**
       * Returns the array of account keys currently cached
       * @returns
       */
      getAccountKeys() {
        return getAccountKeys(this.browserStorage);
      }
      /**
       * Add a new account to the key map
       * @param key
       */
      addAccountKeyToMap(key, correlationId) {
        this.logger.trace("BrowserCacheManager.addAccountKeyToMap called");
        this.logger.tracePii(`BrowserCacheManager.addAccountKeyToMap called with key: ${key}`);
        const accountKeys = this.getAccountKeys();
        if (accountKeys.indexOf(key) === -1) {
          accountKeys.push(key);
          this.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys), correlationId);
          this.logger.verbose("BrowserCacheManager.addAccountKeyToMap account key added");
          return true;
        } else {
          this.logger.verbose("BrowserCacheManager.addAccountKeyToMap account key already exists in map");
          return false;
        }
      }
      /**
       * Remove an account from the key map
       * @param key
       */
      removeAccountKeyFromMap(key, correlationId) {
        this.logger.trace("BrowserCacheManager.removeAccountKeyFromMap called");
        this.logger.tracePii(`BrowserCacheManager.removeAccountKeyFromMap called with key: ${key}`);
        const accountKeys = this.getAccountKeys();
        const removalIndex = accountKeys.indexOf(key);
        if (removalIndex > -1) {
          accountKeys.splice(removalIndex, 1);
          if (accountKeys.length === 0) {
            this.removeItem(StaticCacheKeys.ACCOUNT_KEYS);
            return;
          } else {
            this.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys), correlationId);
          }
          this.logger.trace("BrowserCacheManager.removeAccountKeyFromMap account key removed");
        } else {
          this.logger.trace("BrowserCacheManager.removeAccountKeyFromMap key not found in existing map");
        }
      }
      /**
       * Extends inherited removeAccount function to include removal of the account key from the map
       * @param key
       */
      removeAccount(key, correlationId) {
        super.removeAccount(key, correlationId);
        this.removeAccountKeyFromMap(key, correlationId);
      }
      /**
       * Removes credentials associated with the provided account
       * @param account
       */
      removeAccountContext(account, correlationId) {
        super.removeAccountContext(account, correlationId);
        if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage) {
          this.eventHandler.emitEvent(EventType.ACCOUNT_REMOVED, void 0, account.getAccountInfo());
        }
      }
      /**
       * Removes given idToken from the cache and from the key map
       * @param key
       */
      removeIdToken(key, correlationId) {
        super.removeIdToken(key, correlationId);
        const tokenKeys = this.getTokenKeys();
        const idRemoval = tokenKeys.idToken.indexOf(key);
        if (idRemoval > -1) {
          this.logger.info("idToken removed from tokenKeys map");
          tokenKeys.idToken.splice(idRemoval, 1);
          this.setTokenKeys(tokenKeys, correlationId);
        }
      }
      /**
       * Removes given accessToken from the cache and from the key map
       * @param key
       */
      removeAccessToken(key, correlationId, updateTokenKeys = true) {
        super.removeAccessToken(key, correlationId);
        updateTokenKeys && this.removeAccessTokenKeys([key], correlationId);
      }
      /**
       * Remove access token key from the key map
       * @param key
       * @param correlationId
       * @param tokenKeys
       */
      removeAccessTokenKeys(keys, correlationId) {
        this.logger.trace("removeAccessTokenKey called");
        const tokenKeys = this.getTokenKeys();
        let keysRemoved = 0;
        keys.forEach((key) => {
          const accessRemoval = tokenKeys.accessToken.indexOf(key);
          if (accessRemoval > -1) {
            tokenKeys.accessToken.splice(accessRemoval, 1);
            keysRemoved++;
          }
        });
        if (keysRemoved > 0) {
          this.logger.info(`removed ${keysRemoved} accessToken keys from tokenKeys map`);
          this.setTokenKeys(tokenKeys, correlationId);
          return;
        }
      }
      /**
       * Removes given refreshToken from the cache and from the key map
       * @param key
       */
      removeRefreshToken(key, correlationId) {
        super.removeRefreshToken(key, correlationId);
        const tokenKeys = this.getTokenKeys();
        const refreshRemoval = tokenKeys.refreshToken.indexOf(key);
        if (refreshRemoval > -1) {
          this.logger.info("refreshToken removed from tokenKeys map");
          tokenKeys.refreshToken.splice(refreshRemoval, 1);
          this.setTokenKeys(tokenKeys, correlationId);
        }
      }
      /**
       * Gets the keys for the cached tokens associated with this clientId
       * @returns
       */
      getTokenKeys() {
        return getTokenKeys(this.clientId, this.browserStorage);
      }
      /**
       * Stores the token keys in the cache
       * @param tokenKeys
       * @param correlationId
       * @returns
       */
      setTokenKeys(tokenKeys, correlationId) {
        if (tokenKeys.idToken.length === 0 && tokenKeys.accessToken.length === 0 && tokenKeys.refreshToken.length === 0) {
          this.removeItem(`${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`);
          return;
        } else {
          this.setItem(`${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`, JSON.stringify(tokenKeys), correlationId);
        }
      }
      /**
       * generates idToken entity from a string
       * @param idTokenKey
       */
      getIdTokenCredential(idTokenKey, correlationId) {
        const value = this.browserStorage.getUserData(idTokenKey);
        if (!value) {
          this.logger.trace("BrowserCacheManager.getIdTokenCredential: called, no cache hit");
          this.removeIdToken(idTokenKey, correlationId);
          return null;
        }
        const parsedIdToken = this.validateAndParseJson(value);
        if (!parsedIdToken || !CacheHelpers_exports.isIdTokenEntity(parsedIdToken)) {
          this.logger.trace("BrowserCacheManager.getIdTokenCredential: called, no cache hit");
          return null;
        }
        this.logger.trace("BrowserCacheManager.getIdTokenCredential: cache hit");
        return parsedIdToken;
      }
      /**
       * set IdToken credential to the platform cache
       * @param idToken
       */
      async setIdTokenCredential(idToken, correlationId) {
        this.logger.trace("BrowserCacheManager.setIdTokenCredential called");
        const idTokenKey = CacheHelpers_exports.generateCredentialKey(idToken);
        const timestamp = Date.now().toString();
        idToken.lastUpdatedAt = timestamp;
        await this.setUserData(idTokenKey, JSON.stringify(idToken), correlationId, timestamp);
        const tokenKeys = this.getTokenKeys();
        if (tokenKeys.idToken.indexOf(idTokenKey) === -1) {
          this.logger.info("BrowserCacheManager: addTokenKey - idToken added to map");
          tokenKeys.idToken.push(idTokenKey);
          this.setTokenKeys(tokenKeys, correlationId);
        }
      }
      /**
       * generates accessToken entity from a string
       * @param key
       */
      getAccessTokenCredential(accessTokenKey, correlationId) {
        const value = this.browserStorage.getUserData(accessTokenKey);
        if (!value) {
          this.logger.trace("BrowserCacheManager.getAccessTokenCredential: called, no cache hit");
          this.removeAccessTokenKeys([accessTokenKey], correlationId);
          return null;
        }
        const parsedAccessToken = this.validateAndParseJson(value);
        if (!parsedAccessToken || !CacheHelpers_exports.isAccessTokenEntity(parsedAccessToken)) {
          this.logger.trace("BrowserCacheManager.getAccessTokenCredential: called, no cache hit");
          return null;
        }
        this.logger.trace("BrowserCacheManager.getAccessTokenCredential: cache hit");
        return parsedAccessToken;
      }
      /**
       * set accessToken credential to the platform cache
       * @param accessToken
       */
      async setAccessTokenCredential(accessToken, correlationId) {
        this.logger.trace("BrowserCacheManager.setAccessTokenCredential called");
        const accessTokenKey = CacheHelpers_exports.generateCredentialKey(accessToken);
        const timestamp = Date.now().toString();
        accessToken.lastUpdatedAt = timestamp;
        await this.setUserData(accessTokenKey, JSON.stringify(accessToken), correlationId, timestamp);
        const tokenKeys = this.getTokenKeys();
        const index = tokenKeys.accessToken.indexOf(accessTokenKey);
        if (index !== -1) {
          tokenKeys.accessToken.splice(index, 1);
        }
        this.logger.trace(`access token ${index === -1 ? "added to" : "updated in"} map`);
        tokenKeys.accessToken.push(accessTokenKey);
        this.setTokenKeys(tokenKeys, correlationId);
      }
      /**
       * generates refreshToken entity from a string
       * @param refreshTokenKey
       */
      getRefreshTokenCredential(refreshTokenKey, correlationId) {
        const value = this.browserStorage.getUserData(refreshTokenKey);
        if (!value) {
          this.logger.trace("BrowserCacheManager.getRefreshTokenCredential: called, no cache hit");
          this.removeRefreshToken(refreshTokenKey, correlationId);
          return null;
        }
        const parsedRefreshToken = this.validateAndParseJson(value);
        if (!parsedRefreshToken || !CacheHelpers_exports.isRefreshTokenEntity(parsedRefreshToken)) {
          this.logger.trace("BrowserCacheManager.getRefreshTokenCredential: called, no cache hit");
          return null;
        }
        this.logger.trace("BrowserCacheManager.getRefreshTokenCredential: cache hit");
        return parsedRefreshToken;
      }
      /**
       * set refreshToken credential to the platform cache
       * @param refreshToken
       */
      async setRefreshTokenCredential(refreshToken, correlationId) {
        this.logger.trace("BrowserCacheManager.setRefreshTokenCredential called");
        const refreshTokenKey = CacheHelpers_exports.generateCredentialKey(refreshToken);
        const timestamp = Date.now().toString();
        refreshToken.lastUpdatedAt = timestamp;
        await this.setUserData(refreshTokenKey, JSON.stringify(refreshToken), correlationId, timestamp);
        const tokenKeys = this.getTokenKeys();
        if (tokenKeys.refreshToken.indexOf(refreshTokenKey) === -1) {
          this.logger.info("BrowserCacheManager: addTokenKey - refreshToken added to map");
          tokenKeys.refreshToken.push(refreshTokenKey);
          this.setTokenKeys(tokenKeys, correlationId);
        }
      }
      /**
       * fetch appMetadata entity from the platform cache
       * @param appMetadataKey
       */
      getAppMetadata(appMetadataKey) {
        const value = this.browserStorage.getItem(appMetadataKey);
        if (!value) {
          this.logger.trace("BrowserCacheManager.getAppMetadata: called, no cache hit");
          return null;
        }
        const parsedMetadata = this.validateAndParseJson(value);
        if (!parsedMetadata || !CacheHelpers_exports.isAppMetadataEntity(appMetadataKey, parsedMetadata)) {
          this.logger.trace("BrowserCacheManager.getAppMetadata: called, no cache hit");
          return null;
        }
        this.logger.trace("BrowserCacheManager.getAppMetadata: cache hit");
        return parsedMetadata;
      }
      /**
       * set appMetadata entity to the platform cache
       * @param appMetadata
       */
      setAppMetadata(appMetadata, correlationId) {
        this.logger.trace("BrowserCacheManager.setAppMetadata called");
        const appMetadataKey = CacheHelpers_exports.generateAppMetadataKey(appMetadata);
        this.setItem(appMetadataKey, JSON.stringify(appMetadata), correlationId);
      }
      /**
       * fetch server telemetry entity from the platform cache
       * @param serverTelemetryKey
       */
      getServerTelemetry(serverTelemetryKey) {
        const value = this.browserStorage.getItem(serverTelemetryKey);
        if (!value) {
          this.logger.trace("BrowserCacheManager.getServerTelemetry: called, no cache hit");
          return null;
        }
        const parsedEntity = this.validateAndParseJson(value);
        if (!parsedEntity || !CacheHelpers_exports.isServerTelemetryEntity(serverTelemetryKey, parsedEntity)) {
          this.logger.trace("BrowserCacheManager.getServerTelemetry: called, no cache hit");
          return null;
        }
        this.logger.trace("BrowserCacheManager.getServerTelemetry: cache hit");
        return parsedEntity;
      }
      /**
       * set server telemetry entity to the platform cache
       * @param serverTelemetryKey
       * @param serverTelemetry
       */
      setServerTelemetry(serverTelemetryKey, serverTelemetry, correlationId) {
        this.logger.trace("BrowserCacheManager.setServerTelemetry called");
        this.setItem(serverTelemetryKey, JSON.stringify(serverTelemetry), correlationId);
      }
      /**
       *
       */
      getAuthorityMetadata(key) {
        const value = this.internalStorage.getItem(key);
        if (!value) {
          this.logger.trace("BrowserCacheManager.getAuthorityMetadata: called, no cache hit");
          return null;
        }
        const parsedMetadata = this.validateAndParseJson(value);
        if (parsedMetadata && CacheHelpers_exports.isAuthorityMetadataEntity(key, parsedMetadata)) {
          this.logger.trace("BrowserCacheManager.getAuthorityMetadata: cache hit");
          return parsedMetadata;
        }
        return null;
      }
      /**
       *
       */
      getAuthorityMetadataKeys() {
        const allKeys = this.internalStorage.getKeys();
        return allKeys.filter((key) => {
          return this.isAuthorityMetadata(key);
        });
      }
      /**
       * Sets wrapper metadata in memory
       * @param wrapperSKU
       * @param wrapperVersion
       */
      setWrapperMetadata(wrapperSKU, wrapperVersion) {
        this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_SKU, wrapperSKU);
        this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_VER, wrapperVersion);
      }
      /**
       * Returns wrapper metadata from in-memory storage
       */
      getWrapperMetadata() {
        const sku = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_SKU) || Constants.EMPTY_STRING;
        const version3 = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_VER) || Constants.EMPTY_STRING;
        return [sku, version3];
      }
      /**
       *
       * @param entity
       */
      setAuthorityMetadata(key, entity) {
        this.logger.trace("BrowserCacheManager.setAuthorityMetadata called");
        this.internalStorage.setItem(key, JSON.stringify(entity));
      }
      /**
       * Gets the active account
       */
      getActiveAccount(correlationId) {
        const activeAccountKeyFilters = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);
        const activeAccountValueFilters = this.browserStorage.getItem(activeAccountKeyFilters);
        if (!activeAccountValueFilters) {
          this.logger.trace("BrowserCacheManager.getActiveAccount: No active account filters found");
          return null;
        }
        const activeAccountValueObj = this.validateAndParseJson(activeAccountValueFilters);
        if (activeAccountValueObj) {
          this.logger.trace("BrowserCacheManager.getActiveAccount: Active account filters schema found");
          return this.getAccountInfoFilteredBy({
            homeAccountId: activeAccountValueObj.homeAccountId,
            localAccountId: activeAccountValueObj.localAccountId,
            tenantId: activeAccountValueObj.tenantId
          }, correlationId);
        }
        this.logger.trace("BrowserCacheManager.getActiveAccount: No active account found");
        return null;
      }
      /**
       * Sets the active account's localAccountId in cache
       * @param account
       */
      setActiveAccount(account, correlationId) {
        const activeAccountKey = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);
        if (account) {
          this.logger.verbose("setActiveAccount: Active account set");
          const activeAccountValue = {
            homeAccountId: account.homeAccountId,
            localAccountId: account.localAccountId,
            tenantId: account.tenantId,
            lastUpdatedAt: TimeUtils_exports.nowSeconds().toString()
          };
          this.setItem(activeAccountKey, JSON.stringify(activeAccountValue), correlationId);
        } else {
          this.logger.verbose("setActiveAccount: No account passed, active account not set");
          this.browserStorage.removeItem(activeAccountKey);
        }
        this.eventHandler.emitEvent(EventType.ACTIVE_ACCOUNT_CHANGED);
      }
      /**
       * fetch throttling entity from the platform cache
       * @param throttlingCacheKey
       */
      getThrottlingCache(throttlingCacheKey) {
        const value = this.browserStorage.getItem(throttlingCacheKey);
        if (!value) {
          this.logger.trace("BrowserCacheManager.getThrottlingCache: called, no cache hit");
          return null;
        }
        const parsedThrottlingCache = this.validateAndParseJson(value);
        if (!parsedThrottlingCache || !CacheHelpers_exports.isThrottlingEntity(throttlingCacheKey, parsedThrottlingCache)) {
          this.logger.trace("BrowserCacheManager.getThrottlingCache: called, no cache hit");
          return null;
        }
        this.logger.trace("BrowserCacheManager.getThrottlingCache: cache hit");
        return parsedThrottlingCache;
      }
      /**
       * set throttling entity to the platform cache
       * @param throttlingCacheKey
       * @param throttlingCache
       */
      setThrottlingCache(throttlingCacheKey, throttlingCache, correlationId) {
        this.logger.trace("BrowserCacheManager.setThrottlingCache called");
        this.setItem(throttlingCacheKey, JSON.stringify(throttlingCache), correlationId);
      }
      /**
       * Gets cache item with given key.
       * Will retrieve from cookies if storeAuthStateInCookie is set to true.
       * @param key
       */
      getTemporaryCache(cacheKey, generateKey) {
        const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;
        if (this.cacheConfig.storeAuthStateInCookie) {
          const itemCookie = this.cookieStorage.getItem(key);
          if (itemCookie) {
            this.logger.trace("BrowserCacheManager.getTemporaryCache: storeAuthStateInCookies set to true, retrieving from cookies");
            return itemCookie;
          }
        }
        const value = this.temporaryCacheStorage.getItem(key);
        if (!value) {
          if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage) {
            const item = this.browserStorage.getItem(key);
            if (item) {
              this.logger.trace("BrowserCacheManager.getTemporaryCache: Temporary cache item found in local storage");
              return item;
            }
          }
          this.logger.trace("BrowserCacheManager.getTemporaryCache: No cache item found in local storage");
          return null;
        }
        this.logger.trace("BrowserCacheManager.getTemporaryCache: Temporary cache item returned");
        return value;
      }
      /**
       * Sets the cache item with the key and value given.
       * Stores in cookie if storeAuthStateInCookie is set to true.
       * This can cause cookie overflow if used incorrectly.
       * @param key
       * @param value
       */
      setTemporaryCache(cacheKey, value, generateKey) {
        const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;
        this.temporaryCacheStorage.setItem(key, value);
        if (this.cacheConfig.storeAuthStateInCookie) {
          this.logger.trace("BrowserCacheManager.setTemporaryCache: storeAuthStateInCookie set to true, setting item cookie");
          this.cookieStorage.setItem(key, value, void 0, this.cacheConfig.secureCookies);
        }
      }
      /**
       * Removes the cache item with the given key.
       * @param key
       */
      removeItem(key) {
        this.browserStorage.removeItem(key);
      }
      /**
       * Removes the temporary cache item with the given key.
       * Will also clear the cookie item if storeAuthStateInCookie is set to true.
       * @param key
       */
      removeTemporaryItem(key) {
        this.temporaryCacheStorage.removeItem(key);
        if (this.cacheConfig.storeAuthStateInCookie) {
          this.logger.trace("BrowserCacheManager.removeItem: storeAuthStateInCookie is true, clearing item cookie");
          this.cookieStorage.removeItem(key);
        }
      }
      /**
       * Gets all keys in window.
       */
      getKeys() {
        return this.browserStorage.getKeys();
      }
      /**
       * Clears all cache entries created by MSAL.
       */
      clear(correlationId) {
        this.removeAllAccounts(correlationId);
        this.removeAppMetadata(correlationId);
        this.temporaryCacheStorage.getKeys().forEach((cacheKey) => {
          if (cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1 || cacheKey.indexOf(this.clientId) !== -1) {
            this.removeTemporaryItem(cacheKey);
          }
        });
        this.browserStorage.getKeys().forEach((cacheKey) => {
          if (cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1 || cacheKey.indexOf(this.clientId) !== -1) {
            this.browserStorage.removeItem(cacheKey);
          }
        });
        this.internalStorage.clear();
      }
      /**
       * Clears all access tokes that have claims prior to saving the current one
       * @param performanceClient {IPerformanceClient}
       * @param correlationId {string} correlation id
       * @returns
       */
      clearTokensAndKeysWithClaims(correlationId) {
        this.performanceClient.addQueueMeasurement(PerformanceEvents.ClearTokensAndKeysWithClaims, correlationId);
        const tokenKeys = this.getTokenKeys();
        let removedAccessTokens = 0;
        tokenKeys.accessToken.forEach((key) => {
          const credential = this.getAccessTokenCredential(key, correlationId);
          if ((credential == null ? void 0 : credential.requestedClaimsHash) && key.includes(credential.requestedClaimsHash.toLowerCase())) {
            this.removeAccessToken(key, correlationId);
            removedAccessTokens++;
          }
        });
        if (removedAccessTokens > 0) {
          this.logger.warning(`${removedAccessTokens} access tokens with claims in the cache keys have been removed from the cache.`);
        }
      }
      /**
       * Prepend msal.<client-id> to each key; Skip for any JSON object as Key (defined schemas do not need the key appended: AccessToken Keys or the upcoming schema)
       * @param key
       * @param addInstanceId
       */
      generateCacheKey(key) {
        const generatedKey = this.validateAndParseJson(key);
        if (!generatedKey) {
          if (StringUtils.startsWith(key, Constants.CACHE_PREFIX)) {
            return key;
          }
          return `${Constants.CACHE_PREFIX}.${this.clientId}.${key}`;
        }
        return JSON.stringify(key);
      }
      /**
       * Reset all temporary cache items
       * @param state
       */
      resetRequestCache() {
        this.logger.trace("BrowserCacheManager.resetRequestCache called");
        this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));
        this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.VERIFIER));
        this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.ORIGIN_URI));
        this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.URL_HASH));
        this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.NATIVE_REQUEST));
        this.setInteractionInProgress(false);
      }
      cacheAuthorizeRequest(authCodeRequest, codeVerifier) {
        this.logger.trace("BrowserCacheManager.cacheAuthorizeRequest called");
        const encodedValue = base64Encode(JSON.stringify(authCodeRequest));
        this.setTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, encodedValue, true);
        if (codeVerifier) {
          const encodedVerifier = base64Encode(codeVerifier);
          this.setTemporaryCache(TemporaryCacheKeys.VERIFIER, encodedVerifier, true);
        }
      }
      /**
       * Gets the token exchange parameters from the cache. Throws an error if nothing is found.
       */
      getCachedRequest() {
        this.logger.trace("BrowserCacheManager.getCachedRequest called");
        const encodedTokenRequest = this.getTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, true);
        if (!encodedTokenRequest) {
          throw createBrowserAuthError(noTokenRequestCacheError);
        }
        const encodedVerifier = this.getTemporaryCache(TemporaryCacheKeys.VERIFIER, true);
        let parsedRequest;
        let verifier = "";
        try {
          parsedRequest = JSON.parse(base64Decode(encodedTokenRequest));
          if (encodedVerifier) {
            verifier = base64Decode(encodedVerifier);
          }
        } catch (e) {
          this.logger.errorPii(`Attempted to parse: ${encodedTokenRequest}`);
          this.logger.error(`Parsing cached token request threw with error: ${e}`);
          throw createBrowserAuthError(unableToParseTokenRequestCacheError);
        }
        return [parsedRequest, verifier];
      }
      /**
       * Gets cached native request for redirect flows
       */
      getCachedNativeRequest() {
        this.logger.trace("BrowserCacheManager.getCachedNativeRequest called");
        const cachedRequest = this.getTemporaryCache(TemporaryCacheKeys.NATIVE_REQUEST, true);
        if (!cachedRequest) {
          this.logger.trace("BrowserCacheManager.getCachedNativeRequest: No cached native request found");
          return null;
        }
        const parsedRequest = this.validateAndParseJson(cachedRequest);
        if (!parsedRequest) {
          this.logger.error("BrowserCacheManager.getCachedNativeRequest: Unable to parse native request");
          return null;
        }
        return parsedRequest;
      }
      isInteractionInProgress(matchClientId) {
        var _a3;
        const clientId = (_a3 = this.getInteractionInProgress()) == null ? void 0 : _a3.clientId;
        if (matchClientId) {
          return clientId === this.clientId;
        } else {
          return !!clientId;
        }
      }
      getInteractionInProgress() {
        const key = `${Constants.CACHE_PREFIX}.${TemporaryCacheKeys.INTERACTION_STATUS_KEY}`;
        const value = this.getTemporaryCache(key, false);
        try {
          return value ? JSON.parse(value) : null;
        } catch (e) {
          this.logger.error(`Cannot parse interaction status. Removing temporary cache items and clearing url hash. Retrying interaction should fix the error`);
          this.removeTemporaryItem(key);
          this.resetRequestCache();
          clearHash(window);
          return null;
        }
      }
      setInteractionInProgress(inProgress, type = INTERACTION_TYPE.SIGNIN) {
        var _a3;
        const key = `${Constants.CACHE_PREFIX}.${TemporaryCacheKeys.INTERACTION_STATUS_KEY}`;
        if (inProgress) {
          if (this.getInteractionInProgress()) {
            throw createBrowserAuthError(interactionInProgress);
          } else {
            this.setTemporaryCache(key, JSON.stringify({ clientId: this.clientId, type }), false);
          }
        } else if (!inProgress && ((_a3 = this.getInteractionInProgress()) == null ? void 0 : _a3.clientId) === this.clientId) {
          this.removeTemporaryItem(key);
        }
      }
      /**
       * Builds credential entities from AuthenticationResult object and saves the resulting credentials to the cache
       * @param result
       * @param request
       */
      async hydrateCache(result, request) {
        var _a3, _b2, _c2;
        const idTokenEntity = CacheHelpers_exports.createIdTokenEntity((_a3 = result.account) == null ? void 0 : _a3.homeAccountId, (_b2 = result.account) == null ? void 0 : _b2.environment, result.idToken, this.clientId, result.tenantId);
        let claimsHash;
        if (request.claims) {
          claimsHash = await this.cryptoImpl.hashString(request.claims);
        }
        const accessTokenEntity = CacheHelpers_exports.createAccessTokenEntity(
          (_c2 = result.account) == null ? void 0 : _c2.homeAccountId,
          result.account.environment,
          result.accessToken,
          this.clientId,
          result.tenantId,
          result.scopes.join(" "),
          // Access token expiresOn stored in seconds, converting from AuthenticationResult expiresOn stored as Date
          result.expiresOn ? TimeUtils_exports.toSecondsFromDate(result.expiresOn) : 0,
          result.extExpiresOn ? TimeUtils_exports.toSecondsFromDate(result.extExpiresOn) : 0,
          base64Decode,
          void 0,
          // refreshOn
          result.tokenType,
          void 0,
          // userAssertionHash
          request.sshKid,
          request.claims,
          claimsHash
        );
        const cacheRecord = {
          idToken: idTokenEntity,
          accessToken: accessTokenEntity
        };
        return this.saveCacheRecord(cacheRecord, result.correlationId);
      }
      /**
       * saves a cache record
       * @param cacheRecord {CacheRecord}
       * @param storeInCache {?StoreInCache}
       * @param correlationId {?string} correlation id
       */
      async saveCacheRecord(cacheRecord, correlationId, storeInCache) {
        try {
          await super.saveCacheRecord(cacheRecord, correlationId, storeInCache);
        } catch (e) {
          if (e instanceof CacheError && this.performanceClient && correlationId) {
            try {
              const tokenKeys = this.getTokenKeys();
              this.performanceClient.addFields({
                cacheRtCount: tokenKeys.refreshToken.length,
                cacheIdCount: tokenKeys.idToken.length,
                cacheAtCount: tokenKeys.accessToken.length
              }, correlationId);
            } catch (e2) {
            }
          }
          throw e;
        }
      }
    };
    DEFAULT_BROWSER_CACHE_MANAGER = (clientId, logger24, performanceClient, eventHandler) => {
      const cacheOptions = {
        cacheLocation: BrowserCacheLocation.MemoryStorage,
        temporaryCacheLocation: BrowserCacheLocation.MemoryStorage,
        storeAuthStateInCookie: false,
        secureCookies: false,
        cacheMigrationEnabled: false,
        claimsBasedCachingEnabled: false
      };
      return new BrowserCacheManager(clientId, cacheOptions, DEFAULT_CRYPTO_IMPLEMENTATION, logger24, performanceClient, eventHandler);
    };
  }
});

// node_modules/@azure/msal-browser/dist/cache/AccountManager.mjs
function getAllAccounts(logger24, browserStorage, isInBrowser, correlationId, accountFilter) {
  logger24.verbose("getAllAccounts called");
  return isInBrowser ? browserStorage.getAllAccounts(accountFilter || {}, correlationId) : [];
}
function getAccount(accountFilter, logger24, browserStorage, correlationId) {
  logger24.trace("getAccount called");
  if (Object.keys(accountFilter).length === 0) {
    logger24.warning("getAccount: No accountFilter provided");
    return null;
  }
  const account = browserStorage.getAccountInfoFilteredBy(accountFilter, correlationId);
  if (account) {
    logger24.verbose("getAccount: Account matching provided filter found, returning");
    return account;
  } else {
    logger24.verbose("getAccount: No matching account found, returning null");
    return null;
  }
}
function getAccountByUsername(username, logger24, browserStorage, correlationId) {
  logger24.trace("getAccountByUsername called");
  if (!username) {
    logger24.warning("getAccountByUsername: No username provided");
    return null;
  }
  const account = browserStorage.getAccountInfoFilteredBy({
    username
  }, correlationId);
  if (account) {
    logger24.verbose("getAccountByUsername: Account matching username found, returning");
    logger24.verbosePii(`getAccountByUsername: Returning signed-in accounts matching username: ${username}`);
    return account;
  } else {
    logger24.verbose("getAccountByUsername: No matching account found, returning null");
    return null;
  }
}
function getAccountByHomeId(homeAccountId, logger24, browserStorage, correlationId) {
  logger24.trace("getAccountByHomeId called");
  if (!homeAccountId) {
    logger24.warning("getAccountByHomeId: No homeAccountId provided");
    return null;
  }
  const account = browserStorage.getAccountInfoFilteredBy({
    homeAccountId
  }, correlationId);
  if (account) {
    logger24.verbose("getAccountByHomeId: Account matching homeAccountId found, returning");
    logger24.verbosePii(`getAccountByHomeId: Returning signed-in accounts matching homeAccountId: ${homeAccountId}`);
    return account;
  } else {
    logger24.verbose("getAccountByHomeId: No matching account found, returning null");
    return null;
  }
}
function getAccountByLocalId(localAccountId, logger24, browserStorage, correlationId) {
  logger24.trace("getAccountByLocalId called");
  if (!localAccountId) {
    logger24.warning("getAccountByLocalId: No localAccountId provided");
    return null;
  }
  const account = browserStorage.getAccountInfoFilteredBy({
    localAccountId
  }, correlationId);
  if (account) {
    logger24.verbose("getAccountByLocalId: Account matching localAccountId found, returning");
    logger24.verbosePii(`getAccountByLocalId: Returning signed-in accounts matching localAccountId: ${localAccountId}`);
    return account;
  } else {
    logger24.verbose("getAccountByLocalId: No matching account found, returning null");
    return null;
  }
}
function setActiveAccount(account, browserStorage, correlationId) {
  browserStorage.setActiveAccount(account, correlationId);
}
function getActiveAccount(browserStorage, correlationId) {
  return browserStorage.getActiveAccount(correlationId);
}
var init_AccountManager = __esm({
  "node_modules/@azure/msal-browser/dist/cache/AccountManager.mjs"() {
    "use strict";
  }
});

// node_modules/@azure/msal-browser/dist/event/EventHandler.mjs
var BROADCAST_CHANNEL_NAME2, EventHandler;
var init_EventHandler = __esm({
  "node_modules/@azure/msal-browser/dist/event/EventHandler.mjs"() {
    "use strict";
    init_index_browser();
    init_EventType();
    init_BrowserUtils();
    BROADCAST_CHANNEL_NAME2 = "msal.broadcast.event";
    EventHandler = class {
      constructor(logger24) {
        this.eventCallbacks = /* @__PURE__ */ new Map();
        this.logger = logger24 || new Logger({});
        if (typeof BroadcastChannel !== "undefined") {
          this.broadcastChannel = new BroadcastChannel(BROADCAST_CHANNEL_NAME2);
        }
        this.invokeCrossTabCallbacks = this.invokeCrossTabCallbacks.bind(this);
      }
      /**
       * Adds event callbacks to array
       * @param callback - callback to be invoked when an event is raised
       * @param eventTypes - list of events that this callback will be invoked for, if not provided callback will be invoked for all events
       * @param callbackId - Identifier for the callback, used to locate and remove the callback when no longer required
       */
      addEventCallback(callback, eventTypes, callbackId) {
        if (typeof window !== "undefined") {
          const id = callbackId || createGuid();
          if (this.eventCallbacks.has(id)) {
            this.logger.error(`Event callback with id: ${id} is already registered. Please provide a unique id or remove the existing callback and try again.`);
            return null;
          }
          this.eventCallbacks.set(id, [callback, eventTypes || []]);
          this.logger.verbose(`Event callback registered with id: ${id}`);
          return id;
        }
        return null;
      }
      /**
       * Removes callback with provided id from callback array
       * @param callbackId
       */
      removeEventCallback(callbackId) {
        this.eventCallbacks.delete(callbackId);
        this.logger.verbose(`Event callback ${callbackId} removed.`);
      }
      /**
       * Emits events by calling callback with event message
       * @param eventType
       * @param interactionType
       * @param payload
       * @param error
       */
      emitEvent(eventType, interactionType, payload, error) {
        var _a3;
        const message = {
          eventType,
          interactionType: interactionType || null,
          payload: payload || null,
          error: error || null,
          timestamp: Date.now()
        };
        switch (eventType) {
          case EventType.ACCOUNT_ADDED:
          case EventType.ACCOUNT_REMOVED:
          case EventType.ACTIVE_ACCOUNT_CHANGED:
            (_a3 = this.broadcastChannel) == null ? void 0 : _a3.postMessage(message);
            break;
          default:
            this.invokeCallbacks(message);
            break;
        }
      }
      /**
       * Invoke registered callbacks
       * @param message
       */
      invokeCallbacks(message) {
        this.eventCallbacks.forEach(([callback, eventTypes], callbackId) => {
          if (eventTypes.length === 0 || eventTypes.includes(message.eventType)) {
            this.logger.verbose(`Emitting event to callback ${callbackId}: ${message.eventType}`);
            callback.apply(null, [message]);
          }
        });
      }
      /**
       * Wrapper around invokeCallbacks to handle broadcast events received from other tabs/instances
       * @param event
       */
      invokeCrossTabCallbacks(event) {
        const message = event.data;
        this.invokeCallbacks(message);
      }
      /**
       * Listen for events broadcasted from other tabs/instances
       */
      subscribeCrossTab() {
        var _a3;
        (_a3 = this.broadcastChannel) == null ? void 0 : _a3.addEventListener("message", this.invokeCrossTabCallbacks);
      }
      /**
       * Unsubscribe from broadcast events
       */
      unsubscribeCrossTab() {
        var _a3;
        (_a3 = this.broadcastChannel) == null ? void 0 : _a3.removeEventListener("message", this.invokeCrossTabCallbacks);
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/interaction_client/BaseInteractionClient.mjs
var BaseInteractionClient;
var init_BaseInteractionClient = __esm({
  "node_modules/@azure/msal-browser/dist/interaction_client/BaseInteractionClient.mjs"() {
    "use strict";
    init_index_browser();
    init_packageMetadata2();
    init_BrowserConstants();
    init_BrowserUtils();
    init_BrowserCrypto();
    BaseInteractionClient = class {
      constructor(config, storageImpl, browserCrypto, logger24, eventHandler, navigationClient, performanceClient, platformAuthProvider, correlationId) {
        this.config = config;
        this.browserStorage = storageImpl;
        this.browserCrypto = browserCrypto;
        this.networkClient = this.config.system.networkClient;
        this.eventHandler = eventHandler;
        this.navigationClient = navigationClient;
        this.platformAuthProvider = platformAuthProvider;
        this.correlationId = correlationId || createNewGuid();
        this.logger = logger24.clone(BrowserConstants.MSAL_SKU, version2, this.correlationId);
        this.performanceClient = performanceClient;
      }
      async clearCacheOnLogout(correlationId, account) {
        if (account) {
          if (AccountEntity.accountInfoIsEqual(account, this.browserStorage.getActiveAccount(correlationId), false)) {
            this.logger.verbose("Setting active account to null");
            this.browserStorage.setActiveAccount(null, correlationId);
          }
          try {
            this.browserStorage.removeAccount(AccountEntity.generateAccountCacheKey(account), correlationId);
            this.logger.verbose("Cleared cache items belonging to the account provided in the logout request.");
          } catch (error) {
            this.logger.error("Account provided in logout request was not found. Local cache unchanged.");
          }
        } else {
          try {
            this.logger.verbose("No account provided in logout request, clearing all cache items.", this.correlationId);
            this.browserStorage.clear(correlationId);
            await this.browserCrypto.clearKeystore();
          } catch (e) {
            this.logger.error("Attempted to clear all MSAL cache items and failed. Local cache unchanged.");
          }
        }
      }
      /**
       *
       * Use to get the redirect uri configured in MSAL or null.
       * @param requestRedirectUri
       * @returns Redirect URL
       *
       */
      getRedirectUri(requestRedirectUri) {
        this.logger.verbose("getRedirectUri called");
        const redirectUri = requestRedirectUri || this.config.auth.redirectUri;
        return UrlString.getAbsoluteUrl(redirectUri, getCurrentUri());
      }
      /**
       *
       * @param apiId
       * @param correlationId
       * @param forceRefresh
       */
      initializeServerTelemetryManager(apiId, forceRefresh) {
        this.logger.verbose("initializeServerTelemetryManager called");
        const telemetryPayload = {
          clientId: this.config.auth.clientId,
          correlationId: this.correlationId,
          apiId,
          forceRefresh: forceRefresh || false,
          wrapperSKU: this.browserStorage.getWrapperMetadata()[0],
          wrapperVer: this.browserStorage.getWrapperMetadata()[1]
        };
        return new ServerTelemetryManager(telemetryPayload, this.browserStorage);
      }
      /**
       * Used to get a discovered version of the default authority.
       * @param params {
       *         requestAuthority?: string;
       *         requestAzureCloudOptions?: AzureCloudOptions;
       *         requestExtraQueryParameters?: StringDict;
       *         account?: AccountInfo;
       *        }
       */
      async getDiscoveredAuthority(params) {
        const { account } = params;
        const instanceAwareEQ = params.requestExtraQueryParameters && params.requestExtraQueryParameters.hasOwnProperty("instance_aware") ? params.requestExtraQueryParameters["instance_aware"] : void 0;
        this.performanceClient.addQueueMeasurement(PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority, this.correlationId);
        const authorityOptions = {
          protocolMode: this.config.auth.protocolMode,
          OIDCOptions: this.config.auth.OIDCOptions,
          knownAuthorities: this.config.auth.knownAuthorities,
          cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,
          authorityMetadata: this.config.auth.authorityMetadata,
          skipAuthorityMetadataCache: this.config.auth.skipAuthorityMetadataCache
        };
        const resolvedAuthority = params.requestAuthority || this.config.auth.authority;
        const resolvedInstanceAware = (instanceAwareEQ == null ? void 0 : instanceAwareEQ.length) ? instanceAwareEQ === "true" : this.config.auth.instanceAware;
        const userAuthority = account && resolvedInstanceAware ? this.config.auth.authority.replace(UrlString.getDomainFromUrl(resolvedAuthority), account.environment) : resolvedAuthority;
        const builtAuthority = Authority.generateAuthority(userAuthority, params.requestAzureCloudOptions || this.config.auth.azureCloudOptions);
        const discoveredAuthority = await invokeAsync(AuthorityFactory_exports.createDiscoveredInstance, PerformanceEvents.AuthorityFactoryCreateDiscoveredInstance, this.logger, this.performanceClient, this.correlationId)(builtAuthority, this.config.system.networkClient, this.browserStorage, authorityOptions, this.logger, this.correlationId, this.performanceClient);
        if (account && !discoveredAuthority.isAlias(account.environment)) {
          throw createClientConfigurationError(ClientConfigurationErrorCodes_exports.authorityMismatch);
        }
        return discoveredAuthority;
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/request/RequestHelpers.mjs
async function initializeBaseRequest(request, config, performanceClient, logger24) {
  performanceClient.addQueueMeasurement(PerformanceEvents.InitializeBaseRequest, request.correlationId);
  const authority = request.authority || config.auth.authority;
  const scopes = [...request && request.scopes || []];
  const validatedRequest = {
    ...request,
    correlationId: request.correlationId,
    authority,
    scopes
  };
  if (!validatedRequest.authenticationScheme) {
    validatedRequest.authenticationScheme = AuthenticationScheme.BEARER;
    logger24.verbose(`Authentication Scheme wasn't explicitly set in request, defaulting to "Bearer" request`);
  } else {
    if (validatedRequest.authenticationScheme === AuthenticationScheme.SSH) {
      if (!request.sshJwk) {
        throw createClientConfigurationError(ClientConfigurationErrorCodes_exports.missingSshJwk);
      }
      if (!request.sshKid) {
        throw createClientConfigurationError(ClientConfigurationErrorCodes_exports.missingSshKid);
      }
    }
    logger24.verbose(`Authentication Scheme set to "${validatedRequest.authenticationScheme}" as configured in Auth request`);
  }
  if (config.cache.claimsBasedCachingEnabled && request.claims && // Checks for empty stringified object "{}" which doesn't qualify as requested claims
  !StringUtils.isEmptyObj(request.claims)) {
    validatedRequest.requestedClaimsHash = await hashString(request.claims);
  }
  return validatedRequest;
}
async function initializeSilentRequest(request, account, config, performanceClient, logger24) {
  performanceClient.addQueueMeasurement(PerformanceEvents.InitializeSilentRequest, request.correlationId);
  const baseRequest = await invokeAsync(initializeBaseRequest, PerformanceEvents.InitializeBaseRequest, logger24, performanceClient, request.correlationId)(request, config, performanceClient, logger24);
  return {
    ...request,
    ...baseRequest,
    account,
    forceRefresh: request.forceRefresh || false
  };
}
function validateRequestMethod(interactionRequest, protocolMode) {
  let httpMethod;
  const requestMethod = interactionRequest.httpMethod;
  if (protocolMode === ProtocolMode.EAR) {
    httpMethod = requestMethod || HttpMethod.POST;
    if (httpMethod !== HttpMethod.POST) {
      throw createClientConfigurationError(ClientConfigurationErrorCodes_exports.invalidRequestMethodForEAR);
    }
  } else {
    httpMethod = requestMethod || HttpMethod.GET;
  }
  if (interactionRequest.authorizePostBodyParameters && httpMethod !== HttpMethod.POST) {
    throw createClientConfigurationError(ClientConfigurationErrorCodes_exports.invalidAuthorizePostBodyParameters);
  }
  return httpMethod;
}
var init_RequestHelpers = __esm({
  "node_modules/@azure/msal-browser/dist/request/RequestHelpers.mjs"() {
    "use strict";
    init_index_browser();
    init_BrowserCrypto();
  }
});

// node_modules/@azure/msal-browser/dist/interaction_client/StandardInteractionClient.mjs
var StandardInteractionClient;
var init_StandardInteractionClient = __esm({
  "node_modules/@azure/msal-browser/dist/interaction_client/StandardInteractionClient.mjs"() {
    "use strict";
    init_index_browser();
    init_BaseInteractionClient();
    init_BrowserConstants();
    init_packageMetadata2();
    init_BrowserUtils();
    init_BrowserCrypto();
    init_RequestHelpers();
    StandardInteractionClient = class extends BaseInteractionClient {
      /**
       * Initializer for the logout request.
       * @param logoutRequest
       */
      initializeLogoutRequest(logoutRequest) {
        this.logger.verbose("initializeLogoutRequest called", logoutRequest == null ? void 0 : logoutRequest.correlationId);
        const validLogoutRequest = {
          correlationId: this.correlationId || createNewGuid(),
          ...logoutRequest
        };
        if (logoutRequest) {
          if (!logoutRequest.logoutHint) {
            if (logoutRequest.account) {
              const logoutHint = this.getLogoutHintFromIdTokenClaims(logoutRequest.account);
              if (logoutHint) {
                this.logger.verbose("Setting logoutHint to login_hint ID Token Claim value for the account provided");
                validLogoutRequest.logoutHint = logoutHint;
              }
            } else {
              this.logger.verbose("logoutHint was not set and account was not passed into logout request, logoutHint will not be set");
            }
          } else {
            this.logger.verbose("logoutHint has already been set in logoutRequest");
          }
        } else {
          this.logger.verbose("logoutHint will not be set since no logout request was configured");
        }
        if (!logoutRequest || logoutRequest.postLogoutRedirectUri !== null) {
          if (logoutRequest && logoutRequest.postLogoutRedirectUri) {
            this.logger.verbose("Setting postLogoutRedirectUri to uri set on logout request", validLogoutRequest.correlationId);
            validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(logoutRequest.postLogoutRedirectUri, getCurrentUri());
          } else if (this.config.auth.postLogoutRedirectUri === null) {
            this.logger.verbose("postLogoutRedirectUri configured as null and no uri set on request, not passing post logout redirect", validLogoutRequest.correlationId);
          } else if (this.config.auth.postLogoutRedirectUri) {
            this.logger.verbose("Setting postLogoutRedirectUri to configured uri", validLogoutRequest.correlationId);
            validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(this.config.auth.postLogoutRedirectUri, getCurrentUri());
          } else {
            this.logger.verbose("Setting postLogoutRedirectUri to current page", validLogoutRequest.correlationId);
            validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(getCurrentUri(), getCurrentUri());
          }
        } else {
          this.logger.verbose("postLogoutRedirectUri passed as null, not setting post logout redirect uri", validLogoutRequest.correlationId);
        }
        return validLogoutRequest;
      }
      /**
       * Parses login_hint ID Token Claim out of AccountInfo object to be used as
       * logout_hint in end session request.
       * @param account
       */
      getLogoutHintFromIdTokenClaims(account) {
        const idTokenClaims = account.idTokenClaims;
        if (idTokenClaims) {
          if (idTokenClaims.login_hint) {
            return idTokenClaims.login_hint;
          } else {
            this.logger.verbose("The ID Token Claims tied to the provided account do not contain a login_hint claim, logoutHint will not be added to logout request");
          }
        } else {
          this.logger.verbose("The provided account does not contain ID Token Claims, logoutHint will not be added to logout request");
        }
        return null;
      }
      /**
       * Creates an Authorization Code Client with the given authority, or the default authority.
       * @param params {
       *         serverTelemetryManager: ServerTelemetryManager;
       *         authorityUrl?: string;
       *         requestAzureCloudOptions?: AzureCloudOptions;
       *         requestExtraQueryParameters?: StringDict;
       *         account?: AccountInfo;
       *        }
       */
      async createAuthCodeClient(params) {
        this.performanceClient.addQueueMeasurement(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, this.correlationId);
        const clientConfig = await invokeAsync(this.getClientConfiguration.bind(this), PerformanceEvents.StandardInteractionClientGetClientConfiguration, this.logger, this.performanceClient, this.correlationId)(params);
        return new AuthorizationCodeClient(clientConfig, this.performanceClient);
      }
      /**
       * Creates a Client Configuration object with the given request authority, or the default authority.
       * @param params {
       *         serverTelemetryManager: ServerTelemetryManager;
       *         requestAuthority?: string;
       *         requestAzureCloudOptions?: AzureCloudOptions;
       *         requestExtraQueryParameters?: boolean;
       *         account?: AccountInfo;
       *        }
       */
      async getClientConfiguration(params) {
        const { serverTelemetryManager, requestAuthority, requestAzureCloudOptions, requestExtraQueryParameters, account } = params;
        this.performanceClient.addQueueMeasurement(PerformanceEvents.StandardInteractionClientGetClientConfiguration, this.correlationId);
        const discoveredAuthority = await invokeAsync(this.getDiscoveredAuthority.bind(this), PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority, this.logger, this.performanceClient, this.correlationId)({
          requestAuthority,
          requestAzureCloudOptions,
          requestExtraQueryParameters,
          account
        });
        const logger24 = this.config.system.loggerOptions;
        return {
          authOptions: {
            clientId: this.config.auth.clientId,
            authority: discoveredAuthority,
            clientCapabilities: this.config.auth.clientCapabilities,
            redirectUri: this.config.auth.redirectUri
          },
          systemOptions: {
            tokenRenewalOffsetSeconds: this.config.system.tokenRenewalOffsetSeconds,
            preventCorsPreflight: true
          },
          loggerOptions: {
            loggerCallback: logger24.loggerCallback,
            piiLoggingEnabled: logger24.piiLoggingEnabled,
            logLevel: logger24.logLevel,
            correlationId: this.correlationId
          },
          cacheOptions: {
            claimsBasedCachingEnabled: this.config.cache.claimsBasedCachingEnabled
          },
          cryptoInterface: this.browserCrypto,
          networkInterface: this.networkClient,
          storageInterface: this.browserStorage,
          serverTelemetryManager,
          libraryInfo: {
            sku: BrowserConstants.MSAL_SKU,
            version: version2,
            cpu: Constants.EMPTY_STRING,
            os: Constants.EMPTY_STRING
          },
          telemetry: this.config.telemetry
        };
      }
      /**
       * Helper to initialize required request parameters for interactive APIs and ssoSilent()
       * @param request
       * @param interactionType
       */
      async initializeAuthorizationRequest(request, interactionType) {
        this.performanceClient.addQueueMeasurement(PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, this.correlationId);
        const redirectUri = this.getRedirectUri(request.redirectUri);
        const browserState = {
          interactionType
        };
        const state3 = ProtocolUtils.setRequestState(this.browserCrypto, request && request.state || Constants.EMPTY_STRING, browserState);
        const baseRequest = await invokeAsync(initializeBaseRequest, PerformanceEvents.InitializeBaseRequest, this.logger, this.performanceClient, this.correlationId)({ ...request, correlationId: this.correlationId }, this.config, this.performanceClient, this.logger);
        const interactionRequest = {
          ...baseRequest,
          redirectUri,
          state: state3,
          nonce: request.nonce || createNewGuid(),
          responseMode: this.config.auth.OIDCOptions.serverResponseType
        };
        const validatedRequest = {
          ...interactionRequest,
          httpMethod: validateRequestMethod(interactionRequest, this.config.auth.protocolMode)
        };
        if (request.loginHint || request.sid) {
          return validatedRequest;
        }
        const account = request.account || this.browserStorage.getActiveAccount(this.correlationId);
        if (account) {
          this.logger.verbose("Setting validated request account", this.correlationId);
          this.logger.verbosePii(`Setting validated request account: ${account.homeAccountId}`, this.correlationId);
          validatedRequest.account = account;
        }
        return validatedRequest;
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/utils/BrowserProtocolUtils.mjs
function extractBrowserRequestState(browserCrypto, state3) {
  if (!state3) {
    return null;
  }
  try {
    const requestStateObj = ProtocolUtils.parseRequestState(browserCrypto, state3);
    return requestStateObj.libraryState.meta;
  } catch (e) {
    throw createClientAuthError(ClientAuthErrorCodes_exports.invalidState);
  }
}
var init_BrowserProtocolUtils = __esm({
  "node_modules/@azure/msal-browser/dist/utils/BrowserProtocolUtils.mjs"() {
    "use strict";
    init_index_browser();
  }
});

// node_modules/@azure/msal-browser/dist/response/ResponseHandler.mjs
function deserializeResponse(responseString, responseLocation, logger24) {
  const serverParams = UrlUtils_exports.getDeserializedResponse(responseString);
  if (!serverParams) {
    if (!UrlUtils_exports.stripLeadingHashOrQuery(responseString)) {
      logger24.error(`The request has returned to the redirectUri but a ${responseLocation} is not present. It's likely that the ${responseLocation} has been removed or the page has been redirected by code running on the redirectUri page.`);
      throw createBrowserAuthError(hashEmptyError);
    } else {
      logger24.error(`A ${responseLocation} is present in the iframe but it does not contain known properties. It's likely that the ${responseLocation} has been replaced by code running on the redirectUri page.`);
      logger24.errorPii(`The ${responseLocation} detected is: ${responseString}`);
      throw createBrowserAuthError(hashDoesNotContainKnownProperties);
    }
  }
  return serverParams;
}
function validateInteractionType(response, browserCrypto, interactionType) {
  if (!response.state) {
    throw createBrowserAuthError(noStateInHash);
  }
  const platformStateObj = extractBrowserRequestState(browserCrypto, response.state);
  if (!platformStateObj) {
    throw createBrowserAuthError(unableToParseState);
  }
  if (platformStateObj.interactionType !== interactionType) {
    throw createBrowserAuthError(stateInteractionTypeMismatch);
  }
}
var init_ResponseHandler2 = __esm({
  "node_modules/@azure/msal-browser/dist/response/ResponseHandler.mjs"() {
    "use strict";
    init_index_browser();
    init_BrowserAuthError();
    init_BrowserProtocolUtils();
    init_BrowserAuthErrorCodes();
  }
});

// node_modules/@azure/msal-browser/dist/interaction_handler/InteractionHandler.mjs
var InteractionHandler;
var init_InteractionHandler = __esm({
  "node_modules/@azure/msal-browser/dist/interaction_handler/InteractionHandler.mjs"() {
    "use strict";
    init_index_browser();
    init_BrowserAuthError();
    init_BrowserAuthErrorCodes();
    InteractionHandler = class {
      constructor(authCodeModule, storageImpl, authCodeRequest, logger24, performanceClient) {
        this.authModule = authCodeModule;
        this.browserStorage = storageImpl;
        this.authCodeRequest = authCodeRequest;
        this.logger = logger24;
        this.performanceClient = performanceClient;
      }
      /**
       * Function to handle response parameters from hash.
       * @param locationHash
       */
      async handleCodeResponse(response, request) {
        this.performanceClient.addQueueMeasurement(PerformanceEvents.HandleCodeResponse, request.correlationId);
        let authCodeResponse;
        try {
          authCodeResponse = Authorize_exports.getAuthorizationCodePayload(response, request.state);
        } catch (e) {
          if (e instanceof ServerError && e.subError === userCancelled) {
            throw createBrowserAuthError(userCancelled);
          } else {
            throw e;
          }
        }
        return invokeAsync(this.handleCodeResponseFromServer.bind(this), PerformanceEvents.HandleCodeResponseFromServer, this.logger, this.performanceClient, request.correlationId)(authCodeResponse, request);
      }
      /**
       * Process auth code response from AAD
       * @param authCodeResponse
       * @param state
       * @param authority
       * @param networkModule
       * @returns
       */
      async handleCodeResponseFromServer(authCodeResponse, request, validateNonce = true) {
        this.performanceClient.addQueueMeasurement(PerformanceEvents.HandleCodeResponseFromServer, request.correlationId);
        this.logger.trace("InteractionHandler.handleCodeResponseFromServer called");
        this.authCodeRequest.code = authCodeResponse.code;
        if (authCodeResponse.cloud_instance_host_name) {
          await invokeAsync(this.authModule.updateAuthority.bind(this.authModule), PerformanceEvents.UpdateTokenEndpointAuthority, this.logger, this.performanceClient, request.correlationId)(authCodeResponse.cloud_instance_host_name, request.correlationId);
        }
        if (validateNonce) {
          authCodeResponse.nonce = request.nonce || void 0;
        }
        authCodeResponse.state = request.state;
        if (authCodeResponse.client_info) {
          this.authCodeRequest.clientInfo = authCodeResponse.client_info;
        } else {
          const ccsCred = this.createCcsCredentials(request);
          if (ccsCred) {
            this.authCodeRequest.ccsCredential = ccsCred;
          }
        }
        const tokenResponse = await invokeAsync(this.authModule.acquireToken.bind(this.authModule), PerformanceEvents.AuthClientAcquireToken, this.logger, this.performanceClient, request.correlationId)(this.authCodeRequest, authCodeResponse);
        return tokenResponse;
      }
      /**
       * Build ccs creds if available
       */
      createCcsCredentials(request) {
        if (request.account) {
          return {
            credential: request.account.homeAccountId,
            type: CcsCredentialType.HOME_ACCOUNT_ID
          };
        } else if (request.loginHint) {
          return {
            credential: request.loginHint,
            type: CcsCredentialType.UPN
          };
        }
        return null;
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/error/NativeAuthErrorCodes.mjs
var contentError, userSwitch;
var init_NativeAuthErrorCodes = __esm({
  "node_modules/@azure/msal-browser/dist/error/NativeAuthErrorCodes.mjs"() {
    "use strict";
    contentError = "ContentError";
    userSwitch = "user_switch";
  }
});

// node_modules/@azure/msal-browser/dist/broker/nativeBroker/NativeStatusCodes.mjs
var USER_INTERACTION_REQUIRED, USER_CANCEL, NO_NETWORK, PERSISTENT_ERROR, DISABLED, ACCOUNT_UNAVAILABLE, UX_NOT_ALLOWED;
var init_NativeStatusCodes = __esm({
  "node_modules/@azure/msal-browser/dist/broker/nativeBroker/NativeStatusCodes.mjs"() {
    "use strict";
    USER_INTERACTION_REQUIRED = "USER_INTERACTION_REQUIRED";
    USER_CANCEL = "USER_CANCEL";
    NO_NETWORK = "NO_NETWORK";
    PERSISTENT_ERROR = "PERSISTENT_ERROR";
    DISABLED = "DISABLED";
    ACCOUNT_UNAVAILABLE = "ACCOUNT_UNAVAILABLE";
    UX_NOT_ALLOWED = "UX_NOT_ALLOWED";
  }
});

// node_modules/@azure/msal-browser/dist/error/NativeAuthError.mjs
function isFatalNativeAuthError(error) {
  if (error.ext && error.ext.status && (error.ext.status === PERSISTENT_ERROR || error.ext.status === DISABLED)) {
    return true;
  }
  if (error.ext && error.ext.error && error.ext.error === INVALID_METHOD_ERROR) {
    return true;
  }
  switch (error.errorCode) {
    case contentError:
      return true;
    default:
      return false;
  }
}
function createNativeAuthError(code, description, ext) {
  if (ext && ext.status) {
    switch (ext.status) {
      case ACCOUNT_UNAVAILABLE:
        return createInteractionRequiredAuthError(InteractionRequiredAuthErrorCodes_exports.nativeAccountUnavailable);
      case USER_INTERACTION_REQUIRED:
        return new InteractionRequiredAuthError(code, description);
      case USER_CANCEL:
        return createBrowserAuthError(userCancelled);
      case NO_NETWORK:
        return createBrowserAuthError(noNetworkConnectivity2);
      case UX_NOT_ALLOWED:
        return createInteractionRequiredAuthError(InteractionRequiredAuthErrorCodes_exports.uxNotAllowed);
    }
  }
  return new NativeAuthError(code, NativeAuthErrorMessages[code] || description, ext);
}
var INVALID_METHOD_ERROR, NativeAuthErrorMessages, NativeAuthError;
var init_NativeAuthError = __esm({
  "node_modules/@azure/msal-browser/dist/error/NativeAuthError.mjs"() {
    "use strict";
    init_index_browser();
    init_BrowserAuthError();
    init_NativeAuthErrorCodes();
    init_NativeStatusCodes();
    init_BrowserAuthErrorCodes();
    INVALID_METHOD_ERROR = -2147186943;
    NativeAuthErrorMessages = {
      [userSwitch]: "User attempted to switch accounts in the native broker, which is not allowed. All new accounts must sign-in through the standard web flow first, please try again."
    };
    NativeAuthError = class _NativeAuthError extends AuthError {
      constructor(errorCode, description, ext) {
        super(errorCode, description);
        Object.setPrototypeOf(this, _NativeAuthError.prototype);
        this.name = "NativeAuthError";
        this.ext = ext;
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/interaction_client/SilentCacheClient.mjs
var SilentCacheClient;
var init_SilentCacheClient = __esm({
  "node_modules/@azure/msal-browser/dist/interaction_client/SilentCacheClient.mjs"() {
    "use strict";
    init_StandardInteractionClient();
    init_index_browser();
    init_BrowserConstants();
    init_BrowserAuthError();
    init_BrowserAuthErrorCodes();
    SilentCacheClient = class extends StandardInteractionClient {
      /**
       * Returns unexpired tokens from the cache, if available
       * @param silentRequest
       */
      async acquireToken(silentRequest) {
        this.performanceClient.addQueueMeasurement(PerformanceEvents.SilentCacheClientAcquireToken, silentRequest.correlationId);
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenSilent_silentFlow);
        const clientConfig = await invokeAsync(this.getClientConfiguration.bind(this), PerformanceEvents.StandardInteractionClientGetClientConfiguration, this.logger, this.performanceClient, this.correlationId)({
          serverTelemetryManager,
          requestAuthority: silentRequest.authority,
          requestAzureCloudOptions: silentRequest.azureCloudOptions,
          account: silentRequest.account
        });
        const silentAuthClient = new SilentFlowClient(clientConfig, this.performanceClient);
        this.logger.verbose("Silent auth client created");
        try {
          const response = await invokeAsync(silentAuthClient.acquireCachedToken.bind(silentAuthClient), PerformanceEvents.SilentFlowClientAcquireCachedToken, this.logger, this.performanceClient, silentRequest.correlationId)(silentRequest);
          const authResponse = response[0];
          this.performanceClient.addFields({
            fromCache: true
          }, silentRequest.correlationId);
          return authResponse;
        } catch (error) {
          if (error instanceof BrowserAuthError && error.errorCode === cryptoKeyNotFound) {
            this.logger.verbose("Signing keypair for bound access token not found. Refreshing bound access token and generating a new crypto keypair.");
          }
          throw error;
        }
      }
      /**
       * API to silenty clear the browser cache.
       * @param logoutRequest
       */
      logout(logoutRequest) {
        this.logger.verbose("logoutRedirect called");
        const validLogoutRequest = this.initializeLogoutRequest(logoutRequest);
        return this.clearCacheOnLogout(validLogoutRequest.correlationId, validLogoutRequest == null ? void 0 : validLogoutRequest.account);
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/interaction_client/PlatformAuthInteractionClient.mjs
var PlatformAuthInteractionClient;
var init_PlatformAuthInteractionClient = __esm({
  "node_modules/@azure/msal-browser/dist/interaction_client/PlatformAuthInteractionClient.mjs"() {
    "use strict";
    init_index_browser();
    init_BaseInteractionClient();
    init_BrowserConstants();
    init_NativeAuthError();
    init_BrowserAuthError();
    init_SilentCacheClient();
    init_Base64Decode();
    init_packageMetadata2();
    init_BrowserAuthErrorCodes();
    init_NativeAuthErrorCodes();
    PlatformAuthInteractionClient = class extends BaseInteractionClient {
      constructor(config, browserStorage, browserCrypto, logger24, eventHandler, navigationClient, apiId, performanceClient, provider, accountId, nativeStorageImpl, correlationId) {
        super(config, browserStorage, browserCrypto, logger24, eventHandler, navigationClient, performanceClient, provider, correlationId);
        this.apiId = apiId;
        this.accountId = accountId;
        this.platformAuthProvider = provider;
        this.nativeStorageManager = nativeStorageImpl;
        this.silentCacheClient = new SilentCacheClient(config, this.nativeStorageManager, browserCrypto, logger24, eventHandler, navigationClient, performanceClient, provider, correlationId);
        const extensionName = this.platformAuthProvider.getExtensionName();
        this.skus = ServerTelemetryManager.makeExtraSkuString({
          libraryName: BrowserConstants.MSAL_SKU,
          libraryVersion: version2,
          extensionName,
          extensionVersion: this.platformAuthProvider.getExtensionVersion()
        });
      }
      /**
       * Adds SKUs to request extra query parameters
       * @param request {PlatformAuthRequest}
       * @private
       */
      addRequestSKUs(request) {
        request.extraParameters = {
          ...request.extraParameters,
          [AADServerParamKeys_exports.X_CLIENT_EXTRA_SKU]: this.skus
        };
      }
      /**
       * Acquire token from native platform via browser extension
       * @param request
       */
      async acquireToken(request, cacheLookupPolicy) {
        this.performanceClient.addQueueMeasurement(PerformanceEvents.NativeInteractionClientAcquireToken, request.correlationId);
        this.logger.trace("NativeInteractionClient - acquireToken called.");
        const nativeATMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.NativeInteractionClientAcquireToken, request.correlationId);
        const reqTimestamp = TimeUtils_exports.nowSeconds();
        const serverTelemetryManager = this.initializeServerTelemetryManager(this.apiId);
        try {
          const nativeRequest = await this.initializeNativeRequest(request);
          try {
            const result = await this.acquireTokensFromCache(this.accountId, nativeRequest);
            nativeATMeasurement.end({
              success: true,
              isNativeBroker: false,
              fromCache: true
            });
            return result;
          } catch (e) {
            if (cacheLookupPolicy === CacheLookupPolicy.AccessToken) {
              this.logger.info("MSAL internal Cache does not contain tokens, return error as per cache policy");
              throw e;
            }
            this.logger.info("MSAL internal Cache does not contain tokens, proceed to make a native call");
          }
          const validatedResponse = await this.platformAuthProvider.sendMessage(nativeRequest);
          return await this.handleNativeResponse(validatedResponse, nativeRequest, reqTimestamp).then((result) => {
            nativeATMeasurement.end({
              success: true,
              isNativeBroker: true,
              requestId: result.requestId
            });
            serverTelemetryManager.clearNativeBrokerErrorCode();
            return result;
          }).catch((error) => {
            nativeATMeasurement.end({
              success: false,
              errorCode: error.errorCode,
              subErrorCode: error.subError,
              isNativeBroker: true
            });
            throw error;
          });
        } catch (e) {
          if (e instanceof NativeAuthError) {
            serverTelemetryManager.setNativeBrokerErrorCode(e.errorCode);
          }
          throw e;
        }
      }
      /**
       * Creates silent flow request
       * @param request
       * @param cachedAccount
       * @returns CommonSilentFlowRequest
       */
      createSilentCacheRequest(request, cachedAccount) {
        return {
          authority: request.authority,
          correlationId: this.correlationId,
          scopes: ScopeSet.fromString(request.scope).asArray(),
          account: cachedAccount,
          forceRefresh: false
        };
      }
      /**
       * Fetches the tokens from the cache if un-expired
       * @param nativeAccountId
       * @param request
       * @returns authenticationResult
       */
      async acquireTokensFromCache(nativeAccountId, request) {
        if (!nativeAccountId) {
          this.logger.warning("NativeInteractionClient:acquireTokensFromCache - No nativeAccountId provided");
          throw createClientAuthError(ClientAuthErrorCodes_exports.noAccountFound);
        }
        const account = this.browserStorage.getBaseAccountInfo({
          nativeAccountId
        }, this.correlationId);
        if (!account) {
          throw createClientAuthError(ClientAuthErrorCodes_exports.noAccountFound);
        }
        try {
          const silentRequest = this.createSilentCacheRequest(request, account);
          const result = await this.silentCacheClient.acquireToken(silentRequest);
          const fullAccount = {
            ...account,
            idTokenClaims: result == null ? void 0 : result.idTokenClaims,
            idToken: result == null ? void 0 : result.idToken
          };
          return {
            ...result,
            account: fullAccount
          };
        } catch (e) {
          throw e;
        }
      }
      /**
       * Acquires a token from native platform then redirects to the redirectUri instead of returning the response
       * @param {RedirectRequest} request
       * @param {InProgressPerformanceEvent} rootMeasurement
       */
      async acquireTokenRedirect(request, rootMeasurement) {
        this.logger.trace("NativeInteractionClient - acquireTokenRedirect called.");
        const { ...remainingParameters } = request;
        delete remainingParameters.onRedirectNavigate;
        const nativeRequest = await this.initializeNativeRequest(remainingParameters);
        try {
          await this.platformAuthProvider.sendMessage(nativeRequest);
        } catch (e) {
          if (e instanceof NativeAuthError) {
            const serverTelemetryManager = this.initializeServerTelemetryManager(this.apiId);
            serverTelemetryManager.setNativeBrokerErrorCode(e.errorCode);
            if (isFatalNativeAuthError(e)) {
              throw e;
            }
          }
        }
        this.browserStorage.setTemporaryCache(TemporaryCacheKeys.NATIVE_REQUEST, JSON.stringify(nativeRequest), true);
        const navigationOptions = {
          apiId: ApiId.acquireTokenRedirect,
          timeout: this.config.system.redirectNavigationTimeout,
          noHistory: false
        };
        const redirectUri = this.config.auth.navigateToLoginRequestUrl ? window.location.href : this.getRedirectUri(request.redirectUri);
        rootMeasurement.end({ success: true });
        await this.navigationClient.navigateExternal(redirectUri, navigationOptions);
      }
      /**
       * If the previous page called native platform for a token using redirect APIs, send the same request again and return the response
       * @param performanceClient {IPerformanceClient?}
       * @param correlationId {string?} correlation identifier
       */
      async handleRedirectPromise(performanceClient, correlationId) {
        this.logger.trace("NativeInteractionClient - handleRedirectPromise called.");
        if (!this.browserStorage.isInteractionInProgress(true)) {
          this.logger.info("handleRedirectPromise called but there is no interaction in progress, returning null.");
          return null;
        }
        const cachedRequest = this.browserStorage.getCachedNativeRequest();
        if (!cachedRequest) {
          this.logger.verbose("NativeInteractionClient - handleRedirectPromise called but there is no cached request, returning null.");
          if (performanceClient && correlationId) {
            performanceClient == null ? void 0 : performanceClient.addFields({ errorCode: "no_cached_request" }, correlationId);
          }
          return null;
        }
        const { prompt, ...request } = cachedRequest;
        if (prompt) {
          this.logger.verbose("NativeInteractionClient - handleRedirectPromise called and prompt was included in the original request, removing prompt from cached request to prevent second interaction with native broker window.");
        }
        this.browserStorage.removeItem(this.browserStorage.generateCacheKey(TemporaryCacheKeys.NATIVE_REQUEST));
        const reqTimestamp = TimeUtils_exports.nowSeconds();
        try {
          this.logger.verbose("NativeInteractionClient - handleRedirectPromise sending message to native broker.");
          const response = await this.platformAuthProvider.sendMessage(request);
          const authResult = await this.handleNativeResponse(response, request, reqTimestamp);
          const serverTelemetryManager = this.initializeServerTelemetryManager(this.apiId);
          serverTelemetryManager.clearNativeBrokerErrorCode();
          return authResult;
        } catch (e) {
          throw e;
        }
      }
      /**
       * Logout from native platform via browser extension
       * @param request
       */
      logout() {
        this.logger.trace("NativeInteractionClient - logout called.");
        return Promise.reject("Logout not implemented yet");
      }
      /**
       * Transform response from native platform into AuthenticationResult object which will be returned to the end user
       * @param response
       * @param request
       * @param reqTimestamp
       */
      async handleNativeResponse(response, request, reqTimestamp) {
        var _a3, _b2;
        this.logger.trace("NativeInteractionClient - handleNativeResponse called.");
        const idTokenClaims = AuthToken_exports.extractTokenClaims(response.id_token, base64Decode);
        const homeAccountIdentifier = this.createHomeAccountIdentifier(response, idTokenClaims);
        const cachedhomeAccountId = (_a3 = this.browserStorage.getAccountInfoFilteredBy({
          nativeAccountId: request.accountId
        }, this.correlationId)) == null ? void 0 : _a3.homeAccountId;
        if (((_b2 = request.extraParameters) == null ? void 0 : _b2.child_client_id) && response.account.id !== request.accountId) {
          this.logger.info("handleNativeServerResponse: Double broker flow detected, ignoring accountId mismatch");
        } else if (homeAccountIdentifier !== cachedhomeAccountId && response.account.id !== request.accountId) {
          throw createNativeAuthError(userSwitch);
        }
        const authority = await this.getDiscoveredAuthority({
          requestAuthority: request.authority
        });
        const baseAccount = buildAccountToCache(
          this.browserStorage,
          authority,
          homeAccountIdentifier,
          base64Decode,
          this.correlationId,
          idTokenClaims,
          response.client_info,
          void 0,
          // environment
          idTokenClaims.tid,
          void 0,
          // auth code payload
          response.account.id,
          this.logger
        );
        response.expires_in = Number(response.expires_in);
        const result = await this.generateAuthenticationResult(response, request, idTokenClaims, baseAccount, authority.canonicalAuthority, reqTimestamp);
        await this.cacheAccount(baseAccount, this.correlationId);
        await this.cacheNativeTokens(response, request, homeAccountIdentifier, idTokenClaims, response.access_token, result.tenantId, reqTimestamp);
        return result;
      }
      /**
       * creates an homeAccountIdentifier for the account
       * @param response
       * @param idTokenObj
       * @returns
       */
      createHomeAccountIdentifier(response, idTokenClaims) {
        const homeAccountIdentifier = AccountEntity.generateHomeAccountId(response.client_info || Constants.EMPTY_STRING, AuthorityType.Default, this.logger, this.browserCrypto, idTokenClaims);
        return homeAccountIdentifier;
      }
      /**
       * Helper to generate scopes
       * @param response
       * @param request
       * @returns
       */
      generateScopes(requestScopes, responseScopes) {
        return responseScopes ? ScopeSet.fromString(responseScopes) : ScopeSet.fromString(requestScopes);
      }
      /**
       * If PoP token is requesred, records the PoP token if returned from the WAM, else generates one in the browser
       * @param request
       * @param response
       */
      async generatePopAccessToken(response, request) {
        if (request.tokenType === AuthenticationScheme.POP && request.signPopToken) {
          if (response.shr) {
            this.logger.trace("handleNativeServerResponse: SHR is enabled in native layer");
            return response.shr;
          }
          const popTokenGenerator = new PopTokenGenerator(this.browserCrypto);
          const shrParameters = {
            resourceRequestMethod: request.resourceRequestMethod,
            resourceRequestUri: request.resourceRequestUri,
            shrClaims: request.shrClaims,
            shrNonce: request.shrNonce
          };
          if (!request.keyId) {
            throw createClientAuthError(ClientAuthErrorCodes_exports.keyIdMissing);
          }
          return popTokenGenerator.signPopToken(response.access_token, request.keyId, shrParameters);
        } else {
          return response.access_token;
        }
      }
      /**
       * Generates authentication result
       * @param response
       * @param request
       * @param idTokenObj
       * @param accountEntity
       * @param authority
       * @param reqTimestamp
       * @returns
       */
      async generateAuthenticationResult(response, request, idTokenClaims, accountEntity, authority, reqTimestamp) {
        const mats = this.addTelemetryFromNativeResponse(response.properties.MATS);
        const responseScopes = this.generateScopes(request.scope, response.scope);
        const accountProperties = response.account.properties || {};
        const uid = accountProperties["UID"] || idTokenClaims.oid || idTokenClaims.sub || Constants.EMPTY_STRING;
        const tid = accountProperties["TenantId"] || idTokenClaims.tid || Constants.EMPTY_STRING;
        const accountInfo = updateAccountTenantProfileData(
          accountEntity.getAccountInfo(),
          void 0,
          // tenantProfile optional
          idTokenClaims,
          response.id_token
        );
        if (accountInfo.nativeAccountId !== response.account.id) {
          accountInfo.nativeAccountId = response.account.id;
        }
        const responseAccessToken = await this.generatePopAccessToken(response, request);
        const tokenType = request.tokenType === AuthenticationScheme.POP ? AuthenticationScheme.POP : AuthenticationScheme.BEARER;
        const result = {
          authority,
          uniqueId: uid,
          tenantId: tid,
          scopes: responseScopes.asArray(),
          account: accountInfo,
          idToken: response.id_token,
          idTokenClaims,
          accessToken: responseAccessToken,
          fromCache: mats ? this.isResponseFromCache(mats) : false,
          // Request timestamp and NativeResponse expires_in are in seconds, converting to Date for AuthenticationResult
          expiresOn: TimeUtils_exports.toDateFromSeconds(reqTimestamp + response.expires_in),
          tokenType,
          correlationId: this.correlationId,
          state: response.state,
          fromNativeBroker: true
        };
        return result;
      }
      /**
       * cache the account entity in browser storage
       * @param accountEntity
       */
      async cacheAccount(accountEntity, correlationId) {
        await this.browserStorage.setAccount(accountEntity, this.correlationId);
        this.browserStorage.removeAccountContext(accountEntity, correlationId);
      }
      /**
       * Stores the access_token and id_token in inmemory storage
       * @param response
       * @param request
       * @param homeAccountIdentifier
       * @param idTokenObj
       * @param responseAccessToken
       * @param tenantId
       * @param reqTimestamp
       */
      cacheNativeTokens(response, request, homeAccountIdentifier, idTokenClaims, responseAccessToken, tenantId, reqTimestamp) {
        const cachedIdToken = CacheHelpers_exports.createIdTokenEntity(homeAccountIdentifier, request.authority, response.id_token || "", request.clientId, idTokenClaims.tid || "");
        const expiresIn = request.tokenType === AuthenticationScheme.POP ? Constants.SHR_NONCE_VALIDITY : (typeof response.expires_in === "string" ? parseInt(response.expires_in, 10) : response.expires_in) || 0;
        const tokenExpirationSeconds = reqTimestamp + expiresIn;
        const responseScopes = this.generateScopes(response.scope, request.scope);
        const cachedAccessToken = CacheHelpers_exports.createAccessTokenEntity(homeAccountIdentifier, request.authority, responseAccessToken, request.clientId, idTokenClaims.tid || tenantId, responseScopes.printScopes(), tokenExpirationSeconds, 0, base64Decode, void 0, request.tokenType, void 0, request.keyId);
        const nativeCacheRecord = {
          idToken: cachedIdToken,
          accessToken: cachedAccessToken
        };
        return this.nativeStorageManager.saveCacheRecord(nativeCacheRecord, this.correlationId, request.storeInCache);
      }
      getExpiresInValue(tokenType, expiresIn) {
        return tokenType === AuthenticationScheme.POP ? Constants.SHR_NONCE_VALIDITY : (typeof expiresIn === "string" ? parseInt(expiresIn, 10) : expiresIn) || 0;
      }
      addTelemetryFromNativeResponse(matsResponse) {
        const mats = this.getMATSFromResponse(matsResponse);
        if (!mats) {
          return null;
        }
        this.performanceClient.addFields({
          extensionId: this.platformAuthProvider.getExtensionId(),
          extensionVersion: this.platformAuthProvider.getExtensionVersion(),
          matsBrokerVersion: mats.broker_version,
          matsAccountJoinOnStart: mats.account_join_on_start,
          matsAccountJoinOnEnd: mats.account_join_on_end,
          matsDeviceJoin: mats.device_join,
          matsPromptBehavior: mats.prompt_behavior,
          matsApiErrorCode: mats.api_error_code,
          matsUiVisible: mats.ui_visible,
          matsSilentCode: mats.silent_code,
          matsSilentBiSubCode: mats.silent_bi_sub_code,
          matsSilentMessage: mats.silent_message,
          matsSilentStatus: mats.silent_status,
          matsHttpStatus: mats.http_status,
          matsHttpEventCount: mats.http_event_count
        }, this.correlationId);
        return mats;
      }
      /**
       * Gets MATS telemetry from native response
       * @param response
       * @returns
       */
      getMATSFromResponse(matsResponse) {
        if (matsResponse) {
          try {
            return JSON.parse(matsResponse);
          } catch (e) {
            this.logger.error("NativeInteractionClient - Error parsing MATS telemetry, returning null instead");
          }
        }
        return null;
      }
      /**
       * Returns whether or not response came from native cache
       * @param response
       * @returns
       */
      isResponseFromCache(mats) {
        if (typeof mats.is_cached === "undefined") {
          this.logger.verbose("NativeInteractionClient - MATS telemetry does not contain field indicating if response was served from cache. Returning false.");
          return false;
        }
        return !!mats.is_cached;
      }
      /**
       * Translates developer provided request object into NativeRequest object
       * @param request
       */
      async initializeNativeRequest(request) {
        this.logger.trace("NativeInteractionClient - initializeNativeRequest called");
        const canonicalAuthority = await this.getCanonicalAuthority(request);
        const { scopes, ...remainingProperties } = request;
        const scopeSet = new ScopeSet(scopes || []);
        scopeSet.appendScopes(OIDC_DEFAULT_SCOPES);
        const validatedRequest = {
          ...remainingProperties,
          accountId: this.accountId,
          clientId: this.config.auth.clientId,
          authority: canonicalAuthority.urlString,
          scope: scopeSet.printScopes(),
          redirectUri: this.getRedirectUri(request.redirectUri),
          prompt: this.getPrompt(request.prompt),
          correlationId: this.correlationId,
          tokenType: request.authenticationScheme,
          windowTitleSubstring: document.title,
          extraParameters: {
            ...request.extraQueryParameters,
            ...request.tokenQueryParameters
          },
          extendedExpiryToken: false,
          keyId: request.popKid
        };
        if (validatedRequest.signPopToken && !!request.popKid) {
          throw createBrowserAuthError(invalidPopTokenRequest);
        }
        this.handleExtraBrokerParams(validatedRequest);
        validatedRequest.extraParameters = validatedRequest.extraParameters || {};
        validatedRequest.extraParameters.telemetry = PlatformAuthConstants.MATS_TELEMETRY;
        if (request.authenticationScheme === AuthenticationScheme.POP) {
          const shrParameters = {
            resourceRequestUri: request.resourceRequestUri,
            resourceRequestMethod: request.resourceRequestMethod,
            shrClaims: request.shrClaims,
            shrNonce: request.shrNonce
          };
          const popTokenGenerator = new PopTokenGenerator(this.browserCrypto);
          let reqCnfData;
          if (!validatedRequest.keyId) {
            const generatedReqCnfData = await invokeAsync(popTokenGenerator.generateCnf.bind(popTokenGenerator), PerformanceEvents.PopTokenGenerateCnf, this.logger, this.performanceClient, request.correlationId)(shrParameters, this.logger);
            reqCnfData = generatedReqCnfData.reqCnfString;
            validatedRequest.keyId = generatedReqCnfData.kid;
            validatedRequest.signPopToken = true;
          } else {
            reqCnfData = this.browserCrypto.base64UrlEncode(JSON.stringify({ kid: validatedRequest.keyId }));
            validatedRequest.signPopToken = false;
          }
          validatedRequest.reqCnf = reqCnfData;
        }
        this.addRequestSKUs(validatedRequest);
        return validatedRequest;
      }
      async getCanonicalAuthority(request) {
        const requestAuthority = request.authority || this.config.auth.authority;
        if (request.account) {
          await this.getDiscoveredAuthority({
            requestAuthority,
            requestAzureCloudOptions: request.azureCloudOptions,
            account: request.account
          });
        }
        const canonicalAuthority = new UrlString(requestAuthority);
        canonicalAuthority.validateAsUri();
        return canonicalAuthority;
      }
      getPrompt(prompt) {
        switch (this.apiId) {
          case ApiId.ssoSilent:
          case ApiId.acquireTokenSilent_silentFlow:
            this.logger.trace("initializeNativeRequest: silent request sets prompt to none");
            return PromptValue.NONE;
        }
        if (!prompt) {
          this.logger.trace("initializeNativeRequest: prompt was not provided");
          return void 0;
        }
        switch (prompt) {
          case PromptValue.NONE:
          case PromptValue.CONSENT:
          case PromptValue.LOGIN:
            this.logger.trace("initializeNativeRequest: prompt is compatible with native flow");
            return prompt;
          default:
            this.logger.trace(`initializeNativeRequest: prompt = ${prompt} is not compatible with native flow`);
            throw createBrowserAuthError(nativePromptNotSupported);
        }
      }
      /**
       * Handles extra broker request parameters
       * @param request {PlatformAuthRequest}
       * @private
       */
      handleExtraBrokerParams(request) {
        var _a3;
        const hasExtraBrokerParams = request.extraParameters && request.extraParameters.hasOwnProperty(AADServerParamKeys_exports.BROKER_CLIENT_ID) && request.extraParameters.hasOwnProperty(AADServerParamKeys_exports.BROKER_REDIRECT_URI) && request.extraParameters.hasOwnProperty(AADServerParamKeys_exports.CLIENT_ID);
        if (!request.embeddedClientId && !hasExtraBrokerParams) {
          return;
        }
        let child_client_id = "";
        const child_redirect_uri = request.redirectUri;
        if (request.embeddedClientId) {
          request.redirectUri = this.config.auth.redirectUri;
          child_client_id = request.embeddedClientId;
        } else if (request.extraParameters) {
          request.redirectUri = request.extraParameters[AADServerParamKeys_exports.BROKER_REDIRECT_URI];
          child_client_id = request.extraParameters[AADServerParamKeys_exports.CLIENT_ID];
        }
        request.extraParameters = {
          child_client_id,
          child_redirect_uri
        };
        (_a3 = this.performanceClient) == null ? void 0 : _a3.addFields({
          embeddedClientId: child_client_id,
          embeddedRedirectUri: child_redirect_uri
        }, request.correlationId);
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/protocol/Authorize.mjs
async function getStandardParameters(config, authority, request, logger24, performanceClient) {
  const parameters = Authorize_exports.getStandardAuthorizeRequestParameters({ ...config.auth, authority }, request, logger24, performanceClient);
  RequestParameterBuilder_exports.addLibraryInfo(parameters, {
    sku: BrowserConstants.MSAL_SKU,
    version: version2,
    os: "",
    cpu: ""
  });
  if (config.auth.protocolMode !== ProtocolMode.OIDC) {
    RequestParameterBuilder_exports.addApplicationTelemetry(parameters, config.telemetry.application);
  }
  if (request.platformBroker) {
    RequestParameterBuilder_exports.addNativeBroker(parameters);
    if (request.authenticationScheme === AuthenticationScheme.POP) {
      const cryptoOps = new CryptoOps(logger24, performanceClient);
      const popTokenGenerator = new PopTokenGenerator(cryptoOps);
      let reqCnfData;
      if (!request.popKid) {
        const generatedReqCnfData = await invokeAsync(popTokenGenerator.generateCnf.bind(popTokenGenerator), PerformanceEvents.PopTokenGenerateCnf, logger24, performanceClient, request.correlationId)(request, logger24);
        reqCnfData = generatedReqCnfData.reqCnfString;
      } else {
        reqCnfData = cryptoOps.encodeKid(request.popKid);
      }
      RequestParameterBuilder_exports.addPopToken(parameters, reqCnfData);
    }
  }
  RequestParameterBuilder_exports.instrumentBrokerParams(parameters, request.correlationId, performanceClient);
  return parameters;
}
async function getAuthCodeRequestUrl(config, authority, request, logger24, performanceClient) {
  if (!request.codeChallenge) {
    throw createClientConfigurationError(ClientConfigurationErrorCodes_exports.pkceParamsMissing);
  }
  const parameters = await invokeAsync(getStandardParameters, PerformanceEvents.GetStandardParams, logger24, performanceClient, request.correlationId)(config, authority, request, logger24, performanceClient);
  RequestParameterBuilder_exports.addResponseType(parameters, OAuthResponseType.CODE);
  RequestParameterBuilder_exports.addCodeChallengeParams(parameters, request.codeChallenge, Constants.S256_CODE_CHALLENGE_METHOD);
  RequestParameterBuilder_exports.addExtraQueryParameters(parameters, request.extraQueryParameters || {});
  return Authorize_exports.getAuthorizeUrl(authority, parameters, config.auth.encodeExtraQueryParams, request.extraQueryParameters);
}
async function getEARForm(frame, config, authority, request, logger24, performanceClient) {
  if (!request.earJwk) {
    throw createBrowserAuthError(earJwkEmpty);
  }
  const parameters = await getStandardParameters(config, authority, request, logger24, performanceClient);
  RequestParameterBuilder_exports.addResponseType(parameters, OAuthResponseType.IDTOKEN_TOKEN_REFRESHTOKEN);
  RequestParameterBuilder_exports.addEARParameters(parameters, request.earJwk);
  const queryParams = /* @__PURE__ */ new Map();
  RequestParameterBuilder_exports.addExtraQueryParameters(queryParams, request.extraQueryParameters || {});
  const url = Authorize_exports.getAuthorizeUrl(authority, queryParams, config.auth.encodeExtraQueryParams, request.extraQueryParameters);
  return createForm(frame, url, parameters);
}
async function getCodeForm(frame, config, authority, request, logger24, performanceClient) {
  const parameters = await getStandardParameters(config, authority, request, logger24, performanceClient);
  RequestParameterBuilder_exports.addResponseType(parameters, OAuthResponseType.CODE);
  RequestParameterBuilder_exports.addCodeChallengeParams(parameters, request.codeChallenge, request.codeChallengeMethod || Constants.S256_CODE_CHALLENGE_METHOD);
  RequestParameterBuilder_exports.addPostBodyParameters(parameters, request.authorizePostBodyParameters || {});
  const queryParams = /* @__PURE__ */ new Map();
  RequestParameterBuilder_exports.addExtraQueryParameters(queryParams, request.extraQueryParameters || {});
  const url = Authorize_exports.getAuthorizeUrl(authority, queryParams, config.auth.encodeExtraQueryParams, request.extraQueryParameters);
  return createForm(frame, url, parameters);
}
function createForm(frame, authorizeUrl, parameters) {
  const form = frame.createElement("form");
  form.method = "post";
  form.action = authorizeUrl;
  parameters.forEach((value, key) => {
    const param = frame.createElement("input");
    param.hidden = true;
    param.name = key;
    param.value = value;
    form.appendChild(param);
  });
  frame.body.appendChild(form);
  return form;
}
async function handleResponsePlatformBroker(request, accountId, apiId, config, browserStorage, nativeStorage, eventHandler, logger24, performanceClient, platformAuthProvider) {
  logger24.verbose("Account id found, calling WAM for token");
  if (!platformAuthProvider) {
    throw createBrowserAuthError(nativeConnectionNotEstablished);
  }
  const browserCrypto = new CryptoOps(logger24, performanceClient);
  const nativeInteractionClient = new PlatformAuthInteractionClient(config, browserStorage, browserCrypto, logger24, eventHandler, config.system.navigationClient, apiId, performanceClient, platformAuthProvider, accountId, nativeStorage, request.correlationId);
  const { userRequestState } = ProtocolUtils.parseRequestState(browserCrypto, request.state);
  return invokeAsync(nativeInteractionClient.acquireToken.bind(nativeInteractionClient), PerformanceEvents.NativeInteractionClientAcquireToken, logger24, performanceClient, request.correlationId)({
    ...request,
    state: userRequestState,
    prompt: void 0
    // Server should handle the prompt, ideally native broker can do this part silently
  });
}
async function handleResponseCode(request, response, codeVerifier, apiId, config, authClient, browserStorage, nativeStorage, eventHandler, logger24, performanceClient, platformAuthProvider) {
  ThrottlingUtils.removeThrottle(browserStorage, config.auth.clientId, request);
  if (response.accountId) {
    return invokeAsync(handleResponsePlatformBroker, PerformanceEvents.HandleResponsePlatformBroker, logger24, performanceClient, request.correlationId)(request, response.accountId, apiId, config, browserStorage, nativeStorage, eventHandler, logger24, performanceClient, platformAuthProvider);
  }
  const authCodeRequest = {
    ...request,
    code: response.code || "",
    codeVerifier
  };
  const interactionHandler = new InteractionHandler(authClient, browserStorage, authCodeRequest, logger24, performanceClient);
  const result = await invokeAsync(interactionHandler.handleCodeResponse.bind(interactionHandler), PerformanceEvents.HandleCodeResponse, logger24, performanceClient, request.correlationId)(response, request);
  return result;
}
async function handleResponseEAR(request, response, apiId, config, authority, browserStorage, nativeStorage, eventHandler, logger24, performanceClient, platformAuthProvider) {
  ThrottlingUtils.removeThrottle(browserStorage, config.auth.clientId, request);
  Authorize_exports.validateAuthorizationResponse(response, request.state);
  if (!response.ear_jwe) {
    throw createBrowserAuthError(earJweEmpty);
  }
  if (!request.earJwk) {
    throw createBrowserAuthError(earJwkEmpty);
  }
  const decryptedData = JSON.parse(await invokeAsync(decryptEarResponse, PerformanceEvents.DecryptEarResponse, logger24, performanceClient, request.correlationId)(request.earJwk, response.ear_jwe));
  if (decryptedData.accountId) {
    return invokeAsync(handleResponsePlatformBroker, PerformanceEvents.HandleResponsePlatformBroker, logger24, performanceClient, request.correlationId)(request, decryptedData.accountId, apiId, config, browserStorage, nativeStorage, eventHandler, logger24, performanceClient, platformAuthProvider);
  }
  const responseHandler = new ResponseHandler(config.auth.clientId, browserStorage, new CryptoOps(logger24, performanceClient), logger24, null, null, performanceClient);
  responseHandler.validateTokenResponse(decryptedData);
  const additionalData = {
    code: "",
    state: request.state,
    nonce: request.nonce,
    client_info: decryptedData.client_info,
    cloud_graph_host_name: decryptedData.cloud_graph_host_name,
    cloud_instance_host_name: decryptedData.cloud_instance_host_name,
    cloud_instance_name: decryptedData.cloud_instance_name,
    msgraph_host: decryptedData.msgraph_host
  };
  return await invokeAsync(responseHandler.handleServerTokenResponse.bind(responseHandler), PerformanceEvents.HandleServerTokenResponse, logger24, performanceClient, request.correlationId)(decryptedData, authority, TimeUtils_exports.nowSeconds(), request, additionalData, void 0, void 0, void 0, void 0);
}
var init_Authorize2 = __esm({
  "node_modules/@azure/msal-browser/dist/protocol/Authorize.mjs"() {
    "use strict";
    init_index_browser();
    init_BrowserConstants();
    init_packageMetadata2();
    init_CryptoOps();
    init_BrowserAuthError();
    init_InteractionHandler();
    init_PlatformAuthInteractionClient();
    init_BrowserCrypto();
    init_BrowserAuthErrorCodes();
  }
});

// node_modules/@azure/msal-browser/dist/crypto/PkceGenerator.mjs
async function generatePkceCodes(performanceClient, logger24, correlationId) {
  performanceClient.addQueueMeasurement(PerformanceEvents.GeneratePkceCodes, correlationId);
  const codeVerifier = invoke(generateCodeVerifier, PerformanceEvents.GenerateCodeVerifier, logger24, performanceClient, correlationId)(performanceClient, logger24, correlationId);
  const codeChallenge = await invokeAsync(generateCodeChallengeFromVerifier, PerformanceEvents.GenerateCodeChallengeFromVerifier, logger24, performanceClient, correlationId)(codeVerifier, performanceClient, logger24, correlationId);
  return {
    verifier: codeVerifier,
    challenge: codeChallenge
  };
}
function generateCodeVerifier(performanceClient, logger24, correlationId) {
  try {
    const buffer = new Uint8Array(RANDOM_BYTE_ARR_LENGTH);
    invoke(getRandomValues, PerformanceEvents.GetRandomValues, logger24, performanceClient, correlationId)(buffer);
    const pkceCodeVerifierB64 = urlEncodeArr(buffer);
    return pkceCodeVerifierB64;
  } catch (e) {
    throw createBrowserAuthError(pkceNotCreated);
  }
}
async function generateCodeChallengeFromVerifier(pkceCodeVerifier, performanceClient, logger24, correlationId) {
  performanceClient.addQueueMeasurement(PerformanceEvents.GenerateCodeChallengeFromVerifier, correlationId);
  try {
    const pkceHashedCodeVerifier = await invokeAsync(sha256Digest, PerformanceEvents.Sha256Digest, logger24, performanceClient, correlationId)(pkceCodeVerifier, performanceClient, correlationId);
    return urlEncodeArr(new Uint8Array(pkceHashedCodeVerifier));
  } catch (e) {
    throw createBrowserAuthError(pkceNotCreated);
  }
}
var RANDOM_BYTE_ARR_LENGTH;
var init_PkceGenerator = __esm({
  "node_modules/@azure/msal-browser/dist/crypto/PkceGenerator.mjs"() {
    "use strict";
    init_index_browser();
    init_BrowserAuthError();
    init_Base64Encode();
    init_BrowserCrypto();
    init_BrowserAuthErrorCodes();
    RANDOM_BYTE_ARR_LENGTH = 32;
  }
});

// node_modules/@azure/msal-browser/dist/broker/nativeBroker/PlatformAuthExtensionHandler.mjs
var PlatformAuthExtensionHandler;
var init_PlatformAuthExtensionHandler = __esm({
  "node_modules/@azure/msal-browser/dist/broker/nativeBroker/PlatformAuthExtensionHandler.mjs"() {
    "use strict";
    init_BrowserConstants();
    init_index_browser();
    init_NativeAuthError();
    init_BrowserAuthError();
    init_BrowserCrypto();
    init_BrowserAuthErrorCodes();
    PlatformAuthExtensionHandler = class _PlatformAuthExtensionHandler {
      constructor(logger24, handshakeTimeoutMs, performanceClient, extensionId) {
        this.logger = logger24;
        this.handshakeTimeoutMs = handshakeTimeoutMs;
        this.extensionId = extensionId;
        this.resolvers = /* @__PURE__ */ new Map();
        this.handshakeResolvers = /* @__PURE__ */ new Map();
        this.messageChannel = new MessageChannel();
        this.windowListener = this.onWindowMessage.bind(this);
        this.performanceClient = performanceClient;
        this.handshakeEvent = performanceClient.startMeasurement(PerformanceEvents.NativeMessageHandlerHandshake);
        this.platformAuthType = PlatformAuthConstants.PLATFORM_EXTENSION_PROVIDER;
      }
      /**
       * Sends a given message to the extension and resolves with the extension response
       * @param request
       */
      async sendMessage(request) {
        this.logger.trace(this.platformAuthType + " - sendMessage called.");
        const messageBody = {
          method: NativeExtensionMethod.GetToken,
          request
        };
        const req = {
          channel: PlatformAuthConstants.CHANNEL_ID,
          extensionId: this.extensionId,
          responseId: createNewGuid(),
          body: messageBody
        };
        this.logger.trace(this.platformAuthType + " - Sending request to browser extension");
        this.logger.tracePii(this.platformAuthType + ` - Sending request to browser extension: ${JSON.stringify(req)}`);
        this.messageChannel.port1.postMessage(req);
        const response = await new Promise((resolve, reject) => {
          this.resolvers.set(req.responseId, { resolve, reject });
        });
        const validatedResponse = this.validatePlatformBrokerResponse(response);
        return validatedResponse;
      }
      /**
       * Returns an instance of the MessageHandler that has successfully established a connection with an extension
       * @param {Logger} logger
       * @param {number} handshakeTimeoutMs
       * @param {IPerformanceClient} performanceClient
       * @param {ICrypto} crypto
       */
      static async createProvider(logger24, handshakeTimeoutMs, performanceClient) {
        logger24.trace("PlatformAuthExtensionHandler - createProvider called.");
        try {
          const preferredProvider = new _PlatformAuthExtensionHandler(logger24, handshakeTimeoutMs, performanceClient, PlatformAuthConstants.PREFERRED_EXTENSION_ID);
          await preferredProvider.sendHandshakeRequest();
          return preferredProvider;
        } catch (e) {
          const backupProvider = new _PlatformAuthExtensionHandler(logger24, handshakeTimeoutMs, performanceClient);
          await backupProvider.sendHandshakeRequest();
          return backupProvider;
        }
      }
      /**
       * Send handshake request helper.
       */
      async sendHandshakeRequest() {
        this.logger.trace(this.platformAuthType + " - sendHandshakeRequest called.");
        window.addEventListener("message", this.windowListener, false);
        const req = {
          channel: PlatformAuthConstants.CHANNEL_ID,
          extensionId: this.extensionId,
          responseId: createNewGuid(),
          body: {
            method: NativeExtensionMethod.HandshakeRequest
          }
        };
        this.handshakeEvent.add({
          extensionId: this.extensionId,
          extensionHandshakeTimeoutMs: this.handshakeTimeoutMs
        });
        this.messageChannel.port1.onmessage = (event) => {
          this.onChannelMessage(event);
        };
        window.postMessage(req, window.origin, [this.messageChannel.port2]);
        return new Promise((resolve, reject) => {
          this.handshakeResolvers.set(req.responseId, { resolve, reject });
          this.timeoutId = window.setTimeout(() => {
            window.removeEventListener("message", this.windowListener, false);
            this.messageChannel.port1.close();
            this.messageChannel.port2.close();
            this.handshakeEvent.end({
              extensionHandshakeTimedOut: true,
              success: false
            });
            reject(createBrowserAuthError(nativeHandshakeTimeout));
            this.handshakeResolvers.delete(req.responseId);
          }, this.handshakeTimeoutMs);
        });
      }
      /**
       * Invoked when a message is posted to the window. If a handshake request is received it means the extension is not installed.
       * @param event
       */
      onWindowMessage(event) {
        this.logger.trace(this.platformAuthType + " - onWindowMessage called");
        if (event.source !== window) {
          return;
        }
        const request = event.data;
        if (!request.channel || request.channel !== PlatformAuthConstants.CHANNEL_ID) {
          return;
        }
        if (request.extensionId && request.extensionId !== this.extensionId) {
          return;
        }
        if (request.body.method === NativeExtensionMethod.HandshakeRequest) {
          const handshakeResolver = this.handshakeResolvers.get(request.responseId);
          if (!handshakeResolver) {
            this.logger.trace(this.platformAuthType + `.onWindowMessage - resolver can't be found for request ${request.responseId}`);
            return;
          }
          this.logger.verbose(request.extensionId ? `Extension with id: ${request.extensionId} not installed` : "No extension installed");
          clearTimeout(this.timeoutId);
          this.messageChannel.port1.close();
          this.messageChannel.port2.close();
          window.removeEventListener("message", this.windowListener, false);
          this.handshakeEvent.end({
            success: false,
            extensionInstalled: false
          });
          handshakeResolver.reject(createBrowserAuthError(nativeExtensionNotInstalled));
        }
      }
      /**
       * Invoked when a message is received from the extension on the MessageChannel port
       * @param event
       */
      onChannelMessage(event) {
        this.logger.trace(this.platformAuthType + " - onChannelMessage called.");
        const request = event.data;
        const resolver = this.resolvers.get(request.responseId);
        const handshakeResolver = this.handshakeResolvers.get(request.responseId);
        try {
          const method = request.body.method;
          if (method === NativeExtensionMethod.Response) {
            if (!resolver) {
              return;
            }
            const response = request.body.response;
            this.logger.trace(this.platformAuthType + " - Received response from browser extension");
            this.logger.tracePii(this.platformAuthType + ` - Received response from browser extension: ${JSON.stringify(response)}`);
            if (response.status !== "Success") {
              resolver.reject(createNativeAuthError(response.code, response.description, response.ext));
            } else if (response.result) {
              if (response.result["code"] && response.result["description"]) {
                resolver.reject(createNativeAuthError(response.result["code"], response.result["description"], response.result["ext"]));
              } else {
                resolver.resolve(response.result);
              }
            } else {
              throw createAuthError(AuthErrorCodes_exports.unexpectedError, "Event does not contain result.");
            }
            this.resolvers.delete(request.responseId);
          } else if (method === NativeExtensionMethod.HandshakeResponse) {
            if (!handshakeResolver) {
              this.logger.trace(this.platformAuthType + `.onChannelMessage - resolver can't be found for request ${request.responseId}`);
              return;
            }
            clearTimeout(this.timeoutId);
            window.removeEventListener("message", this.windowListener, false);
            this.extensionId = request.extensionId;
            this.extensionVersion = request.body.version;
            this.logger.verbose(this.platformAuthType + ` - Received HandshakeResponse from extension: ${this.extensionId}`);
            this.handshakeEvent.end({
              extensionInstalled: true,
              success: true
            });
            handshakeResolver.resolve();
            this.handshakeResolvers.delete(request.responseId);
          }
        } catch (err) {
          this.logger.error("Error parsing response from WAM Extension");
          this.logger.errorPii(`Error parsing response from WAM Extension: ${err}`);
          this.logger.errorPii(`Unable to parse ${event}`);
          if (resolver) {
            resolver.reject(err);
          } else if (handshakeResolver) {
            handshakeResolver.reject(err);
          }
        }
      }
      /**
       * Validates native platform response before processing
       * @param response
       */
      validatePlatformBrokerResponse(response) {
        if (response.hasOwnProperty("access_token") && response.hasOwnProperty("id_token") && response.hasOwnProperty("client_info") && response.hasOwnProperty("account") && response.hasOwnProperty("scope") && response.hasOwnProperty("expires_in")) {
          return response;
        } else {
          throw createAuthError(AuthErrorCodes_exports.unexpectedError, "Response missing expected properties.");
        }
      }
      /**
       * Returns the Id for the browser extension this handler is communicating with
       * @returns
       */
      getExtensionId() {
        return this.extensionId;
      }
      /**
       * Returns the version for the browser extension this handler is communicating with
       * @returns
       */
      getExtensionVersion() {
        return this.extensionVersion;
      }
      getExtensionName() {
        var _a3;
        return this.getExtensionId() === PlatformAuthConstants.PREFERRED_EXTENSION_ID ? "chrome" : ((_a3 = this.getExtensionId()) == null ? void 0 : _a3.length) ? "unknown" : void 0;
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/broker/nativeBroker/PlatformAuthDOMHandler.mjs
var PlatformAuthDOMHandler;
var init_PlatformAuthDOMHandler = __esm({
  "node_modules/@azure/msal-browser/dist/broker/nativeBroker/PlatformAuthDOMHandler.mjs"() {
    "use strict";
    init_index_browser();
    init_BrowserConstants();
    init_NativeAuthError();
    PlatformAuthDOMHandler = class _PlatformAuthDOMHandler {
      constructor(logger24, performanceClient, correlationId) {
        this.logger = logger24;
        this.performanceClient = performanceClient;
        this.correlationId = correlationId;
        this.platformAuthType = PlatformAuthConstants.PLATFORM_DOM_PROVIDER;
      }
      static async createProvider(logger24, performanceClient, correlationId) {
        var _a3;
        logger24.trace("PlatformAuthDOMHandler: createProvider called");
        if ((_a3 = window.navigator) == null ? void 0 : _a3.platformAuthentication) {
          const supportedContracts = (
            // @ts-ignore
            await window.navigator.platformAuthentication.getSupportedContracts(PlatformAuthConstants.MICROSOFT_ENTRA_BROKERID)
          );
          if (supportedContracts == null ? void 0 : supportedContracts.includes(PlatformAuthConstants.PLATFORM_DOM_APIS)) {
            logger24.trace("Platform auth api available in DOM");
            return new _PlatformAuthDOMHandler(logger24, performanceClient, correlationId);
          }
        }
        return void 0;
      }
      /**
       * Returns the Id for the broker extension this handler is communicating with
       * @returns
       */
      getExtensionId() {
        return PlatformAuthConstants.MICROSOFT_ENTRA_BROKERID;
      }
      getExtensionVersion() {
        return "";
      }
      getExtensionName() {
        return PlatformAuthConstants.DOM_API_NAME;
      }
      /**
       * Send token request to platform broker via browser DOM API
       * @param request
       * @returns
       */
      async sendMessage(request) {
        this.logger.trace(this.platformAuthType + " - Sending request to browser DOM API");
        try {
          const platformDOMRequest = this.initializePlatformDOMRequest(request);
          const response = (
            // @ts-ignore
            await window.navigator.platformAuthentication.executeGetToken(platformDOMRequest)
          );
          return this.validatePlatformBrokerResponse(response);
        } catch (e) {
          this.logger.error(this.platformAuthType + " - executeGetToken DOM API error");
          throw e;
        }
      }
      initializePlatformDOMRequest(request) {
        this.logger.trace(this.platformAuthType + " - initializeNativeDOMRequest called");
        const { accountId, clientId, authority, scope, redirectUri, correlationId, state: state3, storeInCache, embeddedClientId, extraParameters, ...remainingProperties } = request;
        const validExtraParameters = this.getDOMExtraParams(remainingProperties);
        const platformDOMRequest = {
          accountId,
          brokerId: this.getExtensionId(),
          authority,
          clientId,
          correlationId: correlationId || this.correlationId,
          extraParameters: { ...extraParameters, ...validExtraParameters },
          isSecurityTokenService: false,
          redirectUri,
          scope,
          state: state3,
          storeInCache,
          embeddedClientId
        };
        return platformDOMRequest;
      }
      validatePlatformBrokerResponse(response) {
        if (response.hasOwnProperty("isSuccess")) {
          if (response.hasOwnProperty("accessToken") && response.hasOwnProperty("idToken") && response.hasOwnProperty("clientInfo") && response.hasOwnProperty("account") && response.hasOwnProperty("scopes") && response.hasOwnProperty("expiresIn")) {
            this.logger.trace(this.platformAuthType + " - platform broker returned successful and valid response");
            return this.convertToPlatformBrokerResponse(response);
          } else if (response.hasOwnProperty("error")) {
            const errorResponse = response;
            if (errorResponse.isSuccess === false && errorResponse.error && errorResponse.error.code) {
              this.logger.trace(this.platformAuthType + " - platform broker returned error response");
              throw createNativeAuthError(errorResponse.error.code, errorResponse.error.description, {
                error: parseInt(errorResponse.error.errorCode),
                protocol_error: errorResponse.error.protocolError,
                status: errorResponse.error.status,
                properties: errorResponse.error.properties
              });
            }
          }
        }
        throw createAuthError(AuthErrorCodes_exports.unexpectedError, "Response missing expected properties.");
      }
      convertToPlatformBrokerResponse(response) {
        this.logger.trace(this.platformAuthType + " - convertToNativeResponse called");
        const nativeResponse = {
          access_token: response.accessToken,
          id_token: response.idToken,
          client_info: response.clientInfo,
          account: response.account,
          expires_in: response.expiresIn,
          scope: response.scopes,
          state: response.state || "",
          properties: response.properties || {},
          extendedLifetimeToken: response.extendedLifetimeToken ?? false,
          shr: response.proofOfPossessionPayload
        };
        return nativeResponse;
      }
      getDOMExtraParams(extraParameters) {
        const stringifiedParams = Object.entries(extraParameters).reduce((record, [key, value]) => {
          record[key] = String(value);
          return record;
        }, {});
        const validExtraParams = {
          ...stringifiedParams
        };
        return validExtraParams;
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/broker/nativeBroker/PlatformAuthProvider.mjs
async function isPlatformBrokerAvailable(loggerOptions, perfClient, correlationId) {
  const logger24 = new Logger(loggerOptions || {}, name2, version2);
  logger24.trace("isPlatformBrokerAvailable called");
  const performanceClient = perfClient || new StubPerformanceClient();
  if (typeof window === "undefined") {
    logger24.trace("Non-browser environment detected, returning false");
    return false;
  }
  return !!await getPlatformAuthProvider(logger24, performanceClient, correlationId || createNewGuid());
}
async function getPlatformAuthProvider(logger24, performanceClient, correlationId, nativeBrokerHandshakeTimeout) {
  logger24.trace("getPlatformAuthProvider called", correlationId);
  const enablePlatformBrokerDOMSupport = isDomEnabledForPlatformAuth();
  logger24.trace("Has client allowed platform auth via DOM API: " + enablePlatformBrokerDOMSupport);
  let platformAuthProvider;
  try {
    if (enablePlatformBrokerDOMSupport) {
      platformAuthProvider = await PlatformAuthDOMHandler.createProvider(logger24, performanceClient, correlationId);
    }
    if (!platformAuthProvider) {
      logger24.trace("Platform auth via DOM API not available, checking for extension");
      platformAuthProvider = await PlatformAuthExtensionHandler.createProvider(logger24, nativeBrokerHandshakeTimeout || DEFAULT_NATIVE_BROKER_HANDSHAKE_TIMEOUT_MS, performanceClient);
    }
  } catch (e) {
    logger24.trace("Platform auth not available", e);
  }
  return platformAuthProvider;
}
function isDomEnabledForPlatformAuth() {
  let sessionStorage;
  try {
    sessionStorage = window[BrowserCacheLocation.SessionStorage];
    return (sessionStorage == null ? void 0 : sessionStorage.getItem(PLATFORM_AUTH_DOM_SUPPORT)) === "true";
  } catch (e) {
    return false;
  }
}
function isPlatformAuthAllowed(config, logger24, platformAuthProvider, authenticationScheme) {
  logger24.trace("isPlatformAuthAllowed called");
  if (!config.system.allowPlatformBroker) {
    logger24.trace("isPlatformAuthAllowed: allowPlatformBroker is not enabled, returning false");
    return false;
  }
  if (!platformAuthProvider) {
    logger24.trace("isPlatformAuthAllowed: Platform auth provider is not initialized, returning false");
    return false;
  }
  if (authenticationScheme) {
    switch (authenticationScheme) {
      case AuthenticationScheme.BEARER:
      case AuthenticationScheme.POP:
        logger24.trace("isPlatformAuthAllowed: authenticationScheme is supported, returning true");
        return true;
      default:
        logger24.trace("isPlatformAuthAllowed: authenticationScheme is not supported, returning false");
        return false;
    }
  }
  return true;
}
var init_PlatformAuthProvider = __esm({
  "node_modules/@azure/msal-browser/dist/broker/nativeBroker/PlatformAuthProvider.mjs"() {
    "use strict";
    init_index_browser();
    init_packageMetadata2();
    init_Configuration();
    init_PlatformAuthExtensionHandler();
    init_PlatformAuthDOMHandler();
    init_BrowserCrypto();
    init_BrowserConstants();
  }
});

// node_modules/@azure/msal-browser/dist/interaction_client/PopupClient.mjs
var PopupClient;
var init_PopupClient = __esm({
  "node_modules/@azure/msal-browser/dist/interaction_client/PopupClient.mjs"() {
    "use strict";
    init_index_browser();
    init_StandardInteractionClient();
    init_EventType();
    init_BrowserConstants();
    init_BrowserUtils();
    init_BrowserAuthError();
    init_ResponseHandler2();
    init_Authorize2();
    init_PkceGenerator();
    init_PlatformAuthProvider();
    init_BrowserCrypto();
    init_RequestHelpers();
    init_BrowserAuthErrorCodes();
    PopupClient = class extends StandardInteractionClient {
      constructor(config, storageImpl, browserCrypto, logger24, eventHandler, navigationClient, performanceClient, nativeStorageImpl, platformAuthHandler, correlationId) {
        super(config, storageImpl, browserCrypto, logger24, eventHandler, navigationClient, performanceClient, platformAuthHandler, correlationId);
        this.unloadWindow = this.unloadWindow.bind(this);
        this.nativeStorage = nativeStorageImpl;
        this.eventHandler = eventHandler;
      }
      /**
       * Acquires tokens by opening a popup window to the /authorize endpoint of the authority
       * @param request
       * @param pkceCodes
       */
      acquireToken(request, pkceCodes) {
        let popupParams = void 0;
        try {
          const popupName = this.generatePopupName(request.scopes || OIDC_DEFAULT_SCOPES, request.authority || this.config.auth.authority);
          popupParams = {
            popupName,
            popupWindowAttributes: request.popupWindowAttributes || {},
            popupWindowParent: request.popupWindowParent ?? window
          };
          this.performanceClient.addFields({ isAsyncPopup: this.config.system.asyncPopups }, this.correlationId);
          if (this.config.system.asyncPopups) {
            this.logger.verbose("asyncPopups set to true, acquiring token");
            return this.acquireTokenPopupAsync(request, popupParams, pkceCodes);
          } else {
            const validatedRequest = {
              ...request,
              httpMethod: validateRequestMethod(request, this.config.auth.protocolMode)
            };
            this.logger.verbose("asyncPopup set to false, opening popup before acquiring token");
            popupParams.popup = this.openSizedPopup("about:blank", popupParams);
            return this.acquireTokenPopupAsync(validatedRequest, popupParams, pkceCodes);
          }
        } catch (e) {
          return Promise.reject(e);
        }
      }
      /**
       * Clears local cache for the current user then opens a popup window prompting the user to sign-out of the server
       * @param logoutRequest
       */
      logout(logoutRequest) {
        try {
          this.logger.verbose("logoutPopup called");
          const validLogoutRequest = this.initializeLogoutRequest(logoutRequest);
          const popupParams = {
            popupName: this.generateLogoutPopupName(validLogoutRequest),
            popupWindowAttributes: (logoutRequest == null ? void 0 : logoutRequest.popupWindowAttributes) || {},
            popupWindowParent: (logoutRequest == null ? void 0 : logoutRequest.popupWindowParent) ?? window
          };
          const authority = logoutRequest && logoutRequest.authority;
          const mainWindowRedirectUri = logoutRequest && logoutRequest.mainWindowRedirectUri;
          if (this.config.system.asyncPopups) {
            this.logger.verbose("asyncPopups set to true");
            return this.logoutPopupAsync(validLogoutRequest, popupParams, authority, mainWindowRedirectUri);
          } else {
            this.logger.verbose("asyncPopup set to false, opening popup");
            popupParams.popup = this.openSizedPopup("about:blank", popupParams);
            return this.logoutPopupAsync(validLogoutRequest, popupParams, authority, mainWindowRedirectUri);
          }
        } catch (e) {
          return Promise.reject(e);
        }
      }
      /**
       * Helper which obtains an access_token for your API via opening a popup window in the user's browser
       * @param request
       * @param popupParams
       * @param pkceCodes
       *
       * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.
       */
      async acquireTokenPopupAsync(request, popupParams, pkceCodes) {
        this.logger.verbose("acquireTokenPopupAsync called");
        const validRequest = await invokeAsync(this.initializeAuthorizationRequest.bind(this), PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, this.logger, this.performanceClient, this.correlationId)(request, InteractionType.Popup);
        if (popupParams.popup) {
          preconnect(validRequest.authority);
        }
        const isPlatformBroker = isPlatformAuthAllowed(this.config, this.logger, this.platformAuthProvider, request.authenticationScheme);
        validRequest.platformBroker = isPlatformBroker;
        if (this.config.auth.protocolMode === ProtocolMode.EAR) {
          return this.executeEarFlow(validRequest, popupParams);
        } else {
          return this.executeCodeFlow(validRequest, popupParams, pkceCodes);
        }
      }
      /**
       * Executes auth code + PKCE flow
       * @param request
       * @param popupParams
       * @param pkceCodes
       * @returns
       */
      async executeCodeFlow(request, popupParams, pkceCodes) {
        var _a3;
        const correlationId = request.correlationId;
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenPopup);
        const pkce = pkceCodes || await invokeAsync(generatePkceCodes, PerformanceEvents.GeneratePkceCodes, this.logger, this.performanceClient, correlationId)(this.performanceClient, this.logger, correlationId);
        const popupRequest = {
          ...request,
          codeChallenge: pkce.challenge
        };
        try {
          const authClient = await invokeAsync(this.createAuthCodeClient.bind(this), PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, this.logger, this.performanceClient, correlationId)({
            serverTelemetryManager,
            requestAuthority: popupRequest.authority,
            requestAzureCloudOptions: popupRequest.azureCloudOptions,
            requestExtraQueryParameters: popupRequest.extraQueryParameters,
            account: popupRequest.account
          });
          if (popupRequest.httpMethod === HttpMethod.POST) {
            return await this.executeCodeFlowWithPost(popupRequest, popupParams, authClient, pkce.verifier);
          } else {
            const navigateUrl = await invokeAsync(getAuthCodeRequestUrl, PerformanceEvents.GetAuthCodeUrl, this.logger, this.performanceClient, correlationId)(this.config, authClient.authority, popupRequest, this.logger, this.performanceClient);
            const popupWindow = this.initiateAuthRequest(navigateUrl, popupParams);
            this.eventHandler.emitEvent(EventType.POPUP_OPENED, InteractionType.Popup, { popupWindow }, null);
            const responseString = await this.monitorPopupForHash(popupWindow, popupParams.popupWindowParent);
            const serverParams = invoke(deserializeResponse, PerformanceEvents.DeserializeResponse, this.logger, this.performanceClient, this.correlationId)(responseString, this.config.auth.OIDCOptions.serverResponseType, this.logger);
            return await invokeAsync(handleResponseCode, PerformanceEvents.HandleResponseCode, this.logger, this.performanceClient, correlationId)(request, serverParams, pkce.verifier, ApiId.acquireTokenPopup, this.config, authClient, this.browserStorage, this.nativeStorage, this.eventHandler, this.logger, this.performanceClient, this.platformAuthProvider);
          }
        } catch (e) {
          (_a3 = popupParams.popup) == null ? void 0 : _a3.close();
          if (e instanceof AuthError) {
            e.setCorrelationId(this.correlationId);
            serverTelemetryManager.cacheFailedRequest(e);
          }
          throw e;
        }
      }
      /**
       * Executes EAR flow
       * @param request
       */
      async executeEarFlow(request, popupParams) {
        const correlationId = request.correlationId;
        const discoveredAuthority = await invokeAsync(this.getDiscoveredAuthority.bind(this), PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority, this.logger, this.performanceClient, correlationId)({
          requestAuthority: request.authority,
          requestAzureCloudOptions: request.azureCloudOptions,
          requestExtraQueryParameters: request.extraQueryParameters,
          account: request.account
        });
        const earJwk = await invokeAsync(generateEarKey, PerformanceEvents.GenerateEarKey, this.logger, this.performanceClient, correlationId)();
        const popupRequest = {
          ...request,
          earJwk
        };
        const popupWindow = popupParams.popup || this.openPopup("about:blank", popupParams);
        const form = await getEARForm(popupWindow.document, this.config, discoveredAuthority, popupRequest, this.logger, this.performanceClient);
        form.submit();
        const responseString = await invokeAsync(this.monitorPopupForHash.bind(this), PerformanceEvents.SilentHandlerMonitorIframeForHash, this.logger, this.performanceClient, correlationId)(popupWindow, popupParams.popupWindowParent);
        const serverParams = invoke(deserializeResponse, PerformanceEvents.DeserializeResponse, this.logger, this.performanceClient, this.correlationId)(responseString, this.config.auth.OIDCOptions.serverResponseType, this.logger);
        return invokeAsync(handleResponseEAR, PerformanceEvents.HandleResponseEar, this.logger, this.performanceClient, correlationId)(popupRequest, serverParams, ApiId.acquireTokenPopup, this.config, discoveredAuthority, this.browserStorage, this.nativeStorage, this.eventHandler, this.logger, this.performanceClient, this.platformAuthProvider);
      }
      async executeCodeFlowWithPost(request, popupParams, authClient, pkceVerifier) {
        const correlationId = request.correlationId;
        const discoveredAuthority = await invokeAsync(this.getDiscoveredAuthority.bind(this), PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority, this.logger, this.performanceClient, correlationId)({
          requestAuthority: request.authority,
          requestAzureCloudOptions: request.azureCloudOptions,
          requestExtraQueryParameters: request.extraQueryParameters,
          account: request.account
        });
        const popupWindow = popupParams.popup || this.openPopup("about:blank", popupParams);
        const form = await getCodeForm(popupWindow.document, this.config, discoveredAuthority, request, this.logger, this.performanceClient);
        form.submit();
        const responseString = await invokeAsync(this.monitorPopupForHash.bind(this), PerformanceEvents.SilentHandlerMonitorIframeForHash, this.logger, this.performanceClient, correlationId)(popupWindow, popupParams.popupWindowParent);
        const serverParams = invoke(deserializeResponse, PerformanceEvents.DeserializeResponse, this.logger, this.performanceClient, this.correlationId)(responseString, this.config.auth.OIDCOptions.serverResponseType, this.logger);
        return invokeAsync(handleResponseCode, PerformanceEvents.HandleResponseCode, this.logger, this.performanceClient, correlationId)(request, serverParams, pkceVerifier, ApiId.acquireTokenPopup, this.config, authClient, this.browserStorage, this.nativeStorage, this.eventHandler, this.logger, this.performanceClient, this.platformAuthProvider);
      }
      /**
       *
       * @param validRequest
       * @param popupName
       * @param requestAuthority
       * @param popup
       * @param mainWindowRedirectUri
       * @param popupWindowAttributes
       */
      async logoutPopupAsync(validRequest, popupParams, requestAuthority, mainWindowRedirectUri) {
        var _a3, _b2, _c2, _d2;
        this.logger.verbose("logoutPopupAsync called");
        this.eventHandler.emitEvent(EventType.LOGOUT_START, InteractionType.Popup, validRequest);
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.logoutPopup);
        try {
          await this.clearCacheOnLogout(this.correlationId, validRequest.account);
          const authClient = await invokeAsync(this.createAuthCodeClient.bind(this), PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, this.logger, this.performanceClient, this.correlationId)({
            serverTelemetryManager,
            requestAuthority,
            account: validRequest.account || void 0
          });
          try {
            authClient.authority.endSessionEndpoint;
          } catch {
            if (((_a3 = validRequest.account) == null ? void 0 : _a3.homeAccountId) && validRequest.postLogoutRedirectUri && authClient.authority.protocolMode === ProtocolMode.OIDC) {
              this.browserStorage.removeAccount((_b2 = validRequest.account) == null ? void 0 : _b2.homeAccountId, this.correlationId);
              this.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Popup, validRequest);
              if (mainWindowRedirectUri) {
                const navigationOptions = {
                  apiId: ApiId.logoutPopup,
                  timeout: this.config.system.redirectNavigationTimeout,
                  noHistory: false
                };
                const absoluteUrl = UrlString.getAbsoluteUrl(mainWindowRedirectUri, getCurrentUri());
                await this.navigationClient.navigateInternal(absoluteUrl, navigationOptions);
              }
              (_c2 = popupParams.popup) == null ? void 0 : _c2.close();
              return;
            }
          }
          const logoutUri = authClient.getLogoutUri(validRequest);
          this.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Popup, validRequest);
          const popupWindow = this.openPopup(logoutUri, popupParams);
          this.eventHandler.emitEvent(EventType.POPUP_OPENED, InteractionType.Popup, { popupWindow }, null);
          await this.monitorPopupForHash(popupWindow, popupParams.popupWindowParent).catch(() => {
          });
          if (mainWindowRedirectUri) {
            const navigationOptions = {
              apiId: ApiId.logoutPopup,
              timeout: this.config.system.redirectNavigationTimeout,
              noHistory: false
            };
            const absoluteUrl = UrlString.getAbsoluteUrl(mainWindowRedirectUri, getCurrentUri());
            this.logger.verbose("Redirecting main window to url specified in the request");
            this.logger.verbosePii(`Redirecting main window to: ${absoluteUrl}`);
            await this.navigationClient.navigateInternal(absoluteUrl, navigationOptions);
          } else {
            this.logger.verbose("No main window navigation requested");
          }
        } catch (e) {
          (_d2 = popupParams.popup) == null ? void 0 : _d2.close();
          if (e instanceof AuthError) {
            e.setCorrelationId(this.correlationId);
            serverTelemetryManager.cacheFailedRequest(e);
          }
          this.eventHandler.emitEvent(EventType.LOGOUT_FAILURE, InteractionType.Popup, null, e);
          this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Popup);
          throw e;
        }
        this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Popup);
      }
      /**
       * Opens a popup window with given request Url.
       * @param requestUrl
       */
      initiateAuthRequest(requestUrl, params) {
        if (requestUrl) {
          this.logger.infoPii(`Navigate to: ${requestUrl}`);
          return this.openPopup(requestUrl, params);
        } else {
          this.logger.error("Navigate url is empty");
          throw createBrowserAuthError(emptyNavigateUri);
        }
      }
      /**
       * Monitors a window until it loads a url with the same origin.
       * @param popupWindow - window that is being monitored
       * @param timeout - timeout for processing hash once popup is redirected back to application
       */
      monitorPopupForHash(popupWindow, popupWindowParent) {
        return new Promise((resolve, reject) => {
          this.logger.verbose("PopupHandler.monitorPopupForHash - polling started");
          const intervalId = setInterval(() => {
            if (popupWindow.closed) {
              this.logger.error("PopupHandler.monitorPopupForHash - window closed");
              clearInterval(intervalId);
              reject(createBrowserAuthError(userCancelled));
              return;
            }
            let href = "";
            try {
              href = popupWindow.location.href;
            } catch (e) {
            }
            if (!href || href === "about:blank") {
              return;
            }
            clearInterval(intervalId);
            let responseString = "";
            const responseType = this.config.auth.OIDCOptions.serverResponseType;
            if (popupWindow) {
              if (responseType === ServerResponseType.QUERY) {
                responseString = popupWindow.location.search;
              } else {
                responseString = popupWindow.location.hash;
              }
            }
            this.logger.verbose("PopupHandler.monitorPopupForHash - popup window is on same origin as caller");
            resolve(responseString);
          }, this.config.system.pollIntervalMilliseconds);
        }).finally(() => {
          this.cleanPopup(popupWindow, popupWindowParent);
        });
      }
      /**
       * @hidden
       *
       * Configures popup window for login.
       *
       * @param urlNavigate
       * @param title
       * @param popUpWidth
       * @param popUpHeight
       * @param popupWindowAttributes
       * @ignore
       * @hidden
       */
      openPopup(urlNavigate, popupParams) {
        try {
          let popupWindow;
          if (popupParams.popup) {
            popupWindow = popupParams.popup;
            this.logger.verbosePii(`Navigating popup window to: ${urlNavigate}`);
            popupWindow.location.assign(urlNavigate);
          } else if (typeof popupParams.popup === "undefined") {
            this.logger.verbosePii(`Opening popup window to: ${urlNavigate}`);
            popupWindow = this.openSizedPopup(urlNavigate, popupParams);
          }
          if (!popupWindow) {
            throw createBrowserAuthError(emptyWindowError);
          }
          if (popupWindow.focus) {
            popupWindow.focus();
          }
          this.currentWindow = popupWindow;
          popupParams.popupWindowParent.addEventListener("beforeunload", this.unloadWindow);
          return popupWindow;
        } catch (e) {
          this.logger.error("error opening popup " + e.message);
          throw createBrowserAuthError(popupWindowError);
        }
      }
      /**
       * Helper function to set popup window dimensions and position
       * @param urlNavigate
       * @param popupName
       * @param popupWindowAttributes
       * @returns
       */
      openSizedPopup(urlNavigate, { popupName, popupWindowAttributes, popupWindowParent }) {
        var _a3, _b2, _c2, _d2;
        const winLeft = popupWindowParent.screenLeft ? popupWindowParent.screenLeft : popupWindowParent.screenX;
        const winTop = popupWindowParent.screenTop ? popupWindowParent.screenTop : popupWindowParent.screenY;
        const winWidth = popupWindowParent.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
        const winHeight = popupWindowParent.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
        let width = (_a3 = popupWindowAttributes.popupSize) == null ? void 0 : _a3.width;
        let height = (_b2 = popupWindowAttributes.popupSize) == null ? void 0 : _b2.height;
        let top = (_c2 = popupWindowAttributes.popupPosition) == null ? void 0 : _c2.top;
        let left = (_d2 = popupWindowAttributes.popupPosition) == null ? void 0 : _d2.left;
        if (!width || width < 0 || width > winWidth) {
          this.logger.verbose("Default popup window width used. Window width not configured or invalid.");
          width = BrowserConstants.POPUP_WIDTH;
        }
        if (!height || height < 0 || height > winHeight) {
          this.logger.verbose("Default popup window height used. Window height not configured or invalid.");
          height = BrowserConstants.POPUP_HEIGHT;
        }
        if (!top || top < 0 || top > winHeight) {
          this.logger.verbose("Default popup window top position used. Window top not configured or invalid.");
          top = Math.max(0, winHeight / 2 - BrowserConstants.POPUP_HEIGHT / 2 + winTop);
        }
        if (!left || left < 0 || left > winWidth) {
          this.logger.verbose("Default popup window left position used. Window left not configured or invalid.");
          left = Math.max(0, winWidth / 2 - BrowserConstants.POPUP_WIDTH / 2 + winLeft);
        }
        return popupWindowParent.open(urlNavigate, popupName, `width=${width}, height=${height}, top=${top}, left=${left}, scrollbars=yes`);
      }
      /**
       * Event callback to unload main window.
       */
      unloadWindow(e) {
        if (this.currentWindow) {
          this.currentWindow.close();
        }
        e.preventDefault();
      }
      /**
       * Closes popup, removes any state vars created during popup calls.
       * @param popupWindow
       */
      cleanPopup(popupWindow, popupWindowParent) {
        popupWindow.close();
        popupWindowParent.removeEventListener("beforeunload", this.unloadWindow);
      }
      /**
       * Generates the name for the popup based on the client id and request
       * @param clientId
       * @param request
       */
      generatePopupName(scopes, authority) {
        return `${BrowserConstants.POPUP_NAME_PREFIX}.${this.config.auth.clientId}.${scopes.join("-")}.${authority}.${this.correlationId}`;
      }
      /**
       * Generates the name for the popup based on the client id and request for logouts
       * @param clientId
       * @param request
       */
      generateLogoutPopupName(request) {
        const homeAccountId = request.account && request.account.homeAccountId;
        return `${BrowserConstants.POPUP_NAME_PREFIX}.${this.config.auth.clientId}.${homeAccountId}.${this.correlationId}`;
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/interaction_client/RedirectClient.mjs
function getNavigationType() {
  if (typeof window === "undefined" || typeof window.performance === "undefined" || typeof window.performance.getEntriesByType !== "function") {
    return void 0;
  }
  const navigationEntries = window.performance.getEntriesByType("navigation");
  const navigation = navigationEntries.length ? navigationEntries[0] : void 0;
  return navigation == null ? void 0 : navigation.type;
}
var RedirectClient;
var init_RedirectClient = __esm({
  "node_modules/@azure/msal-browser/dist/interaction_client/RedirectClient.mjs"() {
    "use strict";
    init_index_browser();
    init_StandardInteractionClient();
    init_BrowserConstants();
    init_BrowserUtils();
    init_EventType();
    init_BrowserAuthError();
    init_ResponseHandler2();
    init_Authorize2();
    init_PkceGenerator();
    init_PlatformAuthProvider();
    init_BrowserCrypto();
    init_BrowserAuthErrorCodes();
    RedirectClient = class extends StandardInteractionClient {
      constructor(config, storageImpl, browserCrypto, logger24, eventHandler, navigationClient, performanceClient, nativeStorageImpl, platformAuthHandler, correlationId) {
        super(config, storageImpl, browserCrypto, logger24, eventHandler, navigationClient, performanceClient, platformAuthHandler, correlationId);
        this.nativeStorage = nativeStorageImpl;
      }
      /**
       * Redirects the page to the /authorize endpoint of the IDP
       * @param request
       */
      async acquireToken(request) {
        const validRequest = await invokeAsync(this.initializeAuthorizationRequest.bind(this), PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, this.logger, this.performanceClient, this.correlationId)(request, InteractionType.Redirect);
        validRequest.platformBroker = isPlatformAuthAllowed(this.config, this.logger, this.platformAuthProvider, request.authenticationScheme);
        const handleBackButton = (event) => {
          if (event.persisted) {
            this.logger.verbose("Page was restored from back/forward cache. Clearing temporary cache.");
            this.browserStorage.resetRequestCache();
            this.eventHandler.emitEvent(EventType.RESTORE_FROM_BFCACHE, InteractionType.Redirect);
          }
        };
        const redirectStartPage = this.getRedirectStartPage(request.redirectStartPage);
        this.logger.verbosePii(`Redirect start page: ${redirectStartPage}`);
        this.browserStorage.setTemporaryCache(TemporaryCacheKeys.ORIGIN_URI, redirectStartPage, true);
        window.addEventListener("pageshow", handleBackButton);
        try {
          if (this.config.auth.protocolMode === ProtocolMode.EAR) {
            await this.executeEarFlow(validRequest);
          } else {
            await this.executeCodeFlow(validRequest, request.onRedirectNavigate);
          }
        } catch (e) {
          if (e instanceof AuthError) {
            e.setCorrelationId(this.correlationId);
          }
          window.removeEventListener("pageshow", handleBackButton);
          throw e;
        }
      }
      /**
       * Executes auth code + PKCE flow
       * @param request
       * @returns
       */
      async executeCodeFlow(request, onRedirectNavigate) {
        const correlationId = request.correlationId;
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenRedirect);
        const pkceCodes = await invokeAsync(generatePkceCodes, PerformanceEvents.GeneratePkceCodes, this.logger, this.performanceClient, correlationId)(this.performanceClient, this.logger, correlationId);
        const redirectRequest = {
          ...request,
          codeChallenge: pkceCodes.challenge
        };
        this.browserStorage.cacheAuthorizeRequest(redirectRequest, pkceCodes.verifier);
        try {
          if (redirectRequest.httpMethod === HttpMethod.POST) {
            return await this.executeCodeFlowWithPost(redirectRequest);
          } else {
            const authClient = await invokeAsync(this.createAuthCodeClient.bind(this), PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, this.logger, this.performanceClient, this.correlationId)({
              serverTelemetryManager,
              requestAuthority: redirectRequest.authority,
              requestAzureCloudOptions: redirectRequest.azureCloudOptions,
              requestExtraQueryParameters: redirectRequest.extraQueryParameters,
              account: redirectRequest.account
            });
            const navigateUrl = await invokeAsync(getAuthCodeRequestUrl, PerformanceEvents.GetAuthCodeUrl, this.logger, this.performanceClient, request.correlationId)(this.config, authClient.authority, redirectRequest, this.logger, this.performanceClient);
            return await this.initiateAuthRequest(navigateUrl, onRedirectNavigate);
          }
        } catch (e) {
          if (e instanceof AuthError) {
            e.setCorrelationId(this.correlationId);
            serverTelemetryManager.cacheFailedRequest(e);
          }
          throw e;
        }
      }
      /**
       * Executes EAR flow
       * @param request
       */
      async executeEarFlow(request) {
        const correlationId = request.correlationId;
        const discoveredAuthority = await invokeAsync(this.getDiscoveredAuthority.bind(this), PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority, this.logger, this.performanceClient, correlationId)({
          requestAuthority: request.authority,
          requestAzureCloudOptions: request.azureCloudOptions,
          requestExtraQueryParameters: request.extraQueryParameters,
          account: request.account
        });
        const earJwk = await invokeAsync(generateEarKey, PerformanceEvents.GenerateEarKey, this.logger, this.performanceClient, correlationId)();
        const redirectRequest = {
          ...request,
          earJwk
        };
        this.browserStorage.cacheAuthorizeRequest(redirectRequest);
        const form = await getEARForm(document, this.config, discoveredAuthority, redirectRequest, this.logger, this.performanceClient);
        form.submit();
        return new Promise((resolve, reject) => {
          setTimeout(() => {
            reject(createBrowserAuthError(timedOut, "failed_to_redirect"));
          }, this.config.system.redirectNavigationTimeout);
        });
      }
      /**
       * Executes classic Authorization Code flow with a POST request.
       * @param request
       */
      async executeCodeFlowWithPost(request) {
        const correlationId = request.correlationId;
        const discoveredAuthority = await invokeAsync(this.getDiscoveredAuthority.bind(this), PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority, this.logger, this.performanceClient, correlationId)({
          requestAuthority: request.authority,
          requestAzureCloudOptions: request.azureCloudOptions,
          requestExtraQueryParameters: request.extraQueryParameters,
          account: request.account
        });
        this.browserStorage.cacheAuthorizeRequest(request);
        const form = await getCodeForm(document, this.config, discoveredAuthority, request, this.logger, this.performanceClient);
        form.submit();
        return new Promise((resolve, reject) => {
          setTimeout(() => {
            reject(createBrowserAuthError(timedOut, "failed_to_redirect"));
          }, this.config.system.redirectNavigationTimeout);
        });
      }
      /**
       * Checks if navigateToLoginRequestUrl is set, and:
       * - if true, performs logic to cache and navigate
       * - if false, handles hash string and parses response
       * @param hash {string} url hash
       * @param parentMeasurement {InProgressPerformanceEvent} parent measurement
       */
      async handleRedirectPromise(hash = "", request, pkceVerifier, parentMeasurement) {
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.handleRedirectPromise);
        try {
          const [serverParams, responseString] = this.getRedirectResponse(hash || "");
          if (!serverParams) {
            this.logger.info("handleRedirectPromise did not detect a response as a result of a redirect. Cleaning temporary cache.");
            this.browserStorage.resetRequestCache();
            if (getNavigationType() !== "back_forward") {
              parentMeasurement.event.errorCode = "no_server_response";
            } else {
              this.logger.verbose("Back navigation event detected. Muting no_server_response error");
            }
            return null;
          }
          const loginRequestUrl = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.ORIGIN_URI, true) || Constants.EMPTY_STRING;
          const loginRequestUrlNormalized = UrlString.removeHashFromUrl(loginRequestUrl);
          const currentUrlNormalized = UrlString.removeHashFromUrl(window.location.href);
          if (loginRequestUrlNormalized === currentUrlNormalized && this.config.auth.navigateToLoginRequestUrl) {
            this.logger.verbose("Current page is loginRequestUrl, handling response");
            if (loginRequestUrl.indexOf("#") > -1) {
              replaceHash(loginRequestUrl);
            }
            const handleHashResult = await this.handleResponse(serverParams, request, pkceVerifier, serverTelemetryManager);
            return handleHashResult;
          } else if (!this.config.auth.navigateToLoginRequestUrl) {
            this.logger.verbose("NavigateToLoginRequestUrl set to false, handling response");
            return await this.handleResponse(serverParams, request, pkceVerifier, serverTelemetryManager);
          } else if (!isInIframe() || this.config.system.allowRedirectInIframe) {
            this.browserStorage.setTemporaryCache(TemporaryCacheKeys.URL_HASH, responseString, true);
            const navigationOptions = {
              apiId: ApiId.handleRedirectPromise,
              timeout: this.config.system.redirectNavigationTimeout,
              noHistory: true
            };
            let processHashOnRedirect = true;
            if (!loginRequestUrl || loginRequestUrl === "null") {
              const homepage = getHomepage();
              this.browserStorage.setTemporaryCache(TemporaryCacheKeys.ORIGIN_URI, homepage, true);
              this.logger.warning("Unable to get valid login request url from cache, redirecting to home page");
              processHashOnRedirect = await this.navigationClient.navigateInternal(homepage, navigationOptions);
            } else {
              this.logger.verbose(`Navigating to loginRequestUrl: ${loginRequestUrl}`);
              processHashOnRedirect = await this.navigationClient.navigateInternal(loginRequestUrl, navigationOptions);
            }
            if (!processHashOnRedirect) {
              return await this.handleResponse(serverParams, request, pkceVerifier, serverTelemetryManager);
            }
          }
          return null;
        } catch (e) {
          if (e instanceof AuthError) {
            e.setCorrelationId(this.correlationId);
            serverTelemetryManager.cacheFailedRequest(e);
          }
          throw e;
        }
      }
      /**
       * Gets the response hash for a redirect request
       * Returns null if interactionType in the state value is not "redirect" or the hash does not contain known properties
       * @param hash
       */
      getRedirectResponse(userProvidedResponse) {
        this.logger.verbose("getRedirectResponseHash called");
        let responseString = userProvidedResponse;
        if (!responseString) {
          if (this.config.auth.OIDCOptions.serverResponseType === ServerResponseType.QUERY) {
            responseString = window.location.search;
          } else {
            responseString = window.location.hash;
          }
        }
        let response = UrlUtils_exports.getDeserializedResponse(responseString);
        if (response) {
          try {
            validateInteractionType(response, this.browserCrypto, InteractionType.Redirect);
          } catch (e) {
            if (e instanceof AuthError) {
              this.logger.error(`Interaction type validation failed due to ${e.errorCode}: ${e.errorMessage}`);
            }
            return [null, ""];
          }
          clearHash(window);
          this.logger.verbose("Hash contains known properties, returning response hash");
          return [response, responseString];
        }
        const cachedHash = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.URL_HASH, true);
        this.browserStorage.removeItem(this.browserStorage.generateCacheKey(TemporaryCacheKeys.URL_HASH));
        if (cachedHash) {
          response = UrlUtils_exports.getDeserializedResponse(cachedHash);
          if (response) {
            this.logger.verbose("Hash does not contain known properties, returning cached hash");
            return [response, cachedHash];
          }
        }
        return [null, ""];
      }
      /**
       * Checks if hash exists and handles in window.
       * @param hash
       * @param state
       */
      async handleResponse(serverParams, request, codeVerifier, serverTelemetryManager) {
        const state3 = serverParams.state;
        if (!state3) {
          throw createBrowserAuthError(noStateInHash);
        }
        if (serverParams.ear_jwe) {
          const discoveredAuthority = await invokeAsync(this.getDiscoveredAuthority.bind(this), PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority, this.logger, this.performanceClient, request.correlationId)({
            requestAuthority: request.authority,
            requestAzureCloudOptions: request.azureCloudOptions,
            requestExtraQueryParameters: request.extraQueryParameters,
            account: request.account
          });
          return invokeAsync(handleResponseEAR, PerformanceEvents.HandleResponseEar, this.logger, this.performanceClient, request.correlationId)(request, serverParams, ApiId.acquireTokenRedirect, this.config, discoveredAuthority, this.browserStorage, this.nativeStorage, this.eventHandler, this.logger, this.performanceClient, this.platformAuthProvider);
        }
        const authClient = await invokeAsync(this.createAuthCodeClient.bind(this), PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, this.logger, this.performanceClient, this.correlationId)({ serverTelemetryManager, requestAuthority: request.authority });
        return invokeAsync(handleResponseCode, PerformanceEvents.HandleResponseCode, this.logger, this.performanceClient, request.correlationId)(request, serverParams, codeVerifier, ApiId.acquireTokenRedirect, this.config, authClient, this.browserStorage, this.nativeStorage, this.eventHandler, this.logger, this.performanceClient, this.platformAuthProvider);
      }
      /**
       * Redirects window to given URL.
       * @param urlNavigate
       * @param onRedirectNavigateRequest - onRedirectNavigate callback provided on the request
       */
      async initiateAuthRequest(requestUrl, onRedirectNavigateRequest) {
        this.logger.verbose("RedirectHandler.initiateAuthRequest called");
        if (requestUrl) {
          this.logger.infoPii(`RedirectHandler.initiateAuthRequest: Navigate to: ${requestUrl}`);
          const navigationOptions = {
            apiId: ApiId.acquireTokenRedirect,
            timeout: this.config.system.redirectNavigationTimeout,
            noHistory: false
          };
          const onRedirectNavigate = onRedirectNavigateRequest || this.config.auth.onRedirectNavigate;
          if (typeof onRedirectNavigate === "function") {
            this.logger.verbose("RedirectHandler.initiateAuthRequest: Invoking onRedirectNavigate callback");
            const navigate = onRedirectNavigate(requestUrl);
            if (navigate !== false) {
              this.logger.verbose("RedirectHandler.initiateAuthRequest: onRedirectNavigate did not return false, navigating");
              await this.navigationClient.navigateExternal(requestUrl, navigationOptions);
              return;
            } else {
              this.logger.verbose("RedirectHandler.initiateAuthRequest: onRedirectNavigate returned false, stopping navigation");
              return;
            }
          } else {
            this.logger.verbose("RedirectHandler.initiateAuthRequest: Navigating window to navigate url");
            await this.navigationClient.navigateExternal(requestUrl, navigationOptions);
            return;
          }
        } else {
          this.logger.info("RedirectHandler.initiateAuthRequest: Navigate url is empty");
          throw createBrowserAuthError(emptyNavigateUri);
        }
      }
      /**
       * Use to log out the current user, and redirect the user to the postLogoutRedirectUri.
       * Default behaviour is to redirect the user to `window.location.href`.
       * @param logoutRequest
       */
      async logout(logoutRequest) {
        var _a3, _b2;
        this.logger.verbose("logoutRedirect called");
        const validLogoutRequest = this.initializeLogoutRequest(logoutRequest);
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.logout);
        try {
          this.eventHandler.emitEvent(EventType.LOGOUT_START, InteractionType.Redirect, logoutRequest);
          await this.clearCacheOnLogout(this.correlationId, validLogoutRequest.account);
          const navigationOptions = {
            apiId: ApiId.logout,
            timeout: this.config.system.redirectNavigationTimeout,
            noHistory: false
          };
          const authClient = await invokeAsync(this.createAuthCodeClient.bind(this), PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, this.logger, this.performanceClient, this.correlationId)({
            serverTelemetryManager,
            requestAuthority: logoutRequest && logoutRequest.authority,
            requestExtraQueryParameters: logoutRequest == null ? void 0 : logoutRequest.extraQueryParameters,
            account: logoutRequest && logoutRequest.account || void 0
          });
          if (authClient.authority.protocolMode === ProtocolMode.OIDC) {
            try {
              authClient.authority.endSessionEndpoint;
            } catch {
              if ((_a3 = validLogoutRequest.account) == null ? void 0 : _a3.homeAccountId) {
                this.browserStorage.removeAccount((_b2 = validLogoutRequest.account) == null ? void 0 : _b2.homeAccountId, this.correlationId);
                this.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Redirect, validLogoutRequest);
                return;
              }
            }
          }
          const logoutUri = authClient.getLogoutUri(validLogoutRequest);
          this.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Redirect, validLogoutRequest);
          if (logoutRequest && typeof logoutRequest.onRedirectNavigate === "function") {
            const navigate = logoutRequest.onRedirectNavigate(logoutUri);
            if (navigate !== false) {
              this.logger.verbose("Logout onRedirectNavigate did not return false, navigating");
              if (!this.browserStorage.getInteractionInProgress()) {
                this.browserStorage.setInteractionInProgress(true, INTERACTION_TYPE.SIGNOUT);
              }
              await this.navigationClient.navigateExternal(logoutUri, navigationOptions);
              return;
            } else {
              this.browserStorage.setInteractionInProgress(false);
              this.logger.verbose("Logout onRedirectNavigate returned false, stopping navigation");
            }
          } else {
            if (!this.browserStorage.getInteractionInProgress()) {
              this.browserStorage.setInteractionInProgress(true, INTERACTION_TYPE.SIGNOUT);
            }
            await this.navigationClient.navigateExternal(logoutUri, navigationOptions);
            return;
          }
        } catch (e) {
          if (e instanceof AuthError) {
            e.setCorrelationId(this.correlationId);
            serverTelemetryManager.cacheFailedRequest(e);
          }
          this.eventHandler.emitEvent(EventType.LOGOUT_FAILURE, InteractionType.Redirect, null, e);
          this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Redirect);
          throw e;
        }
        this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Redirect);
      }
      /**
       * Use to get the redirectStartPage either from request or use current window
       * @param requestStartPage
       */
      getRedirectStartPage(requestStartPage) {
        const redirectStartPage = requestStartPage || window.location.href;
        return UrlString.getAbsoluteUrl(redirectStartPage, getCurrentUri());
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/interaction_handler/SilentHandler.mjs
async function initiateCodeRequest(requestUrl, performanceClient, logger24, correlationId, navigateFrameWait) {
  performanceClient.addQueueMeasurement(PerformanceEvents.SilentHandlerInitiateAuthRequest, correlationId);
  if (!requestUrl) {
    logger24.info("Navigate url is empty");
    throw createBrowserAuthError(emptyNavigateUri);
  }
  if (navigateFrameWait) {
    return invokeAsync(loadFrame, PerformanceEvents.SilentHandlerLoadFrame, logger24, performanceClient, correlationId)(requestUrl, navigateFrameWait, performanceClient, correlationId);
  }
  return invoke(loadFrameSync, PerformanceEvents.SilentHandlerLoadFrameSync, logger24, performanceClient, correlationId)(requestUrl);
}
async function initiateCodeFlowWithPost(config, authority, request, logger24, performanceClient) {
  const frame = createHiddenIframe();
  if (!frame.contentDocument) {
    throw "No document associated with iframe!";
  }
  const form = await getCodeForm(frame.contentDocument, config, authority, request, logger24, performanceClient);
  form.submit();
  return frame;
}
async function initiateEarRequest(config, authority, request, logger24, performanceClient) {
  const frame = createHiddenIframe();
  if (!frame.contentDocument) {
    throw "No document associated with iframe!";
  }
  const form = await getEARForm(frame.contentDocument, config, authority, request, logger24, performanceClient);
  form.submit();
  return frame;
}
async function monitorIframeForHash(iframe, timeout, pollIntervalMilliseconds, performanceClient, logger24, correlationId, responseType) {
  performanceClient.addQueueMeasurement(PerformanceEvents.SilentHandlerMonitorIframeForHash, correlationId);
  return new Promise((resolve, reject) => {
    if (timeout < DEFAULT_IFRAME_TIMEOUT_MS) {
      logger24.warning(`system.loadFrameTimeout or system.iframeHashTimeout set to lower (${timeout}ms) than the default (${DEFAULT_IFRAME_TIMEOUT_MS}ms). This may result in timeouts.`);
    }
    const timeoutId = window.setTimeout(() => {
      window.clearInterval(intervalId);
      reject(createBrowserAuthError(monitorWindowTimeout));
    }, timeout);
    const intervalId = window.setInterval(() => {
      let href = "";
      const contentWindow = iframe.contentWindow;
      try {
        href = contentWindow ? contentWindow.location.href : "";
      } catch (e) {
      }
      if (!href || href === "about:blank") {
        return;
      }
      let responseString = "";
      if (contentWindow) {
        if (responseType === ServerResponseType.QUERY) {
          responseString = contentWindow.location.search;
        } else {
          responseString = contentWindow.location.hash;
        }
      }
      window.clearTimeout(timeoutId);
      window.clearInterval(intervalId);
      resolve(responseString);
    }, pollIntervalMilliseconds);
  }).finally(() => {
    invoke(removeHiddenIframe, PerformanceEvents.RemoveHiddenIframe, logger24, performanceClient, correlationId)(iframe);
  });
}
function loadFrame(urlNavigate, navigateFrameWait, performanceClient, correlationId) {
  performanceClient.addQueueMeasurement(PerformanceEvents.SilentHandlerLoadFrame, correlationId);
  return new Promise((resolve, reject) => {
    const frameHandle = createHiddenIframe();
    window.setTimeout(() => {
      if (!frameHandle) {
        reject("Unable to load iframe");
        return;
      }
      frameHandle.src = urlNavigate;
      resolve(frameHandle);
    }, navigateFrameWait);
  });
}
function loadFrameSync(urlNavigate) {
  const frameHandle = createHiddenIframe();
  frameHandle.src = urlNavigate;
  return frameHandle;
}
function createHiddenIframe() {
  const authFrame = document.createElement("iframe");
  authFrame.className = "msalSilentIframe";
  authFrame.style.visibility = "hidden";
  authFrame.style.position = "absolute";
  authFrame.style.width = authFrame.style.height = "0";
  authFrame.style.border = "0";
  authFrame.setAttribute("sandbox", "allow-scripts allow-same-origin allow-forms");
  document.body.appendChild(authFrame);
  return authFrame;
}
function removeHiddenIframe(iframe) {
  if (document.body === iframe.parentNode) {
    document.body.removeChild(iframe);
  }
}
var init_SilentHandler = __esm({
  "node_modules/@azure/msal-browser/dist/interaction_handler/SilentHandler.mjs"() {
    "use strict";
    init_index_browser();
    init_BrowserAuthError();
    init_Configuration();
    init_Authorize2();
    init_BrowserAuthErrorCodes();
  }
});

// node_modules/@azure/msal-browser/dist/interaction_client/SilentIframeClient.mjs
var SilentIframeClient;
var init_SilentIframeClient = __esm({
  "node_modules/@azure/msal-browser/dist/interaction_client/SilentIframeClient.mjs"() {
    "use strict";
    init_index_browser();
    init_StandardInteractionClient();
    init_BrowserAuthError();
    init_BrowserConstants();
    init_SilentHandler();
    init_BrowserUtils();
    init_ResponseHandler2();
    init_Authorize2();
    init_PkceGenerator();
    init_PlatformAuthProvider();
    init_BrowserCrypto();
    init_BrowserAuthErrorCodes();
    SilentIframeClient = class extends StandardInteractionClient {
      constructor(config, storageImpl, browserCrypto, logger24, eventHandler, navigationClient, apiId, performanceClient, nativeStorageImpl, platformAuthProvider, correlationId) {
        super(config, storageImpl, browserCrypto, logger24, eventHandler, navigationClient, performanceClient, platformAuthProvider, correlationId);
        this.apiId = apiId;
        this.nativeStorage = nativeStorageImpl;
      }
      /**
       * Acquires a token silently by opening a hidden iframe to the /authorize endpoint with prompt=none or prompt=no_session
       * @param request
       */
      async acquireToken(request) {
        this.performanceClient.addQueueMeasurement(PerformanceEvents.SilentIframeClientAcquireToken, request.correlationId);
        if (!request.loginHint && !request.sid && (!request.account || !request.account.username)) {
          this.logger.warning("No user hint provided. The authorization server may need more information to complete this request.");
        }
        const inputRequest = { ...request };
        if (inputRequest.prompt) {
          if (inputRequest.prompt !== PromptValue.NONE && inputRequest.prompt !== PromptValue.NO_SESSION) {
            this.logger.warning(`SilentIframeClient. Replacing invalid prompt ${inputRequest.prompt} with ${PromptValue.NONE}`);
            inputRequest.prompt = PromptValue.NONE;
          }
        } else {
          inputRequest.prompt = PromptValue.NONE;
        }
        const silentRequest = await invokeAsync(this.initializeAuthorizationRequest.bind(this), PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, this.logger, this.performanceClient, request.correlationId)(inputRequest, InteractionType.Silent);
        silentRequest.platformBroker = isPlatformAuthAllowed(this.config, this.logger, this.platformAuthProvider, silentRequest.authenticationScheme);
        preconnect(silentRequest.authority);
        if (this.config.auth.protocolMode === ProtocolMode.EAR) {
          return this.executeEarFlow(silentRequest);
        } else {
          return this.executeCodeFlow(silentRequest);
        }
      }
      /**
       * Executes auth code + PKCE flow
       * @param request
       * @returns
       */
      async executeCodeFlow(request) {
        let authClient;
        const serverTelemetryManager = this.initializeServerTelemetryManager(this.apiId);
        try {
          authClient = await invokeAsync(this.createAuthCodeClient.bind(this), PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, this.logger, this.performanceClient, request.correlationId)({
            serverTelemetryManager,
            requestAuthority: request.authority,
            requestAzureCloudOptions: request.azureCloudOptions,
            requestExtraQueryParameters: request.extraQueryParameters,
            account: request.account
          });
          return await invokeAsync(this.silentTokenHelper.bind(this), PerformanceEvents.SilentIframeClientTokenHelper, this.logger, this.performanceClient, request.correlationId)(authClient, request);
        } catch (e) {
          if (e instanceof AuthError) {
            e.setCorrelationId(this.correlationId);
            serverTelemetryManager.cacheFailedRequest(e);
          }
          if (!authClient || !(e instanceof AuthError) || e.errorCode !== BrowserConstants.INVALID_GRANT_ERROR) {
            throw e;
          }
          this.performanceClient.addFields({
            retryError: e.errorCode
          }, this.correlationId);
          return await invokeAsync(this.silentTokenHelper.bind(this), PerformanceEvents.SilentIframeClientTokenHelper, this.logger, this.performanceClient, this.correlationId)(authClient, request);
        }
      }
      /**
       * Executes EAR flow
       * @param request
       */
      async executeEarFlow(request) {
        const correlationId = request.correlationId;
        const discoveredAuthority = await invokeAsync(this.getDiscoveredAuthority.bind(this), PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority, this.logger, this.performanceClient, correlationId)({
          requestAuthority: request.authority,
          requestAzureCloudOptions: request.azureCloudOptions,
          requestExtraQueryParameters: request.extraQueryParameters,
          account: request.account
        });
        const earJwk = await invokeAsync(generateEarKey, PerformanceEvents.GenerateEarKey, this.logger, this.performanceClient, correlationId)();
        const silentRequest = {
          ...request,
          earJwk
        };
        const msalFrame = await invokeAsync(initiateEarRequest, PerformanceEvents.SilentHandlerInitiateAuthRequest, this.logger, this.performanceClient, correlationId)(this.config, discoveredAuthority, silentRequest, this.logger, this.performanceClient);
        const responseType = this.config.auth.OIDCOptions.serverResponseType;
        const responseString = await invokeAsync(monitorIframeForHash, PerformanceEvents.SilentHandlerMonitorIframeForHash, this.logger, this.performanceClient, correlationId)(msalFrame, this.config.system.iframeHashTimeout, this.config.system.pollIntervalMilliseconds, this.performanceClient, this.logger, correlationId, responseType);
        const serverParams = invoke(deserializeResponse, PerformanceEvents.DeserializeResponse, this.logger, this.performanceClient, correlationId)(responseString, responseType, this.logger);
        return invokeAsync(handleResponseEAR, PerformanceEvents.HandleResponseEar, this.logger, this.performanceClient, correlationId)(silentRequest, serverParams, this.apiId, this.config, discoveredAuthority, this.browserStorage, this.nativeStorage, this.eventHandler, this.logger, this.performanceClient, this.platformAuthProvider);
      }
      /**
       * Currently Unsupported
       */
      logout() {
        return Promise.reject(createBrowserAuthError(silentLogoutUnsupported));
      }
      /**
       * Helper which acquires an authorization code silently using a hidden iframe from given url
       * using the scopes requested as part of the id, and exchanges the code for a set of OAuth tokens.
       * @param navigateUrl
       * @param userRequestScopes
       */
      async silentTokenHelper(authClient, request) {
        const correlationId = request.correlationId;
        this.performanceClient.addQueueMeasurement(PerformanceEvents.SilentIframeClientTokenHelper, correlationId);
        const pkceCodes = await invokeAsync(generatePkceCodes, PerformanceEvents.GeneratePkceCodes, this.logger, this.performanceClient, correlationId)(this.performanceClient, this.logger, correlationId);
        const silentRequest = {
          ...request,
          codeChallenge: pkceCodes.challenge
        };
        let msalFrame;
        if (request.httpMethod === HttpMethod.POST) {
          msalFrame = await invokeAsync(initiateCodeFlowWithPost, PerformanceEvents.SilentHandlerInitiateAuthRequest, this.logger, this.performanceClient, correlationId)(this.config, authClient.authority, silentRequest, this.logger, this.performanceClient);
        } else {
          const navigateUrl = await invokeAsync(getAuthCodeRequestUrl, PerformanceEvents.GetAuthCodeUrl, this.logger, this.performanceClient, correlationId)(this.config, authClient.authority, silentRequest, this.logger, this.performanceClient);
          msalFrame = await invokeAsync(initiateCodeRequest, PerformanceEvents.SilentHandlerInitiateAuthRequest, this.logger, this.performanceClient, correlationId)(navigateUrl, this.performanceClient, this.logger, correlationId, this.config.system.navigateFrameWait);
        }
        const responseType = this.config.auth.OIDCOptions.serverResponseType;
        const responseString = await invokeAsync(monitorIframeForHash, PerformanceEvents.SilentHandlerMonitorIframeForHash, this.logger, this.performanceClient, correlationId)(msalFrame, this.config.system.iframeHashTimeout, this.config.system.pollIntervalMilliseconds, this.performanceClient, this.logger, correlationId, responseType);
        const serverParams = invoke(deserializeResponse, PerformanceEvents.DeserializeResponse, this.logger, this.performanceClient, correlationId)(responseString, responseType, this.logger);
        return invokeAsync(handleResponseCode, PerformanceEvents.HandleResponseCode, this.logger, this.performanceClient, correlationId)(request, serverParams, pkceCodes.verifier, this.apiId, this.config, authClient, this.browserStorage, this.nativeStorage, this.eventHandler, this.logger, this.performanceClient, this.platformAuthProvider);
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/interaction_client/SilentRefreshClient.mjs
var SilentRefreshClient;
var init_SilentRefreshClient = __esm({
  "node_modules/@azure/msal-browser/dist/interaction_client/SilentRefreshClient.mjs"() {
    "use strict";
    init_StandardInteractionClient();
    init_index_browser();
    init_BrowserConstants();
    init_BrowserAuthError();
    init_RequestHelpers();
    init_BrowserAuthErrorCodes();
    SilentRefreshClient = class extends StandardInteractionClient {
      /**
       * Exchanges the refresh token for new tokens
       * @param request
       */
      async acquireToken(request) {
        this.performanceClient.addQueueMeasurement(PerformanceEvents.SilentRefreshClientAcquireToken, request.correlationId);
        const baseRequest = await invokeAsync(initializeBaseRequest, PerformanceEvents.InitializeBaseRequest, this.logger, this.performanceClient, request.correlationId)(request, this.config, this.performanceClient, this.logger);
        const silentRequest = {
          ...request,
          ...baseRequest
        };
        if (request.redirectUri) {
          silentRequest.redirectUri = this.getRedirectUri(request.redirectUri);
        }
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenSilent_silentFlow);
        const refreshTokenClient = await this.createRefreshTokenClient({
          serverTelemetryManager,
          authorityUrl: silentRequest.authority,
          azureCloudOptions: silentRequest.azureCloudOptions,
          account: silentRequest.account
        });
        return invokeAsync(refreshTokenClient.acquireTokenByRefreshToken.bind(refreshTokenClient), PerformanceEvents.RefreshTokenClientAcquireTokenByRefreshToken, this.logger, this.performanceClient, request.correlationId)(silentRequest).catch((e) => {
          e.setCorrelationId(this.correlationId);
          serverTelemetryManager.cacheFailedRequest(e);
          throw e;
        });
      }
      /**
       * Currently Unsupported
       */
      logout() {
        return Promise.reject(createBrowserAuthError(silentLogoutUnsupported));
      }
      /**
       * Creates a Refresh Client with the given authority, or the default authority.
       * @param params {
       *         serverTelemetryManager: ServerTelemetryManager;
       *         authorityUrl?: string;
       *         azureCloudOptions?: AzureCloudOptions;
       *         extraQueryParams?: StringDict;
       *         account?: AccountInfo;
       *        }
       */
      async createRefreshTokenClient(params) {
        const clientConfig = await invokeAsync(this.getClientConfiguration.bind(this), PerformanceEvents.StandardInteractionClientGetClientConfiguration, this.logger, this.performanceClient, this.correlationId)({
          serverTelemetryManager: params.serverTelemetryManager,
          requestAuthority: params.authorityUrl,
          requestAzureCloudOptions: params.azureCloudOptions,
          requestExtraQueryParameters: params.extraQueryParameters,
          account: params.account
        });
        return new RefreshTokenClient(clientConfig, this.performanceClient);
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/cache/TokenCache.mjs
var TokenCache;
var init_TokenCache = __esm({
  "node_modules/@azure/msal-browser/dist/cache/TokenCache.mjs"() {
    "use strict";
    init_index_browser();
    init_BrowserAuthError();
    init_Base64Decode();
    init_BrowserCrypto();
    init_BrowserAuthErrorCodes();
    TokenCache = class {
      constructor(configuration, storage, logger24, cryptoObj) {
        this.isBrowserEnvironment = typeof window !== "undefined";
        this.config = configuration;
        this.storage = storage;
        this.logger = logger24;
        this.cryptoObj = cryptoObj;
      }
      // Move getAllAccounts here and cache utility APIs
      /**
       * API to load tokens to msal-browser cache.
       * @param request
       * @param response
       * @param options
       * @returns `AuthenticationResult` for the response that was loaded.
       */
      async loadExternalTokens(request, response, options) {
        if (!this.isBrowserEnvironment) {
          throw createBrowserAuthError(nonBrowserEnvironment);
        }
        const correlationId = request.correlationId || createNewGuid();
        const idTokenClaims = response.id_token ? AuthToken_exports.extractTokenClaims(response.id_token, base64Decode) : void 0;
        const authorityOptions = {
          protocolMode: this.config.auth.protocolMode,
          knownAuthorities: this.config.auth.knownAuthorities,
          cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,
          authorityMetadata: this.config.auth.authorityMetadata,
          skipAuthorityMetadataCache: this.config.auth.skipAuthorityMetadataCache
        };
        const authority = request.authority ? new Authority(Authority.generateAuthority(request.authority, request.azureCloudOptions), this.config.system.networkClient, this.storage, authorityOptions, this.logger, request.correlationId || createNewGuid()) : void 0;
        const cacheRecordAccount = await this.loadAccount(request, options.clientInfo || response.client_info || "", correlationId, idTokenClaims, authority);
        const idToken = await this.loadIdToken(response, cacheRecordAccount.homeAccountId, cacheRecordAccount.environment, cacheRecordAccount.realm, correlationId);
        const accessToken = await this.loadAccessToken(request, response, cacheRecordAccount.homeAccountId, cacheRecordAccount.environment, cacheRecordAccount.realm, options, correlationId);
        const refreshToken = await this.loadRefreshToken(response, cacheRecordAccount.homeAccountId, cacheRecordAccount.environment, correlationId);
        return this.generateAuthenticationResult(request, {
          account: cacheRecordAccount,
          idToken,
          accessToken,
          refreshToken
        }, idTokenClaims, authority);
      }
      /**
       * Helper function to load account to msal-browser cache
       * @param idToken
       * @param environment
       * @param clientInfo
       * @param authorityType
       * @param requestHomeAccountId
       * @returns `AccountEntity`
       */
      async loadAccount(request, clientInfo, correlationId, idTokenClaims, authority) {
        this.logger.verbose("TokenCache - loading account");
        if (request.account) {
          const accountEntity = AccountEntity.createFromAccountInfo(request.account);
          await this.storage.setAccount(accountEntity, correlationId);
          return accountEntity;
        } else if (!authority || !clientInfo && !idTokenClaims) {
          this.logger.error("TokenCache - if an account is not provided on the request, authority and either clientInfo or idToken must be provided instead.");
          throw createBrowserAuthError(unableToLoadToken);
        }
        const homeAccountId = AccountEntity.generateHomeAccountId(clientInfo, authority.authorityType, this.logger, this.cryptoObj, idTokenClaims);
        const claimsTenantId = idTokenClaims == null ? void 0 : idTokenClaims.tid;
        const cachedAccount = buildAccountToCache(
          this.storage,
          authority,
          homeAccountId,
          base64Decode,
          correlationId,
          idTokenClaims,
          clientInfo,
          authority.hostnameAndPort,
          claimsTenantId,
          void 0,
          // authCodePayload
          void 0,
          // nativeAccountId
          this.logger
        );
        await this.storage.setAccount(cachedAccount, correlationId);
        return cachedAccount;
      }
      /**
       * Helper function to load id tokens to msal-browser cache
       * @param idToken
       * @param homeAccountId
       * @param environment
       * @param tenantId
       * @returns `IdTokenEntity`
       */
      async loadIdToken(response, homeAccountId, environment, tenantId, correlationId) {
        if (!response.id_token) {
          this.logger.verbose("TokenCache - no id token found in response");
          return null;
        }
        this.logger.verbose("TokenCache - loading id token");
        const idTokenEntity = CacheHelpers_exports.createIdTokenEntity(homeAccountId, environment, response.id_token, this.config.auth.clientId, tenantId);
        await this.storage.setIdTokenCredential(idTokenEntity, correlationId);
        return idTokenEntity;
      }
      /**
       * Helper function to load access tokens to msal-browser cache
       * @param request
       * @param response
       * @param homeAccountId
       * @param environment
       * @param tenantId
       * @returns `AccessTokenEntity`
       */
      async loadAccessToken(request, response, homeAccountId, environment, tenantId, options, correlationId) {
        if (!response.access_token) {
          this.logger.verbose("TokenCache - no access token found in response");
          return null;
        } else if (!response.expires_in) {
          this.logger.error("TokenCache - no expiration set on the access token. Cannot add it to the cache.");
          return null;
        } else if (!response.scope && (!request.scopes || !request.scopes.length)) {
          this.logger.error("TokenCache - scopes not specified in the request or response. Cannot add token to the cache.");
          return null;
        }
        this.logger.verbose("TokenCache - loading access token");
        const scopes = response.scope ? ScopeSet.fromString(response.scope) : new ScopeSet(request.scopes);
        const expiresOn = options.expiresOn || response.expires_in + TimeUtils_exports.nowSeconds();
        const extendedExpiresOn = options.extendedExpiresOn || (response.ext_expires_in || response.expires_in) + TimeUtils_exports.nowSeconds();
        const accessTokenEntity = CacheHelpers_exports.createAccessTokenEntity(homeAccountId, environment, response.access_token, this.config.auth.clientId, tenantId, scopes.printScopes(), expiresOn, extendedExpiresOn, base64Decode);
        await this.storage.setAccessTokenCredential(accessTokenEntity, correlationId);
        return accessTokenEntity;
      }
      /**
       * Helper function to load refresh tokens to msal-browser cache
       * @param request
       * @param response
       * @param homeAccountId
       * @param environment
       * @returns `RefreshTokenEntity`
       */
      async loadRefreshToken(response, homeAccountId, environment, correlationId) {
        if (!response.refresh_token) {
          this.logger.verbose("TokenCache - no refresh token found in response");
          return null;
        }
        this.logger.verbose("TokenCache - loading refresh token");
        const refreshTokenEntity = CacheHelpers_exports.createRefreshTokenEntity(
          homeAccountId,
          environment,
          response.refresh_token,
          this.config.auth.clientId,
          response.foci,
          void 0,
          // userAssertionHash
          response.refresh_token_expires_in
        );
        await this.storage.setRefreshTokenCredential(refreshTokenEntity, correlationId);
        return refreshTokenEntity;
      }
      /**
       * Helper function to generate an `AuthenticationResult` for the result.
       * @param request
       * @param idTokenObj
       * @param cacheRecord
       * @param authority
       * @returns `AuthenticationResult`
       */
      generateAuthenticationResult(request, cacheRecord, idTokenClaims, authority) {
        var _a3, _b2, _c2;
        let accessToken = "";
        let responseScopes = [];
        let expiresOn = null;
        let extExpiresOn;
        if (cacheRecord == null ? void 0 : cacheRecord.accessToken) {
          accessToken = cacheRecord.accessToken.secret;
          responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();
          expiresOn = TimeUtils_exports.toDateFromSeconds(cacheRecord.accessToken.expiresOn);
          extExpiresOn = TimeUtils_exports.toDateFromSeconds(cacheRecord.accessToken.extendedExpiresOn);
        }
        const accountEntity = cacheRecord.account;
        return {
          authority: authority ? authority.canonicalAuthority : "",
          uniqueId: cacheRecord.account.localAccountId,
          tenantId: cacheRecord.account.realm,
          scopes: responseScopes,
          account: accountEntity.getAccountInfo(),
          idToken: ((_a3 = cacheRecord.idToken) == null ? void 0 : _a3.secret) || "",
          idTokenClaims: idTokenClaims || {},
          accessToken,
          fromCache: true,
          expiresOn,
          correlationId: request.correlationId || "",
          requestId: "",
          extExpiresOn,
          familyId: ((_b2 = cacheRecord.refreshToken) == null ? void 0 : _b2.familyId) || "",
          tokenType: ((_c2 = cacheRecord == null ? void 0 : cacheRecord.accessToken) == null ? void 0 : _c2.tokenType) || "",
          state: request.state || "",
          cloudGraphHostName: accountEntity.cloudGraphHostName || "",
          msGraphHost: accountEntity.msGraphHost || "",
          fromNativeBroker: false
        };
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/interaction_client/HybridSpaAuthorizationCodeClient.mjs
var HybridSpaAuthorizationCodeClient;
var init_HybridSpaAuthorizationCodeClient = __esm({
  "node_modules/@azure/msal-browser/dist/interaction_client/HybridSpaAuthorizationCodeClient.mjs"() {
    "use strict";
    init_index_browser();
    HybridSpaAuthorizationCodeClient = class extends AuthorizationCodeClient {
      constructor(config) {
        super(config);
        this.includeRedirectUri = false;
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/interaction_client/SilentAuthCodeClient.mjs
var SilentAuthCodeClient;
var init_SilentAuthCodeClient = __esm({
  "node_modules/@azure/msal-browser/dist/interaction_client/SilentAuthCodeClient.mjs"() {
    "use strict";
    init_index_browser();
    init_StandardInteractionClient();
    init_BrowserAuthError();
    init_BrowserConstants();
    init_HybridSpaAuthorizationCodeClient();
    init_InteractionHandler();
    init_BrowserAuthErrorCodes();
    SilentAuthCodeClient = class extends StandardInteractionClient {
      constructor(config, storageImpl, browserCrypto, logger24, eventHandler, navigationClient, apiId, performanceClient, platformAuthProvider, correlationId) {
        super(config, storageImpl, browserCrypto, logger24, eventHandler, navigationClient, performanceClient, platformAuthProvider, correlationId);
        this.apiId = apiId;
      }
      /**
       * Acquires a token silently by redeeming an authorization code against the /token endpoint
       * @param request
       */
      async acquireToken(request) {
        if (!request.code) {
          throw createBrowserAuthError(authCodeRequired);
        }
        const silentRequest = await invokeAsync(this.initializeAuthorizationRequest.bind(this), PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, this.logger, this.performanceClient, request.correlationId)(request, InteractionType.Silent);
        const serverTelemetryManager = this.initializeServerTelemetryManager(this.apiId);
        try {
          const authCodeRequest = {
            ...silentRequest,
            code: request.code
          };
          const clientConfig = await invokeAsync(this.getClientConfiguration.bind(this), PerformanceEvents.StandardInteractionClientGetClientConfiguration, this.logger, this.performanceClient, request.correlationId)({
            serverTelemetryManager,
            requestAuthority: silentRequest.authority,
            requestAzureCloudOptions: silentRequest.azureCloudOptions,
            requestExtraQueryParameters: silentRequest.extraQueryParameters,
            account: silentRequest.account
          });
          const authClient = new HybridSpaAuthorizationCodeClient(clientConfig);
          this.logger.verbose("Auth code client created");
          const interactionHandler = new InteractionHandler(authClient, this.browserStorage, authCodeRequest, this.logger, this.performanceClient);
          return await invokeAsync(interactionHandler.handleCodeResponseFromServer.bind(interactionHandler), PerformanceEvents.HandleCodeResponseFromServer, this.logger, this.performanceClient, request.correlationId)({
            code: request.code,
            msgraph_host: request.msGraphHost,
            cloud_graph_host_name: request.cloudGraphHostName,
            cloud_instance_host_name: request.cloudInstanceHostName
          }, silentRequest, false);
        } catch (e) {
          if (e instanceof AuthError) {
            e.setCorrelationId(this.correlationId);
            serverTelemetryManager.cacheFailedRequest(e);
          }
          throw e;
        }
      }
      /**
       * Currently Unsupported
       */
      logout() {
        return Promise.reject(createBrowserAuthError(silentLogoutUnsupported));
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/utils/MsalFrameStatsUtils.mjs
function collectInstanceStats(currentClientId, performanceEvent, logger24) {
  var _a3;
  const frameInstances = (
    // @ts-ignore
    ((_a3 = window.msal) == null ? void 0 : _a3.clientIds) || []
  );
  const msalInstanceCount = frameInstances.length;
  const sameClientIdInstanceCount = frameInstances.filter((i) => i === currentClientId).length;
  if (sameClientIdInstanceCount > 1) {
    logger24.warning("There is already an instance of MSAL.js in the window with the same client id.");
  }
  performanceEvent.add({
    msalInstanceCount,
    sameClientIdInstanceCount
  });
}
var init_MsalFrameStatsUtils = __esm({
  "node_modules/@azure/msal-browser/dist/utils/MsalFrameStatsUtils.mjs"() {
    "use strict";
  }
});

// node_modules/@azure/msal-browser/dist/controllers/StandardController.mjs
function getAccountType(account) {
  const idTokenClaims = account == null ? void 0 : account.idTokenClaims;
  if ((idTokenClaims == null ? void 0 : idTokenClaims.tfp) || (idTokenClaims == null ? void 0 : idTokenClaims.acr)) {
    return "B2C";
  }
  if (!(idTokenClaims == null ? void 0 : idTokenClaims.tid)) {
    return void 0;
  } else if ((idTokenClaims == null ? void 0 : idTokenClaims.tid) === "9188040d-6c67-4c5b-b112-36a304b66dad") {
    return "MSA";
  }
  return "AAD";
}
function preflightCheck2(initialized, performanceEvent) {
  try {
    preflightCheck(initialized);
  } catch (e) {
    performanceEvent.end({ success: false }, e);
    throw e;
  }
}
function checkIfRefreshTokenErrorCanBeResolvedSilently(refreshTokenError, cacheLookupPolicy) {
  const noInteractionRequired = !(refreshTokenError instanceof InteractionRequiredAuthError && // For refresh token errors, bad_token does not always require interaction (silently resolvable)
  refreshTokenError.subError !== InteractionRequiredAuthErrorCodes_exports.badToken);
  const refreshTokenRefreshRequired = refreshTokenError.errorCode === BrowserConstants.INVALID_GRANT_ERROR || refreshTokenError.errorCode === ClientAuthErrorCodes_exports.tokenRefreshRequired;
  const isSilentlyResolvable = noInteractionRequired && refreshTokenRefreshRequired || refreshTokenError.errorCode === InteractionRequiredAuthErrorCodes_exports.noTokensFound || refreshTokenError.errorCode === InteractionRequiredAuthErrorCodes_exports.refreshTokenExpired;
  const tryIframeRenewal = iFrameRenewalPolicies.includes(cacheLookupPolicy);
  return isSilentlyResolvable && tryIframeRenewal;
}
var StandardController;
var init_StandardController = __esm({
  "node_modules/@azure/msal-browser/dist/controllers/StandardController.mjs"() {
    "use strict";
    init_CryptoOps();
    init_index_browser();
    init_BrowserCacheManager();
    init_AccountManager();
    init_BrowserConstants();
    init_BrowserUtils();
    init_EventType();
    init_EventHandler();
    init_PopupClient();
    init_RedirectClient();
    init_SilentIframeClient();
    init_SilentRefreshClient();
    init_TokenCache();
    init_PlatformAuthInteractionClient();
    init_NativeAuthError();
    init_SilentCacheClient();
    init_SilentAuthCodeClient();
    init_BrowserAuthError();
    init_BrowserCrypto();
    init_RequestHelpers();
    init_PkceGenerator();
    init_PlatformAuthProvider();
    init_MsalFrameStatsUtils();
    init_BrowserAuthErrorCodes();
    StandardController = class _StandardController {
      /**
       * @constructor
       * Constructor for the PublicClientApplication used to instantiate the PublicClientApplication object
       *
       * Important attributes in the Configuration object for auth are:
       * - clientID: the application ID of your application. You can obtain one by registering your application with our Application registration portal : https://portal.azure.com/#blade/Microsoft_AAD_IAM/ActiveDirectoryMenuBlade/RegisteredAppsPreview
       * - authority: the authority URL for your application.
       * - redirect_uri: the uri of your application registered in the portal.
       *
       * In Azure AD, authority is a URL indicating the Azure active directory that MSAL uses to obtain tokens.
       * It is of the form https://login.microsoftonline.com/{Enter_the_Tenant_Info_Here}
       * If your application supports Accounts in one organizational directory, replace "Enter_the_Tenant_Info_Here" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).
       * If your application supports Accounts in any organizational directory, replace "Enter_the_Tenant_Info_Here" value with organizations.
       * If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace "Enter_the_Tenant_Info_Here" value with common.
       * To restrict support to Personal Microsoft accounts only, replace "Enter_the_Tenant_Info_Here" value with consumers.
       *
       * In Azure B2C, authority is of the form https://{instance}/tfp/{tenant}/{policyName}/
       * Full B2C functionality will be available in this library in future versions.
       *
       * @param configuration Object for the MSAL PublicClientApplication instance
       */
      constructor(operatingContext) {
        this.operatingContext = operatingContext;
        this.isBrowserEnvironment = this.operatingContext.isBrowserEnvironment();
        this.config = operatingContext.getConfig();
        this.initialized = false;
        this.logger = this.operatingContext.getLogger();
        this.networkClient = this.config.system.networkClient;
        this.navigationClient = this.config.system.navigationClient;
        this.redirectResponse = /* @__PURE__ */ new Map();
        this.hybridAuthCodeResponses = /* @__PURE__ */ new Map();
        this.performanceClient = this.config.telemetry.client;
        this.browserCrypto = this.isBrowserEnvironment ? new CryptoOps(this.logger, this.performanceClient) : DEFAULT_CRYPTO_IMPLEMENTATION;
        this.eventHandler = new EventHandler(this.logger);
        this.browserStorage = this.isBrowserEnvironment ? new BrowserCacheManager(this.config.auth.clientId, this.config.cache, this.browserCrypto, this.logger, this.performanceClient, this.eventHandler, buildStaticAuthorityOptions(this.config.auth)) : DEFAULT_BROWSER_CACHE_MANAGER(this.config.auth.clientId, this.logger, this.performanceClient, this.eventHandler);
        const nativeCacheOptions = {
          cacheLocation: BrowserCacheLocation.MemoryStorage,
          temporaryCacheLocation: BrowserCacheLocation.MemoryStorage,
          storeAuthStateInCookie: false,
          secureCookies: false,
          cacheMigrationEnabled: false,
          claimsBasedCachingEnabled: false
        };
        this.nativeInternalStorage = new BrowserCacheManager(this.config.auth.clientId, nativeCacheOptions, this.browserCrypto, this.logger, this.performanceClient, this.eventHandler);
        this.tokenCache = new TokenCache(this.config, this.browserStorage, this.logger, this.browserCrypto);
        this.activeSilentTokenRequests = /* @__PURE__ */ new Map();
        this.trackPageVisibility = this.trackPageVisibility.bind(this);
        this.trackPageVisibilityWithMeasurement = this.trackPageVisibilityWithMeasurement.bind(this);
      }
      static async createController(operatingContext, request) {
        const controller = new _StandardController(operatingContext);
        await controller.initialize(request);
        return controller;
      }
      trackPageVisibility(correlationId) {
        if (!correlationId) {
          return;
        }
        this.logger.info("Perf: Visibility change detected");
        this.performanceClient.incrementFields({ visibilityChangeCount: 1 }, correlationId);
      }
      /**
       * Initializer function to perform async startup tasks such as connecting to WAM extension
       * @param request {?InitializeApplicationRequest} correlation id
       */
      async initialize(request, isBroker) {
        this.logger.trace("initialize called");
        if (this.initialized) {
          this.logger.info("initialize has already been called, exiting early.");
          return;
        }
        if (!this.isBrowserEnvironment) {
          this.logger.info("in non-browser environment, exiting early.");
          this.initialized = true;
          this.eventHandler.emitEvent(EventType.INITIALIZE_END);
          return;
        }
        const initCorrelationId = (request == null ? void 0 : request.correlationId) || this.getRequestCorrelationId();
        const allowPlatformBroker = this.config.system.allowPlatformBroker;
        const initMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.InitializeClientApplication, initCorrelationId);
        this.eventHandler.emitEvent(EventType.INITIALIZE_START);
        if (!isBroker) {
          try {
            this.logMultipleInstances(initMeasurement);
          } catch {
          }
        }
        await invokeAsync(this.browserStorage.initialize.bind(this.browserStorage), PerformanceEvents.InitializeCache, this.logger, this.performanceClient, initCorrelationId)(initCorrelationId);
        if (allowPlatformBroker) {
          try {
            this.platformAuthProvider = await getPlatformAuthProvider(this.logger, this.performanceClient, initCorrelationId, this.config.system.nativeBrokerHandshakeTimeout);
          } catch (e) {
            this.logger.verbose(e);
          }
        }
        if (!this.config.cache.claimsBasedCachingEnabled) {
          this.logger.verbose("Claims-based caching is disabled. Clearing the previous cache with claims");
          invoke(this.browserStorage.clearTokensAndKeysWithClaims.bind(this.browserStorage), PerformanceEvents.ClearTokensAndKeysWithClaims, this.logger, this.performanceClient, initCorrelationId)(initCorrelationId);
        }
        this.config.system.asyncPopups && await this.preGeneratePkceCodes(initCorrelationId);
        this.initialized = true;
        this.eventHandler.emitEvent(EventType.INITIALIZE_END);
        initMeasurement.end({
          allowPlatformBroker,
          success: true
        });
      }
      // #region Redirect Flow
      /**
       * Event handler function which allows users to fire events after the PublicClientApplication object
       * has loaded during redirect flows. This should be invoked on all page loads involved in redirect
       * auth flows.
       * @param hash Hash to process. Defaults to the current value of window.location.hash. Only needs to be provided explicitly if the response to be handled is not contained in the current value.
       * @returns Token response or null. If the return value is null, then no auth redirect was detected.
       */
      async handleRedirectPromise(hash) {
        this.logger.verbose("handleRedirectPromise called");
        blockAPICallsBeforeInitialize(this.initialized);
        if (this.isBrowserEnvironment) {
          const redirectResponseKey = hash || "";
          let response = this.redirectResponse.get(redirectResponseKey);
          if (typeof response === "undefined") {
            response = this.handleRedirectPromiseInternal(hash);
            this.redirectResponse.set(redirectResponseKey, response);
            this.logger.verbose("handleRedirectPromise has been called for the first time, storing the promise");
          } else {
            this.logger.verbose("handleRedirectPromise has been called previously, returning the result from the first call");
          }
          return response;
        }
        this.logger.verbose("handleRedirectPromise returns null, not browser environment");
        return null;
      }
      /**
       * The internal details of handleRedirectPromise. This is separated out to a helper to allow handleRedirectPromise to memoize requests
       * @param hash
       * @returns
       */
      async handleRedirectPromiseInternal(hash) {
        var _a3;
        if (!this.browserStorage.isInteractionInProgress(true)) {
          this.logger.info("handleRedirectPromise called but there is no interaction in progress, returning null.");
          return null;
        }
        const interactionType = (_a3 = this.browserStorage.getInteractionInProgress()) == null ? void 0 : _a3.type;
        if (interactionType === INTERACTION_TYPE.SIGNOUT) {
          this.logger.verbose("handleRedirectPromise removing interaction_in_progress flag and returning null after sign-out");
          this.browserStorage.setInteractionInProgress(false);
          return Promise.resolve(null);
        }
        const loggedInAccounts = this.getAllAccounts();
        const platformBrokerRequest = this.browserStorage.getCachedNativeRequest();
        const useNative = platformBrokerRequest && this.platformAuthProvider && !hash;
        let rootMeasurement;
        this.eventHandler.emitEvent(EventType.HANDLE_REDIRECT_START, InteractionType.Redirect);
        let redirectResponse;
        try {
          if (useNative && this.platformAuthProvider) {
            rootMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenRedirect, (platformBrokerRequest == null ? void 0 : platformBrokerRequest.correlationId) || "");
            this.logger.trace("handleRedirectPromise - acquiring token from native platform");
            const nativeClient = new PlatformAuthInteractionClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, ApiId.handleRedirectPromise, this.performanceClient, this.platformAuthProvider, platformBrokerRequest.accountId, this.nativeInternalStorage, platformBrokerRequest.correlationId);
            redirectResponse = invokeAsync(nativeClient.handleRedirectPromise.bind(nativeClient), PerformanceEvents.HandleNativeRedirectPromiseMeasurement, this.logger, this.performanceClient, rootMeasurement.event.correlationId)(this.performanceClient, rootMeasurement.event.correlationId);
          } else {
            const [standardRequest, codeVerifier] = this.browserStorage.getCachedRequest();
            const correlationId = standardRequest.correlationId;
            rootMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenRedirect, correlationId);
            this.logger.trace("handleRedirectPromise - acquiring token from web flow");
            const redirectClient = this.createRedirectClient(correlationId);
            redirectResponse = invokeAsync(redirectClient.handleRedirectPromise.bind(redirectClient), PerformanceEvents.HandleRedirectPromiseMeasurement, this.logger, this.performanceClient, rootMeasurement.event.correlationId)(hash, standardRequest, codeVerifier, rootMeasurement);
          }
        } catch (e) {
          this.browserStorage.resetRequestCache();
          throw e;
        }
        return redirectResponse.then((result) => {
          if (result) {
            this.browserStorage.resetRequestCache();
            const isLoggingIn = loggedInAccounts.length < this.getAllAccounts().length;
            if (isLoggingIn) {
              this.eventHandler.emitEvent(EventType.LOGIN_SUCCESS, InteractionType.Redirect, result);
              this.logger.verbose("handleRedirectResponse returned result, login success");
            } else {
              this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Redirect, result);
              this.logger.verbose("handleRedirectResponse returned result, acquire token success");
            }
            rootMeasurement.end({
              success: true,
              accountType: getAccountType(result.account)
            });
          } else {
            if (rootMeasurement.event.errorCode) {
              rootMeasurement.end({ success: false });
            } else {
              rootMeasurement.discard();
            }
          }
          this.eventHandler.emitEvent(EventType.HANDLE_REDIRECT_END, InteractionType.Redirect);
          return result;
        }).catch((e) => {
          this.browserStorage.resetRequestCache();
          const eventError = e;
          if (loggedInAccounts.length > 0) {
            this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Redirect, null, eventError);
          } else {
            this.eventHandler.emitEvent(EventType.LOGIN_FAILURE, InteractionType.Redirect, null, eventError);
          }
          this.eventHandler.emitEvent(EventType.HANDLE_REDIRECT_END, InteractionType.Redirect);
          rootMeasurement.end({
            success: false
          }, eventError);
          throw e;
        });
      }
      /**
       * Use when you want to obtain an access_token for your API by redirecting the user's browser window to the authorization endpoint. This function redirects
       * the page, so any code that follows this function will not execute.
       *
       * IMPORTANT: It is NOT recommended to have code that is dependent on the resolution of the Promise. This function will navigate away from the current
       * browser window. It currently returns a Promise in order to reflect the asynchronous nature of the code running in this function.
       *
       * @param request
       */
      async acquireTokenRedirect(request) {
        const correlationId = this.getRequestCorrelationId(request);
        this.logger.verbose("acquireTokenRedirect called", correlationId);
        const atrMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenPreRedirect, correlationId);
        atrMeasurement.add({
          accountType: getAccountType(request.account),
          scenarioId: request.scenarioId
        });
        const onRedirectNavigateCb = request.onRedirectNavigate;
        if (onRedirectNavigateCb) {
          request.onRedirectNavigate = (url) => {
            const navigate = typeof onRedirectNavigateCb === "function" ? onRedirectNavigateCb(url) : void 0;
            if (navigate !== false) {
              atrMeasurement.end({ success: true });
            } else {
              atrMeasurement.discard();
            }
            return navigate;
          };
        } else {
          const configOnRedirectNavigateCb = this.config.auth.onRedirectNavigate;
          this.config.auth.onRedirectNavigate = (url) => {
            const navigate = typeof configOnRedirectNavigateCb === "function" ? configOnRedirectNavigateCb(url) : void 0;
            if (navigate !== false) {
              atrMeasurement.end({ success: true });
            } else {
              atrMeasurement.discard();
            }
            return navigate;
          };
        }
        const isLoggedIn = this.getAllAccounts().length > 0;
        try {
          redirectPreflightCheck(this.initialized, this.config);
          this.browserStorage.setInteractionInProgress(true, INTERACTION_TYPE.SIGNIN);
          if (isLoggedIn) {
            this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_START, InteractionType.Redirect, request);
          } else {
            this.eventHandler.emitEvent(EventType.LOGIN_START, InteractionType.Redirect, request);
          }
          let result;
          if (this.platformAuthProvider && this.canUsePlatformBroker(request)) {
            const nativeClient = new PlatformAuthInteractionClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, ApiId.acquireTokenRedirect, this.performanceClient, this.platformAuthProvider, this.getNativeAccountId(request), this.nativeInternalStorage, correlationId);
            result = nativeClient.acquireTokenRedirect(request, atrMeasurement).catch((e) => {
              if (e instanceof NativeAuthError && isFatalNativeAuthError(e)) {
                this.platformAuthProvider = void 0;
                const redirectClient = this.createRedirectClient(correlationId);
                return redirectClient.acquireToken(request);
              } else if (e instanceof InteractionRequiredAuthError) {
                this.logger.verbose("acquireTokenRedirect - Resolving interaction required error thrown by native broker by falling back to web flow");
                const redirectClient = this.createRedirectClient(correlationId);
                return redirectClient.acquireToken(request);
              }
              throw e;
            });
          } else {
            const redirectClient = this.createRedirectClient(correlationId);
            result = redirectClient.acquireToken(request);
          }
          return await result;
        } catch (e) {
          this.browserStorage.resetRequestCache();
          atrMeasurement.end({ success: false }, e);
          if (isLoggedIn) {
            this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Redirect, null, e);
          } else {
            this.eventHandler.emitEvent(EventType.LOGIN_FAILURE, InteractionType.Redirect, null, e);
          }
          throw e;
        }
      }
      // #endregion
      // #region Popup Flow
      /**
       * Use when you want to obtain an access_token for your API via opening a popup window in the user's browser
       *
       * @param request
       *
       * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.
       */
      acquireTokenPopup(request) {
        const correlationId = this.getRequestCorrelationId(request);
        const atPopupMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenPopup, correlationId);
        atPopupMeasurement.add({
          scenarioId: request.scenarioId,
          accountType: getAccountType(request.account)
        });
        try {
          this.logger.verbose("acquireTokenPopup called", correlationId);
          preflightCheck2(this.initialized, atPopupMeasurement);
          this.browserStorage.setInteractionInProgress(true, INTERACTION_TYPE.SIGNIN);
        } catch (e) {
          return Promise.reject(e);
        }
        const loggedInAccounts = this.getAllAccounts();
        if (loggedInAccounts.length > 0) {
          this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_START, InteractionType.Popup, request);
        } else {
          this.eventHandler.emitEvent(EventType.LOGIN_START, InteractionType.Popup, request);
        }
        let result;
        const pkce = this.getPreGeneratedPkceCodes(correlationId);
        if (this.canUsePlatformBroker(request)) {
          result = this.acquireTokenNative({
            ...request,
            correlationId
          }, ApiId.acquireTokenPopup).then((response) => {
            atPopupMeasurement.end({
              success: true,
              isNativeBroker: true,
              accountType: getAccountType(response.account)
            });
            return response;
          }).catch((e) => {
            if (e instanceof NativeAuthError && isFatalNativeAuthError(e)) {
              this.platformAuthProvider = void 0;
              const popupClient = this.createPopupClient(correlationId);
              return popupClient.acquireToken(request, pkce);
            } else if (e instanceof InteractionRequiredAuthError) {
              this.logger.verbose("acquireTokenPopup - Resolving interaction required error thrown by native broker by falling back to web flow");
              const popupClient = this.createPopupClient(correlationId);
              return popupClient.acquireToken(request, pkce);
            }
            throw e;
          });
        } else {
          const popupClient = this.createPopupClient(correlationId);
          result = popupClient.acquireToken(request, pkce);
        }
        return result.then((result2) => {
          const isLoggingIn = loggedInAccounts.length < this.getAllAccounts().length;
          if (isLoggingIn) {
            this.eventHandler.emitEvent(EventType.LOGIN_SUCCESS, InteractionType.Popup, result2);
          } else {
            this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Popup, result2);
          }
          atPopupMeasurement.end({
            success: true,
            accessTokenSize: result2.accessToken.length,
            idTokenSize: result2.idToken.length,
            accountType: getAccountType(result2.account)
          });
          return result2;
        }).catch((e) => {
          if (loggedInAccounts.length > 0) {
            this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Popup, null, e);
          } else {
            this.eventHandler.emitEvent(EventType.LOGIN_FAILURE, InteractionType.Popup, null, e);
          }
          atPopupMeasurement.end({
            success: false
          }, e);
          return Promise.reject(e);
        }).finally(async () => {
          this.browserStorage.setInteractionInProgress(false);
          if (this.config.system.asyncPopups) {
            await this.preGeneratePkceCodes(correlationId);
          }
        });
      }
      trackPageVisibilityWithMeasurement() {
        const measurement = this.ssoSilentMeasurement || this.acquireTokenByCodeAsyncMeasurement;
        if (!measurement) {
          return;
        }
        this.logger.info("Perf: Visibility change detected in ", measurement.event.name);
        measurement.increment({
          visibilityChangeCount: 1
        });
      }
      // #endregion
      // #region Silent Flow
      /**
       * This function uses a hidden iframe to fetch an authorization code from the eSTS. There are cases where this may not work:
       * - Any browser using a form of Intelligent Tracking Prevention
       * - If there is not an established session with the service
       *
       * In these cases, the request must be done inside a popup or full frame redirect.
       *
       * For the cases where interaction is required, you cannot send a request with prompt=none.
       *
       * If your refresh token has expired, you can use this function to fetch a new set of tokens silently as long as
       * you session on the server still exists.
       * @param request {@link SsoSilentRequest}
       *
       * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.
       */
      async ssoSilent(request) {
        var _a3, _b2;
        const correlationId = this.getRequestCorrelationId(request);
        const validRequest = {
          ...request,
          // will be PromptValue.NONE or PromptValue.NO_SESSION
          prompt: request.prompt,
          correlationId
        };
        this.ssoSilentMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.SsoSilent, correlationId);
        (_a3 = this.ssoSilentMeasurement) == null ? void 0 : _a3.add({
          scenarioId: request.scenarioId,
          accountType: getAccountType(request.account)
        });
        preflightCheck2(this.initialized, this.ssoSilentMeasurement);
        (_b2 = this.ssoSilentMeasurement) == null ? void 0 : _b2.increment({
          visibilityChangeCount: 0
        });
        document.addEventListener("visibilitychange", this.trackPageVisibilityWithMeasurement);
        this.logger.verbose("ssoSilent called", correlationId);
        this.eventHandler.emitEvent(EventType.SSO_SILENT_START, InteractionType.Silent, validRequest);
        let result;
        if (this.canUsePlatformBroker(validRequest)) {
          result = this.acquireTokenNative(validRequest, ApiId.ssoSilent).catch((e) => {
            if (e instanceof NativeAuthError && isFatalNativeAuthError(e)) {
              this.platformAuthProvider = void 0;
              const silentIframeClient = this.createSilentIframeClient(validRequest.correlationId);
              return silentIframeClient.acquireToken(validRequest);
            }
            throw e;
          });
        } else {
          const silentIframeClient = this.createSilentIframeClient(validRequest.correlationId);
          result = silentIframeClient.acquireToken(validRequest);
        }
        return result.then((response) => {
          var _a4;
          this.eventHandler.emitEvent(EventType.SSO_SILENT_SUCCESS, InteractionType.Silent, response);
          (_a4 = this.ssoSilentMeasurement) == null ? void 0 : _a4.end({
            success: true,
            isNativeBroker: response.fromNativeBroker,
            accessTokenSize: response.accessToken.length,
            idTokenSize: response.idToken.length,
            accountType: getAccountType(response.account)
          });
          return response;
        }).catch((e) => {
          var _a4;
          this.eventHandler.emitEvent(EventType.SSO_SILENT_FAILURE, InteractionType.Silent, null, e);
          (_a4 = this.ssoSilentMeasurement) == null ? void 0 : _a4.end({
            success: false
          }, e);
          throw e;
        }).finally(() => {
          document.removeEventListener("visibilitychange", this.trackPageVisibilityWithMeasurement);
        });
      }
      /**
       * This function redeems an authorization code (passed as code) from the eSTS token endpoint.
       * This authorization code should be acquired server-side using a confidential client to acquire a spa_code.
       * This API is not indended for normal authorization code acquisition and redemption.
       *
       * Redemption of this authorization code will not require PKCE, as it was acquired by a confidential client.
       *
       * @param request {@link AuthorizationCodeRequest}
       * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.
       */
      async acquireTokenByCode(request) {
        const correlationId = this.getRequestCorrelationId(request);
        this.logger.trace("acquireTokenByCode called", correlationId);
        const atbcMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenByCode, correlationId);
        preflightCheck2(this.initialized, atbcMeasurement);
        this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_BY_CODE_START, InteractionType.Silent, request);
        atbcMeasurement.add({ scenarioId: request.scenarioId });
        try {
          if (request.code && request.nativeAccountId) {
            throw createBrowserAuthError(spaCodeAndNativeAccountIdPresent);
          } else if (request.code) {
            const hybridAuthCode = request.code;
            let response = this.hybridAuthCodeResponses.get(hybridAuthCode);
            if (!response) {
              this.logger.verbose("Initiating new acquireTokenByCode request", correlationId);
              response = this.acquireTokenByCodeAsync({
                ...request,
                correlationId
              }).then((result) => {
                this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_BY_CODE_SUCCESS, InteractionType.Silent, result);
                this.hybridAuthCodeResponses.delete(hybridAuthCode);
                atbcMeasurement.end({
                  success: true,
                  isNativeBroker: result.fromNativeBroker,
                  accessTokenSize: result.accessToken.length,
                  idTokenSize: result.idToken.length,
                  accountType: getAccountType(result.account)
                });
                return result;
              }).catch((error) => {
                this.hybridAuthCodeResponses.delete(hybridAuthCode);
                this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_BY_CODE_FAILURE, InteractionType.Silent, null, error);
                atbcMeasurement.end({
                  success: false
                }, error);
                throw error;
              });
              this.hybridAuthCodeResponses.set(hybridAuthCode, response);
            } else {
              this.logger.verbose("Existing acquireTokenByCode request found", correlationId);
              atbcMeasurement.discard();
            }
            return await response;
          } else if (request.nativeAccountId) {
            if (this.canUsePlatformBroker(request, request.nativeAccountId)) {
              const result = await this.acquireTokenNative({
                ...request,
                correlationId
              }, ApiId.acquireTokenByCode, request.nativeAccountId).catch((e) => {
                if (e instanceof NativeAuthError && isFatalNativeAuthError(e)) {
                  this.platformAuthProvider = void 0;
                }
                throw e;
              });
              atbcMeasurement.end({
                accountType: getAccountType(result.account),
                success: true
              });
              return result;
            } else {
              throw createBrowserAuthError(unableToAcquireTokenFromNativePlatform);
            }
          } else {
            throw createBrowserAuthError(authCodeOrNativeAccountIdRequired);
          }
        } catch (e) {
          this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_BY_CODE_FAILURE, InteractionType.Silent, null, e);
          atbcMeasurement.end({
            success: false
          }, e);
          throw e;
        }
      }
      /**
       * Creates a SilentAuthCodeClient to redeem an authorization code.
       * @param request
       * @returns Result of the operation to redeem the authorization code
       */
      async acquireTokenByCodeAsync(request) {
        var _a3;
        this.logger.trace("acquireTokenByCodeAsync called", request.correlationId);
        this.acquireTokenByCodeAsyncMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenByCodeAsync, request.correlationId);
        (_a3 = this.acquireTokenByCodeAsyncMeasurement) == null ? void 0 : _a3.increment({
          visibilityChangeCount: 0
        });
        document.addEventListener("visibilitychange", this.trackPageVisibilityWithMeasurement);
        const silentAuthCodeClient = this.createSilentAuthCodeClient(request.correlationId);
        const silentTokenResult = await silentAuthCodeClient.acquireToken(request).then((response) => {
          var _a4;
          (_a4 = this.acquireTokenByCodeAsyncMeasurement) == null ? void 0 : _a4.end({
            success: true,
            fromCache: response.fromCache,
            isNativeBroker: response.fromNativeBroker
          });
          return response;
        }).catch((tokenRenewalError) => {
          var _a4;
          (_a4 = this.acquireTokenByCodeAsyncMeasurement) == null ? void 0 : _a4.end({
            success: false
          }, tokenRenewalError);
          throw tokenRenewalError;
        }).finally(() => {
          document.removeEventListener("visibilitychange", this.trackPageVisibilityWithMeasurement);
        });
        return silentTokenResult;
      }
      /**
       * Attempt to acquire an access token from the cache
       * @param silentCacheClient SilentCacheClient
       * @param commonRequest CommonSilentFlowRequest
       * @param silentRequest SilentRequest
       * @returns A promise that, when resolved, returns the access token
       */
      async acquireTokenFromCache(commonRequest, cacheLookupPolicy) {
        this.performanceClient.addQueueMeasurement(PerformanceEvents.AcquireTokenFromCache, commonRequest.correlationId);
        switch (cacheLookupPolicy) {
          case CacheLookupPolicy.Default:
          case CacheLookupPolicy.AccessToken:
          case CacheLookupPolicy.AccessTokenAndRefreshToken:
            const silentCacheClient = this.createSilentCacheClient(commonRequest.correlationId);
            return invokeAsync(silentCacheClient.acquireToken.bind(silentCacheClient), PerformanceEvents.SilentCacheClientAcquireToken, this.logger, this.performanceClient, commonRequest.correlationId)(commonRequest);
          default:
            throw createClientAuthError(ClientAuthErrorCodes_exports.tokenRefreshRequired);
        }
      }
      /**
       * Attempt to acquire an access token via a refresh token
       * @param commonRequest CommonSilentFlowRequest
       * @param cacheLookupPolicy CacheLookupPolicy
       * @returns A promise that, when resolved, returns the access token
       */
      async acquireTokenByRefreshToken(commonRequest, cacheLookupPolicy) {
        this.performanceClient.addQueueMeasurement(PerformanceEvents.AcquireTokenByRefreshToken, commonRequest.correlationId);
        switch (cacheLookupPolicy) {
          case CacheLookupPolicy.Default:
          case CacheLookupPolicy.AccessTokenAndRefreshToken:
          case CacheLookupPolicy.RefreshToken:
          case CacheLookupPolicy.RefreshTokenAndNetwork:
            const silentRefreshClient = this.createSilentRefreshClient(commonRequest.correlationId);
            return invokeAsync(silentRefreshClient.acquireToken.bind(silentRefreshClient), PerformanceEvents.SilentRefreshClientAcquireToken, this.logger, this.performanceClient, commonRequest.correlationId)(commonRequest);
          default:
            throw createClientAuthError(ClientAuthErrorCodes_exports.tokenRefreshRequired);
        }
      }
      /**
       * Attempt to acquire an access token via an iframe
       * @param request CommonSilentFlowRequest
       * @returns A promise that, when resolved, returns the access token
       */
      async acquireTokenBySilentIframe(request) {
        this.performanceClient.addQueueMeasurement(PerformanceEvents.AcquireTokenBySilentIframe, request.correlationId);
        const silentIframeClient = this.createSilentIframeClient(request.correlationId);
        return invokeAsync(silentIframeClient.acquireToken.bind(silentIframeClient), PerformanceEvents.SilentIframeClientAcquireToken, this.logger, this.performanceClient, request.correlationId)(request);
      }
      // #endregion
      // #region Logout
      /**
       * Deprecated logout function. Use logoutRedirect or logoutPopup instead
       * @param logoutRequest
       * @deprecated
       */
      async logout(logoutRequest) {
        const correlationId = this.getRequestCorrelationId(logoutRequest);
        this.logger.warning("logout API is deprecated and will be removed in msal-browser v3.0.0. Use logoutRedirect instead.", correlationId);
        return this.logoutRedirect({
          correlationId,
          ...logoutRequest
        });
      }
      /**
       * Use to log out the current user, and redirect the user to the postLogoutRedirectUri.
       * Default behaviour is to redirect the user to `window.location.href`.
       * @param logoutRequest
       */
      async logoutRedirect(logoutRequest) {
        const correlationId = this.getRequestCorrelationId(logoutRequest);
        redirectPreflightCheck(this.initialized, this.config);
        this.browserStorage.setInteractionInProgress(true, INTERACTION_TYPE.SIGNOUT);
        const redirectClient = this.createRedirectClient(correlationId);
        return redirectClient.logout(logoutRequest);
      }
      /**
       * Clears local cache for the current user then opens a popup window prompting the user to sign-out of the server
       * @param logoutRequest
       */
      logoutPopup(logoutRequest) {
        try {
          const correlationId = this.getRequestCorrelationId(logoutRequest);
          preflightCheck(this.initialized);
          this.browserStorage.setInteractionInProgress(true, INTERACTION_TYPE.SIGNOUT);
          const popupClient = this.createPopupClient(correlationId);
          return popupClient.logout(logoutRequest).finally(() => {
            this.browserStorage.setInteractionInProgress(false);
          });
        } catch (e) {
          return Promise.reject(e);
        }
      }
      /**
       * Creates a cache interaction client to clear broswer cache.
       * @param logoutRequest
       */
      async clearCache(logoutRequest) {
        if (!this.isBrowserEnvironment) {
          this.logger.info("in non-browser environment, returning early.");
          return;
        }
        const correlationId = this.getRequestCorrelationId(logoutRequest);
        const cacheClient = this.createSilentCacheClient(correlationId);
        return cacheClient.logout(logoutRequest);
      }
      // #endregion
      // #region Account APIs
      /**
       * Returns all the accounts in the cache that match the optional filter. If no filter is provided, all accounts are returned.
       * @param accountFilter - (Optional) filter to narrow down the accounts returned
       * @returns Array of AccountInfo objects in cache
       */
      getAllAccounts(accountFilter) {
        const correlationId = this.getRequestCorrelationId();
        return getAllAccounts(this.logger, this.browserStorage, this.isBrowserEnvironment, correlationId, accountFilter);
      }
      /**
       * Returns the first account found in the cache that matches the account filter passed in.
       * @param accountFilter
       * @returns The first account found in the cache matching the provided filter or null if no account could be found.
       */
      getAccount(accountFilter) {
        const correlationId = this.getRequestCorrelationId();
        return getAccount(accountFilter, this.logger, this.browserStorage, correlationId);
      }
      /**
       * Returns the signed in account matching username.
       * (the account object is created at the time of successful login)
       * or null when no matching account is found.
       * This API is provided for convenience but getAccountById should be used for best reliability
       * @param username
       * @returns The account object stored in MSAL
       */
      getAccountByUsername(username) {
        const correlationId = this.getRequestCorrelationId();
        return getAccountByUsername(username, this.logger, this.browserStorage, correlationId);
      }
      /**
       * Returns the signed in account matching homeAccountId.
       * (the account object is created at the time of successful login)
       * or null when no matching account is found
       * @param homeAccountId
       * @returns The account object stored in MSAL
       */
      getAccountByHomeId(homeAccountId) {
        const correlationId = this.getRequestCorrelationId();
        return getAccountByHomeId(homeAccountId, this.logger, this.browserStorage, correlationId);
      }
      /**
       * Returns the signed in account matching localAccountId.
       * (the account object is created at the time of successful login)
       * or null when no matching account is found
       * @param localAccountId
       * @returns The account object stored in MSAL
       */
      getAccountByLocalId(localAccountId) {
        const correlationId = this.getRequestCorrelationId();
        return getAccountByLocalId(localAccountId, this.logger, this.browserStorage, correlationId);
      }
      /**
       * Sets the account to use as the active account. If no account is passed to the acquireToken APIs, then MSAL will use this active account.
       * @param account
       */
      setActiveAccount(account) {
        const correlationId = this.getRequestCorrelationId();
        setActiveAccount(account, this.browserStorage, correlationId);
      }
      /**
       * Gets the currently active account
       */
      getActiveAccount() {
        const correlationId = this.getRequestCorrelationId();
        return getActiveAccount(this.browserStorage, correlationId);
      }
      // #endregion
      /**
       * Hydrates the cache with the tokens from an AuthenticationResult
       * @param result
       * @param request
       * @returns
       */
      async hydrateCache(result, request) {
        this.logger.verbose("hydrateCache called");
        const accountEntity = AccountEntity.createFromAccountInfo(result.account, result.cloudGraphHostName, result.msGraphHost);
        await this.browserStorage.setAccount(accountEntity, result.correlationId);
        if (result.fromNativeBroker) {
          this.logger.verbose("Response was from native broker, storing in-memory");
          return this.nativeInternalStorage.hydrateCache(result, request);
        } else {
          return this.browserStorage.hydrateCache(result, request);
        }
      }
      // #region Helpers
      /**
       * Acquire a token from native device (e.g. WAM)
       * @param request
       */
      async acquireTokenNative(request, apiId, accountId, cacheLookupPolicy) {
        this.logger.trace("acquireTokenNative called");
        if (!this.platformAuthProvider) {
          throw createBrowserAuthError(nativeConnectionNotEstablished);
        }
        const nativeClient = new PlatformAuthInteractionClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, apiId, this.performanceClient, this.platformAuthProvider, accountId || this.getNativeAccountId(request), this.nativeInternalStorage, request.correlationId);
        return nativeClient.acquireToken(request, cacheLookupPolicy);
      }
      /**
       * Returns boolean indicating if this request can use the platform broker
       * @param request
       */
      canUsePlatformBroker(request, accountId) {
        this.logger.trace("canUsePlatformBroker called");
        if (!this.platformAuthProvider) {
          this.logger.trace("canUsePlatformBroker: platform broker unavilable, returning false");
          return false;
        }
        if (!isPlatformAuthAllowed(this.config, this.logger, this.platformAuthProvider, request.authenticationScheme)) {
          this.logger.trace("canUsePlatformBroker: isBrokerAvailable returned false, returning false");
          return false;
        }
        if (request.prompt) {
          switch (request.prompt) {
            case PromptValue.NONE:
            case PromptValue.CONSENT:
            case PromptValue.LOGIN:
              this.logger.trace("canUsePlatformBroker: prompt is compatible with platform broker flow");
              break;
            default:
              this.logger.trace(`canUsePlatformBroker: prompt = ${request.prompt} is not compatible with platform broker flow, returning false`);
              return false;
          }
        }
        if (!accountId && !this.getNativeAccountId(request)) {
          this.logger.trace("canUsePlatformBroker: nativeAccountId is not available, returning false");
          return false;
        }
        return true;
      }
      /**
       * Get the native accountId from the account
       * @param request
       * @returns
       */
      getNativeAccountId(request) {
        const account = request.account || this.getAccount({
          loginHint: request.loginHint,
          sid: request.sid
        }) || this.getActiveAccount();
        return account && account.nativeAccountId || "";
      }
      /**
       * Returns new instance of the Popup Interaction Client
       * @param correlationId
       */
      createPopupClient(correlationId) {
        return new PopupClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, this.performanceClient, this.nativeInternalStorage, this.platformAuthProvider, correlationId);
      }
      /**
       * Returns new instance of the Redirect Interaction Client
       * @param correlationId
       */
      createRedirectClient(correlationId) {
        return new RedirectClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, this.performanceClient, this.nativeInternalStorage, this.platformAuthProvider, correlationId);
      }
      /**
       * Returns new instance of the Silent Iframe Interaction Client
       * @param correlationId
       */
      createSilentIframeClient(correlationId) {
        return new SilentIframeClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, ApiId.ssoSilent, this.performanceClient, this.nativeInternalStorage, this.platformAuthProvider, correlationId);
      }
      /**
       * Returns new instance of the Silent Cache Interaction Client
       */
      createSilentCacheClient(correlationId) {
        return new SilentCacheClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, this.performanceClient, this.platformAuthProvider, correlationId);
      }
      /**
       * Returns new instance of the Silent Refresh Interaction Client
       */
      createSilentRefreshClient(correlationId) {
        return new SilentRefreshClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, this.performanceClient, this.platformAuthProvider, correlationId);
      }
      /**
       * Returns new instance of the Silent AuthCode Interaction Client
       */
      createSilentAuthCodeClient(correlationId) {
        return new SilentAuthCodeClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, ApiId.acquireTokenByCode, this.performanceClient, this.platformAuthProvider, correlationId);
      }
      /**
       * Adds event callbacks to array
       * @param callback
       */
      addEventCallback(callback, eventTypes) {
        return this.eventHandler.addEventCallback(callback, eventTypes);
      }
      /**
       * Removes callback with provided id from callback array
       * @param callbackId
       */
      removeEventCallback(callbackId) {
        this.eventHandler.removeEventCallback(callbackId);
      }
      /**
       * Registers a callback to receive performance events.
       *
       * @param {PerformanceCallbackFunction} callback
       * @returns {string}
       */
      addPerformanceCallback(callback) {
        blockNonBrowserEnvironment();
        return this.performanceClient.addPerformanceCallback(callback);
      }
      /**
       * Removes a callback registered with addPerformanceCallback.
       *
       * @param {string} callbackId
       * @returns {boolean}
       */
      removePerformanceCallback(callbackId) {
        return this.performanceClient.removePerformanceCallback(callbackId);
      }
      /**
       * Adds event listener that emits an event when a user account is added or removed from localstorage in a different browser tab or window
       * @deprecated These events will be raised by default and this method will be removed in a future major version.
       */
      enableAccountStorageEvents() {
        if (this.config.cache.cacheLocation !== BrowserCacheLocation.LocalStorage) {
          this.logger.info("Account storage events are only available when cacheLocation is set to localStorage");
          return;
        }
        this.eventHandler.subscribeCrossTab();
      }
      /**
       * Removes event listener that emits an event when a user account is added or removed from localstorage in a different browser tab or window
       * @deprecated These events will be raised by default and this method will be removed in a future major version.
       */
      disableAccountStorageEvents() {
        if (this.config.cache.cacheLocation !== BrowserCacheLocation.LocalStorage) {
          this.logger.info("Account storage events are only available when cacheLocation is set to localStorage");
          return;
        }
        this.eventHandler.unsubscribeCrossTab();
      }
      /**
       * Gets the token cache for the application.
       */
      getTokenCache() {
        return this.tokenCache;
      }
      /**
       * Returns the logger instance
       */
      getLogger() {
        return this.logger;
      }
      /**
       * Replaces the default logger set in configurations with new Logger with new configurations
       * @param logger Logger instance
       */
      setLogger(logger24) {
        this.logger = logger24;
      }
      /**
       * Called by wrapper libraries (Angular & React) to set SKU and Version passed down to telemetry, logger, etc.
       * @param sku
       * @param version
       */
      initializeWrapperLibrary(sku, version3) {
        this.browserStorage.setWrapperMetadata(sku, version3);
      }
      /**
       * Sets navigation client
       * @param navigationClient
       */
      setNavigationClient(navigationClient) {
        this.navigationClient = navigationClient;
      }
      /**
       * Returns the configuration object
       */
      getConfiguration() {
        return this.config;
      }
      /**
       * Returns the performance client
       */
      getPerformanceClient() {
        return this.performanceClient;
      }
      /**
       * Returns the browser env indicator
       */
      isBrowserEnv() {
        return this.isBrowserEnvironment;
      }
      /**
       * Generates a correlation id for a request if none is provided.
       *
       * @protected
       * @param {?Partial<BaseAuthRequest>} [request]
       * @returns {string}
       */
      getRequestCorrelationId(request) {
        if (request == null ? void 0 : request.correlationId) {
          return request.correlationId;
        }
        if (this.isBrowserEnvironment) {
          return createNewGuid();
        }
        return Constants.EMPTY_STRING;
      }
      // #endregion
      /**
       * Use when initiating the login process by redirecting the user's browser to the authorization endpoint. This function redirects the page, so
       * any code that follows this function will not execute.
       *
       * IMPORTANT: It is NOT recommended to have code that is dependent on the resolution of the Promise. This function will navigate away from the current
       * browser window. It currently returns a Promise in order to reflect the asynchronous nature of the code running in this function.
       *
       * @param request
       */
      async loginRedirect(request) {
        const correlationId = this.getRequestCorrelationId(request);
        this.logger.verbose("loginRedirect called", correlationId);
        return this.acquireTokenRedirect({
          correlationId,
          ...request || DEFAULT_REQUEST
        });
      }
      /**
       * Use when initiating the login process via opening a popup window in the user's browser
       *
       * @param request
       *
       * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.
       */
      loginPopup(request) {
        const correlationId = this.getRequestCorrelationId(request);
        this.logger.verbose("loginPopup called", correlationId);
        return this.acquireTokenPopup({
          correlationId,
          ...request || DEFAULT_REQUEST
        });
      }
      /**
       * Silently acquire an access token for a given set of scopes. Returns currently processing promise if parallel requests are made.
       *
       * @param {@link (SilentRequest:type)}
       * @returns {Promise.<AuthenticationResult>} - a promise that is fulfilled when this function has completed, or rejected if an error was raised. Returns the {@link AuthResponse} object
       */
      async acquireTokenSilent(request) {
        const correlationId = this.getRequestCorrelationId(request);
        const atsMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenSilent, correlationId);
        atsMeasurement.add({
          cacheLookupPolicy: request.cacheLookupPolicy,
          scenarioId: request.scenarioId
        });
        preflightCheck2(this.initialized, atsMeasurement);
        this.logger.verbose("acquireTokenSilent called", correlationId);
        const account = request.account || this.getActiveAccount();
        if (!account) {
          throw createBrowserAuthError(noAccountError);
        }
        atsMeasurement.add({ accountType: getAccountType(account) });
        return this.acquireTokenSilentDeduped(request, account, correlationId).then((result) => {
          atsMeasurement.end({
            success: true,
            fromCache: result.fromCache,
            isNativeBroker: result.fromNativeBroker,
            accessTokenSize: result.accessToken.length,
            idTokenSize: result.idToken.length
          });
          return {
            ...result,
            state: request.state,
            correlationId
            // Ensures PWB scenarios can correctly match request to response
          };
        }).catch((error) => {
          if (error instanceof AuthError) {
            error.setCorrelationId(correlationId);
          }
          atsMeasurement.end({
            success: false
          }, error);
          throw error;
        });
      }
      /**
       * Checks if identical request is already in flight and returns reference to the existing promise or fires off a new one if this is the first
       * @param request
       * @param account
       * @param correlationId
       * @returns
       */
      async acquireTokenSilentDeduped(request, account, correlationId) {
        const thumbprint = getRequestThumbprint(this.config.auth.clientId, {
          ...request,
          authority: request.authority || this.config.auth.authority,
          correlationId
        }, account.homeAccountId);
        const silentRequestKey = JSON.stringify(thumbprint);
        const inProgressRequest = this.activeSilentTokenRequests.get(silentRequestKey);
        if (typeof inProgressRequest === "undefined") {
          this.logger.verbose("acquireTokenSilent called for the first time, storing active request", correlationId);
          this.performanceClient.addFields({ deduped: false }, correlationId);
          const activeRequest = invokeAsync(this.acquireTokenSilentAsync.bind(this), PerformanceEvents.AcquireTokenSilentAsync, this.logger, this.performanceClient, correlationId)({
            ...request,
            correlationId
          }, account);
          this.activeSilentTokenRequests.set(silentRequestKey, activeRequest);
          return activeRequest.finally(() => {
            this.activeSilentTokenRequests.delete(silentRequestKey);
          });
        } else {
          this.logger.verbose("acquireTokenSilent has been called previously, returning the result from the first call", correlationId);
          this.performanceClient.addFields({ deduped: true }, correlationId);
          return inProgressRequest;
        }
      }
      /**
       * Silently acquire an access token for a given set of scopes. Will use cached token if available, otherwise will attempt to acquire a new token from the network via refresh token.
       * @param {@link (SilentRequest:type)}
       * @param {@link (AccountInfo:type)}
       * @returns {Promise.<AuthenticationResult>} - a promise that is fulfilled when this function has completed, or rejected if an error was raised. Returns the {@link AuthResponse}
       */
      async acquireTokenSilentAsync(request, account) {
        const trackPageVisibility = () => this.trackPageVisibility(request.correlationId);
        this.performanceClient.addQueueMeasurement(PerformanceEvents.AcquireTokenSilentAsync, request.correlationId);
        this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_START, InteractionType.Silent, request);
        if (request.correlationId) {
          this.performanceClient.incrementFields({ visibilityChangeCount: 0 }, request.correlationId);
        }
        document.addEventListener("visibilitychange", trackPageVisibility);
        const silentRequest = await invokeAsync(initializeSilentRequest, PerformanceEvents.InitializeSilentRequest, this.logger, this.performanceClient, request.correlationId)(request, account, this.config, this.performanceClient, this.logger);
        const cacheLookupPolicy = request.cacheLookupPolicy || CacheLookupPolicy.Default;
        const result = this.acquireTokenSilentNoIframe(silentRequest, cacheLookupPolicy).catch(async (refreshTokenError) => {
          const shouldTryToResolveSilently = checkIfRefreshTokenErrorCanBeResolvedSilently(refreshTokenError, cacheLookupPolicy);
          if (shouldTryToResolveSilently) {
            if (!this.activeIframeRequest) {
              let _resolve;
              this.activeIframeRequest = [
                new Promise((resolve) => {
                  _resolve = resolve;
                }),
                silentRequest.correlationId
              ];
              this.logger.verbose("Refresh token expired/invalid or CacheLookupPolicy is set to Skip, attempting acquire token by iframe.", silentRequest.correlationId);
              return invokeAsync(this.acquireTokenBySilentIframe.bind(this), PerformanceEvents.AcquireTokenBySilentIframe, this.logger, this.performanceClient, silentRequest.correlationId)(silentRequest).then((iframeResult) => {
                _resolve(true);
                return iframeResult;
              }).catch((e) => {
                _resolve(false);
                throw e;
              }).finally(() => {
                this.activeIframeRequest = void 0;
              });
            } else if (cacheLookupPolicy !== CacheLookupPolicy.Skip) {
              const [activePromise, activeCorrelationId] = this.activeIframeRequest;
              this.logger.verbose(`Iframe request is already in progress, awaiting resolution for request with correlationId: ${activeCorrelationId}`, silentRequest.correlationId);
              const awaitConcurrentIframeMeasure = this.performanceClient.startMeasurement(PerformanceEvents.AwaitConcurrentIframe, silentRequest.correlationId);
              awaitConcurrentIframeMeasure.add({
                awaitIframeCorrelationId: activeCorrelationId
              });
              const activePromiseResult = await activePromise;
              awaitConcurrentIframeMeasure.end({
                success: activePromiseResult
              });
              if (activePromiseResult) {
                this.logger.verbose(`Parallel iframe request with correlationId: ${activeCorrelationId} succeeded. Retrying cache and/or RT redemption`, silentRequest.correlationId);
                return this.acquireTokenSilentNoIframe(silentRequest, cacheLookupPolicy);
              } else {
                this.logger.info(`Iframe request with correlationId: ${activeCorrelationId} failed. Interaction is required.`);
                throw refreshTokenError;
              }
            } else {
              this.logger.warning("Another iframe request is currently in progress and CacheLookupPolicy is set to Skip. This may result in degraded performance and/or reliability for both calls. Please consider changing the CacheLookupPolicy to take advantage of request queuing and token cache.", silentRequest.correlationId);
              return invokeAsync(this.acquireTokenBySilentIframe.bind(this), PerformanceEvents.AcquireTokenBySilentIframe, this.logger, this.performanceClient, silentRequest.correlationId)(silentRequest);
            }
          } else {
            throw refreshTokenError;
          }
        });
        return result.then((response) => {
          this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Silent, response);
          if (request.correlationId) {
            this.performanceClient.addFields({
              fromCache: response.fromCache,
              isNativeBroker: response.fromNativeBroker
            }, request.correlationId);
          }
          return response;
        }).catch((tokenRenewalError) => {
          this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Silent, null, tokenRenewalError);
          throw tokenRenewalError;
        }).finally(() => {
          document.removeEventListener("visibilitychange", trackPageVisibility);
        });
      }
      /**
       * AcquireTokenSilent without the iframe fallback. This is used to enable the correct fallbacks in cases where there's a potential for multiple silent requests to be made in parallel and prevent those requests from making concurrent iframe requests.
       * @param silentRequest
       * @param cacheLookupPolicy
       * @returns
       */
      async acquireTokenSilentNoIframe(silentRequest, cacheLookupPolicy) {
        if (isPlatformAuthAllowed(this.config, this.logger, this.platformAuthProvider, silentRequest.authenticationScheme) && silentRequest.account.nativeAccountId) {
          this.logger.verbose("acquireTokenSilent - attempting to acquire token from native platform");
          return this.acquireTokenNative(silentRequest, ApiId.acquireTokenSilent_silentFlow, silentRequest.account.nativeAccountId, cacheLookupPolicy).catch(async (e) => {
            if (e instanceof NativeAuthError && isFatalNativeAuthError(e)) {
              this.logger.verbose("acquireTokenSilent - native platform unavailable, falling back to web flow");
              this.platformAuthProvider = void 0;
              throw createClientAuthError(ClientAuthErrorCodes_exports.tokenRefreshRequired);
            }
            throw e;
          });
        } else {
          this.logger.verbose("acquireTokenSilent - attempting to acquire token from web flow");
          if (cacheLookupPolicy === CacheLookupPolicy.AccessToken) {
            this.logger.verbose("acquireTokenSilent - cache lookup policy set to AccessToken, attempting to acquire token from local cache");
          }
          return invokeAsync(this.acquireTokenFromCache.bind(this), PerformanceEvents.AcquireTokenFromCache, this.logger, this.performanceClient, silentRequest.correlationId)(silentRequest, cacheLookupPolicy).catch((cacheError) => {
            if (cacheLookupPolicy === CacheLookupPolicy.AccessToken) {
              throw cacheError;
            }
            this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_NETWORK_START, InteractionType.Silent, silentRequest);
            return invokeAsync(this.acquireTokenByRefreshToken.bind(this), PerformanceEvents.AcquireTokenByRefreshToken, this.logger, this.performanceClient, silentRequest.correlationId)(silentRequest, cacheLookupPolicy);
          });
        }
      }
      /**
       * Pre-generates PKCE codes and stores it in local variable
       * @param correlationId
       */
      async preGeneratePkceCodes(correlationId) {
        this.logger.verbose("Generating new PKCE codes");
        this.pkceCode = await invokeAsync(generatePkceCodes, PerformanceEvents.GeneratePkceCodes, this.logger, this.performanceClient, correlationId)(this.performanceClient, this.logger, correlationId);
        return Promise.resolve();
      }
      /**
       * Provides pre-generated PKCE codes, if any
       * @param correlationId
       */
      getPreGeneratedPkceCodes(correlationId) {
        this.logger.verbose("Attempting to pick up pre-generated PKCE codes");
        const res = this.pkceCode ? { ...this.pkceCode } : void 0;
        this.pkceCode = void 0;
        this.logger.verbose(`${res ? "Found" : "Did not find"} pre-generated PKCE codes`);
        this.performanceClient.addFields({ usePreGeneratedPkce: !!res }, correlationId);
        return res;
      }
      logMultipleInstances(performanceEvent) {
        const clientId = this.config.auth.clientId;
        if (!window)
          return;
        window.msal = window.msal || {};
        window.msal.clientIds = window.msal.clientIds || [];
        const clientIds = window.msal.clientIds;
        if (clientIds.length > 0) {
          this.logger.verbose("There is already an instance of MSAL.js in the window.");
        }
        window.msal.clientIds.push(clientId);
        collectInstanceStats(clientId, performanceEvent, this.logger);
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/naa/BridgeError.mjs
function isBridgeError(error) {
  return error.status !== void 0;
}
var init_BridgeError = __esm({
  "node_modules/@azure/msal-browser/dist/naa/BridgeError.mjs"() {
    "use strict";
  }
});

// node_modules/@azure/msal-browser/dist/naa/mapping/NestedAppAuthAdapter.mjs
var NestedAppAuthAdapter;
var init_NestedAppAuthAdapter = __esm({
  "node_modules/@azure/msal-browser/dist/naa/mapping/NestedAppAuthAdapter.mjs"() {
    "use strict";
    init_index_browser();
    init_BridgeError();
    init_BridgeStatusCode();
    NestedAppAuthAdapter = class {
      constructor(clientId, clientCapabilities, crypto, logger24) {
        this.clientId = clientId;
        this.clientCapabilities = clientCapabilities;
        this.crypto = crypto;
        this.logger = logger24;
      }
      toNaaTokenRequest(request) {
        var _a3;
        let extraParams;
        if (request.extraQueryParameters === void 0) {
          extraParams = /* @__PURE__ */ new Map();
        } else {
          extraParams = new Map(Object.entries(request.extraQueryParameters));
        }
        const correlationId = request.correlationId || this.crypto.createNewGuid();
        const claims = RequestParameterBuilder_exports.addClientCapabilitiesToClaims(request.claims, this.clientCapabilities);
        const scopes = request.scopes || OIDC_DEFAULT_SCOPES;
        const tokenRequest = {
          platformBrokerId: (_a3 = request.account) == null ? void 0 : _a3.homeAccountId,
          clientId: this.clientId,
          authority: request.authority,
          scope: scopes.join(" "),
          correlationId,
          claims: !StringUtils.isEmptyObj(claims) ? claims : void 0,
          state: request.state,
          authenticationScheme: request.authenticationScheme || AuthenticationScheme.BEARER,
          extraParameters: extraParams
        };
        return tokenRequest;
      }
      fromNaaTokenResponse(request, response, reqTimestamp) {
        if (!response.token.id_token || !response.token.access_token) {
          throw createClientAuthError(ClientAuthErrorCodes_exports.nullOrEmptyToken);
        }
        const expiresOn = TimeUtils_exports.toDateFromSeconds(reqTimestamp + (response.token.expires_in || 0));
        const idTokenClaims = AuthToken_exports.extractTokenClaims(response.token.id_token, this.crypto.base64Decode);
        const account = this.fromNaaAccountInfo(response.account, response.token.id_token, idTokenClaims);
        const scopes = response.token.scope || request.scope;
        const authenticationResult = {
          authority: response.token.authority || account.environment,
          uniqueId: account.localAccountId,
          tenantId: account.tenantId,
          scopes: scopes.split(" "),
          account,
          idToken: response.token.id_token,
          idTokenClaims,
          accessToken: response.token.access_token,
          fromCache: false,
          expiresOn,
          tokenType: request.authenticationScheme || AuthenticationScheme.BEARER,
          correlationId: request.correlationId,
          extExpiresOn: expiresOn,
          state: request.state
        };
        return authenticationResult;
      }
      /*
       *  export type AccountInfo = {
       *     homeAccountId: string;
       *     environment: string;
       *     tenantId: string;
       *     username: string;
       *     localAccountId: string;
       *     name?: string;
       *     idToken?: string;
       *     idTokenClaims?: TokenClaims & {
       *         [key: string]:
       *             | string
       *             | number
       *             | string[]
       *             | object
       *             | undefined
       *             | unknown;
       *     };
       *     nativeAccountId?: string;
       *     authorityType?: string;
       * };
       */
      fromNaaAccountInfo(fromAccount, idToken, idTokenClaims) {
        const effectiveIdTokenClaims = idTokenClaims || fromAccount.idTokenClaims;
        const localAccountId = fromAccount.localAccountId || (effectiveIdTokenClaims == null ? void 0 : effectiveIdTokenClaims.oid) || (effectiveIdTokenClaims == null ? void 0 : effectiveIdTokenClaims.sub) || "";
        const tenantId = fromAccount.tenantId || (effectiveIdTokenClaims == null ? void 0 : effectiveIdTokenClaims.tid) || "";
        const homeAccountId = fromAccount.homeAccountId || `${localAccountId}.${tenantId}`;
        const username = fromAccount.username || (effectiveIdTokenClaims == null ? void 0 : effectiveIdTokenClaims.preferred_username) || "";
        const name3 = fromAccount.name || (effectiveIdTokenClaims == null ? void 0 : effectiveIdTokenClaims.name);
        const tenantProfiles = /* @__PURE__ */ new Map();
        const tenantProfile = buildTenantProfile(homeAccountId, localAccountId, tenantId, effectiveIdTokenClaims);
        tenantProfiles.set(tenantId, tenantProfile);
        const account = {
          homeAccountId,
          environment: fromAccount.environment,
          tenantId,
          username,
          localAccountId,
          name: name3,
          idToken,
          idTokenClaims: effectiveIdTokenClaims,
          tenantProfiles
        };
        return account;
      }
      /**
       *
       * @param error BridgeError
       * @returns AuthError, ClientAuthError, ClientConfigurationError, ServerError, InteractionRequiredError
       */
      fromBridgeError(error) {
        if (isBridgeError(error)) {
          switch (error.status) {
            case BridgeStatusCode.UserCancel:
              return new ClientAuthError(ClientAuthErrorCodes_exports.userCanceled);
            case BridgeStatusCode.NoNetwork:
              return new ClientAuthError(ClientAuthErrorCodes_exports.noNetworkConnectivity);
            case BridgeStatusCode.AccountUnavailable:
              return new ClientAuthError(ClientAuthErrorCodes_exports.noAccountFound);
            case BridgeStatusCode.Disabled:
              return new ClientAuthError(ClientAuthErrorCodes_exports.nestedAppAuthBridgeDisabled);
            case BridgeStatusCode.NestedAppAuthUnavailable:
              return new ClientAuthError(error.code || ClientAuthErrorCodes_exports.nestedAppAuthBridgeDisabled, error.description);
            case BridgeStatusCode.TransientError:
            case BridgeStatusCode.PersistentError:
              return new ServerError(error.code, error.description);
            case BridgeStatusCode.UserInteractionRequired:
              return new InteractionRequiredAuthError(error.code, error.description);
            default:
              return new AuthError(error.code, error.description);
          }
        } else {
          return new AuthError("unknown_error", "An unknown error occurred");
        }
      }
      /**
       * Returns an AuthenticationResult from the given cache items
       *
       * @param account
       * @param idToken
       * @param accessToken
       * @param reqTimestamp
       * @returns
       */
      toAuthenticationResultFromCache(account, idToken, accessToken, request, correlationId) {
        if (!idToken || !accessToken) {
          throw createClientAuthError(ClientAuthErrorCodes_exports.nullOrEmptyToken);
        }
        const idTokenClaims = AuthToken_exports.extractTokenClaims(idToken.secret, this.crypto.base64Decode);
        const scopes = accessToken.target || request.scopes.join(" ");
        const authenticationResult = {
          authority: accessToken.environment || account.environment,
          uniqueId: account.localAccountId,
          tenantId: account.tenantId,
          scopes: scopes.split(" "),
          account,
          idToken: idToken.secret,
          idTokenClaims: idTokenClaims || {},
          accessToken: accessToken.secret,
          fromCache: true,
          expiresOn: TimeUtils_exports.toDateFromSeconds(accessToken.expiresOn),
          extExpiresOn: TimeUtils_exports.toDateFromSeconds(accessToken.extendedExpiresOn),
          tokenType: request.authenticationScheme || AuthenticationScheme.BEARER,
          correlationId,
          state: request.state
        };
        return authenticationResult;
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/error/NestedAppAuthError.mjs
var NestedAppAuthErrorMessage, NestedAppAuthError;
var init_NestedAppAuthError = __esm({
  "node_modules/@azure/msal-browser/dist/error/NestedAppAuthError.mjs"() {
    "use strict";
    init_index_browser();
    NestedAppAuthErrorMessage = {
      unsupportedMethod: {
        code: "unsupported_method",
        desc: "This method is not supported in nested app environment."
      }
    };
    NestedAppAuthError = class _NestedAppAuthError extends AuthError {
      constructor(errorCode, errorMessage2) {
        super(errorCode, errorMessage2);
        Object.setPrototypeOf(this, _NestedAppAuthError.prototype);
        this.name = "NestedAppAuthError";
      }
      static createUnsupportedError() {
        return new _NestedAppAuthError(NestedAppAuthErrorMessage.unsupportedMethod.code, NestedAppAuthErrorMessage.unsupportedMethod.desc);
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/controllers/NestedAppAuthController.mjs
var NestedAppAuthController;
var init_NestedAppAuthController = __esm({
  "node_modules/@azure/msal-browser/dist/controllers/NestedAppAuthController.mjs"() {
    "use strict";
    init_index_browser();
    init_BrowserConstants();
    init_CryptoOps();
    init_NestedAppAuthAdapter();
    init_NestedAppAuthError();
    init_EventHandler();
    init_EventType();
    init_BrowserCacheManager();
    init_AccountManager();
    init_BrowserCrypto();
    NestedAppAuthController = class _NestedAppAuthController {
      constructor(operatingContext) {
        this.operatingContext = operatingContext;
        const proxy = this.operatingContext.getBridgeProxy();
        if (proxy !== void 0) {
          this.bridgeProxy = proxy;
        } else {
          throw new Error("unexpected: bridgeProxy is undefined");
        }
        this.config = operatingContext.getConfig();
        this.logger = this.operatingContext.getLogger();
        this.performanceClient = this.config.telemetry.client;
        this.browserCrypto = operatingContext.isBrowserEnvironment() ? new CryptoOps(this.logger, this.performanceClient, true) : DEFAULT_CRYPTO_IMPLEMENTATION;
        this.eventHandler = new EventHandler(this.logger);
        this.browserStorage = this.operatingContext.isBrowserEnvironment() ? new BrowserCacheManager(this.config.auth.clientId, this.config.cache, this.browserCrypto, this.logger, this.performanceClient, this.eventHandler, buildStaticAuthorityOptions(this.config.auth)) : DEFAULT_BROWSER_CACHE_MANAGER(this.config.auth.clientId, this.logger, this.performanceClient, this.eventHandler);
        this.nestedAppAuthAdapter = new NestedAppAuthAdapter(this.config.auth.clientId, this.config.auth.clientCapabilities, this.browserCrypto, this.logger);
        const accountContext = this.bridgeProxy.getAccountContext();
        this.currentAccountContext = accountContext ? accountContext : null;
      }
      /**
       * Factory function to create a new instance of NestedAppAuthController
       * @param operatingContext
       * @returns Promise<IController>
       */
      static async createController(operatingContext) {
        const controller = new _NestedAppAuthController(operatingContext);
        return Promise.resolve(controller);
      }
      /**
       * Specific implementation of initialize function for NestedAppAuthController
       * @returns
       */
      async initialize(request, isBroker) {
        const initCorrelationId = (request == null ? void 0 : request.correlationId) || createNewGuid();
        await this.browserStorage.initialize(initCorrelationId);
        return Promise.resolve();
      }
      /**
       * Validate the incoming request and add correlationId if not present
       * @param request
       * @returns
       */
      ensureValidRequest(request) {
        if (request == null ? void 0 : request.correlationId) {
          return request;
        }
        return {
          ...request,
          correlationId: this.browserCrypto.createNewGuid()
        };
      }
      /**
       * Internal implementation of acquireTokenInteractive flow
       * @param request
       * @returns
       */
      async acquireTokenInteractive(request) {
        const validRequest = this.ensureValidRequest(request);
        this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_START, InteractionType.Popup, validRequest);
        const atPopupMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenPopup, validRequest.correlationId);
        atPopupMeasurement == null ? void 0 : atPopupMeasurement.add({ nestedAppAuthRequest: true });
        try {
          const naaRequest = this.nestedAppAuthAdapter.toNaaTokenRequest(validRequest);
          const reqTimestamp = TimeUtils_exports.nowSeconds();
          const response = await this.bridgeProxy.getTokenInteractive(naaRequest);
          const result = {
            ...this.nestedAppAuthAdapter.fromNaaTokenResponse(naaRequest, response, reqTimestamp)
          };
          try {
            await this.hydrateCache(result, request);
          } catch (error) {
            this.logger.warningPii(`Failed to hydrate cache. Error: ${error}`, validRequest.correlationId);
          }
          this.currentAccountContext = {
            homeAccountId: result.account.homeAccountId,
            environment: result.account.environment,
            tenantId: result.account.tenantId
          };
          this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Popup, result);
          atPopupMeasurement.add({
            accessTokenSize: result.accessToken.length,
            idTokenSize: result.idToken.length
          });
          atPopupMeasurement.end({
            success: true,
            requestId: result.requestId
          });
          return result;
        } catch (e) {
          const error = e instanceof AuthError ? e : this.nestedAppAuthAdapter.fromBridgeError(e);
          this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Popup, null, e);
          atPopupMeasurement.end({
            success: false
          }, e);
          throw error;
        }
      }
      /**
       * Internal implementation of acquireTokenSilent flow
       * @param request
       * @returns
       */
      async acquireTokenSilentInternal(request) {
        const validRequest = this.ensureValidRequest(request);
        this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_START, InteractionType.Silent, validRequest);
        const result = await this.acquireTokenFromCache(validRequest);
        if (result) {
          this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Silent, result);
          return result;
        }
        const ssoSilentMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.SsoSilent, validRequest.correlationId);
        ssoSilentMeasurement == null ? void 0 : ssoSilentMeasurement.increment({
          visibilityChangeCount: 0
        });
        ssoSilentMeasurement == null ? void 0 : ssoSilentMeasurement.add({
          nestedAppAuthRequest: true
        });
        try {
          const naaRequest = this.nestedAppAuthAdapter.toNaaTokenRequest(validRequest);
          const reqTimestamp = TimeUtils_exports.nowSeconds();
          const response = await this.bridgeProxy.getTokenSilent(naaRequest);
          const result2 = this.nestedAppAuthAdapter.fromNaaTokenResponse(naaRequest, response, reqTimestamp);
          try {
            await this.hydrateCache(result2, request);
          } catch (error) {
            this.logger.warningPii(`Failed to hydrate cache. Error: ${error}`, validRequest.correlationId);
          }
          this.currentAccountContext = {
            homeAccountId: result2.account.homeAccountId,
            environment: result2.account.environment,
            tenantId: result2.account.tenantId
          };
          this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Silent, result2);
          ssoSilentMeasurement == null ? void 0 : ssoSilentMeasurement.add({
            accessTokenSize: result2.accessToken.length,
            idTokenSize: result2.idToken.length
          });
          ssoSilentMeasurement == null ? void 0 : ssoSilentMeasurement.end({
            success: true,
            requestId: result2.requestId
          });
          return result2;
        } catch (e) {
          const error = e instanceof AuthError ? e : this.nestedAppAuthAdapter.fromBridgeError(e);
          this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Silent, null, e);
          ssoSilentMeasurement == null ? void 0 : ssoSilentMeasurement.end({
            success: false
          }, e);
          throw error;
        }
      }
      /**
       * acquires tokens from cache
       * @param request
       * @returns
       */
      async acquireTokenFromCache(request) {
        const atsMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenSilent, request.correlationId);
        atsMeasurement == null ? void 0 : atsMeasurement.add({
          nestedAppAuthRequest: true
        });
        if (request.claims) {
          this.logger.verbose("Claims are present in the request, skipping cache lookup");
          return null;
        }
        if (request.forceRefresh) {
          this.logger.verbose("forceRefresh is set to true, skipping cache lookup");
          return null;
        }
        let result = null;
        if (!request.cacheLookupPolicy) {
          request.cacheLookupPolicy = CacheLookupPolicy.Default;
        }
        switch (request.cacheLookupPolicy) {
          case CacheLookupPolicy.Default:
          case CacheLookupPolicy.AccessToken:
          case CacheLookupPolicy.AccessTokenAndRefreshToken:
            result = await this.acquireTokenFromCacheInternal(request);
            break;
          default:
            return null;
        }
        if (result) {
          this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Silent, result);
          atsMeasurement == null ? void 0 : atsMeasurement.add({
            accessTokenSize: result == null ? void 0 : result.accessToken.length,
            idTokenSize: result == null ? void 0 : result.idToken.length
          });
          atsMeasurement == null ? void 0 : atsMeasurement.end({
            success: true
          });
          return result;
        }
        this.logger.warning("Cached tokens are not found for the account, proceeding with silent token request.");
        this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Silent, null);
        atsMeasurement == null ? void 0 : atsMeasurement.end({
          success: false
        });
        return null;
      }
      /**
       *
       * @param request
       * @returns
       */
      async acquireTokenFromCacheInternal(request) {
        var _a3;
        const accountContext = this.bridgeProxy.getAccountContext() || this.currentAccountContext;
        let currentAccount = null;
        const correlationId = request.correlationId || this.browserCrypto.createNewGuid();
        if (accountContext) {
          currentAccount = getAccount(accountContext, this.logger, this.browserStorage, correlationId);
        }
        if (!currentAccount) {
          this.logger.verbose("No active account found, falling back to the host");
          return Promise.resolve(null);
        }
        this.logger.verbose("active account found, attempting to acquire token silently");
        const authRequest = {
          ...request,
          correlationId: request.correlationId || this.browserCrypto.createNewGuid(),
          authority: request.authority || currentAccount.environment,
          scopes: ((_a3 = request.scopes) == null ? void 0 : _a3.length) ? request.scopes : [...OIDC_DEFAULT_SCOPES]
        };
        const tokenKeys = this.browserStorage.getTokenKeys();
        const cachedAccessToken = this.browserStorage.getAccessToken(currentAccount, authRequest, tokenKeys, currentAccount.tenantId);
        if (!cachedAccessToken) {
          this.logger.verbose("No cached access token found");
          return Promise.resolve(null);
        } else if (TimeUtils_exports.wasClockTurnedBack(cachedAccessToken.cachedAt) || TimeUtils_exports.isTokenExpired(cachedAccessToken.expiresOn, this.config.system.tokenRenewalOffsetSeconds)) {
          this.logger.verbose("Cached access token has expired");
          return Promise.resolve(null);
        }
        const cachedIdToken = this.browserStorage.getIdToken(currentAccount, authRequest.correlationId, tokenKeys, currentAccount.tenantId, this.performanceClient);
        if (!cachedIdToken) {
          this.logger.verbose("No cached id token found");
          return Promise.resolve(null);
        }
        return this.nestedAppAuthAdapter.toAuthenticationResultFromCache(currentAccount, cachedIdToken, cachedAccessToken, authRequest, authRequest.correlationId);
      }
      /**
       * acquireTokenPopup flow implementation
       * @param request
       * @returns
       */
      async acquireTokenPopup(request) {
        return this.acquireTokenInteractive(request);
      }
      /**
       * acquireTokenRedirect flow is not supported in nested app auth
       * @param request
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      acquireTokenRedirect(request) {
        throw NestedAppAuthError.createUnsupportedError();
      }
      /**
       * acquireTokenSilent flow implementation
       * @param silentRequest
       * @returns
       */
      async acquireTokenSilent(silentRequest) {
        return this.acquireTokenSilentInternal(silentRequest);
      }
      /**
       * Hybrid flow is not currently supported in nested app auth
       * @param request
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      acquireTokenByCode(request) {
        throw NestedAppAuthError.createUnsupportedError();
      }
      /**
       * acquireTokenNative flow is not currently supported in nested app auth
       * @param request
       * @param apiId
       * @param accountId
       */
      acquireTokenNative(request, apiId, accountId) {
        throw NestedAppAuthError.createUnsupportedError();
      }
      /**
       * acquireTokenByRefreshToken flow is not currently supported in nested app auth
       * @param commonRequest
       * @param silentRequest
       */
      acquireTokenByRefreshToken(commonRequest, silentRequest) {
        throw NestedAppAuthError.createUnsupportedError();
      }
      /**
       * Adds event callbacks to array
       * @param callback
       * @param eventTypes
       */
      addEventCallback(callback, eventTypes) {
        return this.eventHandler.addEventCallback(callback, eventTypes);
      }
      /**
       * Removes callback with provided id from callback array
       * @param callbackId
       */
      removeEventCallback(callbackId) {
        this.eventHandler.removeEventCallback(callbackId);
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      addPerformanceCallback(callback) {
        throw NestedAppAuthError.createUnsupportedError();
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      removePerformanceCallback(callbackId) {
        throw NestedAppAuthError.createUnsupportedError();
      }
      enableAccountStorageEvents() {
        throw NestedAppAuthError.createUnsupportedError();
      }
      disableAccountStorageEvents() {
        throw NestedAppAuthError.createUnsupportedError();
      }
      // #region Account APIs
      /**
       * Returns all the accounts in the cache that match the optional filter. If no filter is provided, all accounts are returned.
       * @param accountFilter - (Optional) filter to narrow down the accounts returned
       * @returns Array of AccountInfo objects in cache
       */
      getAllAccounts(accountFilter) {
        const correlationId = this.browserCrypto.createNewGuid();
        return getAllAccounts(this.logger, this.browserStorage, this.isBrowserEnv(), correlationId, accountFilter);
      }
      /**
       * Returns the first account found in the cache that matches the account filter passed in.
       * @param accountFilter
       * @returns The first account found in the cache matching the provided filter or null if no account could be found.
       */
      getAccount(accountFilter) {
        const correlationId = this.browserCrypto.createNewGuid();
        return getAccount(accountFilter, this.logger, this.browserStorage, correlationId);
      }
      /**
       * Returns the signed in account matching username.
       * (the account object is created at the time of successful login)
       * or null when no matching account is found.
       * This API is provided for convenience but getAccountById should be used for best reliability
       * @param username
       * @returns The account object stored in MSAL
       */
      getAccountByUsername(username) {
        const correlationId = this.browserCrypto.createNewGuid();
        return getAccountByUsername(username, this.logger, this.browserStorage, correlationId);
      }
      /**
       * Returns the signed in account matching homeAccountId.
       * (the account object is created at the time of successful login)
       * or null when no matching account is found
       * @param homeAccountId
       * @returns The account object stored in MSAL
       */
      getAccountByHomeId(homeAccountId) {
        const correlationId = this.browserCrypto.createNewGuid();
        return getAccountByHomeId(homeAccountId, this.logger, this.browserStorage, correlationId);
      }
      /**
       * Returns the signed in account matching localAccountId.
       * (the account object is created at the time of successful login)
       * or null when no matching account is found
       * @param localAccountId
       * @returns The account object stored in MSAL
       */
      getAccountByLocalId(localAccountId) {
        const correlationId = this.browserCrypto.createNewGuid();
        return getAccountByLocalId(localAccountId, this.logger, this.browserStorage, correlationId);
      }
      /**
       * Sets the account to use as the active account. If no account is passed to the acquireToken APIs, then MSAL will use this active account.
       * @param account
       */
      setActiveAccount(account) {
        const correlationId = this.browserCrypto.createNewGuid();
        return setActiveAccount(account, this.browserStorage, correlationId);
      }
      /**
       * Gets the currently active account
       */
      getActiveAccount() {
        const correlationId = this.browserCrypto.createNewGuid();
        return getActiveAccount(this.browserStorage, correlationId);
      }
      // #endregion
      handleRedirectPromise(hash) {
        return Promise.resolve(null);
      }
      loginPopup(request) {
        return this.acquireTokenInteractive(request || DEFAULT_REQUEST);
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      loginRedirect(request) {
        throw NestedAppAuthError.createUnsupportedError();
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      logout(logoutRequest) {
        throw NestedAppAuthError.createUnsupportedError();
      }
      logoutRedirect(logoutRequest) {
        throw NestedAppAuthError.createUnsupportedError();
      }
      logoutPopup(logoutRequest) {
        throw NestedAppAuthError.createUnsupportedError();
      }
      ssoSilent(request) {
        return this.acquireTokenSilentInternal(request);
      }
      getTokenCache() {
        throw NestedAppAuthError.createUnsupportedError();
      }
      /**
       * Returns the logger instance
       */
      getLogger() {
        return this.logger;
      }
      /**
       * Replaces the default logger set in configurations with new Logger with new configurations
       * @param logger Logger instance
       */
      setLogger(logger24) {
        this.logger = logger24;
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      initializeWrapperLibrary(sku, version3) {
        return;
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      setNavigationClient(navigationClient) {
        this.logger.warning("setNavigationClient is not supported in nested app auth");
      }
      getConfiguration() {
        return this.config;
      }
      isBrowserEnv() {
        return this.operatingContext.isBrowserEnvironment();
      }
      getBrowserCrypto() {
        return this.browserCrypto;
      }
      getPerformanceClient() {
        throw NestedAppAuthError.createUnsupportedError();
      }
      getRedirectResponse() {
        throw NestedAppAuthError.createUnsupportedError();
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      async clearCache(logoutRequest) {
        throw NestedAppAuthError.createUnsupportedError();
      }
      async hydrateCache(result, request) {
        this.logger.verbose("hydrateCache called");
        const accountEntity = AccountEntity.createFromAccountInfo(result.account, result.cloudGraphHostName, result.msGraphHost);
        await this.browserStorage.setAccount(accountEntity, result.correlationId);
        return this.browserStorage.hydrateCache(result, request);
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/controllers/ControllerFactory.mjs
async function createV3Controller(config, request) {
  const standard = new StandardOperatingContext(config);
  await standard.initialize();
  return StandardController.createController(standard, request);
}
async function createController(config) {
  const standard = new StandardOperatingContext(config);
  const nestedApp = new NestedAppOperatingContext(config);
  const operatingContexts = [standard.initialize(), nestedApp.initialize()];
  await Promise.all(operatingContexts);
  if (nestedApp.isAvailable() && config.auth.supportsNestedAppAuth) {
    return NestedAppAuthController.createController(nestedApp);
  } else if (standard.isAvailable()) {
    return StandardController.createController(standard);
  } else {
    return null;
  }
}
var init_ControllerFactory = __esm({
  "node_modules/@azure/msal-browser/dist/controllers/ControllerFactory.mjs"() {
    "use strict";
    init_NestedAppOperatingContext();
    init_StandardOperatingContext();
    init_StandardController();
    init_NestedAppAuthController();
  }
});

// node_modules/@azure/msal-browser/dist/app/PublicClientApplication.mjs
async function createNestablePublicClientApplication(configuration) {
  const nestedAppAuth = new NestedAppOperatingContext(configuration);
  await nestedAppAuth.initialize();
  if (nestedAppAuth.isAvailable()) {
    const controller = new NestedAppAuthController(nestedAppAuth);
    const nestablePCA = new PublicClientApplication(configuration, controller);
    await nestablePCA.initialize();
    return nestablePCA;
  }
  return createStandardPublicClientApplication(configuration);
}
async function createStandardPublicClientApplication(configuration) {
  const pca = new PublicClientApplication(configuration);
  await pca.initialize();
  return pca;
}
var PublicClientApplication;
var init_PublicClientApplication = __esm({
  "node_modules/@azure/msal-browser/dist/app/PublicClientApplication.mjs"() {
    "use strict";
    init_ControllerFactory();
    init_StandardController();
    init_StandardOperatingContext();
    init_NestedAppAuthController();
    init_NestedAppOperatingContext();
    PublicClientApplication = class _PublicClientApplication {
      /**
       * Creates StandardController and passes it to the PublicClientApplication
       *
       * @param configuration {Configuration}
       */
      static async createPublicClientApplication(configuration) {
        const controller = await createV3Controller(configuration);
        const pca = new _PublicClientApplication(configuration, controller);
        return pca;
      }
      /**
       * @constructor
       * Constructor for the PublicClientApplication used to instantiate the PublicClientApplication object
       *
       * Important attributes in the Configuration object for auth are:
       * - clientID: the application ID of your application. You can obtain one by registering your application with our Application registration portal : https://portal.azure.com/#blade/Microsoft_AAD_IAM/ActiveDirectoryMenuBlade/RegisteredAppsPreview
       * - authority: the authority URL for your application.
       * - redirect_uri: the uri of your application registered in the portal.
       *
       * In Azure AD, authority is a URL indicating the Azure active directory that MSAL uses to obtain tokens.
       * It is of the form https://login.microsoftonline.com/{Enter_the_Tenant_Info_Here}
       * If your application supports Accounts in one organizational directory, replace "Enter_the_Tenant_Info_Here" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).
       * If your application supports Accounts in any organizational directory, replace "Enter_the_Tenant_Info_Here" value with organizations.
       * If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace "Enter_the_Tenant_Info_Here" value with common.
       * To restrict support to Personal Microsoft accounts only, replace "Enter_the_Tenant_Info_Here" value with consumers.
       *
       * In Azure B2C, authority is of the form https://{instance}/tfp/{tenant}/{policyName}/
       * Full B2C functionality will be available in this library in future versions.
       *
       * @param configuration Object for the MSAL PublicClientApplication instance
       * @param IController Optional parameter to explictly set the controller. (Will be removed when we remove public constructor)
       */
      constructor(configuration, controller) {
        this.isBroker = false;
        this.controller = controller || new StandardController(new StandardOperatingContext(configuration));
      }
      /**
       * Initializer function to perform async startup tasks such as connecting to WAM extension
       * @param request {?InitializeApplicationRequest}
       */
      async initialize(request) {
        return this.controller.initialize(request, this.isBroker);
      }
      /**
       * Use when you want to obtain an access_token for your API via opening a popup window in the user's browser
       *
       * @param request
       *
       * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.
       */
      async acquireTokenPopup(request) {
        return this.controller.acquireTokenPopup(request);
      }
      /**
       * Use when you want to obtain an access_token for your API by redirecting the user's browser window to the authorization endpoint. This function redirects
       * the page, so any code that follows this function will not execute.
       *
       * IMPORTANT: It is NOT recommended to have code that is dependent on the resolution of the Promise. This function will navigate away from the current
       * browser window. It currently returns a Promise in order to reflect the asynchronous nature of the code running in this function.
       *
       * @param request
       */
      acquireTokenRedirect(request) {
        return this.controller.acquireTokenRedirect(request);
      }
      /**
       * Silently acquire an access token for a given set of scopes. Returns currently processing promise if parallel requests are made.
       *
       * @param {@link (SilentRequest:type)}
       * @returns {Promise.<AuthenticationResult>} - a promise that is fulfilled when this function has completed, or rejected if an error was raised. Returns the {@link AuthenticationResult} object
       */
      acquireTokenSilent(silentRequest) {
        return this.controller.acquireTokenSilent(silentRequest);
      }
      /**
       * This function redeems an authorization code (passed as code) from the eSTS token endpoint.
       * This authorization code should be acquired server-side using a confidential client to acquire a spa_code.
       * This API is not indended for normal authorization code acquisition and redemption.
       *
       * Redemption of this authorization code will not require PKCE, as it was acquired by a confidential client.
       *
       * @param request {@link AuthorizationCodeRequest}
       * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.
       */
      acquireTokenByCode(request) {
        return this.controller.acquireTokenByCode(request);
      }
      /**
       * Adds event callbacks to array
       * @param callback
       * @param eventTypes
       */
      addEventCallback(callback, eventTypes) {
        return this.controller.addEventCallback(callback, eventTypes);
      }
      /**
       * Removes callback with provided id from callback array
       * @param callbackId
       */
      removeEventCallback(callbackId) {
        return this.controller.removeEventCallback(callbackId);
      }
      /**
       * Registers a callback to receive performance events.
       *
       * @param {PerformanceCallbackFunction} callback
       * @returns {string}
       */
      addPerformanceCallback(callback) {
        return this.controller.addPerformanceCallback(callback);
      }
      /**
       * Removes a callback registered with addPerformanceCallback.
       *
       * @param {string} callbackId
       * @returns {boolean}
       */
      removePerformanceCallback(callbackId) {
        return this.controller.removePerformanceCallback(callbackId);
      }
      /**
       * Adds event listener that emits an event when a user account is added or removed from localstorage in a different browser tab or window
       */
      enableAccountStorageEvents() {
        this.controller.enableAccountStorageEvents();
      }
      /**
       * Removes event listener that emits an event when a user account is added or removed from localstorage in a different browser tab or window
       */
      disableAccountStorageEvents() {
        this.controller.disableAccountStorageEvents();
      }
      /**
       * Returns the first account found in the cache that matches the account filter passed in.
       * @param accountFilter
       * @returns The first account found in the cache matching the provided filter or null if no account could be found.
       */
      getAccount(accountFilter) {
        return this.controller.getAccount(accountFilter);
      }
      /**
       * Returns the signed in account matching homeAccountId.
       * (the account object is created at the time of successful login)
       * or null when no matching account is found
       * @param homeAccountId
       * @returns The account object stored in MSAL
       * @deprecated - Use getAccount instead
       */
      getAccountByHomeId(homeAccountId) {
        return this.controller.getAccountByHomeId(homeAccountId);
      }
      /**
       * Returns the signed in account matching localAccountId.
       * (the account object is created at the time of successful login)
       * or null when no matching account is found
       * @param localAccountId
       * @returns The account object stored in MSAL
       * @deprecated - Use getAccount instead
       */
      getAccountByLocalId(localId) {
        return this.controller.getAccountByLocalId(localId);
      }
      /**
       * Returns the signed in account matching username.
       * (the account object is created at the time of successful login)
       * or null when no matching account is found.
       * This API is provided for convenience but getAccountById should be used for best reliability
       * @param userName
       * @returns The account object stored in MSAL
       * @deprecated - Use getAccount instead
       */
      getAccountByUsername(userName) {
        return this.controller.getAccountByUsername(userName);
      }
      /**
       * Returns all the accounts in the cache that match the optional filter. If no filter is provided, all accounts are returned.
       * @param accountFilter - (Optional) filter to narrow down the accounts returned
       * @returns Array of AccountInfo objects in cache
       */
      getAllAccounts(accountFilter) {
        return this.controller.getAllAccounts(accountFilter);
      }
      /**
       * Event handler function which allows users to fire events after the PublicClientApplication object
       * has loaded during redirect flows. This should be invoked on all page loads involved in redirect
       * auth flows.
       * @param hash Hash to process. Defaults to the current value of window.location.hash. Only needs to be provided explicitly if the response to be handled is not contained in the current value.
       * @returns Token response or null. If the return value is null, then no auth redirect was detected.
       */
      handleRedirectPromise(hash) {
        return this.controller.handleRedirectPromise(hash);
      }
      /**
       * Use when initiating the login process via opening a popup window in the user's browser
       *
       * @param request
       *
       * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.
       */
      loginPopup(request) {
        return this.controller.loginPopup(request);
      }
      /**
       * Use when initiating the login process by redirecting the user's browser to the authorization endpoint. This function redirects the page, so
       * any code that follows this function will not execute.
       *
       * IMPORTANT: It is NOT recommended to have code that is dependent on the resolution of the Promise. This function will navigate away from the current
       * browser window. It currently returns a Promise in order to reflect the asynchronous nature of the code running in this function.
       *
       * @param request
       */
      loginRedirect(request) {
        return this.controller.loginRedirect(request);
      }
      /**
       * Deprecated logout function. Use logoutRedirect or logoutPopup instead
       * @param logoutRequest
       * @deprecated
       */
      logout(logoutRequest) {
        return this.controller.logout(logoutRequest);
      }
      /**
       * Use to log out the current user, and redirect the user to the postLogoutRedirectUri.
       * Default behaviour is to redirect the user to `window.location.href`.
       * @param logoutRequest
       */
      logoutRedirect(logoutRequest) {
        return this.controller.logoutRedirect(logoutRequest);
      }
      /**
       * Clears local cache for the current user then opens a popup window prompting the user to sign-out of the server
       * @param logoutRequest
       */
      logoutPopup(logoutRequest) {
        return this.controller.logoutPopup(logoutRequest);
      }
      /**
       * This function uses a hidden iframe to fetch an authorization code from the eSTS. There are cases where this may not work:
       * - Any browser using a form of Intelligent Tracking Prevention
       * - If there is not an established session with the service
       *
       * In these cases, the request must be done inside a popup or full frame redirect.
       *
       * For the cases where interaction is required, you cannot send a request with prompt=none.
       *
       * If your refresh token has expired, you can use this function to fetch a new set of tokens silently as long as
       * you session on the server still exists.
       * @param request {@link SsoSilentRequest}
       *
       * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.
       */
      ssoSilent(request) {
        return this.controller.ssoSilent(request);
      }
      /**
       * Gets the token cache for the application.
       */
      getTokenCache() {
        return this.controller.getTokenCache();
      }
      /**
       * Returns the logger instance
       */
      getLogger() {
        return this.controller.getLogger();
      }
      /**
       * Replaces the default logger set in configurations with new Logger with new configurations
       * @param logger Logger instance
       */
      setLogger(logger24) {
        this.controller.setLogger(logger24);
      }
      /**
       * Sets the account to use as the active account. If no account is passed to the acquireToken APIs, then MSAL will use this active account.
       * @param account
       */
      setActiveAccount(account) {
        this.controller.setActiveAccount(account);
      }
      /**
       * Gets the currently active account
       */
      getActiveAccount() {
        return this.controller.getActiveAccount();
      }
      /**
       * Called by wrapper libraries (Angular & React) to set SKU and Version passed down to telemetry, logger, etc.
       * @param sku
       * @param version
       */
      initializeWrapperLibrary(sku, version3) {
        return this.controller.initializeWrapperLibrary(sku, version3);
      }
      /**
       * Sets navigation client
       * @param navigationClient
       */
      setNavigationClient(navigationClient) {
        this.controller.setNavigationClient(navigationClient);
      }
      /**
       * Returns the configuration object
       * @internal
       */
      getConfiguration() {
        return this.controller.getConfiguration();
      }
      /**
       * Hydrates cache with the tokens and account in the AuthenticationResult object
       * @param result
       * @param request - The request object that was used to obtain the AuthenticationResult
       * @returns
       */
      async hydrateCache(result, request) {
        return this.controller.hydrateCache(result, request);
      }
      /**
       * Clears tokens and account from the browser cache.
       * @param logoutRequest
       */
      clearCache(logoutRequest) {
        return this.controller.clearCache(logoutRequest);
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/controllers/UnknownOperatingContextController.mjs
var UnknownOperatingContextController;
var init_UnknownOperatingContextController = __esm({
  "node_modules/@azure/msal-browser/dist/controllers/UnknownOperatingContextController.mjs"() {
    "use strict";
    init_index_browser();
    init_BrowserCacheManager();
    init_CryptoOps();
    init_BrowserUtils();
    init_EventHandler();
    UnknownOperatingContextController = class {
      constructor(operatingContext) {
        this.initialized = false;
        this.operatingContext = operatingContext;
        this.isBrowserEnvironment = this.operatingContext.isBrowserEnvironment();
        this.config = operatingContext.getConfig();
        this.logger = operatingContext.getLogger();
        this.performanceClient = this.config.telemetry.client;
        this.browserCrypto = this.isBrowserEnvironment ? new CryptoOps(this.logger, this.performanceClient) : DEFAULT_CRYPTO_IMPLEMENTATION;
        this.eventHandler = new EventHandler(this.logger);
        this.browserStorage = this.isBrowserEnvironment ? new BrowserCacheManager(this.config.auth.clientId, this.config.cache, this.browserCrypto, this.logger, this.performanceClient, this.eventHandler, void 0) : DEFAULT_BROWSER_CACHE_MANAGER(this.config.auth.clientId, this.logger, this.performanceClient, this.eventHandler);
      }
      getBrowserStorage() {
        return this.browserStorage;
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getAccount(accountFilter) {
        return null;
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getAccountByHomeId(homeAccountId) {
        return null;
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getAccountByLocalId(localAccountId) {
        return null;
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getAccountByUsername(username) {
        return null;
      }
      getAllAccounts() {
        return [];
      }
      initialize() {
        this.initialized = true;
        return Promise.resolve();
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      acquireTokenPopup(request) {
        blockAPICallsBeforeInitialize(this.initialized);
        blockNonBrowserEnvironment();
        return {};
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      acquireTokenRedirect(request) {
        blockAPICallsBeforeInitialize(this.initialized);
        blockNonBrowserEnvironment();
        return Promise.resolve();
      }
      acquireTokenSilent(silentRequest) {
        blockAPICallsBeforeInitialize(this.initialized);
        blockNonBrowserEnvironment();
        return {};
      }
      acquireTokenByCode(request) {
        blockAPICallsBeforeInitialize(this.initialized);
        blockNonBrowserEnvironment();
        return {};
      }
      acquireTokenNative(request, apiId, accountId) {
        blockAPICallsBeforeInitialize(this.initialized);
        blockNonBrowserEnvironment();
        return {};
      }
      acquireTokenByRefreshToken(commonRequest, silentRequest) {
        blockAPICallsBeforeInitialize(this.initialized);
        blockNonBrowserEnvironment();
        return {};
      }
      addEventCallback(callback, eventTypes) {
        return null;
      }
      removeEventCallback(callbackId) {
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      addPerformanceCallback(callback) {
        blockAPICallsBeforeInitialize(this.initialized);
        blockNonBrowserEnvironment();
        return "";
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      removePerformanceCallback(callbackId) {
        blockAPICallsBeforeInitialize(this.initialized);
        blockNonBrowserEnvironment();
        return true;
      }
      enableAccountStorageEvents() {
        blockAPICallsBeforeInitialize(this.initialized);
        blockNonBrowserEnvironment();
      }
      disableAccountStorageEvents() {
        blockAPICallsBeforeInitialize(this.initialized);
        blockNonBrowserEnvironment();
      }
      handleRedirectPromise(hash) {
        blockAPICallsBeforeInitialize(this.initialized);
        return Promise.resolve(null);
      }
      loginPopup(request) {
        blockAPICallsBeforeInitialize(this.initialized);
        blockNonBrowserEnvironment();
        return {};
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      loginRedirect(request) {
        blockAPICallsBeforeInitialize(this.initialized);
        blockNonBrowserEnvironment();
        return {};
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      logout(logoutRequest) {
        blockAPICallsBeforeInitialize(this.initialized);
        blockNonBrowserEnvironment();
        return {};
      }
      logoutRedirect(logoutRequest) {
        blockAPICallsBeforeInitialize(this.initialized);
        blockNonBrowserEnvironment();
        return {};
      }
      logoutPopup(logoutRequest) {
        blockAPICallsBeforeInitialize(this.initialized);
        blockNonBrowserEnvironment();
        return {};
      }
      ssoSilent(request) {
        blockAPICallsBeforeInitialize(this.initialized);
        blockNonBrowserEnvironment();
        return {};
      }
      getTokenCache() {
        blockAPICallsBeforeInitialize(this.initialized);
        blockNonBrowserEnvironment();
        return {};
      }
      getLogger() {
        return this.logger;
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      setLogger(logger24) {
        blockAPICallsBeforeInitialize(this.initialized);
        blockNonBrowserEnvironment();
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      setActiveAccount(account) {
        blockAPICallsBeforeInitialize(this.initialized);
        blockNonBrowserEnvironment();
      }
      getActiveAccount() {
        blockAPICallsBeforeInitialize(this.initialized);
        blockNonBrowserEnvironment();
        return null;
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      initializeWrapperLibrary(sku, version3) {
        this.browserStorage.setWrapperMetadata(sku, version3);
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      setNavigationClient(navigationClient) {
        blockAPICallsBeforeInitialize(this.initialized);
        blockNonBrowserEnvironment();
      }
      getConfiguration() {
        return this.config;
      }
      isBrowserEnv() {
        blockAPICallsBeforeInitialize(this.initialized);
        blockNonBrowserEnvironment();
        return true;
      }
      getBrowserCrypto() {
        blockAPICallsBeforeInitialize(this.initialized);
        blockNonBrowserEnvironment();
        return {};
      }
      getPerformanceClient() {
        blockAPICallsBeforeInitialize(this.initialized);
        blockNonBrowserEnvironment();
        return {};
      }
      getRedirectResponse() {
        blockAPICallsBeforeInitialize(this.initialized);
        blockNonBrowserEnvironment();
        return {};
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      async clearCache(logoutRequest) {
        blockAPICallsBeforeInitialize(this.initialized);
        blockNonBrowserEnvironment();
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      async hydrateCache(result, request) {
        blockAPICallsBeforeInitialize(this.initialized);
        blockNonBrowserEnvironment();
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/operatingcontext/UnknownOperatingContext.mjs
var UnknownOperatingContext;
var init_UnknownOperatingContext = __esm({
  "node_modules/@azure/msal-browser/dist/operatingcontext/UnknownOperatingContext.mjs"() {
    "use strict";
    init_BaseOperatingContext();
    UnknownOperatingContext = class _UnknownOperatingContext extends BaseOperatingContext {
      /**
       * Returns the unique identifier for this operating context
       * @returns string
       */
      getId() {
        return _UnknownOperatingContext.ID;
      }
      /**
       * Return the module name.  Intended for use with import() to enable dynamic import
       * of the implementation associated with this operating context
       * @returns
       */
      getModuleName() {
        return _UnknownOperatingContext.MODULE_NAME;
      }
      /**
       * Checks whether the operating context is available.
       * Confirms that the code is running a browser rather.  This is required.
       * @returns Promise<boolean> indicating whether this operating context is currently available.
       */
      async initialize() {
        return true;
      }
    };
    UnknownOperatingContext.MODULE_NAME = "";
    UnknownOperatingContext.ID = "UnknownOperatingContext";
  }
});

// node_modules/@azure/msal-browser/dist/app/PublicClientNext.mjs
var PublicClientNext;
var init_PublicClientNext = __esm({
  "node_modules/@azure/msal-browser/dist/app/PublicClientNext.mjs"() {
    "use strict";
    init_ControllerFactory();
    init_UnknownOperatingContextController();
    init_UnknownOperatingContext();
    PublicClientNext = class _PublicClientNext {
      static async createPublicClientApplication(configuration) {
        const controller = await createController(configuration);
        let pca;
        if (controller !== null) {
          pca = new _PublicClientNext(configuration, controller);
        } else {
          pca = new _PublicClientNext(configuration);
        }
        return pca;
      }
      /**
       * @constructor
       * Constructor for the PublicClientNext used to instantiate the PublicClientNext object
       *
       * Important attributes in the Configuration object for auth are:
       * - clientID: the application ID of your application. You can obtain one by registering your application with our Application registration portal : https://portal.azure.com/#blade/Microsoft_AAD_IAM/ActiveDirectoryMenuBlade/RegisteredAppsPreview
       * - authority: the authority URL for your application.
       * - redirect_uri: the uri of your application registered in the portal.
       *
       * In Azure AD, authority is a URL indicating the Azure active directory that MSAL uses to obtain tokens.
       * It is of the form https://login.microsoftonline.com/{Enter_the_Tenant_Info_Here}
       * If your application supports Accounts in one organizational directory, replace "Enter_the_Tenant_Info_Here" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).
       * If your application supports Accounts in any organizational directory, replace "Enter_the_Tenant_Info_Here" value with organizations.
       * If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace "Enter_the_Tenant_Info_Here" value with common.
       * To restrict support to Personal Microsoft accounts only, replace "Enter_the_Tenant_Info_Here" value with consumers.
       *
       * In Azure B2C, authority is of the form https://{instance}/tfp/{tenant}/{policyName}/
       * Full B2C functionality will be available in this library in future versions.
       *
       * @param configuration Object for the MSAL PublicClientApplication instance
       * @param IController Optional parameter to explictly set the controller. (Will be removed when we remove public constructor)
       */
      constructor(configuration, controller) {
        this.configuration = configuration;
        if (controller) {
          this.controller = controller;
        } else {
          const operatingContext = new UnknownOperatingContext(configuration);
          this.controller = new UnknownOperatingContextController(operatingContext);
        }
      }
      /**
       * Initializer function to perform async startup tasks such as connecting to WAM extension
       */
      async initialize() {
        if (this.controller instanceof UnknownOperatingContextController) {
          const result = await createController(this.configuration);
          if (result !== null) {
            this.controller = result;
          }
          return this.controller.initialize();
        }
        return Promise.resolve();
      }
      /**
       * Use when you want to obtain an access_token for your API via opening a popup window in the user's browser
       *
       * @param request
       *
       * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.
       */
      async acquireTokenPopup(request) {
        return this.controller.acquireTokenPopup(request);
      }
      /**
       * Use when you want to obtain an access_token for your API by redirecting the user's browser window to the authorization endpoint. This function redirects
       * the page, so any code that follows this function will not execute.
       *
       * IMPORTANT: It is NOT recommended to have code that is dependent on the resolution of the Promise. This function will navigate away from the current
       * browser window. It currently returns a Promise in order to reflect the asynchronous nature of the code running in this function.
       *
       * @param request
       */
      acquireTokenRedirect(request) {
        return this.controller.acquireTokenRedirect(request);
      }
      /**
       * Silently acquire an access token for a given set of scopes. Returns currently processing promise if parallel requests are made.
       *
       * @param {@link (SilentRequest:type)}
       * @returns {Promise.<AuthenticationResult>} - a promise that is fulfilled when this function has completed, or rejected if an error was raised. Returns the {@link AuthenticationResult} object
       */
      acquireTokenSilent(silentRequest) {
        return this.controller.acquireTokenSilent(silentRequest);
      }
      /**
       * This function redeems an authorization code (passed as code) from the eSTS token endpoint.
       * This authorization code should be acquired server-side using a confidential client to acquire a spa_code.
       * This API is not indended for normal authorization code acquisition and redemption.
       *
       * Redemption of this authorization code will not require PKCE, as it was acquired by a confidential client.
       *
       * @param request {@link AuthorizationCodeRequest}
       * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.
       */
      acquireTokenByCode(request) {
        return this.controller.acquireTokenByCode(request);
      }
      /**
       * Adds event callbacks to array
       * @param callback
       */
      addEventCallback(callback, eventTypes) {
        return this.controller.addEventCallback(callback, eventTypes);
      }
      /**
       * Removes callback with provided id from callback array
       * @param callbackId
       */
      removeEventCallback(callbackId) {
        return this.controller.removeEventCallback(callbackId);
      }
      /**
       * Registers a callback to receive performance events.
       *
       * @param {PerformanceCallbackFunction} callback
       * @returns {string}
       */
      addPerformanceCallback(callback) {
        return this.controller.addPerformanceCallback(callback);
      }
      /**
       * Removes a callback registered with addPerformanceCallback.
       *
       * @param {string} callbackId
       * @returns {boolean}
       */
      removePerformanceCallback(callbackId) {
        return this.controller.removePerformanceCallback(callbackId);
      }
      /**
       * Adds event listener that emits an event when a user account is added or removed from localstorage in a different browser tab or window
       */
      enableAccountStorageEvents() {
        this.controller.enableAccountStorageEvents();
      }
      /**
       * Removes event listener that emits an event when a user account is added or removed from localstorage in a different browser tab or window
       */
      disableAccountStorageEvents() {
        this.controller.disableAccountStorageEvents();
      }
      /**
       * Returns the first account found in the cache that matches the account filter passed in.
       * @param accountFilter
       * @returns The first account found in the cache matching the provided filter or null if no account could be found.
       */
      getAccount(accountFilter) {
        return this.controller.getAccount(accountFilter);
      }
      /**
       * Returns the signed in account matching homeAccountId.
       * (the account object is created at the time of successful login)
       * or null when no matching account is found
       * @param homeAccountId
       * @returns The account object stored in MSAL
       * @deprecated - Use getAccount instead
       */
      getAccountByHomeId(homeAccountId) {
        return this.controller.getAccountByHomeId(homeAccountId);
      }
      /**
       * Returns the signed in account matching localAccountId.
       * (the account object is created at the time of successful login)
       * or null when no matching account is found
       * @param localAccountId
       * @returns The account object stored in MSAL
       * @deprecated - Use getAccount instead
       */
      getAccountByLocalId(localId) {
        return this.controller.getAccountByLocalId(localId);
      }
      /**
       * Returns the signed in account matching username.
       * (the account object is created at the time of successful login)
       * or null when no matching account is found.
       * This API is provided for convenience but getAccountById should be used for best reliability
       * @param userName
       * @returns The account object stored in MSAL
       * @deprecated - Use getAccount instead
       */
      getAccountByUsername(userName) {
        return this.controller.getAccountByUsername(userName);
      }
      /**
       * Returns all the accounts in the cache that match the optional filter. If no filter is provided, all accounts are returned.
       * @param accountFilter - (Optional) filter to narrow down the accounts returned
       * @returns Array of AccountInfo objects in cache
       */
      getAllAccounts(accountFilter) {
        return this.controller.getAllAccounts(accountFilter);
      }
      /**
       * Event handler function which allows users to fire events after the PublicClientApplication object
       * has loaded during redirect flows. This should be invoked on all page loads involved in redirect
       * auth flows.
       * @param hash Hash to process. Defaults to the current value of window.location.hash. Only needs to be provided explicitly if the response to be handled is not contained in the current value.
       * @returns Token response or null. If the return value is null, then no auth redirect was detected.
       */
      handleRedirectPromise(hash) {
        return this.controller.handleRedirectPromise(hash);
      }
      /**
       * Use when initiating the login process via opening a popup window in the user's browser
       *
       * @param request
       *
       * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.
       */
      loginPopup(request) {
        return this.controller.loginPopup(request);
      }
      /**
       * Use when initiating the login process by redirecting the user's browser to the authorization endpoint. This function redirects the page, so
       * any code that follows this function will not execute.
       *
       * IMPORTANT: It is NOT recommended to have code that is dependent on the resolution of the Promise. This function will navigate away from the current
       * browser window. It currently returns a Promise in order to reflect the asynchronous nature of the code running in this function.
       *
       * @param request
       */
      loginRedirect(request) {
        return this.controller.loginRedirect(request);
      }
      /**
       * Deprecated logout function. Use logoutRedirect or logoutPopup instead
       * @param logoutRequest
       * @deprecated
       */
      logout(logoutRequest) {
        return this.controller.logout(logoutRequest);
      }
      /**
       * Use to log out the current user, and redirect the user to the postLogoutRedirectUri.
       * Default behaviour is to redirect the user to `window.location.href`.
       * @param logoutRequest
       */
      logoutRedirect(logoutRequest) {
        return this.controller.logoutRedirect(logoutRequest);
      }
      /**
       * Clears local cache for the current user then opens a popup window prompting the user to sign-out of the server
       * @param logoutRequest
       */
      logoutPopup(logoutRequest) {
        return this.controller.logoutPopup(logoutRequest);
      }
      /**
       * This function uses a hidden iframe to fetch an authorization code from the eSTS. There are cases where this may not work:
       * - Any browser using a form of Intelligent Tracking Prevention
       * - If there is not an established session with the service
       *
       * In these cases, the request must be done inside a popup or full frame redirect.
       *
       * For the cases where interaction is required, you cannot send a request with prompt=none.
       *
       * If your refresh token has expired, you can use this function to fetch a new set of tokens silently as long as
       * you session on the server still exists.
       * @param request {@link SsoSilentRequest}
       *
       * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.
       */
      ssoSilent(request) {
        return this.controller.ssoSilent(request);
      }
      /**
       * Gets the token cache for the application.
       */
      getTokenCache() {
        return this.controller.getTokenCache();
      }
      /**
       * Returns the logger instance
       */
      getLogger() {
        return this.controller.getLogger();
      }
      /**
       * Replaces the default logger set in configurations with new Logger with new configurations
       * @param logger Logger instance
       */
      setLogger(logger24) {
        this.controller.setLogger(logger24);
      }
      /**
       * Sets the account to use as the active account. If no account is passed to the acquireToken APIs, then MSAL will use this active account.
       * @param account
       */
      setActiveAccount(account) {
        this.controller.setActiveAccount(account);
      }
      /**
       * Gets the currently active account
       */
      getActiveAccount() {
        return this.controller.getActiveAccount();
      }
      /**
       * Called by wrapper libraries (Angular & React) to set SKU and Version passed down to telemetry, logger, etc.
       * @param sku
       * @param version
       */
      initializeWrapperLibrary(sku, version3) {
        return this.controller.initializeWrapperLibrary(sku, version3);
      }
      /**
       * Sets navigation client
       * @param navigationClient
       */
      setNavigationClient(navigationClient) {
        this.controller.setNavigationClient(navigationClient);
      }
      /**
       * Returns the configuration object
       * @internal
       */
      getConfiguration() {
        return this.controller.getConfiguration();
      }
      /**
       * Hydrates cache with the tokens and account in the AuthenticationResult object
       * @param result
       * @param request - The request object that was used to obtain the AuthenticationResult
       * @returns
       */
      async hydrateCache(result, request) {
        return this.controller.hydrateCache(result, request);
      }
      /**
       * Clears tokens and account from the browser cache.
       * @param logoutRequest
       */
      clearCache(logoutRequest) {
        return this.controller.clearCache(logoutRequest);
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/app/IPublicClientApplication.mjs
var stubbedPublicClientApplication;
var init_IPublicClientApplication = __esm({
  "node_modules/@azure/msal-browser/dist/app/IPublicClientApplication.mjs"() {
    "use strict";
    init_BrowserConfigurationAuthError();
    init_BrowserConfigurationAuthErrorCodes();
    stubbedPublicClientApplication = {
      initialize: () => {
        return Promise.reject(createBrowserConfigurationAuthError(stubbedPublicClientApplicationCalled));
      },
      acquireTokenPopup: () => {
        return Promise.reject(createBrowserConfigurationAuthError(stubbedPublicClientApplicationCalled));
      },
      acquireTokenRedirect: () => {
        return Promise.reject(createBrowserConfigurationAuthError(stubbedPublicClientApplicationCalled));
      },
      acquireTokenSilent: () => {
        return Promise.reject(createBrowserConfigurationAuthError(stubbedPublicClientApplicationCalled));
      },
      acquireTokenByCode: () => {
        return Promise.reject(createBrowserConfigurationAuthError(stubbedPublicClientApplicationCalled));
      },
      getAllAccounts: () => {
        return [];
      },
      getAccount: () => {
        return null;
      },
      getAccountByHomeId: () => {
        return null;
      },
      getAccountByUsername: () => {
        return null;
      },
      getAccountByLocalId: () => {
        return null;
      },
      handleRedirectPromise: () => {
        return Promise.reject(createBrowserConfigurationAuthError(stubbedPublicClientApplicationCalled));
      },
      loginPopup: () => {
        return Promise.reject(createBrowserConfigurationAuthError(stubbedPublicClientApplicationCalled));
      },
      loginRedirect: () => {
        return Promise.reject(createBrowserConfigurationAuthError(stubbedPublicClientApplicationCalled));
      },
      logout: () => {
        return Promise.reject(createBrowserConfigurationAuthError(stubbedPublicClientApplicationCalled));
      },
      logoutRedirect: () => {
        return Promise.reject(createBrowserConfigurationAuthError(stubbedPublicClientApplicationCalled));
      },
      logoutPopup: () => {
        return Promise.reject(createBrowserConfigurationAuthError(stubbedPublicClientApplicationCalled));
      },
      ssoSilent: () => {
        return Promise.reject(createBrowserConfigurationAuthError(stubbedPublicClientApplicationCalled));
      },
      addEventCallback: () => {
        return null;
      },
      removeEventCallback: () => {
        return;
      },
      addPerformanceCallback: () => {
        return "";
      },
      removePerformanceCallback: () => {
        return false;
      },
      enableAccountStorageEvents: () => {
        return;
      },
      disableAccountStorageEvents: () => {
        return;
      },
      getTokenCache: () => {
        throw createBrowserConfigurationAuthError(stubbedPublicClientApplicationCalled);
      },
      getLogger: () => {
        throw createBrowserConfigurationAuthError(stubbedPublicClientApplicationCalled);
      },
      setLogger: () => {
        return;
      },
      setActiveAccount: () => {
        return;
      },
      getActiveAccount: () => {
        return null;
      },
      initializeWrapperLibrary: () => {
        return;
      },
      setNavigationClient: () => {
        return;
      },
      getConfiguration: () => {
        throw createBrowserConfigurationAuthError(stubbedPublicClientApplicationCalled);
      },
      hydrateCache: () => {
        return Promise.reject(createBrowserConfigurationAuthError(stubbedPublicClientApplicationCalled));
      },
      clearCache: () => {
        return Promise.reject(createBrowserConfigurationAuthError(stubbedPublicClientApplicationCalled));
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/event/EventMessage.mjs
var EventMessageUtils;
var init_EventMessage = __esm({
  "node_modules/@azure/msal-browser/dist/event/EventMessage.mjs"() {
    "use strict";
    init_EventType();
    init_BrowserConstants();
    EventMessageUtils = class {
      /**
       * Gets interaction status from event message
       * @param message
       * @param currentStatus
       */
      static getInteractionStatusFromEvent(message, currentStatus) {
        switch (message.eventType) {
          case EventType.LOGIN_START:
            return InteractionStatus.Login;
          case EventType.SSO_SILENT_START:
            return InteractionStatus.SsoSilent;
          case EventType.ACQUIRE_TOKEN_START:
            if (message.interactionType === InteractionType.Redirect || message.interactionType === InteractionType.Popup) {
              return InteractionStatus.AcquireToken;
            }
            break;
          case EventType.HANDLE_REDIRECT_START:
            return InteractionStatus.HandleRedirect;
          case EventType.LOGOUT_START:
            return InteractionStatus.Logout;
          case EventType.SSO_SILENT_SUCCESS:
          case EventType.SSO_SILENT_FAILURE:
            if (currentStatus && currentStatus !== InteractionStatus.SsoSilent) {
              break;
            }
            return InteractionStatus.None;
          case EventType.LOGOUT_END:
            if (currentStatus && currentStatus !== InteractionStatus.Logout) {
              break;
            }
            return InteractionStatus.None;
          case EventType.HANDLE_REDIRECT_END:
            if (currentStatus && currentStatus !== InteractionStatus.HandleRedirect) {
              break;
            }
            return InteractionStatus.None;
          case EventType.LOGIN_SUCCESS:
          case EventType.LOGIN_FAILURE:
          case EventType.ACQUIRE_TOKEN_SUCCESS:
          case EventType.ACQUIRE_TOKEN_FAILURE:
          case EventType.RESTORE_FROM_BFCACHE:
            if (message.interactionType === InteractionType.Redirect || message.interactionType === InteractionType.Popup) {
              if (currentStatus && currentStatus !== InteractionStatus.Login && currentStatus !== InteractionStatus.AcquireToken) {
                break;
              }
              return InteractionStatus.None;
            }
            break;
        }
        return null;
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/crypto/SignedHttpRequest.mjs
var SignedHttpRequest;
var init_SignedHttpRequest = __esm({
  "node_modules/@azure/msal-browser/dist/crypto/SignedHttpRequest.mjs"() {
    "use strict";
    init_CryptoOps();
    init_index_browser();
    init_packageMetadata2();
    SignedHttpRequest = class {
      constructor(shrParameters, shrOptions) {
        const loggerOptions = shrOptions && shrOptions.loggerOptions || {};
        this.logger = new Logger(loggerOptions, name2, version2);
        this.cryptoOps = new CryptoOps(this.logger);
        this.popTokenGenerator = new PopTokenGenerator(this.cryptoOps);
        this.shrParameters = shrParameters;
      }
      /**
       * Generates and caches a keypair for the given request options.
       * @returns Public key digest, which should be sent to the token issuer.
       */
      async generatePublicKeyThumbprint() {
        const { kid } = await this.popTokenGenerator.generateKid(this.shrParameters);
        return kid;
      }
      /**
       * Generates a signed http request for the given payload with the given key.
       * @param payload Payload to sign (e.g. access token)
       * @param publicKeyThumbprint Public key digest (from generatePublicKeyThumbprint API)
       * @param claims Additional claims to include/override in the signed JWT
       * @returns Pop token signed with the corresponding private key
       */
      async signRequest(payload, publicKeyThumbprint, claims) {
        return this.popTokenGenerator.signPayload(payload, publicKeyThumbprint, this.shrParameters, claims);
      }
      /**
       * Removes cached keys from browser for given public key thumbprint
       * @param publicKeyThumbprint Public key digest (from generatePublicKeyThumbprint API)
       * @returns If keys are properly deleted
       */
      async removeKeys(publicKeyThumbprint) {
        return this.cryptoOps.removeTokenBindingKey(publicKeyThumbprint).then(() => true).catch((error) => {
          if (error instanceof ClientAuthError && error.errorCode === ClientAuthErrorCodes_exports.bindingKeyNotRemoved) {
            return false;
          }
          throw error;
        });
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/telemetry/BrowserPerformanceClient.mjs
function getPerfMeasurementModule() {
  let sessionStorage;
  try {
    sessionStorage = window[BrowserCacheLocation.SessionStorage];
    const perfEnabled = sessionStorage == null ? void 0 : sessionStorage.getItem(BROWSER_PERF_ENABLED_KEY);
    if (Number(perfEnabled) === 1) {
      return import("./BrowserPerformanceMeasurement-CH7WY3WE.js");
    }
  } catch (e) {
  }
  return void 0;
}
function supportsBrowserPerformanceNow() {
  return typeof window !== "undefined" && typeof window.performance !== "undefined" && typeof window.performance.now === "function";
}
function getPerfDurationMs(startTime) {
  if (!startTime || !supportsBrowserPerformanceNow()) {
    return void 0;
  }
  return Math.round(window.performance.now() - startTime);
}
var BrowserPerformanceClient;
var init_BrowserPerformanceClient = __esm({
  "node_modules/@azure/msal-browser/dist/telemetry/BrowserPerformanceClient.mjs"() {
    "use strict";
    init_index_browser();
    init_packageMetadata2();
    init_BrowserConstants();
    init_BrowserCrypto();
    BrowserPerformanceClient = class extends PerformanceClient {
      constructor(configuration, intFields, abbreviations) {
        var _a3, _b2;
        super(configuration.auth.clientId, configuration.auth.authority || `${Constants.DEFAULT_AUTHORITY}`, new Logger(((_a3 = configuration.system) == null ? void 0 : _a3.loggerOptions) || {}, name2, version2), name2, version2, ((_b2 = configuration.telemetry) == null ? void 0 : _b2.application) || {
          appName: "",
          appVersion: ""
        }, intFields, abbreviations);
      }
      generateId() {
        return createNewGuid();
      }
      getPageVisibility() {
        var _a3;
        return ((_a3 = document.visibilityState) == null ? void 0 : _a3.toString()) || null;
      }
      deleteIncompleteSubMeasurements(inProgressEvent) {
        var _a3;
        void ((_a3 = getPerfMeasurementModule()) == null ? void 0 : _a3.then((module) => {
          const rootEvent = this.eventsByCorrelationId.get(inProgressEvent.event.correlationId);
          const isRootEvent = rootEvent && rootEvent.eventId === inProgressEvent.event.eventId;
          const incompleteMeasurements = [];
          if (isRootEvent && (rootEvent == null ? void 0 : rootEvent.incompleteSubMeasurements)) {
            rootEvent.incompleteSubMeasurements.forEach((subMeasurement) => {
              incompleteMeasurements.push({ ...subMeasurement });
            });
          }
          module.BrowserPerformanceMeasurement.flushMeasurements(inProgressEvent.event.correlationId, incompleteMeasurements);
        }));
      }
      /**
       * Starts measuring performance for a given operation. Returns a function that should be used to end the measurement.
       * Also captures browser page visibilityState.
       *
       * @param {PerformanceEvents} measureName
       * @param {?string} [correlationId]
       * @returns {((event?: Partial<PerformanceEvent>) => PerformanceEvent| null)}
       */
      startMeasurement(measureName, correlationId) {
        var _a3;
        const startPageVisibility = this.getPageVisibility();
        const inProgressEvent = super.startMeasurement(measureName, correlationId);
        const startTime = supportsBrowserPerformanceNow() ? window.performance.now() : void 0;
        const browserMeasurement = (_a3 = getPerfMeasurementModule()) == null ? void 0 : _a3.then((module) => {
          return new module.BrowserPerformanceMeasurement(measureName, inProgressEvent.event.correlationId);
        });
        void (browserMeasurement == null ? void 0 : browserMeasurement.then((measurement) => measurement.startMeasurement()));
        return {
          ...inProgressEvent,
          end: (event, error) => {
            const res = inProgressEvent.end({
              ...event,
              startPageVisibility,
              endPageVisibility: this.getPageVisibility(),
              durationMs: getPerfDurationMs(startTime)
            }, error);
            void (browserMeasurement == null ? void 0 : browserMeasurement.then((measurement) => measurement.endMeasurement()));
            this.deleteIncompleteSubMeasurements(inProgressEvent);
            return res;
          },
          discard: () => {
            inProgressEvent.discard();
            void (browserMeasurement == null ? void 0 : browserMeasurement.then((measurement) => measurement.flushMeasurement()));
            this.deleteIncompleteSubMeasurements(inProgressEvent);
          }
        };
      }
      /**
       * Adds pre-queue time to preQueueTimeByCorrelationId map.
       * @param {PerformanceEvents} eventName
       * @param {?string} correlationId
       * @returns
       */
      setPreQueueTime(eventName, correlationId) {
        if (!supportsBrowserPerformanceNow()) {
          this.logger.trace(`BrowserPerformanceClient: window performance API not available, unable to set telemetry queue time for ${eventName}`);
          return;
        }
        if (!correlationId) {
          this.logger.trace(`BrowserPerformanceClient: correlationId for ${eventName} not provided, unable to set telemetry queue time`);
          return;
        }
        const preQueueEvent = this.preQueueTimeByCorrelationId.get(correlationId);
        if (preQueueEvent) {
          this.logger.trace(`BrowserPerformanceClient: Incomplete pre-queue ${preQueueEvent.name} found`, correlationId);
          this.addQueueMeasurement(preQueueEvent.name, correlationId, void 0, true);
        }
        this.preQueueTimeByCorrelationId.set(correlationId, {
          name: eventName,
          time: window.performance.now()
        });
      }
      /**
       * Calculates and adds queue time measurement for given performance event.
       *
       * @param {PerformanceEvents} eventName
       * @param {?string} correlationId
       * @param {?number} queueTime
       * @param {?boolean} manuallyCompleted - indicator for manually completed queue measurements
       * @returns
       */
      addQueueMeasurement(eventName, correlationId, queueTime, manuallyCompleted) {
        if (!supportsBrowserPerformanceNow()) {
          this.logger.trace(`BrowserPerformanceClient: window performance API not available, unable to add queue measurement for ${eventName}`);
          return;
        }
        if (!correlationId) {
          this.logger.trace(`BrowserPerformanceClient: correlationId for ${eventName} not provided, unable to add queue measurement`);
          return;
        }
        const preQueueTime = super.getPreQueueTime(eventName, correlationId);
        if (!preQueueTime) {
          return;
        }
        const currentTime = window.performance.now();
        const resQueueTime = queueTime || super.calculateQueuedTime(preQueueTime, currentTime);
        return super.addQueueMeasurement(eventName, correlationId, resQueueTime, manuallyCompleted);
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/index.mjs
var dist_exports = {};
__export(dist_exports, {
  AccountEntity: () => AccountEntity,
  ApiId: () => ApiId,
  AuthError: () => AuthError,
  AuthErrorCodes: () => AuthErrorCodes_exports,
  AuthErrorMessage: () => AuthErrorMessage,
  AuthenticationHeaderParser: () => AuthenticationHeaderParser,
  AuthenticationScheme: () => AuthenticationScheme,
  AzureCloudInstance: () => AzureCloudInstance,
  BrowserAuthError: () => BrowserAuthError,
  BrowserAuthErrorCodes: () => BrowserAuthErrorCodes_exports,
  BrowserAuthErrorMessage: () => BrowserAuthErrorMessage,
  BrowserCacheLocation: () => BrowserCacheLocation,
  BrowserConfigurationAuthError: () => BrowserConfigurationAuthError,
  BrowserConfigurationAuthErrorCodes: () => BrowserConfigurationAuthErrorCodes_exports,
  BrowserConfigurationAuthErrorMessage: () => BrowserConfigurationAuthErrorMessage,
  BrowserPerformanceClient: () => BrowserPerformanceClient,
  BrowserPerformanceMeasurement: () => BrowserPerformanceMeasurement,
  BrowserUtils: () => BrowserUtils_exports,
  CacheLookupPolicy: () => CacheLookupPolicy,
  ClientAuthError: () => ClientAuthError,
  ClientAuthErrorCodes: () => ClientAuthErrorCodes_exports,
  ClientAuthErrorMessage: () => ClientAuthErrorMessage,
  ClientConfigurationError: () => ClientConfigurationError,
  ClientConfigurationErrorCodes: () => ClientConfigurationErrorCodes_exports,
  ClientConfigurationErrorMessage: () => ClientConfigurationErrorMessage,
  DEFAULT_IFRAME_TIMEOUT_MS: () => DEFAULT_IFRAME_TIMEOUT_MS,
  EventHandler: () => EventHandler,
  EventMessageUtils: () => EventMessageUtils,
  EventType: () => EventType,
  InteractionRequiredAuthError: () => InteractionRequiredAuthError,
  InteractionRequiredAuthErrorCodes: () => InteractionRequiredAuthErrorCodes_exports,
  InteractionRequiredAuthErrorMessage: () => InteractionRequiredAuthErrorMessage,
  InteractionStatus: () => InteractionStatus,
  InteractionType: () => InteractionType,
  JsonWebTokenTypes: () => JsonWebTokenTypes,
  LocalStorage: () => LocalStorage,
  LogLevel: () => LogLevel,
  Logger: () => Logger,
  MemoryStorage: () => MemoryStorage,
  NavigationClient: () => NavigationClient,
  OIDC_DEFAULT_SCOPES: () => OIDC_DEFAULT_SCOPES,
  PerformanceEvents: () => PerformanceEvents,
  PromptValue: () => PromptValue,
  ProtocolMode: () => ProtocolMode,
  PublicClientApplication: () => PublicClientApplication,
  PublicClientNext: () => PublicClientNext,
  ServerError: () => ServerError,
  ServerResponseType: () => ServerResponseType,
  SessionStorage: () => SessionStorage,
  SignedHttpRequest: () => SignedHttpRequest,
  StringUtils: () => StringUtils,
  StubPerformanceClient: () => StubPerformanceClient,
  UrlString: () => UrlString,
  WrapperSKU: () => WrapperSKU,
  createNestablePublicClientApplication: () => createNestablePublicClientApplication,
  createStandardPublicClientApplication: () => createStandardPublicClientApplication,
  isPlatformBrokerAvailable: () => isPlatformBrokerAvailable,
  stubbedPublicClientApplication: () => stubbedPublicClientApplication,
  version: () => version2
});
var init_dist = __esm({
  "node_modules/@azure/msal-browser/dist/index.mjs"() {
    "use strict";
    init_BrowserUtils();
    init_PublicClientApplication();
    init_PublicClientNext();
    init_Configuration();
    init_BrowserConstants();
    init_BrowserAuthError();
    init_BrowserConfigurationAuthError();
    init_IPublicClientApplication();
    init_NavigationClient();
    init_MemoryStorage();
    init_LocalStorage();
    init_SessionStorage();
    init_EventMessage();
    init_EventType();
    init_EventHandler();
    init_SignedHttpRequest();
    init_BrowserPerformanceClient();
    init_BrowserPerformanceMeasurement();
    init_index_browser();
    init_packageMetadata2();
    init_PlatformAuthProvider();
    init_BrowserAuthErrorCodes();
    init_BrowserConfigurationAuthErrorCodes();
  }
});

// node_modules/@azure/identity/dist/browser/msal/msal.js
var init_msal = __esm({
  "node_modules/@azure/identity/dist/browser/msal/msal.js"() {
    init_dist();
  }
});

// node_modules/@azure/identity/dist/browser/msal/utils.js
function ensureValidMsalToken(scopes, msalToken, getTokenOptions) {
  const error = (message) => {
    logger4.getToken.info(message);
    return new AuthenticationRequiredError({
      scopes: Array.isArray(scopes) ? scopes : [scopes],
      getTokenOptions,
      message
    });
  };
  if (!msalToken) {
    throw error("No response");
  }
  if (!msalToken.expiresOn) {
    throw error(`Response had no "expiresOn" property.`);
  }
  if (!msalToken.accessToken) {
    throw error(`Response had no "accessToken" property.`);
  }
}
function getAuthority(tenantId, host) {
  if (!host) {
    host = DefaultAuthorityHost;
  }
  if (new RegExp(`${tenantId}/?$`).test(host)) {
    return host;
  }
  if (host.endsWith("/")) {
    return host + tenantId;
  } else {
    return `${host}/${tenantId}`;
  }
}
function getKnownAuthorities(tenantId, authorityHost, disableInstanceDiscovery) {
  if (tenantId === "adfs" && authorityHost || disableInstanceDiscovery) {
    return [authorityHost];
  }
  return [];
}
function getMSALLogLevel(logLevel) {
  switch (logLevel) {
    case "error":
      return dist_exports.LogLevel.Error;
    case "info":
      return dist_exports.LogLevel.Info;
    case "verbose":
      return dist_exports.LogLevel.Verbose;
    case "warning":
      return dist_exports.LogLevel.Warning;
    default:
      return dist_exports.LogLevel.Info;
  }
}
function handleMsalError(scopes, error, getTokenOptions) {
  if (error.name === "AuthError" || error.name === "ClientAuthError" || error.name === "BrowserAuthError") {
    const msalError = error;
    switch (msalError.errorCode) {
      case "endpoints_resolution_error":
        logger4.info(formatError(scopes, error.message));
        return new CredentialUnavailableError(error.message);
      case "device_code_polling_cancelled":
        return new AbortError("The authentication has been aborted by the caller.");
      case "consent_required":
      case "interaction_required":
      case "login_required":
        logger4.info(formatError(scopes, `Authentication returned errorCode ${msalError.errorCode}`));
        break;
      default:
        logger4.info(formatError(scopes, `Failed to acquire token: ${error.message}`));
        break;
    }
  }
  if (error.name === "ClientConfigurationError" || error.name === "BrowserConfigurationAuthError" || error.name === "AbortError" || error.name === "AuthenticationError") {
    return error;
  }
  if (error.name === "NativeAuthError") {
    logger4.info(formatError(scopes, `Error from the native broker: ${error.message} with status code: ${error.statusCode}`));
    return error;
  }
  return new AuthenticationRequiredError({ scopes, getTokenOptions, message: error.message });
}
function publicToMsal(account) {
  return {
    localAccountId: account.homeAccountId,
    environment: account.authority,
    username: account.username,
    homeAccountId: account.homeAccountId,
    tenantId: account.tenantId
  };
}
function msalToPublic(clientId, account) {
  var _a3;
  const record = {
    authority: (_a3 = account.environment) !== null && _a3 !== void 0 ? _a3 : DefaultAuthority,
    homeAccountId: account.homeAccountId,
    tenantId: account.tenantId || DefaultTenantId,
    username: account.username,
    clientId,
    version: LatestAuthenticationRecordVersion
  };
  return record;
}
function serializeAuthenticationRecord(record) {
  return JSON.stringify(record);
}
function deserializeAuthenticationRecord(serializedRecord) {
  const parsed = JSON.parse(serializedRecord);
  if (parsed.version && parsed.version !== LatestAuthenticationRecordVersion) {
    throw Error("Unsupported AuthenticationRecord version");
  }
  return parsed;
}
var logger4, LatestAuthenticationRecordVersion, defaultLoggerCallback;
var init_utils = __esm({
  "node_modules/@azure/identity/dist/browser/msal/utils.js"() {
    init_errors();
    init_logging();
    init_constants();
    init_browser4();
    init_browser3();
    init_msal();
    logger4 = credentialLogger("IdentityUtils");
    LatestAuthenticationRecordVersion = "1.0";
    defaultLoggerCallback = (credLogger, platform = isNode ? "Node" : "Browser") => (level, message, containsPii) => {
      if (containsPii) {
        return;
      }
      switch (level) {
        case dist_exports.LogLevel.Error:
          credLogger.info(`MSAL ${platform} V2 error: ${message}`);
          return;
        case dist_exports.LogLevel.Info:
          credLogger.info(`MSAL ${platform} V2 info message: ${message}`);
          return;
        case dist_exports.LogLevel.Verbose:
          credLogger.info(`MSAL ${platform} V2 verbose message: ${message}`);
          return;
        case dist_exports.LogLevel.Warning:
          credLogger.info(`MSAL ${platform} V2 warning: ${message}`);
          return;
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/abort-controller/AbortError.js
var AbortError2;
var init_AbortError2 = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/abort-controller/AbortError.js"() {
    AbortError2 = class extends Error {
      constructor(message) {
        super(message);
        this.name = "AbortError";
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/httpHeaders.js
function normalizeName(name3) {
  return name3.toLowerCase();
}
function* headerIterator(map) {
  for (const entry of map.values()) {
    yield [entry.name, entry.value];
  }
}
function createHttpHeaders(rawHeaders) {
  return new HttpHeadersImpl(rawHeaders);
}
var HttpHeadersImpl;
var init_httpHeaders = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/httpHeaders.js"() {
    HttpHeadersImpl = class {
      constructor(rawHeaders) {
        this._headersMap = /* @__PURE__ */ new Map();
        if (rawHeaders) {
          for (const headerName of Object.keys(rawHeaders)) {
            this.set(headerName, rawHeaders[headerName]);
          }
        }
      }
      /**
       * Set a header in this collection with the provided name and value. The name is
       * case-insensitive.
       * @param name - The name of the header to set. This value is case-insensitive.
       * @param value - The value of the header to set.
       */
      set(name3, value) {
        this._headersMap.set(normalizeName(name3), { name: name3, value: String(value).trim() });
      }
      /**
       * Get the header value for the provided header name, or undefined if no header exists in this
       * collection with the provided name.
       * @param name - The name of the header. This value is case-insensitive.
       */
      get(name3) {
        var _a3;
        return (_a3 = this._headersMap.get(normalizeName(name3))) === null || _a3 === void 0 ? void 0 : _a3.value;
      }
      /**
       * Get whether or not this header collection contains a header entry for the provided header name.
       * @param name - The name of the header to set. This value is case-insensitive.
       */
      has(name3) {
        return this._headersMap.has(normalizeName(name3));
      }
      /**
       * Remove the header with the provided headerName.
       * @param name - The name of the header to remove.
       */
      delete(name3) {
        this._headersMap.delete(normalizeName(name3));
      }
      /**
       * Get the JSON object representation of this HTTP header collection.
       */
      toJSON(options = {}) {
        const result = {};
        if (options.preserveCase) {
          for (const entry of this._headersMap.values()) {
            result[entry.name] = entry.value;
          }
        } else {
          for (const [normalizedName, entry] of this._headersMap) {
            result[normalizedName] = entry.value;
          }
        }
        return result;
      }
      /**
       * Get the string representation of this HTTP header collection.
       */
      toString() {
        return JSON.stringify(this.toJSON({ preserveCase: true }));
      }
      /**
       * Iterate over tuples of header [name, value] pairs.
       */
      [Symbol.iterator]() {
        return headerIterator(this._headersMap);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/auth/schemes.js
var init_schemes = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/auth/schemes.js"() {
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/auth/oauth2Flows.js
var init_oauth2Flows = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/auth/oauth2Flows.js"() {
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/pipelineRequest.js
function createPipelineRequest(options) {
  return new PipelineRequestImpl(options);
}
var PipelineRequestImpl;
var init_pipelineRequest = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/pipelineRequest.js"() {
    init_httpHeaders();
    init_uuidUtils();
    PipelineRequestImpl = class {
      constructor(options) {
        var _a3, _b2, _c2, _d2, _e, _f, _g;
        this.url = options.url;
        this.body = options.body;
        this.headers = (_a3 = options.headers) !== null && _a3 !== void 0 ? _a3 : createHttpHeaders();
        this.method = (_b2 = options.method) !== null && _b2 !== void 0 ? _b2 : "GET";
        this.timeout = (_c2 = options.timeout) !== null && _c2 !== void 0 ? _c2 : 0;
        this.multipartBody = options.multipartBody;
        this.formData = options.formData;
        this.disableKeepAlive = (_d2 = options.disableKeepAlive) !== null && _d2 !== void 0 ? _d2 : false;
        this.proxySettings = options.proxySettings;
        this.streamResponseStatusCodes = options.streamResponseStatusCodes;
        this.withCredentials = (_e = options.withCredentials) !== null && _e !== void 0 ? _e : false;
        this.abortSignal = options.abortSignal;
        this.onUploadProgress = options.onUploadProgress;
        this.onDownloadProgress = options.onDownloadProgress;
        this.requestId = options.requestId || randomUUID();
        this.allowInsecureConnection = (_f = options.allowInsecureConnection) !== null && _f !== void 0 ? _f : false;
        this.enableBrowserStreams = (_g = options.enableBrowserStreams) !== null && _g !== void 0 ? _g : false;
        this.requestOverrides = options.requestOverrides;
        this.authSchemes = options.authSchemes;
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/pipeline.js
function createEmptyPipeline() {
  return HttpPipeline.create();
}
var ValidPhaseNames, HttpPipeline;
var init_pipeline = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/pipeline.js"() {
    ValidPhaseNames = /* @__PURE__ */ new Set(["Deserialize", "Serialize", "Retry", "Sign"]);
    HttpPipeline = class _HttpPipeline {
      constructor(policies) {
        var _a3;
        this._policies = [];
        this._policies = (_a3 = policies === null || policies === void 0 ? void 0 : policies.slice(0)) !== null && _a3 !== void 0 ? _a3 : [];
        this._orderedPolicies = void 0;
      }
      addPolicy(policy, options = {}) {
        if (options.phase && options.afterPhase) {
          throw new Error("Policies inside a phase cannot specify afterPhase.");
        }
        if (options.phase && !ValidPhaseNames.has(options.phase)) {
          throw new Error(`Invalid phase name: ${options.phase}`);
        }
        if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) {
          throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);
        }
        this._policies.push({
          policy,
          options
        });
        this._orderedPolicies = void 0;
      }
      removePolicy(options) {
        const removedPolicies = [];
        this._policies = this._policies.filter((policyDescriptor) => {
          if (options.name && policyDescriptor.policy.name === options.name || options.phase && policyDescriptor.options.phase === options.phase) {
            removedPolicies.push(policyDescriptor.policy);
            return false;
          } else {
            return true;
          }
        });
        this._orderedPolicies = void 0;
        return removedPolicies;
      }
      sendRequest(httpClient, request) {
        const policies = this.getOrderedPolicies();
        const pipeline = policies.reduceRight((next, policy) => {
          return (req) => {
            return policy.sendRequest(req, next);
          };
        }, (req) => httpClient.sendRequest(req));
        return pipeline(request);
      }
      getOrderedPolicies() {
        if (!this._orderedPolicies) {
          this._orderedPolicies = this.orderPolicies();
        }
        return this._orderedPolicies;
      }
      clone() {
        return new _HttpPipeline(this._policies);
      }
      static create() {
        return new _HttpPipeline();
      }
      orderPolicies() {
        const result = [];
        const policyMap = /* @__PURE__ */ new Map();
        function createPhase(name3) {
          return {
            name: name3,
            policies: /* @__PURE__ */ new Set(),
            hasRun: false,
            hasAfterPolicies: false
          };
        }
        const serializePhase = createPhase("Serialize");
        const noPhase = createPhase("None");
        const deserializePhase = createPhase("Deserialize");
        const retryPhase = createPhase("Retry");
        const signPhase = createPhase("Sign");
        const orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];
        function getPhase(phase) {
          if (phase === "Retry") {
            return retryPhase;
          } else if (phase === "Serialize") {
            return serializePhase;
          } else if (phase === "Deserialize") {
            return deserializePhase;
          } else if (phase === "Sign") {
            return signPhase;
          } else {
            return noPhase;
          }
        }
        for (const descriptor of this._policies) {
          const policy = descriptor.policy;
          const options = descriptor.options;
          const policyName = policy.name;
          if (policyMap.has(policyName)) {
            throw new Error("Duplicate policy names not allowed in pipeline");
          }
          const node = {
            policy,
            dependsOn: /* @__PURE__ */ new Set(),
            dependants: /* @__PURE__ */ new Set()
          };
          if (options.afterPhase) {
            node.afterPhase = getPhase(options.afterPhase);
            node.afterPhase.hasAfterPolicies = true;
          }
          policyMap.set(policyName, node);
          const phase = getPhase(options.phase);
          phase.policies.add(node);
        }
        for (const descriptor of this._policies) {
          const { policy, options } = descriptor;
          const policyName = policy.name;
          const node = policyMap.get(policyName);
          if (!node) {
            throw new Error(`Missing node for policy ${policyName}`);
          }
          if (options.afterPolicies) {
            for (const afterPolicyName of options.afterPolicies) {
              const afterNode = policyMap.get(afterPolicyName);
              if (afterNode) {
                node.dependsOn.add(afterNode);
                afterNode.dependants.add(node);
              }
            }
          }
          if (options.beforePolicies) {
            for (const beforePolicyName of options.beforePolicies) {
              const beforeNode = policyMap.get(beforePolicyName);
              if (beforeNode) {
                beforeNode.dependsOn.add(node);
                node.dependants.add(beforeNode);
              }
            }
          }
        }
        function walkPhase(phase) {
          phase.hasRun = true;
          for (const node of phase.policies) {
            if (node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size)) {
              continue;
            }
            if (node.dependsOn.size === 0) {
              result.push(node.policy);
              for (const dependant of node.dependants) {
                dependant.dependsOn.delete(node);
              }
              policyMap.delete(node.policy.name);
              phase.policies.delete(node);
            }
          }
        }
        function walkPhases() {
          for (const phase of orderedPhases) {
            walkPhase(phase);
            if (phase.policies.size > 0 && phase !== noPhase) {
              if (!noPhase.hasRun) {
                walkPhase(noPhase);
              }
              return;
            }
            if (phase.hasAfterPolicies) {
              walkPhase(noPhase);
            }
          }
        }
        let iteration = 0;
        while (policyMap.size > 0) {
          iteration++;
          const initialResultLength = result.length;
          walkPhases();
          if (result.length <= initialResultLength && iteration > 1) {
            throw new Error("Cannot satisfy policy dependencies due to requirements cycle.");
          }
        }
        return result;
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/util/inspect.common.js
var custom;
var init_inspect_common = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/util/inspect.common.js"() {
    custom = Symbol();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/util/inspect.js
var init_inspect = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/util/inspect.js"() {
    init_inspect_common();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/restError.js
function isRestError(e) {
  if (e instanceof RestError) {
    return true;
  }
  return isError(e) && e.name === "RestError";
}
var errorSanitizer, RestError;
var init_restError = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/restError.js"() {
    init_error();
    init_inspect();
    init_sanitizer();
    errorSanitizer = new Sanitizer();
    RestError = class _RestError extends Error {
      constructor(message, options = {}) {
        super(message);
        this.name = "RestError";
        this.code = options.code;
        this.statusCode = options.statusCode;
        Object.defineProperty(this, "request", { value: options.request, enumerable: false });
        Object.defineProperty(this, "response", { value: options.response, enumerable: false });
        Object.defineProperty(this, custom, {
          value: () => {
            return `RestError: ${this.message} 
 ${errorSanitizer.sanitize(Object.assign(Object.assign({}, this), { request: this.request, response: this.response }))}`;
          },
          enumerable: false
        });
        Object.setPrototypeOf(this, _RestError.prototype);
      }
    };
    RestError.REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
    RestError.PARSE_ERROR = "PARSE_ERROR";
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/util/typeGuards.js
function isNodeReadableStream(x) {
  return Boolean(x && typeof x["pipe"] === "function");
}
function isWebReadableStream(x) {
  return Boolean(x && typeof x.getReader === "function" && typeof x.tee === "function");
}
function isBlob(x) {
  return typeof x.stream === "function";
}
var init_typeGuards2 = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/util/typeGuards.js"() {
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/fetchHttpClient.js
function isBlob2(body) {
  return (typeof Blob === "function" || typeof Blob === "object") && body instanceof Blob;
}
async function makeRequest(request) {
  const { abortController, abortControllerCleanup } = setupAbortSignal(request);
  try {
    const headers = buildFetchHeaders(request.headers);
    const { streaming, body: requestBody } = buildRequestBody(request);
    const requestInit = Object.assign(Object.assign({ body: requestBody, method: request.method, headers, signal: abortController.signal }, "credentials" in Request.prototype ? { credentials: request.withCredentials ? "include" : "same-origin" } : {}), "cache" in Request.prototype ? { cache: "no-store" } : {});
    if (streaming) {
      requestInit.duplex = "half";
    }
    const response = await fetch(request.url, Object.assign(Object.assign({}, requestInit), request.requestOverrides));
    if (isBlob2(request.body) && request.onUploadProgress) {
      request.onUploadProgress({ loadedBytes: request.body.size });
    }
    return buildPipelineResponse(response, request, abortControllerCleanup);
  } catch (e) {
    abortControllerCleanup === null || abortControllerCleanup === void 0 ? void 0 : abortControllerCleanup();
    throw e;
  }
}
async function buildPipelineResponse(httpResponse, request, abortControllerCleanup) {
  var _a3, _b2;
  const headers = buildPipelineHeaders(httpResponse);
  const response = {
    request,
    headers,
    status: httpResponse.status
  };
  const bodyStream = isWebReadableStream(httpResponse.body) ? buildBodyStream(httpResponse.body, {
    onProgress: request.onDownloadProgress,
    onEnd: abortControllerCleanup
  }) : httpResponse.body;
  if (
    // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code
    ((_a3 = request.streamResponseStatusCodes) === null || _a3 === void 0 ? void 0 : _a3.has(Number.POSITIVE_INFINITY)) || ((_b2 = request.streamResponseStatusCodes) === null || _b2 === void 0 ? void 0 : _b2.has(response.status))
  ) {
    if (request.enableBrowserStreams) {
      response.browserStreamBody = bodyStream !== null && bodyStream !== void 0 ? bodyStream : void 0;
    } else {
      const responseStream = new Response(bodyStream);
      response.blobBody = responseStream.blob();
      abortControllerCleanup === null || abortControllerCleanup === void 0 ? void 0 : abortControllerCleanup();
    }
  } else {
    const responseStream = new Response(bodyStream);
    response.bodyAsText = await responseStream.text();
    abortControllerCleanup === null || abortControllerCleanup === void 0 ? void 0 : abortControllerCleanup();
  }
  return response;
}
function setupAbortSignal(request) {
  const abortController = new AbortController();
  let abortControllerCleanup;
  let abortListener;
  if (request.abortSignal) {
    if (request.abortSignal.aborted) {
      throw new AbortError2("The operation was aborted. Request has already been canceled.");
    }
    abortListener = (event) => {
      if (event.type === "abort") {
        abortController.abort();
      }
    };
    request.abortSignal.addEventListener("abort", abortListener);
    abortControllerCleanup = () => {
      var _a3;
      if (abortListener) {
        (_a3 = request.abortSignal) === null || _a3 === void 0 ? void 0 : _a3.removeEventListener("abort", abortListener);
      }
    };
  }
  if (request.timeout > 0) {
    setTimeout(() => {
      abortController.abort();
    }, request.timeout);
  }
  return { abortController, abortControllerCleanup };
}
function getError(e, request) {
  var _a3;
  if (e && (e === null || e === void 0 ? void 0 : e.name) === "AbortError") {
    return e;
  } else {
    return new RestError(`Error sending request: ${e.message}`, {
      code: (_a3 = e === null || e === void 0 ? void 0 : e.code) !== null && _a3 !== void 0 ? _a3 : RestError.REQUEST_SEND_ERROR,
      request
    });
  }
}
function buildFetchHeaders(pipelineHeaders) {
  const headers = new Headers();
  for (const [name3, value] of pipelineHeaders) {
    headers.append(name3, value);
  }
  return headers;
}
function buildPipelineHeaders(httpResponse) {
  const responseHeaders = createHttpHeaders();
  for (const [name3, value] of httpResponse.headers) {
    responseHeaders.set(name3, value);
  }
  return responseHeaders;
}
function buildRequestBody(request) {
  const body = typeof request.body === "function" ? request.body() : request.body;
  if (isNodeReadableStream(body)) {
    throw new Error("Node streams are not supported in browser environment.");
  }
  return isWebReadableStream(body) ? { streaming: true, body: buildBodyStream(body, { onProgress: request.onUploadProgress }) } : { streaming: false, body };
}
function buildBodyStream(readableStream, options = {}) {
  let loadedBytes = 0;
  const { onProgress, onEnd } = options;
  if (isTransformStreamSupported(readableStream)) {
    return readableStream.pipeThrough(new TransformStream({
      transform(chunk, controller) {
        if (chunk === null) {
          controller.terminate();
          return;
        }
        controller.enqueue(chunk);
        loadedBytes += chunk.length;
        if (onProgress) {
          onProgress({ loadedBytes });
        }
      },
      flush() {
        onEnd === null || onEnd === void 0 ? void 0 : onEnd();
      }
    }));
  } else {
    const reader = readableStream.getReader();
    return new ReadableStream({
      async pull(controller) {
        var _a3;
        const { done, value } = await reader.read();
        if (done || !value) {
          onEnd === null || onEnd === void 0 ? void 0 : onEnd();
          controller.close();
          reader.releaseLock();
          return;
        }
        loadedBytes += (_a3 = value === null || value === void 0 ? void 0 : value.length) !== null && _a3 !== void 0 ? _a3 : 0;
        controller.enqueue(value);
        if (onProgress) {
          onProgress({ loadedBytes });
        }
      },
      cancel(reason) {
        onEnd === null || onEnd === void 0 ? void 0 : onEnd();
        return reader.cancel(reason);
      }
    });
  }
}
function createFetchHttpClient() {
  return new FetchHttpClient();
}
function isTransformStreamSupported(readableStream) {
  return readableStream.pipeThrough !== void 0 && self.TransformStream !== void 0;
}
var FetchHttpClient;
var init_fetchHttpClient = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/fetchHttpClient.js"() {
    init_AbortError2();
    init_restError();
    init_httpHeaders();
    init_typeGuards2();
    FetchHttpClient = class {
      /**
       * Makes a request over an underlying transport layer and returns the response.
       * @param request - The request to be made.
       */
      async sendRequest(request) {
        const url = new URL(request.url);
        const isInsecure = url.protocol !== "https:";
        if (isInsecure && !request.allowInsecureConnection) {
          throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);
        }
        if (request.proxySettings) {
          throw new Error("HTTP proxy is not supported in browser environment");
        }
        try {
          return await makeRequest(request);
        } catch (e) {
          throw getError(e, request);
        }
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/defaultHttpClient.js
function createDefaultHttpClient() {
  return createFetchHttpClient();
}
var init_defaultHttpClient = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/defaultHttpClient.js"() {
    init_fetchHttpClient();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/log.js
var logger5;
var init_log2 = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/log.js"() {
    init_logger();
    logger5 = createClientLogger("ts-http-runtime");
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/policies/logPolicy.js
function logPolicy(options = {}) {
  var _a3;
  const logger24 = (_a3 = options.logger) !== null && _a3 !== void 0 ? _a3 : logger5.info;
  const sanitizer = new Sanitizer({
    additionalAllowedHeaderNames: options.additionalAllowedHeaderNames,
    additionalAllowedQueryParameters: options.additionalAllowedQueryParameters
  });
  return {
    name: logPolicyName,
    async sendRequest(request, next) {
      if (!logger24.enabled) {
        return next(request);
      }
      logger24(`Request: ${sanitizer.sanitize(request)}`);
      const response = await next(request);
      logger24(`Response status code: ${response.status}`);
      logger24(`Headers: ${sanitizer.sanitize(response.headers)}`);
      return response;
    }
  };
}
var logPolicyName;
var init_logPolicy = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/policies/logPolicy.js"() {
    init_log2();
    init_sanitizer();
    logPolicyName = "logPolicy";
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/policies/redirectPolicy.js
function redirectPolicy(options = {}) {
  const { maxRetries = 20 } = options;
  return {
    name: redirectPolicyName,
    async sendRequest(request, next) {
      const response = await next(request);
      return handleRedirect(next, response, maxRetries);
    }
  };
}
async function handleRedirect(next, response, maxRetries, currentRetries = 0) {
  const { request, status, headers } = response;
  const locationHeader = headers.get("location");
  if (locationHeader && (status === 300 || status === 301 && allowedRedirect.includes(request.method) || status === 302 && allowedRedirect.includes(request.method) || status === 303 && request.method === "POST" || status === 307) && currentRetries < maxRetries) {
    const url = new URL(locationHeader, request.url);
    request.url = url.toString();
    if (status === 303) {
      request.method = "GET";
      request.headers.delete("Content-Length");
      delete request.body;
    }
    request.headers.delete("Authorization");
    const res = await next(request);
    return handleRedirect(next, res, maxRetries, currentRetries + 1);
  }
  return response;
}
var redirectPolicyName, allowedRedirect;
var init_redirectPolicy = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/policies/redirectPolicy.js"() {
    redirectPolicyName = "redirectPolicy";
    allowedRedirect = ["GET", "HEAD"];
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/util/userAgentPlatform.js
function getHeaderName() {
  return "x-ms-useragent";
}
var init_userAgentPlatform = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/util/userAgentPlatform.js"() {
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/constants.js
var DEFAULT_RETRY_POLICY_COUNT;
var init_constants2 = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/constants.js"() {
    DEFAULT_RETRY_POLICY_COUNT = 3;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/util/userAgent.js
function getUserAgentHeaderName() {
  return getHeaderName();
}
var init_userAgent = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/util/userAgent.js"() {
    init_userAgentPlatform();
    init_constants2();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/policies/userAgentPolicy.js
var UserAgentHeaderName;
var init_userAgentPolicy = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/policies/userAgentPolicy.js"() {
    init_userAgent();
    UserAgentHeaderName = getUserAgentHeaderName();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/policies/decompressResponsePolicy.js
function decompressResponsePolicy() {
  throw new Error("decompressResponsePolicy is not supported in browser environment");
}
var init_decompressResponsePolicy = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/policies/decompressResponsePolicy.js"() {
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/util/helpers.js
function delay3(delayInMs, value, options) {
  return new Promise((resolve, reject) => {
    let timer = void 0;
    let onAborted = void 0;
    const rejectOnAbort = () => {
      return reject(new AbortError2((options === null || options === void 0 ? void 0 : options.abortErrorMsg) ? options === null || options === void 0 ? void 0 : options.abortErrorMsg : StandardAbortMessage2));
    };
    const removeListeners = () => {
      if ((options === null || options === void 0 ? void 0 : options.abortSignal) && onAborted) {
        options.abortSignal.removeEventListener("abort", onAborted);
      }
    };
    onAborted = () => {
      if (timer) {
        clearTimeout(timer);
      }
      removeListeners();
      return rejectOnAbort();
    };
    if ((options === null || options === void 0 ? void 0 : options.abortSignal) && options.abortSignal.aborted) {
      return rejectOnAbort();
    }
    timer = setTimeout(() => {
      removeListeners();
      resolve(value);
    }, delayInMs);
    if (options === null || options === void 0 ? void 0 : options.abortSignal) {
      options.abortSignal.addEventListener("abort", onAborted);
    }
  });
}
function parseHeaderValueAsNumber(response, headerName) {
  const value = response.headers.get(headerName);
  if (!value)
    return;
  const valueAsNum = Number(value);
  if (Number.isNaN(valueAsNum))
    return;
  return valueAsNum;
}
var StandardAbortMessage2;
var init_helpers = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/util/helpers.js"() {
    init_AbortError2();
    StandardAbortMessage2 = "The operation was aborted.";
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/retryStrategies/throttlingRetryStrategy.js
function getRetryAfterInMs(response) {
  if (!(response && [429, 503].includes(response.status)))
    return void 0;
  try {
    for (const header of AllRetryAfterHeaders) {
      const retryAfterValue = parseHeaderValueAsNumber(response, header);
      if (retryAfterValue === 0 || retryAfterValue) {
        const multiplyingFactor = header === RetryAfterHeader ? 1e3 : 1;
        return retryAfterValue * multiplyingFactor;
      }
    }
    const retryAfterHeader = response.headers.get(RetryAfterHeader);
    if (!retryAfterHeader)
      return;
    const date = Date.parse(retryAfterHeader);
    const diff = date - Date.now();
    return Number.isFinite(diff) ? Math.max(0, diff) : void 0;
  } catch (_a3) {
    return void 0;
  }
}
function isThrottlingRetryResponse(response) {
  return Number.isFinite(getRetryAfterInMs(response));
}
function throttlingRetryStrategy() {
  return {
    name: "throttlingRetryStrategy",
    retry({ response }) {
      const retryAfterInMs = getRetryAfterInMs(response);
      if (!Number.isFinite(retryAfterInMs)) {
        return { skipStrategy: true };
      }
      return {
        retryAfterInMs
      };
    }
  };
}
var RetryAfterHeader, AllRetryAfterHeaders;
var init_throttlingRetryStrategy = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/retryStrategies/throttlingRetryStrategy.js"() {
    init_helpers();
    RetryAfterHeader = "Retry-After";
    AllRetryAfterHeaders = ["retry-after-ms", "x-ms-retry-after-ms", RetryAfterHeader];
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/retryStrategies/exponentialRetryStrategy.js
function exponentialRetryStrategy(options = {}) {
  var _a3, _b2;
  const retryInterval = (_a3 = options.retryDelayInMs) !== null && _a3 !== void 0 ? _a3 : DEFAULT_CLIENT_RETRY_INTERVAL;
  const maxRetryInterval = (_b2 = options.maxRetryDelayInMs) !== null && _b2 !== void 0 ? _b2 : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
  return {
    name: "exponentialRetryStrategy",
    retry({ retryCount, response, responseError }) {
      const matchedSystemError = isSystemError(responseError);
      const ignoreSystemErrors = matchedSystemError && options.ignoreSystemErrors;
      const isExponential = isExponentialRetryResponse(response);
      const ignoreExponentialResponse = isExponential && options.ignoreHttpStatusCodes;
      const unknownResponse = response && (isThrottlingRetryResponse(response) || !isExponential);
      if (unknownResponse || ignoreExponentialResponse || ignoreSystemErrors) {
        return { skipStrategy: true };
      }
      if (responseError && !matchedSystemError && !isExponential) {
        return { errorToThrow: responseError };
      }
      return calculateRetryDelay(retryCount, {
        retryDelayInMs: retryInterval,
        maxRetryDelayInMs: maxRetryInterval
      });
    }
  };
}
function isExponentialRetryResponse(response) {
  return Boolean(response && response.status !== void 0 && (response.status >= 500 || response.status === 408) && response.status !== 501 && response.status !== 505);
}
function isSystemError(err) {
  if (!err) {
    return false;
  }
  return err.code === "ETIMEDOUT" || err.code === "ESOCKETTIMEDOUT" || err.code === "ECONNREFUSED" || err.code === "ECONNRESET" || err.code === "ENOENT" || err.code === "ENOTFOUND";
}
var DEFAULT_CLIENT_RETRY_INTERVAL, DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
var init_exponentialRetryStrategy = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/retryStrategies/exponentialRetryStrategy.js"() {
    init_delay();
    init_throttlingRetryStrategy();
    DEFAULT_CLIENT_RETRY_INTERVAL = 1e3;
    DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1e3 * 64;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/policies/retryPolicy.js
function retryPolicy(strategies, options = { maxRetries: DEFAULT_RETRY_POLICY_COUNT }) {
  const logger24 = options.logger || retryPolicyLogger;
  return {
    name: retryPolicyName,
    async sendRequest(request, next) {
      var _a3, _b2;
      let response;
      let responseError;
      let retryCount = -1;
      retryRequest: while (true) {
        retryCount += 1;
        response = void 0;
        responseError = void 0;
        try {
          logger24.info(`Retry ${retryCount}: Attempting to send request`, request.requestId);
          response = await next(request);
          logger24.info(`Retry ${retryCount}: Received a response from request`, request.requestId);
        } catch (e) {
          logger24.error(`Retry ${retryCount}: Received an error from request`, request.requestId);
          responseError = e;
          if (!e || responseError.name !== "RestError") {
            throw e;
          }
          response = responseError.response;
        }
        if ((_a3 = request.abortSignal) === null || _a3 === void 0 ? void 0 : _a3.aborted) {
          logger24.error(`Retry ${retryCount}: Request aborted.`);
          const abortError = new AbortError2();
          throw abortError;
        }
        if (retryCount >= ((_b2 = options.maxRetries) !== null && _b2 !== void 0 ? _b2 : DEFAULT_RETRY_POLICY_COUNT)) {
          logger24.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`);
          if (responseError) {
            throw responseError;
          } else if (response) {
            return response;
          } else {
            throw new Error("Maximum retries reached with no response or error to throw");
          }
        }
        logger24.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);
        strategiesLoop: for (const strategy of strategies) {
          const strategyLogger = strategy.logger || logger24;
          strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);
          const modifiers = strategy.retry({
            retryCount,
            response,
            responseError
          });
          if (modifiers.skipStrategy) {
            strategyLogger.info(`Retry ${retryCount}: Skipped.`);
            continue strategiesLoop;
          }
          const { errorToThrow, retryAfterInMs, redirectTo } = modifiers;
          if (errorToThrow) {
            strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow);
            throw errorToThrow;
          }
          if (retryAfterInMs || retryAfterInMs === 0) {
            strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`);
            await delay3(retryAfterInMs, void 0, { abortSignal: request.abortSignal });
            continue retryRequest;
          }
          if (redirectTo) {
            strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`);
            request.url = redirectTo;
            continue retryRequest;
          }
        }
        if (responseError) {
          logger24.info(`None of the retry strategies could work with the received error. Throwing it.`);
          throw responseError;
        }
        if (response) {
          logger24.info(`None of the retry strategies could work with the received response. Returning it.`);
          return response;
        }
      }
    }
  };
}
var retryPolicyLogger, retryPolicyName;
var init_retryPolicy = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/policies/retryPolicy.js"() {
    init_helpers();
    init_AbortError2();
    init_logger();
    init_constants2();
    retryPolicyLogger = createClientLogger("ts-http-runtime retryPolicy");
    retryPolicyName = "retryPolicy";
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/policies/defaultRetryPolicy.js
function defaultRetryPolicy(options = {}) {
  var _a3;
  return {
    name: defaultRetryPolicyName,
    sendRequest: retryPolicy([throttlingRetryStrategy(), exponentialRetryStrategy(options)], {
      maxRetries: (_a3 = options.maxRetries) !== null && _a3 !== void 0 ? _a3 : DEFAULT_RETRY_POLICY_COUNT
    }).sendRequest
  };
}
var defaultRetryPolicyName;
var init_defaultRetryPolicy = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/policies/defaultRetryPolicy.js"() {
    init_exponentialRetryStrategy();
    init_throttlingRetryStrategy();
    init_retryPolicy();
    init_constants2();
    defaultRetryPolicyName = "defaultRetryPolicy";
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/policies/formDataPolicy.js
function formDataToFormDataMap(formData) {
  var _a3;
  const formDataMap = {};
  for (const [key, value] of formData.entries()) {
    (_a3 = formDataMap[key]) !== null && _a3 !== void 0 ? _a3 : formDataMap[key] = [];
    formDataMap[key].push(value);
  }
  return formDataMap;
}
function formDataPolicy() {
  return {
    name: formDataPolicyName,
    async sendRequest(request, next) {
      if (isNodeLike && typeof FormData !== "undefined" && request.body instanceof FormData) {
        request.formData = formDataToFormDataMap(request.body);
        request.body = void 0;
      }
      if (request.formData) {
        const contentType = request.headers.get("Content-Type");
        if (contentType && contentType.indexOf("application/x-www-form-urlencoded") !== -1) {
          request.body = wwwFormUrlEncode(request.formData);
        } else {
          await prepareFormData(request.formData, request);
        }
        request.formData = void 0;
      }
      return next(request);
    }
  };
}
function wwwFormUrlEncode(formData) {
  const urlSearchParams = new URLSearchParams();
  for (const [key, value] of Object.entries(formData)) {
    if (Array.isArray(value)) {
      for (const subValue of value) {
        urlSearchParams.append(key, subValue.toString());
      }
    } else {
      urlSearchParams.append(key, value.toString());
    }
  }
  return urlSearchParams.toString();
}
async function prepareFormData(formData, request) {
  const contentType = request.headers.get("Content-Type");
  if (contentType && !contentType.startsWith("multipart/form-data")) {
    return;
  }
  request.headers.set("Content-Type", contentType !== null && contentType !== void 0 ? contentType : "multipart/form-data");
  const parts = [];
  for (const [fieldName, values] of Object.entries(formData)) {
    for (const value of Array.isArray(values) ? values : [values]) {
      if (typeof value === "string") {
        parts.push({
          headers: createHttpHeaders({
            "Content-Disposition": `form-data; name="${fieldName}"`
          }),
          body: stringToUint8Array(value, "utf-8")
        });
      } else if (value === void 0 || value === null || typeof value !== "object") {
        throw new Error(`Unexpected value for key ${fieldName}: ${value}. Value should be serialized to string first.`);
      } else {
        const fileName = value.name || "blob";
        const headers = createHttpHeaders();
        headers.set("Content-Disposition", `form-data; name="${fieldName}"; filename="${fileName}"`);
        headers.set("Content-Type", value.type || "application/octet-stream");
        parts.push({
          headers,
          body: value
        });
      }
    }
  }
  request.multipartBody = { parts };
}
var formDataPolicyName;
var init_formDataPolicy = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/policies/formDataPolicy.js"() {
    init_bytesEncoding();
    init_checkEnvironment();
    init_httpHeaders();
    formDataPolicyName = "formDataPolicy";
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/policies/proxyPolicy.common.js
function proxyPolicy() {
  throw new Error(errorMessage);
}
var errorMessage;
var init_proxyPolicy_common = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/policies/proxyPolicy.common.js"() {
    errorMessage = "proxyPolicy is not supported in browser environment";
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/policies/proxyPolicy.js
var init_proxyPolicy = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/policies/proxyPolicy.js"() {
    init_proxyPolicy_common();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/policies/agentPolicy.js
function agentPolicy(agent) {
  return {
    name: agentPolicyName,
    sendRequest: async (req, next) => {
      if (!req.agent) {
        req.agent = agent;
      }
      return next(req);
    }
  };
}
var agentPolicyName;
var init_agentPolicy = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/policies/agentPolicy.js"() {
    agentPolicyName = "agentPolicy";
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/policies/tlsPolicy.js
function tlsPolicy(tlsSettings) {
  return {
    name: tlsPolicyName,
    sendRequest: async (req, next) => {
      if (!req.tlsSettings) {
        req.tlsSettings = tlsSettings;
      }
      return next(req);
    }
  };
}
var tlsPolicyName;
var init_tlsPolicy = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/policies/tlsPolicy.js"() {
    tlsPolicyName = "tlsPolicy";
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/util/concat.common.js
function drain(stream) {
  return new Response(stream).blob();
}
async function toBlobPart(source) {
  if (source instanceof Blob || source instanceof Uint8Array) {
    return source;
  }
  if (isWebReadableStream(source)) {
    return drain(source);
  } else {
    throw new Error("Unsupported source type. Only Blob, Uint8Array, and ReadableStream are supported in browser.");
  }
}
async function concat(sources) {
  const parts = [];
  for (const source of sources) {
    parts.push(await toBlobPart(typeof source === "function" ? source() : source));
  }
  return new Blob(parts);
}
var init_concat_common = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/util/concat.common.js"() {
    init_typeGuards2();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/util/concat.js
var init_concat = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/util/concat.js"() {
    init_concat_common();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/policies/multipartPolicy.js
function generateBoundary() {
  return `----AzSDKFormBoundary${randomUUID()}`;
}
function encodeHeaders(headers) {
  let result = "";
  for (const [key, value] of headers) {
    result += `${key}: ${value}\r
`;
  }
  return result;
}
function getLength(source) {
  if (source instanceof Uint8Array) {
    return source.byteLength;
  } else if (isBlob(source)) {
    return source.size === -1 ? void 0 : source.size;
  } else {
    return void 0;
  }
}
function getTotalLength(sources) {
  let total = 0;
  for (const source of sources) {
    const partLength = getLength(source);
    if (partLength === void 0) {
      return void 0;
    } else {
      total += partLength;
    }
  }
  return total;
}
async function buildRequestBody2(request, parts, boundary) {
  const sources = [
    stringToUint8Array(`--${boundary}`, "utf-8"),
    ...parts.flatMap((part) => [
      stringToUint8Array("\r\n", "utf-8"),
      stringToUint8Array(encodeHeaders(part.headers), "utf-8"),
      stringToUint8Array("\r\n", "utf-8"),
      part.body,
      stringToUint8Array(`\r
--${boundary}`, "utf-8")
    ]),
    stringToUint8Array("--\r\n\r\n", "utf-8")
  ];
  const contentLength = getTotalLength(sources);
  if (contentLength) {
    request.headers.set("Content-Length", contentLength);
  }
  request.body = await concat(sources);
}
function assertValidBoundary(boundary) {
  if (boundary.length > maxBoundaryLength) {
    throw new Error(`Multipart boundary "${boundary}" exceeds maximum length of 70 characters`);
  }
  if (Array.from(boundary).some((x) => !validBoundaryCharacters.has(x))) {
    throw new Error(`Multipart boundary "${boundary}" contains invalid characters`);
  }
}
function multipartPolicy() {
  return {
    name: multipartPolicyName,
    async sendRequest(request, next) {
      var _a3;
      if (!request.multipartBody) {
        return next(request);
      }
      if (request.body) {
        throw new Error("multipartBody and regular body cannot be set at the same time");
      }
      let boundary = request.multipartBody.boundary;
      const contentTypeHeader = (_a3 = request.headers.get("Content-Type")) !== null && _a3 !== void 0 ? _a3 : "multipart/mixed";
      const parsedHeader = contentTypeHeader.match(/^(multipart\/[^ ;]+)(?:; *boundary=(.+))?$/);
      if (!parsedHeader) {
        throw new Error(`Got multipart request body, but content-type header was not multipart: ${contentTypeHeader}`);
      }
      const [, contentType, parsedBoundary] = parsedHeader;
      if (parsedBoundary && boundary && parsedBoundary !== boundary) {
        throw new Error(`Multipart boundary was specified as ${parsedBoundary} in the header, but got ${boundary} in the request body`);
      }
      boundary !== null && boundary !== void 0 ? boundary : boundary = parsedBoundary;
      if (boundary) {
        assertValidBoundary(boundary);
      } else {
        boundary = generateBoundary();
      }
      request.headers.set("Content-Type", `${contentType}; boundary=${boundary}`);
      await buildRequestBody2(request, request.multipartBody.parts, boundary);
      request.multipartBody = void 0;
      return next(request);
    }
  };
}
var multipartPolicyName, maxBoundaryLength, validBoundaryCharacters;
var init_multipartPolicy = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/policies/multipartPolicy.js"() {
    init_bytesEncoding();
    init_typeGuards2();
    init_uuidUtils();
    init_concat();
    multipartPolicyName = "multipartPolicy";
    maxBoundaryLength = 70;
    validBoundaryCharacters = new Set(`abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'()+,-./:=?`);
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/createPipelineFromOptions.js
var init_createPipelineFromOptions = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/createPipelineFromOptions.js"() {
    init_logPolicy();
    init_pipeline();
    init_redirectPolicy();
    init_userAgentPolicy();
    init_decompressResponsePolicy();
    init_defaultRetryPolicy();
    init_formDataPolicy();
    init_checkEnvironment();
    init_proxyPolicy();
    init_agentPolicy();
    init_tlsPolicy();
    init_multipartPolicy();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/client/apiVersionPolicy.js
var init_apiVersionPolicy = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/client/apiVersionPolicy.js"() {
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/auth/credentials.js
var init_credentials = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/auth/credentials.js"() {
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/policies/auth/checkInsecureConnection.js
var init_checkInsecureConnection = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/policies/auth/checkInsecureConnection.js"() {
    init_log2();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/policies/auth/apiKeyAuthenticationPolicy.js
var init_apiKeyAuthenticationPolicy = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/policies/auth/apiKeyAuthenticationPolicy.js"() {
    init_checkInsecureConnection();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/policies/auth/basicAuthenticationPolicy.js
var init_basicAuthenticationPolicy = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/policies/auth/basicAuthenticationPolicy.js"() {
    init_bytesEncoding();
    init_checkInsecureConnection();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/policies/auth/bearerAuthenticationPolicy.js
var init_bearerAuthenticationPolicy = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/policies/auth/bearerAuthenticationPolicy.js"() {
    init_checkInsecureConnection();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/policies/auth/oauth2AuthenticationPolicy.js
var init_oauth2AuthenticationPolicy = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/policies/auth/oauth2AuthenticationPolicy.js"() {
    init_checkInsecureConnection();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/client/clientHelpers.js
var init_clientHelpers = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/client/clientHelpers.js"() {
    init_defaultHttpClient();
    init_createPipelineFromOptions();
    init_apiVersionPolicy();
    init_credentials();
    init_apiKeyAuthenticationPolicy();
    init_basicAuthenticationPolicy();
    init_bearerAuthenticationPolicy();
    init_oauth2AuthenticationPolicy();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/client/multipart.js
var init_multipart = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/client/multipart.js"() {
    init_restError();
    init_httpHeaders();
    init_bytesEncoding();
    init_typeGuards2();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/client/sendRequest.js
var init_sendRequest = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/client/sendRequest.js"() {
    init_restError();
    init_httpHeaders();
    init_pipelineRequest();
    init_clientHelpers();
    init_typeGuards2();
    init_multipart();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/client/urlHelpers.js
var init_urlHelpers = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/client/urlHelpers.js"() {
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/client/getClient.js
var init_getClient = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/client/getClient.js"() {
    init_clientHelpers();
    init_sendRequest();
    init_urlHelpers();
    init_checkEnvironment();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/client/operationOptionHelpers.js
var init_operationOptionHelpers = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/client/operationOptionHelpers.js"() {
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/client/restError.js
var init_restError2 = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/client/restError.js"() {
    init_restError();
    init_httpHeaders();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/index.js
var init_browser5 = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/index.js"() {
    init_AbortError2();
    init_logger();
    init_httpHeaders();
    init_schemes();
    init_oauth2Flows();
    init_pipelineRequest();
    init_pipeline();
    init_restError();
    init_bytesEncoding();
    init_defaultHttpClient();
    init_getClient();
    init_operationOptionHelpers();
    init_restError2();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/pipeline.js
function createEmptyPipeline2() {
  return createEmptyPipeline();
}
var init_pipeline2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/pipeline.js"() {
    init_browser5();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/log.js
var logger6;
var init_log3 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/log.js"() {
    init_browser();
    logger6 = createClientLogger2("core-rest-pipeline");
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/policies/exponentialRetryPolicy.js
var init_exponentialRetryPolicy = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/policies/exponentialRetryPolicy.js"() {
    init_exponentialRetryStrategy();
    init_retryPolicy();
    init_constants2();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/policies/systemErrorRetryPolicy.js
var init_systemErrorRetryPolicy = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/policies/systemErrorRetryPolicy.js"() {
    init_exponentialRetryStrategy();
    init_retryPolicy();
    init_constants2();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/policies/throttlingRetryPolicy.js
var init_throttlingRetryPolicy = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/policies/throttlingRetryPolicy.js"() {
    init_throttlingRetryStrategy();
    init_retryPolicy();
    init_constants2();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/browser/policies/internal.js
var init_internal3 = __esm({
  "node_modules/@typespec/ts-http-runtime/dist/browser/policies/internal.js"() {
    init_agentPolicy();
    init_decompressResponsePolicy();
    init_defaultRetryPolicy();
    init_exponentialRetryPolicy();
    init_retryPolicy();
    init_systemErrorRetryPolicy();
    init_throttlingRetryPolicy();
    init_formDataPolicy();
    init_logPolicy();
    init_multipartPolicy();
    init_proxyPolicy();
    init_redirectPolicy();
    init_tlsPolicy();
    init_userAgentPolicy();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/logPolicy.js
function logPolicy2(options = {}) {
  return logPolicy(Object.assign({ logger: logger6.info }, options));
}
var init_logPolicy2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/logPolicy.js"() {
    init_log3();
    init_internal3();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/redirectPolicy.js
function redirectPolicy2(options = {}) {
  return redirectPolicy(options);
}
var init_redirectPolicy2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/redirectPolicy.js"() {
    init_internal3();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/util/userAgentPlatform.js
function getHeaderName2() {
  return "x-ms-useragent";
}
function getBrowserInfo(userAgent) {
  const browserRegexes = [
    { name: "Firefox", regex: /Firefox\/([\d.]+)/ },
    { name: "Safari", regex: /Version\/([\d.]+).*Safari/ }
  ];
  for (const browser of browserRegexes) {
    const match = userAgent.match(browser.regex);
    if (match) {
      return { brand: browser.name, version: match[1] };
    }
  }
  return void 0;
}
function getBrandVersionString(brands) {
  const brandOrder = ["Google Chrome", "Microsoft Edge", "Opera", "Brave", "Chromium"];
  for (const brand of brandOrder) {
    const foundBrand = brands.find((b) => b.brand === brand);
    if (foundBrand) {
      return foundBrand;
    }
  }
  return void 0;
}
async function setPlatformSpecificData2(map) {
  const localNavigator = globalThis.navigator;
  let osPlatform = "unknown";
  if (localNavigator === null || localNavigator === void 0 ? void 0 : localNavigator.userAgentData) {
    const entropyValues = await localNavigator.userAgentData.getHighEntropyValues([
      "architecture",
      "platformVersion"
    ]);
    osPlatform = `${entropyValues.architecture}-${entropyValues.platform}-${entropyValues.platformVersion}`;
    const brand = getBrandVersionString(localNavigator.userAgentData.brands);
    if (brand) {
      map.set(brand.brand, brand.version);
    }
  } else if (localNavigator === null || localNavigator === void 0 ? void 0 : localNavigator.platform) {
    osPlatform = localNavigator.platform;
    const brand = getBrowserInfo(localNavigator.userAgent);
    if (brand) {
      map.set(brand.brand, brand.version);
    }
  } else if (typeof globalThis.EdgeRuntime === "string") {
    map.set("EdgeRuntime", globalThis.EdgeRuntime);
  }
  map.set("OS", osPlatform);
}
var init_userAgentPlatform2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/util/userAgentPlatform.js"() {
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/constants.js
var SDK_VERSION3;
var init_constants3 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/constants.js"() {
    SDK_VERSION3 = "1.22.0";
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/util/userAgent.js
function getUserAgentString(telemetryInfo) {
  const parts = [];
  for (const [key, value] of telemetryInfo) {
    const token = value ? `${key}/${value}` : key;
    parts.push(token);
  }
  return parts.join(" ");
}
function getUserAgentHeaderName2() {
  return getHeaderName2();
}
async function getUserAgentValue2(prefix) {
  const runtimeInfo = /* @__PURE__ */ new Map();
  runtimeInfo.set("core-rest-pipeline", SDK_VERSION3);
  await setPlatformSpecificData2(runtimeInfo);
  const defaultAgent = getUserAgentString(runtimeInfo);
  const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
  return userAgentValue;
}
var init_userAgent2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/util/userAgent.js"() {
    init_userAgentPlatform2();
    init_constants3();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/userAgentPolicy.js
function userAgentPolicy2(options = {}) {
  const userAgentValue = getUserAgentValue2(options.userAgentPrefix);
  return {
    name: userAgentPolicyName2,
    async sendRequest(request, next) {
      if (!request.headers.has(UserAgentHeaderName2)) {
        request.headers.set(UserAgentHeaderName2, await userAgentValue);
      }
      return next(request);
    }
  };
}
var UserAgentHeaderName2, userAgentPolicyName2;
var init_userAgentPolicy2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/userAgentPolicy.js"() {
    init_userAgent2();
    UserAgentHeaderName2 = getUserAgentHeaderName2();
    userAgentPolicyName2 = "userAgentPolicy";
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/util/file.js
function hasRawContent(x) {
  return typeof x[rawContent] === "function";
}
function getRawContent(blob) {
  if (hasRawContent(blob)) {
    return blob[rawContent]();
  } else {
    return blob;
  }
}
var rawContent;
var init_file = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/util/file.js"() {
    init_browser4();
    rawContent = Symbol("rawContent");
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/multipartPolicy.js
function multipartPolicy2() {
  const tspPolicy = multipartPolicy();
  return {
    name: multipartPolicyName2,
    sendRequest: async (request, next) => {
      if (request.multipartBody) {
        for (const part of request.multipartBody.parts) {
          if (hasRawContent(part.body)) {
            part.body = getRawContent(part.body);
          }
        }
      }
      return tspPolicy.sendRequest(request, next);
    }
  };
}
var multipartPolicyName2;
var init_multipartPolicy2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/multipartPolicy.js"() {
    init_internal3();
    init_file();
    multipartPolicyName2 = multipartPolicyName;
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/decompressResponsePolicy.js
function decompressResponsePolicy2() {
  return decompressResponsePolicy();
}
var init_decompressResponsePolicy2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/decompressResponsePolicy.js"() {
    init_internal3();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/defaultRetryPolicy.js
function defaultRetryPolicy2(options = {}) {
  return defaultRetryPolicy(options);
}
var init_defaultRetryPolicy2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/defaultRetryPolicy.js"() {
    init_internal3();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/formDataPolicy.js
function formDataPolicy2() {
  return formDataPolicy();
}
var init_formDataPolicy2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/formDataPolicy.js"() {
    init_internal3();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/proxyPolicy.js
function proxyPolicy2(proxySettings, options) {
  return proxyPolicy(proxySettings, options);
}
var init_proxyPolicy2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/proxyPolicy.js"() {
    init_internal3();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/setClientRequestIdPolicy.js
function setClientRequestIdPolicy(requestIdHeaderName = "x-ms-client-request-id") {
  return {
    name: setClientRequestIdPolicyName,
    async sendRequest(request, next) {
      if (!request.headers.has(requestIdHeaderName)) {
        request.headers.set(requestIdHeaderName, request.requestId);
      }
      return next(request);
    }
  };
}
var setClientRequestIdPolicyName;
var init_setClientRequestIdPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/setClientRequestIdPolicy.js"() {
    setClientRequestIdPolicyName = "setClientRequestIdPolicy";
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/agentPolicy.js
function agentPolicy2(agent) {
  return agentPolicy(agent);
}
var init_agentPolicy2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/agentPolicy.js"() {
    init_internal3();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/tlsPolicy.js
function tlsPolicy2(tlsSettings) {
  return tlsPolicy(tlsSettings);
}
var init_tlsPolicy2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/tlsPolicy.js"() {
    init_internal3();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/restError.js
function isRestError2(e) {
  return isRestError(e);
}
var RestError2;
var init_restError3 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/restError.js"() {
    init_browser5();
    RestError2 = RestError;
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/tracingPolicy.js
function tracingPolicy(options = {}) {
  const userAgentPromise = getUserAgentValue2(options.userAgentPrefix);
  const sanitizer = new Sanitizer({
    additionalAllowedQueryParameters: options.additionalAllowedQueryParameters
  });
  const tracingClient2 = tryCreateTracingClient();
  return {
    name: tracingPolicyName,
    async sendRequest(request, next) {
      var _a3;
      if (!tracingClient2) {
        return next(request);
      }
      const userAgent = await userAgentPromise;
      const spanAttributes = {
        "http.url": sanitizer.sanitizeUrl(request.url),
        "http.method": request.method,
        "http.user_agent": userAgent,
        requestId: request.requestId
      };
      if (userAgent) {
        spanAttributes["http.user_agent"] = userAgent;
      }
      const { span, tracingContext } = (_a3 = tryCreateSpan(tracingClient2, request, spanAttributes)) !== null && _a3 !== void 0 ? _a3 : {};
      if (!span || !tracingContext) {
        return next(request);
      }
      try {
        const response = await tracingClient2.withContext(tracingContext, next, request);
        tryProcessResponse(span, response);
        return response;
      } catch (err) {
        tryProcessError(span, err);
        throw err;
      }
    }
  };
}
function tryCreateTracingClient() {
  try {
    return createTracingClient({
      namespace: "",
      packageName: "@azure/core-rest-pipeline",
      packageVersion: SDK_VERSION3
    });
  } catch (e) {
    logger6.warning(`Error when creating the TracingClient: ${getErrorMessage(e)}`);
    return void 0;
  }
}
function tryCreateSpan(tracingClient2, request, spanAttributes) {
  try {
    const { span, updatedOptions } = tracingClient2.startSpan(`HTTP ${request.method}`, { tracingOptions: request.tracingOptions }, {
      spanKind: "client",
      spanAttributes
    });
    if (!span.isRecording()) {
      span.end();
      return void 0;
    }
    const headers = tracingClient2.createRequestHeaders(updatedOptions.tracingOptions.tracingContext);
    for (const [key, value] of Object.entries(headers)) {
      request.headers.set(key, value);
    }
    return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };
  } catch (e) {
    logger6.warning(`Skipping creating a tracing span due to an error: ${getErrorMessage(e)}`);
    return void 0;
  }
}
function tryProcessError(span, error) {
  try {
    span.setStatus({
      status: "error",
      error: isError2(error) ? error : void 0
    });
    if (isRestError2(error) && error.statusCode) {
      span.setAttribute("http.status_code", error.statusCode);
    }
    span.end();
  } catch (e) {
    logger6.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);
  }
}
function tryProcessResponse(span, response) {
  try {
    span.setAttribute("http.status_code", response.status);
    const serviceRequestId = response.headers.get("x-ms-request-id");
    if (serviceRequestId) {
      span.setAttribute("serviceRequestId", serviceRequestId);
    }
    if (response.status >= 400) {
      span.setStatus({
        status: "error"
      });
    }
    span.end();
  } catch (e) {
    logger6.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);
  }
}
var tracingPolicyName;
var init_tracingPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/tracingPolicy.js"() {
    init_browser2();
    init_constants3();
    init_userAgent2();
    init_log3();
    init_browser4();
    init_restError3();
    init_internal2();
    tracingPolicyName = "tracingPolicy";
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/util/wrapAbortSignal.js
function wrapAbortSignalLike(abortSignalLike) {
  if (abortSignalLike instanceof AbortSignal) {
    return { abortSignal: abortSignalLike };
  }
  if (abortSignalLike.aborted) {
    return { abortSignal: AbortSignal.abort(abortSignalLike.reason) };
  }
  const controller = new AbortController();
  let needsCleanup = true;
  function cleanup() {
    if (needsCleanup) {
      abortSignalLike.removeEventListener("abort", listener);
      needsCleanup = false;
    }
  }
  function listener() {
    controller.abort(abortSignalLike.reason);
    cleanup();
  }
  abortSignalLike.addEventListener("abort", listener);
  return { abortSignal: controller.signal, cleanup };
}
var init_wrapAbortSignal = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/util/wrapAbortSignal.js"() {
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/wrapAbortSignalLikePolicy.js
function wrapAbortSignalLikePolicy() {
  return {
    name: wrapAbortSignalLikePolicyName,
    sendRequest: async (request, next) => {
      if (!request.abortSignal) {
        return next(request);
      }
      const { abortSignal, cleanup } = wrapAbortSignalLike(request.abortSignal);
      request.abortSignal = abortSignal;
      try {
        return await next(request);
      } finally {
        cleanup === null || cleanup === void 0 ? void 0 : cleanup();
      }
    }
  };
}
var wrapAbortSignalLikePolicyName;
var init_wrapAbortSignalLikePolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/wrapAbortSignalLikePolicy.js"() {
    init_wrapAbortSignal();
    wrapAbortSignalLikePolicyName = "wrapAbortSignalLikePolicy";
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/createPipelineFromOptions.js
function createPipelineFromOptions2(options) {
  var _a3;
  const pipeline = createEmptyPipeline2();
  if (isNodeLike2) {
    if (options.agent) {
      pipeline.addPolicy(agentPolicy2(options.agent));
    }
    if (options.tlsOptions) {
      pipeline.addPolicy(tlsPolicy2(options.tlsOptions));
    }
    pipeline.addPolicy(proxyPolicy2(options.proxyOptions));
    pipeline.addPolicy(decompressResponsePolicy2());
  }
  pipeline.addPolicy(wrapAbortSignalLikePolicy());
  pipeline.addPolicy(formDataPolicy2(), { beforePolicies: [multipartPolicyName2] });
  pipeline.addPolicy(userAgentPolicy2(options.userAgentOptions));
  pipeline.addPolicy(setClientRequestIdPolicy((_a3 = options.telemetryOptions) === null || _a3 === void 0 ? void 0 : _a3.clientRequestIdHeaderName));
  pipeline.addPolicy(multipartPolicy2(), { afterPhase: "Deserialize" });
  pipeline.addPolicy(defaultRetryPolicy2(options.retryOptions), { phase: "Retry" });
  pipeline.addPolicy(tracingPolicy(Object.assign(Object.assign({}, options.userAgentOptions), options.loggingOptions)), {
    afterPhase: "Retry"
  });
  if (isNodeLike2) {
    pipeline.addPolicy(redirectPolicy2(options.redirectOptions), { afterPhase: "Retry" });
  }
  pipeline.addPolicy(logPolicy2(options.loggingOptions), { afterPhase: "Sign" });
  return pipeline;
}
var init_createPipelineFromOptions2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/createPipelineFromOptions.js"() {
    init_logPolicy2();
    init_pipeline2();
    init_redirectPolicy2();
    init_userAgentPolicy2();
    init_multipartPolicy2();
    init_decompressResponsePolicy2();
    init_defaultRetryPolicy2();
    init_formDataPolicy2();
    init_browser4();
    init_proxyPolicy2();
    init_setClientRequestIdPolicy();
    init_agentPolicy2();
    init_tlsPolicy2();
    init_tracingPolicy();
    init_wrapAbortSignalLikePolicy();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/defaultHttpClient.js
function createDefaultHttpClient2() {
  const client = createDefaultHttpClient();
  return {
    async sendRequest(request) {
      const { abortSignal, cleanup } = request.abortSignal ? wrapAbortSignalLike(request.abortSignal) : {};
      try {
        request.abortSignal = abortSignal;
        return await client.sendRequest(request);
      } finally {
        cleanup === null || cleanup === void 0 ? void 0 : cleanup();
      }
    }
  };
}
var init_defaultHttpClient2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/defaultHttpClient.js"() {
    init_browser5();
    init_wrapAbortSignal();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/httpHeaders.js
function createHttpHeaders2(rawHeaders) {
  return createHttpHeaders(rawHeaders);
}
var init_httpHeaders2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/httpHeaders.js"() {
    init_browser5();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/pipelineRequest.js
function createPipelineRequest2(options) {
  return createPipelineRequest(options);
}
var init_pipelineRequest2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/pipelineRequest.js"() {
    init_browser5();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/exponentialRetryPolicy.js
var init_exponentialRetryPolicy2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/exponentialRetryPolicy.js"() {
    init_internal3();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/systemErrorRetryPolicy.js
var init_systemErrorRetryPolicy2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/systemErrorRetryPolicy.js"() {
    init_internal3();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/throttlingRetryPolicy.js
var init_throttlingRetryPolicy2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/throttlingRetryPolicy.js"() {
    init_internal3();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/retryPolicy.js
var retryPolicyLogger2;
var init_retryPolicy2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/retryPolicy.js"() {
    init_browser();
    init_constants3();
    init_internal3();
    retryPolicyLogger2 = createClientLogger2("core-rest-pipeline retryPolicy");
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/util/tokenCycler.js
async function beginRefresh(getAccessToken, retryIntervalInMs, refreshTimeout) {
  async function tryGetAccessToken() {
    if (Date.now() < refreshTimeout) {
      try {
        return await getAccessToken();
      } catch (_a3) {
        return null;
      }
    } else {
      const finalToken = await getAccessToken();
      if (finalToken === null) {
        throw new Error("Failed to refresh access token.");
      }
      return finalToken;
    }
  }
  let token = await tryGetAccessToken();
  while (token === null) {
    await delay(retryIntervalInMs);
    token = await tryGetAccessToken();
  }
  return token;
}
function createTokenCycler(credential, tokenCyclerOptions) {
  let refreshWorker = null;
  let token = null;
  let tenantId;
  const options = Object.assign(Object.assign({}, DEFAULT_CYCLER_OPTIONS), tokenCyclerOptions);
  const cycler = {
    /**
     * Produces true if a refresh job is currently in progress.
     */
    get isRefreshing() {
      return refreshWorker !== null;
    },
    /**
     * Produces true if the cycler SHOULD refresh (we are within the refresh
     * window and not already refreshing)
     */
    get shouldRefresh() {
      var _a3;
      if (cycler.isRefreshing) {
        return false;
      }
      if ((token === null || token === void 0 ? void 0 : token.refreshAfterTimestamp) && token.refreshAfterTimestamp < Date.now()) {
        return true;
      }
      return ((_a3 = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a3 !== void 0 ? _a3 : 0) - options.refreshWindowInMs < Date.now();
    },
    /**
     * Produces true if the cycler MUST refresh (null or nearly-expired
     * token).
     */
    get mustRefresh() {
      return token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now();
    }
  };
  function refresh(scopes, getTokenOptions) {
    var _a3;
    if (!cycler.isRefreshing) {
      const tryGetAccessToken = () => credential.getToken(scopes, getTokenOptions);
      refreshWorker = beginRefresh(
        tryGetAccessToken,
        options.retryIntervalInMs,
        // If we don't have a token, then we should timeout immediately
        (_a3 = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a3 !== void 0 ? _a3 : Date.now()
      ).then((_token) => {
        refreshWorker = null;
        token = _token;
        tenantId = getTokenOptions.tenantId;
        return token;
      }).catch((reason) => {
        refreshWorker = null;
        token = null;
        tenantId = void 0;
        throw reason;
      });
    }
    return refreshWorker;
  }
  return async (scopes, tokenOptions) => {
    const hasClaimChallenge = Boolean(tokenOptions.claims);
    const tenantIdChanged = tenantId !== tokenOptions.tenantId;
    if (hasClaimChallenge) {
      token = null;
    }
    const mustRefresh = tenantIdChanged || hasClaimChallenge || cycler.mustRefresh;
    if (mustRefresh) {
      return refresh(scopes, tokenOptions);
    }
    if (cycler.shouldRefresh) {
      refresh(scopes, tokenOptions);
    }
    return token;
  };
}
var DEFAULT_CYCLER_OPTIONS;
var init_tokenCycler = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/util/tokenCycler.js"() {
    init_browser4();
    DEFAULT_CYCLER_OPTIONS = {
      forcedRefreshWindowInMs: 1e3,
      // Force waiting for a refresh 1s before the token expires
      retryIntervalInMs: 3e3,
      // Allow refresh attempts every 3s
      refreshWindowInMs: 1e3 * 60 * 2
      // Start refreshing 2m before expiry
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/bearerTokenAuthenticationPolicy.js
async function trySendRequest(request, next) {
  try {
    return [await next(request), void 0];
  } catch (e) {
    if (isRestError2(e) && e.response) {
      return [e.response, e];
    } else {
      throw e;
    }
  }
}
async function defaultAuthorizeRequest(options) {
  const { scopes, getAccessToken, request } = options;
  const getTokenOptions = {
    abortSignal: request.abortSignal,
    tracingOptions: request.tracingOptions,
    enableCae: true
  };
  const accessToken = await getAccessToken(scopes, getTokenOptions);
  if (accessToken) {
    options.request.headers.set("Authorization", `Bearer ${accessToken.token}`);
  }
}
function isChallengeResponse(response) {
  return response.status === 401 && response.headers.has("WWW-Authenticate");
}
async function authorizeRequestOnCaeChallenge(onChallengeOptions, caeClaims) {
  var _a3;
  const { scopes } = onChallengeOptions;
  const accessToken = await onChallengeOptions.getAccessToken(scopes, {
    enableCae: true,
    claims: caeClaims
  });
  if (!accessToken) {
    return false;
  }
  onChallengeOptions.request.headers.set("Authorization", `${(_a3 = accessToken.tokenType) !== null && _a3 !== void 0 ? _a3 : "Bearer"} ${accessToken.token}`);
  return true;
}
function bearerTokenAuthenticationPolicy(options) {
  var _a3, _b2, _c2;
  const { credential, scopes, challengeCallbacks } = options;
  const logger24 = options.logger || logger6;
  const callbacks = {
    authorizeRequest: (_b2 = (_a3 = challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequest) === null || _a3 === void 0 ? void 0 : _a3.bind(challengeCallbacks)) !== null && _b2 !== void 0 ? _b2 : defaultAuthorizeRequest,
    authorizeRequestOnChallenge: (_c2 = challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequestOnChallenge) === null || _c2 === void 0 ? void 0 : _c2.bind(challengeCallbacks)
  };
  const getAccessToken = credential ? createTokenCycler(
    credential
    /* , options */
  ) : () => Promise.resolve(null);
  return {
    name: bearerTokenAuthenticationPolicyName,
    /**
     * If there's no challenge parameter:
     * - It will try to retrieve the token using the cache, or the credential's getToken.
     * - Then it will try the next policy with or without the retrieved token.
     *
     * It uses the challenge parameters to:
     * - Skip a first attempt to get the token from the credential if there's no cached token,
     *   since it expects the token to be retrievable only after the challenge.
     * - Prepare the outgoing request if the `prepareRequest` method has been provided.
     * - Send an initial request to receive the challenge if it fails.
     * - Process a challenge if the response contains it.
     * - Retrieve a token with the challenge information, then re-send the request.
     */
    async sendRequest(request, next) {
      if (!request.url.toLowerCase().startsWith("https://")) {
        throw new Error("Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.");
      }
      await callbacks.authorizeRequest({
        scopes: Array.isArray(scopes) ? scopes : [scopes],
        request,
        getAccessToken,
        logger: logger24
      });
      let response;
      let error;
      let shouldSendRequest;
      [response, error] = await trySendRequest(request, next);
      if (isChallengeResponse(response)) {
        let claims = getCaeChallengeClaims(response.headers.get("WWW-Authenticate"));
        if (claims) {
          let parsedClaim;
          try {
            parsedClaim = atob(claims);
          } catch (e) {
            logger24.warning(`The WWW-Authenticate header contains "claims" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`);
            return response;
          }
          shouldSendRequest = await authorizeRequestOnCaeChallenge({
            scopes: Array.isArray(scopes) ? scopes : [scopes],
            response,
            request,
            getAccessToken,
            logger: logger24
          }, parsedClaim);
          if (shouldSendRequest) {
            [response, error] = await trySendRequest(request, next);
          }
        } else if (callbacks.authorizeRequestOnChallenge) {
          shouldSendRequest = await callbacks.authorizeRequestOnChallenge({
            scopes: Array.isArray(scopes) ? scopes : [scopes],
            request,
            response,
            getAccessToken,
            logger: logger24
          });
          if (shouldSendRequest) {
            [response, error] = await trySendRequest(request, next);
          }
          if (isChallengeResponse(response)) {
            claims = getCaeChallengeClaims(response.headers.get("WWW-Authenticate"));
            if (claims) {
              let parsedClaim;
              try {
                parsedClaim = atob(claims);
              } catch (e) {
                logger24.warning(`The WWW-Authenticate header contains "claims" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`);
                return response;
              }
              shouldSendRequest = await authorizeRequestOnCaeChallenge({
                scopes: Array.isArray(scopes) ? scopes : [scopes],
                response,
                request,
                getAccessToken,
                logger: logger24
              }, parsedClaim);
              if (shouldSendRequest) {
                [response, error] = await trySendRequest(request, next);
              }
            }
          }
        }
      }
      if (error) {
        throw error;
      } else {
        return response;
      }
    }
  };
}
function parseChallenges(challenges) {
  const challengeRegex = /(\w+)\s+((?:\w+=(?:"[^"]*"|[^,]*),?\s*)+)/g;
  const paramRegex = /(\w+)="([^"]*)"/g;
  const parsedChallenges = [];
  let match;
  while ((match = challengeRegex.exec(challenges)) !== null) {
    const scheme = match[1];
    const paramsString = match[2];
    const params = {};
    let paramMatch;
    while ((paramMatch = paramRegex.exec(paramsString)) !== null) {
      params[paramMatch[1]] = paramMatch[2];
    }
    parsedChallenges.push({ scheme, params });
  }
  return parsedChallenges;
}
function getCaeChallengeClaims(challenges) {
  var _a3;
  if (!challenges) {
    return;
  }
  const parsedChallenges = parseChallenges(challenges);
  return (_a3 = parsedChallenges.find((x) => x.scheme === "Bearer" && x.params.claims && x.params.error === "insufficient_claims")) === null || _a3 === void 0 ? void 0 : _a3.params.claims;
}
var bearerTokenAuthenticationPolicyName;
var init_bearerTokenAuthenticationPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/bearerTokenAuthenticationPolicy.js"() {
    init_tokenCycler();
    init_log3();
    init_restError3();
    bearerTokenAuthenticationPolicyName = "bearerTokenAuthenticationPolicy";
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/ndJsonPolicy.js
var init_ndJsonPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/ndJsonPolicy.js"() {
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/auxiliaryAuthenticationHeaderPolicy.js
var init_auxiliaryAuthenticationHeaderPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/auxiliaryAuthenticationHeaderPolicy.js"() {
    init_tokenCycler();
    init_log3();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/index.js
var init_browser6 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/index.js"() {
    init_pipeline2();
    init_createPipelineFromOptions2();
    init_defaultHttpClient2();
    init_httpHeaders2();
    init_pipelineRequest2();
    init_restError3();
    init_decompressResponsePolicy2();
    init_exponentialRetryPolicy2();
    init_setClientRequestIdPolicy();
    init_logPolicy2();
    init_multipartPolicy2();
    init_proxyPolicy2();
    init_redirectPolicy2();
    init_systemErrorRetryPolicy2();
    init_throttlingRetryPolicy2();
    init_retryPolicy2();
    init_tracingPolicy();
    init_defaultRetryPolicy2();
    init_userAgentPolicy2();
    init_tlsPolicy2();
    init_formDataPolicy2();
    init_bearerTokenAuthenticationPolicy();
    init_ndJsonPolicy();
    init_auxiliaryAuthenticationHeaderPolicy();
    init_agentPolicy2();
    init_file();
  }
});

// node_modules/@azure/identity/dist/browser/util/processMultiTenantRequest.js
function createConfigurationErrorMessage(tenantId) {
  return `The current credential is not configured to acquire tokens for tenant ${tenantId}. To enable acquiring tokens for this tenant add it to the AdditionallyAllowedTenants on the credential options, or add "*" to AdditionallyAllowedTenants to allow acquiring tokens for any tenant.`;
}
function processMultiTenantRequest(tenantId, getTokenOptions, additionallyAllowedTenantIds = []) {
  var _a3;
  let resolvedTenantId;
  if (tenantId === "adfs") {
    resolvedTenantId = tenantId;
  } else {
    resolvedTenantId = (_a3 = getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.tenantId) !== null && _a3 !== void 0 ? _a3 : tenantId;
  }
  if (tenantId && resolvedTenantId !== tenantId && !additionallyAllowedTenantIds.includes("*") && !additionallyAllowedTenantIds.some((t) => t.localeCompare(resolvedTenantId) === 0)) {
    throw new Error(createConfigurationErrorMessage(tenantId));
  }
  return resolvedTenantId;
}
var init_processMultiTenantRequest = __esm({
  "node_modules/@azure/identity/dist/browser/util/processMultiTenantRequest.js"() {
  }
});

// node_modules/@azure/identity/dist/browser/util/tenantIdUtils.js
function checkTenantId(logger24, tenantId) {
  if (!tenantId.match(/^[0-9a-zA-Z-.]+$/)) {
    const error = new Error("Invalid tenant id provided. You can locate your tenant id by following the instructions listed here: https://learn.microsoft.com/partner-center/find-ids-and-domain-names.");
    logger24.info(formatError("", error));
    throw error;
  }
}
function resolveTenantId(logger24, tenantId, clientId) {
  if (tenantId) {
    checkTenantId(logger24, tenantId);
    return tenantId;
  }
  if (!clientId) {
    clientId = DeveloperSignOnClientId;
  }
  if (clientId !== DeveloperSignOnClientId) {
    return "common";
  }
  return "organizations";
}
function resolveAdditionallyAllowedTenantIds(additionallyAllowedTenants) {
  if (!additionallyAllowedTenants || additionallyAllowedTenants.length === 0) {
    return [];
  }
  if (additionallyAllowedTenants.includes("*")) {
    return ALL_TENANTS;
  }
  return additionallyAllowedTenants;
}
var init_tenantIdUtils = __esm({
  "node_modules/@azure/identity/dist/browser/util/tenantIdUtils.js"() {
    init_constants();
    init_logging();
    init_processMultiTenantRequest();
  }
});

// node_modules/@azure/core-client/dist/browser/base64.js
var init_base64 = __esm({
  "node_modules/@azure/core-client/dist/browser/base64.js"() {
  }
});

// node_modules/@azure/core-client/dist/browser/interfaces.js
var XML_ATTRKEY, XML_CHARKEY;
var init_interfaces = __esm({
  "node_modules/@azure/core-client/dist/browser/interfaces.js"() {
    XML_ATTRKEY = "$";
    XML_CHARKEY = "_";
  }
});

// node_modules/@azure/core-client/dist/browser/utils.js
function isPrimitiveBody(value, mapperTypeName) {
  return mapperTypeName !== "Composite" && mapperTypeName !== "Dictionary" && (typeof value === "string" || typeof value === "number" || typeof value === "boolean" || (mapperTypeName === null || mapperTypeName === void 0 ? void 0 : mapperTypeName.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i)) !== null || value === void 0 || value === null);
}
function handleNullableResponseAndWrappableBody(responseObject) {
  const combinedHeadersAndBody = Object.assign(Object.assign({}, responseObject.headers), responseObject.body);
  if (responseObject.hasNullableType && Object.getOwnPropertyNames(combinedHeadersAndBody).length === 0) {
    return responseObject.shouldWrapBody ? { body: null } : null;
  } else {
    return responseObject.shouldWrapBody ? Object.assign(Object.assign({}, responseObject.headers), { body: responseObject.body }) : combinedHeadersAndBody;
  }
}
function flattenResponse(fullResponse, responseSpec) {
  var _a3, _b2;
  const parsedHeaders = fullResponse.parsedHeaders;
  if (fullResponse.request.method === "HEAD") {
    return Object.assign(Object.assign({}, parsedHeaders), { body: fullResponse.parsedBody });
  }
  const bodyMapper = responseSpec && responseSpec.bodyMapper;
  const isNullable = Boolean(bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.nullable);
  const expectedBodyTypeName = bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.type.name;
  if (expectedBodyTypeName === "Stream") {
    return Object.assign(Object.assign({}, parsedHeaders), { blobBody: fullResponse.blobBody, readableStreamBody: fullResponse.readableStreamBody });
  }
  const modelProperties = expectedBodyTypeName === "Composite" && bodyMapper.type.modelProperties || {};
  const isPageableResponse = Object.keys(modelProperties).some((k) => modelProperties[k].serializedName === "");
  if (expectedBodyTypeName === "Sequence" || isPageableResponse) {
    const arrayResponse = (_a3 = fullResponse.parsedBody) !== null && _a3 !== void 0 ? _a3 : [];
    for (const key of Object.keys(modelProperties)) {
      if (modelProperties[key].serializedName) {
        arrayResponse[key] = (_b2 = fullResponse.parsedBody) === null || _b2 === void 0 ? void 0 : _b2[key];
      }
    }
    if (parsedHeaders) {
      for (const key of Object.keys(parsedHeaders)) {
        arrayResponse[key] = parsedHeaders[key];
      }
    }
    return isNullable && !fullResponse.parsedBody && !parsedHeaders && Object.getOwnPropertyNames(modelProperties).length === 0 ? null : arrayResponse;
  }
  return handleNullableResponseAndWrappableBody({
    body: fullResponse.parsedBody,
    headers: parsedHeaders,
    hasNullableType: isNullable,
    shouldWrapBody: isPrimitiveBody(fullResponse.parsedBody, expectedBodyTypeName)
  });
}
var init_utils2 = __esm({
  "node_modules/@azure/core-client/dist/browser/utils.js"() {
  }
});

// node_modules/@azure/core-client/dist/browser/serializer.js
var MapperTypeNames;
var init_serializer = __esm({
  "node_modules/@azure/core-client/dist/browser/serializer.js"() {
    init_base64();
    init_interfaces();
    init_utils2();
    MapperTypeNames = {
      Base64Url: "Base64Url",
      Boolean: "Boolean",
      ByteArray: "ByteArray",
      Composite: "Composite",
      Date: "Date",
      DateTime: "DateTime",
      DateTimeRfc1123: "DateTimeRfc1123",
      Dictionary: "Dictionary",
      Enum: "Enum",
      Number: "Number",
      Object: "Object",
      Sequence: "Sequence",
      String: "String",
      Stream: "Stream",
      TimeSpan: "TimeSpan",
      UnixTime: "UnixTime"
    };
  }
});

// node_modules/@azure/core-client/dist/browser/state.js
var state2;
var init_state2 = __esm({
  "node_modules/@azure/core-client/dist/browser/state.js"() {
    state2 = {
      operationRequestMap: /* @__PURE__ */ new WeakMap()
    };
  }
});

// node_modules/@azure/core-client/dist/browser/operationHelpers.js
function getOperationArgumentValueFromParameter(operationArguments, parameter, fallbackObject) {
  let parameterPath = parameter.parameterPath;
  const parameterMapper = parameter.mapper;
  let value;
  if (typeof parameterPath === "string") {
    parameterPath = [parameterPath];
  }
  if (Array.isArray(parameterPath)) {
    if (parameterPath.length > 0) {
      if (parameterMapper.isConstant) {
        value = parameterMapper.defaultValue;
      } else {
        let propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);
        if (!propertySearchResult.propertyFound && fallbackObject) {
          propertySearchResult = getPropertyFromParameterPath(fallbackObject, parameterPath);
        }
        let useDefaultValue = false;
        if (!propertySearchResult.propertyFound) {
          useDefaultValue = parameterMapper.required || parameterPath[0] === "options" && parameterPath.length === 2;
        }
        value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;
      }
    }
  } else {
    if (parameterMapper.required) {
      value = {};
    }
    for (const propertyName in parameterPath) {
      const propertyMapper = parameterMapper.type.modelProperties[propertyName];
      const propertyPath = parameterPath[propertyName];
      const propertyValue = getOperationArgumentValueFromParameter(operationArguments, {
        parameterPath: propertyPath,
        mapper: propertyMapper
      }, fallbackObject);
      if (propertyValue !== void 0) {
        if (!value) {
          value = {};
        }
        value[propertyName] = propertyValue;
      }
    }
  }
  return value;
}
function getPropertyFromParameterPath(parent, parameterPath) {
  const result = { propertyFound: false };
  let i = 0;
  for (; i < parameterPath.length; ++i) {
    const parameterPathPart = parameterPath[i];
    if (parent && parameterPathPart in parent) {
      parent = parent[parameterPathPart];
    } else {
      break;
    }
  }
  if (i === parameterPath.length) {
    result.propertyValue = parent;
    result.propertyFound = true;
  }
  return result;
}
function hasOriginalRequest(request) {
  return originalRequestSymbol in request;
}
function getOperationRequestInfo(request) {
  if (hasOriginalRequest(request)) {
    return getOperationRequestInfo(request[originalRequestSymbol]);
  }
  let info = state2.operationRequestMap.get(request);
  if (!info) {
    info = {};
    state2.operationRequestMap.set(request, info);
  }
  return info;
}
var originalRequestSymbol;
var init_operationHelpers = __esm({
  "node_modules/@azure/core-client/dist/browser/operationHelpers.js"() {
    init_state2();
    originalRequestSymbol = Symbol.for("@azure/core-client original request");
  }
});

// node_modules/@azure/core-client/dist/browser/deserializationPolicy.js
function deserializationPolicy(options = {}) {
  var _a3, _b2, _c2, _d2, _e, _f, _g;
  const jsonContentTypes = (_b2 = (_a3 = options.expectedContentTypes) === null || _a3 === void 0 ? void 0 : _a3.json) !== null && _b2 !== void 0 ? _b2 : defaultJsonContentTypes;
  const xmlContentTypes = (_d2 = (_c2 = options.expectedContentTypes) === null || _c2 === void 0 ? void 0 : _c2.xml) !== null && _d2 !== void 0 ? _d2 : defaultXmlContentTypes;
  const parseXML = options.parseXML;
  const serializerOptions = options.serializerOptions;
  const updatedOptions = {
    xml: {
      rootName: (_e = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _e !== void 0 ? _e : "",
      includeRoot: (_f = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _f !== void 0 ? _f : false,
      xmlCharKey: (_g = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _g !== void 0 ? _g : XML_CHARKEY
    }
  };
  return {
    name: deserializationPolicyName,
    async sendRequest(request, next) {
      const response = await next(request);
      return deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, updatedOptions, parseXML);
    }
  };
}
function getOperationResponseMap(parsedResponse) {
  let result;
  const request = parsedResponse.request;
  const operationInfo = getOperationRequestInfo(request);
  const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;
  if (operationSpec) {
    if (!(operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter)) {
      result = operationSpec.responses[parsedResponse.status];
    } else {
      result = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter(operationSpec, parsedResponse);
    }
  }
  return result;
}
function shouldDeserializeResponse(parsedResponse) {
  const request = parsedResponse.request;
  const operationInfo = getOperationRequestInfo(request);
  const shouldDeserialize = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.shouldDeserialize;
  let result;
  if (shouldDeserialize === void 0) {
    result = true;
  } else if (typeof shouldDeserialize === "boolean") {
    result = shouldDeserialize;
  } else {
    result = shouldDeserialize(parsedResponse);
  }
  return result;
}
async function deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, options, parseXML) {
  const parsedResponse = await parse(jsonContentTypes, xmlContentTypes, response, options, parseXML);
  if (!shouldDeserializeResponse(parsedResponse)) {
    return parsedResponse;
  }
  const operationInfo = getOperationRequestInfo(parsedResponse.request);
  const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;
  if (!operationSpec || !operationSpec.responses) {
    return parsedResponse;
  }
  const responseSpec = getOperationResponseMap(parsedResponse);
  const { error, shouldReturnResponse } = handleErrorResponse(parsedResponse, operationSpec, responseSpec, options);
  if (error) {
    throw error;
  } else if (shouldReturnResponse) {
    return parsedResponse;
  }
  if (responseSpec) {
    if (responseSpec.bodyMapper) {
      let valueToDeserialize = parsedResponse.parsedBody;
      if (operationSpec.isXML && responseSpec.bodyMapper.type.name === MapperTypeNames.Sequence) {
        valueToDeserialize = typeof valueToDeserialize === "object" ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : [];
      }
      try {
        parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, "operationRes.parsedBody", options);
      } catch (deserializeError) {
        const restError = new RestError2(`Error ${deserializeError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, {
          statusCode: parsedResponse.status,
          request: parsedResponse.request,
          response: parsedResponse
        });
        throw restError;
      }
    } else if (operationSpec.httpMethod === "HEAD") {
      parsedResponse.parsedBody = response.status >= 200 && response.status < 300;
    }
    if (responseSpec.headersMapper) {
      parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders", { xml: {}, ignoreUnknownProperties: true });
    }
  }
  return parsedResponse;
}
function isOperationSpecEmpty(operationSpec) {
  const expectedStatusCodes = Object.keys(operationSpec.responses);
  return expectedStatusCodes.length === 0 || expectedStatusCodes.length === 1 && expectedStatusCodes[0] === "default";
}
function handleErrorResponse(parsedResponse, operationSpec, responseSpec, options) {
  var _a3, _b2, _c2, _d2, _e;
  const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;
  const isExpectedStatusCode = isOperationSpecEmpty(operationSpec) ? isSuccessByStatus : !!responseSpec;
  if (isExpectedStatusCode) {
    if (responseSpec) {
      if (!responseSpec.isError) {
        return { error: null, shouldReturnResponse: false };
      }
    } else {
      return { error: null, shouldReturnResponse: false };
    }
  }
  const errorResponseSpec = responseSpec !== null && responseSpec !== void 0 ? responseSpec : operationSpec.responses.default;
  const initialErrorMessage = ((_a3 = parsedResponse.request.streamResponseStatusCodes) === null || _a3 === void 0 ? void 0 : _a3.has(parsedResponse.status)) ? `Unexpected status code: ${parsedResponse.status}` : parsedResponse.bodyAsText;
  const error = new RestError2(initialErrorMessage, {
    statusCode: parsedResponse.status,
    request: parsedResponse.request,
    response: parsedResponse
  });
  if (!errorResponseSpec && !(((_c2 = (_b2 = parsedResponse.parsedBody) === null || _b2 === void 0 ? void 0 : _b2.error) === null || _c2 === void 0 ? void 0 : _c2.code) && ((_e = (_d2 = parsedResponse.parsedBody) === null || _d2 === void 0 ? void 0 : _d2.error) === null || _e === void 0 ? void 0 : _e.message))) {
    throw error;
  }
  const defaultBodyMapper = errorResponseSpec === null || errorResponseSpec === void 0 ? void 0 : errorResponseSpec.bodyMapper;
  const defaultHeadersMapper = errorResponseSpec === null || errorResponseSpec === void 0 ? void 0 : errorResponseSpec.headersMapper;
  try {
    if (parsedResponse.parsedBody) {
      const parsedBody = parsedResponse.parsedBody;
      let deserializedError;
      if (defaultBodyMapper) {
        let valueToDeserialize = parsedBody;
        if (operationSpec.isXML && defaultBodyMapper.type.name === MapperTypeNames.Sequence) {
          valueToDeserialize = [];
          const elementName = defaultBodyMapper.xmlElementName;
          if (typeof parsedBody === "object" && elementName) {
            valueToDeserialize = parsedBody[elementName];
          }
        }
        deserializedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, "error.response.parsedBody", options);
      }
      const internalError = parsedBody.error || deserializedError || parsedBody;
      error.code = internalError.code;
      if (internalError.message) {
        error.message = internalError.message;
      }
      if (defaultBodyMapper) {
        error.response.parsedBody = deserializedError;
      }
    }
    if (parsedResponse.headers && defaultHeadersMapper) {
      error.response.parsedHeaders = operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders");
    }
  } catch (defaultError) {
    error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody - "${parsedResponse.bodyAsText}" for the default response.`;
  }
  return { error, shouldReturnResponse: false };
}
async function parse(jsonContentTypes, xmlContentTypes, operationResponse, opts, parseXML) {
  var _a3;
  if (!((_a3 = operationResponse.request.streamResponseStatusCodes) === null || _a3 === void 0 ? void 0 : _a3.has(operationResponse.status)) && operationResponse.bodyAsText) {
    const text = operationResponse.bodyAsText;
    const contentType = operationResponse.headers.get("Content-Type") || "";
    const contentComponents = !contentType ? [] : contentType.split(";").map((component) => component.toLowerCase());
    try {
      if (contentComponents.length === 0 || contentComponents.some((component) => jsonContentTypes.indexOf(component) !== -1)) {
        operationResponse.parsedBody = JSON.parse(text);
        return operationResponse;
      } else if (contentComponents.some((component) => xmlContentTypes.indexOf(component) !== -1)) {
        if (!parseXML) {
          throw new Error("Parsing XML not supported.");
        }
        const body = await parseXML(text, opts.xml);
        operationResponse.parsedBody = body;
        return operationResponse;
      }
    } catch (err) {
      const msg = `Error "${err}" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;
      const errCode = err.code || RestError2.PARSE_ERROR;
      const e = new RestError2(msg, {
        code: errCode,
        statusCode: operationResponse.status,
        request: operationResponse.request,
        response: operationResponse
      });
      throw e;
    }
  }
  return operationResponse;
}
var defaultJsonContentTypes, defaultXmlContentTypes, deserializationPolicyName;
var init_deserializationPolicy = __esm({
  "node_modules/@azure/core-client/dist/browser/deserializationPolicy.js"() {
    init_interfaces();
    init_browser6();
    init_serializer();
    init_operationHelpers();
    defaultJsonContentTypes = ["application/json", "text/json"];
    defaultXmlContentTypes = ["application/xml", "application/atom+xml"];
    deserializationPolicyName = "deserializationPolicy";
  }
});

// node_modules/@azure/core-client/dist/browser/interfaceHelpers.js
function getStreamingResponseStatusCodes(operationSpec) {
  const result = /* @__PURE__ */ new Set();
  for (const statusCode in operationSpec.responses) {
    const operationResponse = operationSpec.responses[statusCode];
    if (operationResponse.bodyMapper && operationResponse.bodyMapper.type.name === MapperTypeNames.Stream) {
      result.add(Number(statusCode));
    }
  }
  return result;
}
function getPathStringFromParameter(parameter) {
  const { parameterPath, mapper } = parameter;
  let result;
  if (typeof parameterPath === "string") {
    result = parameterPath;
  } else if (Array.isArray(parameterPath)) {
    result = parameterPath.join(".");
  } else {
    result = mapper.serializedName;
  }
  return result;
}
var init_interfaceHelpers = __esm({
  "node_modules/@azure/core-client/dist/browser/interfaceHelpers.js"() {
    init_serializer();
  }
});

// node_modules/@azure/core-client/dist/browser/serializationPolicy.js
function serializationPolicy(options = {}) {
  const stringifyXML = options.stringifyXML;
  return {
    name: serializationPolicyName,
    async sendRequest(request, next) {
      const operationInfo = getOperationRequestInfo(request);
      const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;
      const operationArguments = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationArguments;
      if (operationSpec && operationArguments) {
        serializeHeaders(request, operationArguments, operationSpec);
        serializeRequestBody(request, operationArguments, operationSpec, stringifyXML);
      }
      return next(request);
    }
  };
}
function serializeHeaders(request, operationArguments, operationSpec) {
  var _a3, _b2;
  if (operationSpec.headerParameters) {
    for (const headerParameter of operationSpec.headerParameters) {
      let headerValue = getOperationArgumentValueFromParameter(operationArguments, headerParameter);
      if (headerValue !== null && headerValue !== void 0 || headerParameter.mapper.required) {
        headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, getPathStringFromParameter(headerParameter));
        const headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;
        if (headerCollectionPrefix) {
          for (const key of Object.keys(headerValue)) {
            request.headers.set(headerCollectionPrefix + key, headerValue[key]);
          }
        } else {
          request.headers.set(headerParameter.mapper.serializedName || getPathStringFromParameter(headerParameter), headerValue);
        }
      }
    }
  }
  const customHeaders = (_b2 = (_a3 = operationArguments.options) === null || _a3 === void 0 ? void 0 : _a3.requestOptions) === null || _b2 === void 0 ? void 0 : _b2.customHeaders;
  if (customHeaders) {
    for (const customHeaderName of Object.keys(customHeaders)) {
      request.headers.set(customHeaderName, customHeaders[customHeaderName]);
    }
  }
}
function serializeRequestBody(request, operationArguments, operationSpec, stringifyXML = function() {
  throw new Error("XML serialization unsupported!");
}) {
  var _a3, _b2, _c2, _d2, _e;
  const serializerOptions = (_a3 = operationArguments.options) === null || _a3 === void 0 ? void 0 : _a3.serializerOptions;
  const updatedOptions = {
    xml: {
      rootName: (_b2 = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _b2 !== void 0 ? _b2 : "",
      includeRoot: (_c2 = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _c2 !== void 0 ? _c2 : false,
      xmlCharKey: (_d2 = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _d2 !== void 0 ? _d2 : XML_CHARKEY
    }
  };
  const xmlCharKey = updatedOptions.xml.xmlCharKey;
  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {
    request.body = getOperationArgumentValueFromParameter(operationArguments, operationSpec.requestBody);
    const bodyMapper = operationSpec.requestBody.mapper;
    const { required, serializedName, xmlName, xmlElementName, xmlNamespace, xmlNamespacePrefix, nullable } = bodyMapper;
    const typeName = bodyMapper.type.name;
    try {
      if (request.body !== void 0 && request.body !== null || nullable && request.body === null || required) {
        const requestBodyParameterPathString = getPathStringFromParameter(operationSpec.requestBody);
        request.body = operationSpec.serializer.serialize(bodyMapper, request.body, requestBodyParameterPathString, updatedOptions);
        const isStream = typeName === MapperTypeNames.Stream;
        if (operationSpec.isXML) {
          const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : "xmlns";
          const value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, request.body, updatedOptions);
          if (typeName === MapperTypeNames.Sequence) {
            request.body = stringifyXML(prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), { rootName: xmlName || serializedName, xmlCharKey });
          } else if (!isStream) {
            request.body = stringifyXML(value, {
              rootName: xmlName || serializedName,
              xmlCharKey
            });
          }
        } else if (typeName === MapperTypeNames.String && (((_e = operationSpec.contentType) === null || _e === void 0 ? void 0 : _e.match("text/plain")) || operationSpec.mediaType === "text")) {
          return;
        } else if (!isStream) {
          request.body = JSON.stringify(request.body);
        }
      }
    } catch (error) {
      throw new Error(`Error "${error.message}" occurred in serializing the payload - ${JSON.stringify(serializedName, void 0, "  ")}.`);
    }
  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {
    request.formData = {};
    for (const formDataParameter of operationSpec.formDataParameters) {
      const formDataParameterValue = getOperationArgumentValueFromParameter(operationArguments, formDataParameter);
      if (formDataParameterValue !== void 0 && formDataParameterValue !== null) {
        const formDataParameterPropertyName = formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);
        request.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, getPathStringFromParameter(formDataParameter), updatedOptions);
      }
    }
  }
}
function getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {
  if (xmlNamespace && !["Composite", "Sequence", "Dictionary"].includes(typeName)) {
    const result = {};
    result[options.xml.xmlCharKey] = serializedValue;
    result[XML_ATTRKEY] = { [xmlnsKey]: xmlNamespace };
    return result;
  }
  return serializedValue;
}
function prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {
  if (!Array.isArray(obj)) {
    obj = [obj];
  }
  if (!xmlNamespaceKey || !xmlNamespace) {
    return { [elementName]: obj };
  }
  const result = { [elementName]: obj };
  result[XML_ATTRKEY] = { [xmlNamespaceKey]: xmlNamespace };
  return result;
}
var serializationPolicyName;
var init_serializationPolicy = __esm({
  "node_modules/@azure/core-client/dist/browser/serializationPolicy.js"() {
    init_interfaces();
    init_operationHelpers();
    init_serializer();
    init_interfaceHelpers();
    serializationPolicyName = "serializationPolicy";
  }
});

// node_modules/@azure/core-client/dist/browser/pipeline.js
function createClientPipeline(options = {}) {
  const pipeline = createPipelineFromOptions2(options !== null && options !== void 0 ? options : {});
  if (options.credentialOptions) {
    pipeline.addPolicy(bearerTokenAuthenticationPolicy({
      credential: options.credentialOptions.credential,
      scopes: options.credentialOptions.credentialScopes
    }));
  }
  pipeline.addPolicy(serializationPolicy(options.serializationOptions), { phase: "Serialize" });
  pipeline.addPolicy(deserializationPolicy(options.deserializationOptions), {
    phase: "Deserialize"
  });
  return pipeline;
}
var init_pipeline3 = __esm({
  "node_modules/@azure/core-client/dist/browser/pipeline.js"() {
    init_deserializationPolicy();
    init_browser6();
    init_serializationPolicy();
  }
});

// node_modules/@azure/core-client/dist/browser/httpClientCache.js
function getCachedDefaultHttpClient() {
  if (!cachedHttpClient) {
    cachedHttpClient = createDefaultHttpClient2();
  }
  return cachedHttpClient;
}
var cachedHttpClient;
var init_httpClientCache = __esm({
  "node_modules/@azure/core-client/dist/browser/httpClientCache.js"() {
    init_browser6();
  }
});

// node_modules/@azure/core-client/dist/browser/urlHelpers.js
function getRequestUrl(baseUri, operationSpec, operationArguments, fallbackObject) {
  const urlReplacements = calculateUrlReplacements(operationSpec, operationArguments, fallbackObject);
  let isAbsolutePath = false;
  let requestUrl = replaceAll(baseUri, urlReplacements);
  if (operationSpec.path) {
    let path = replaceAll(operationSpec.path, urlReplacements);
    if (operationSpec.path === "/{nextLink}" && path.startsWith("/")) {
      path = path.substring(1);
    }
    if (isAbsoluteUrl(path)) {
      requestUrl = path;
      isAbsolutePath = true;
    } else {
      requestUrl = appendPath(requestUrl, path);
    }
  }
  const { queryParams, sequenceParams } = calculateQueryParameters(operationSpec, operationArguments, fallbackObject);
  requestUrl = appendQueryParams(requestUrl, queryParams, sequenceParams, isAbsolutePath);
  return requestUrl;
}
function replaceAll(input, replacements) {
  let result = input;
  for (const [searchValue, replaceValue] of replacements) {
    result = result.split(searchValue).join(replaceValue);
  }
  return result;
}
function calculateUrlReplacements(operationSpec, operationArguments, fallbackObject) {
  var _a3;
  const result = /* @__PURE__ */ new Map();
  if ((_a3 = operationSpec.urlParameters) === null || _a3 === void 0 ? void 0 : _a3.length) {
    for (const urlParameter of operationSpec.urlParameters) {
      let urlParameterValue = getOperationArgumentValueFromParameter(operationArguments, urlParameter, fallbackObject);
      const parameterPathString = getPathStringFromParameter(urlParameter);
      urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, parameterPathString);
      if (!urlParameter.skipEncoding) {
        urlParameterValue = encodeURIComponent(urlParameterValue);
      }
      result.set(`{${urlParameter.mapper.serializedName || parameterPathString}}`, urlParameterValue);
    }
  }
  return result;
}
function isAbsoluteUrl(url) {
  return url.includes("://");
}
function appendPath(url, pathToAppend) {
  if (!pathToAppend) {
    return url;
  }
  const parsedUrl = new URL(url);
  let newPath = parsedUrl.pathname;
  if (!newPath.endsWith("/")) {
    newPath = `${newPath}/`;
  }
  if (pathToAppend.startsWith("/")) {
    pathToAppend = pathToAppend.substring(1);
  }
  const searchStart = pathToAppend.indexOf("?");
  if (searchStart !== -1) {
    const path = pathToAppend.substring(0, searchStart);
    const search = pathToAppend.substring(searchStart + 1);
    newPath = newPath + path;
    if (search) {
      parsedUrl.search = parsedUrl.search ? `${parsedUrl.search}&${search}` : search;
    }
  } else {
    newPath = newPath + pathToAppend;
  }
  parsedUrl.pathname = newPath;
  return parsedUrl.toString();
}
function calculateQueryParameters(operationSpec, operationArguments, fallbackObject) {
  var _a3;
  const result = /* @__PURE__ */ new Map();
  const sequenceParams = /* @__PURE__ */ new Set();
  if ((_a3 = operationSpec.queryParameters) === null || _a3 === void 0 ? void 0 : _a3.length) {
    for (const queryParameter of operationSpec.queryParameters) {
      if (queryParameter.mapper.type.name === "Sequence" && queryParameter.mapper.serializedName) {
        sequenceParams.add(queryParameter.mapper.serializedName);
      }
      let queryParameterValue = getOperationArgumentValueFromParameter(operationArguments, queryParameter, fallbackObject);
      if (queryParameterValue !== void 0 && queryParameterValue !== null || queryParameter.mapper.required) {
        queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, getPathStringFromParameter(queryParameter));
        const delimiter = queryParameter.collectionFormat ? CollectionFormatToDelimiterMap[queryParameter.collectionFormat] : "";
        if (Array.isArray(queryParameterValue)) {
          queryParameterValue = queryParameterValue.map((item) => {
            if (item === null || item === void 0) {
              return "";
            }
            return item;
          });
        }
        if (queryParameter.collectionFormat === "Multi" && queryParameterValue.length === 0) {
          continue;
        } else if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "SSV" || queryParameter.collectionFormat === "TSV")) {
          queryParameterValue = queryParameterValue.join(delimiter);
        }
        if (!queryParameter.skipEncoding) {
          if (Array.isArray(queryParameterValue)) {
            queryParameterValue = queryParameterValue.map((item) => {
              return encodeURIComponent(item);
            });
          } else {
            queryParameterValue = encodeURIComponent(queryParameterValue);
          }
        }
        if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "CSV" || queryParameter.collectionFormat === "Pipes")) {
          queryParameterValue = queryParameterValue.join(delimiter);
        }
        result.set(queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter), queryParameterValue);
      }
    }
  }
  return {
    queryParams: result,
    sequenceParams
  };
}
function simpleParseQueryParams(queryString) {
  const result = /* @__PURE__ */ new Map();
  if (!queryString || queryString[0] !== "?") {
    return result;
  }
  queryString = queryString.slice(1);
  const pairs = queryString.split("&");
  for (const pair of pairs) {
    const [name3, value] = pair.split("=", 2);
    const existingValue = result.get(name3);
    if (existingValue) {
      if (Array.isArray(existingValue)) {
        existingValue.push(value);
      } else {
        result.set(name3, [existingValue, value]);
      }
    } else {
      result.set(name3, value);
    }
  }
  return result;
}
function appendQueryParams(url, queryParams, sequenceParams, noOverwrite = false) {
  if (queryParams.size === 0) {
    return url;
  }
  const parsedUrl = new URL(url);
  const combinedParams = simpleParseQueryParams(parsedUrl.search);
  for (const [name3, value] of queryParams) {
    const existingValue = combinedParams.get(name3);
    if (Array.isArray(existingValue)) {
      if (Array.isArray(value)) {
        existingValue.push(...value);
        const valueSet = new Set(existingValue);
        combinedParams.set(name3, Array.from(valueSet));
      } else {
        existingValue.push(value);
      }
    } else if (existingValue) {
      if (Array.isArray(value)) {
        value.unshift(existingValue);
      } else if (sequenceParams.has(name3)) {
        combinedParams.set(name3, [existingValue, value]);
      }
      if (!noOverwrite) {
        combinedParams.set(name3, value);
      }
    } else {
      combinedParams.set(name3, value);
    }
  }
  const searchPieces = [];
  for (const [name3, value] of combinedParams) {
    if (typeof value === "string") {
      searchPieces.push(`${name3}=${value}`);
    } else if (Array.isArray(value)) {
      for (const subValue of value) {
        searchPieces.push(`${name3}=${subValue}`);
      }
    } else {
      searchPieces.push(`${name3}=${value}`);
    }
  }
  parsedUrl.search = searchPieces.length ? `?${searchPieces.join("&")}` : "";
  return parsedUrl.toString();
}
var CollectionFormatToDelimiterMap;
var init_urlHelpers2 = __esm({
  "node_modules/@azure/core-client/dist/browser/urlHelpers.js"() {
    init_operationHelpers();
    init_interfaceHelpers();
    CollectionFormatToDelimiterMap = {
      CSV: ",",
      SSV: " ",
      Multi: "Multi",
      TSV: "	",
      Pipes: "|"
    };
  }
});

// node_modules/@azure/core-client/dist/browser/log.js
var logger7;
var init_log4 = __esm({
  "node_modules/@azure/core-client/dist/browser/log.js"() {
    init_browser();
    logger7 = createClientLogger2("core-client");
  }
});

// node_modules/@azure/core-client/dist/browser/serviceClient.js
function createDefaultPipeline2(options) {
  const credentialScopes = getCredentialScopes(options);
  const credentialOptions = options.credential && credentialScopes ? { credentialScopes, credential: options.credential } : void 0;
  return createClientPipeline(Object.assign(Object.assign({}, options), { credentialOptions }));
}
function getCredentialScopes(options) {
  if (options.credentialScopes) {
    return options.credentialScopes;
  }
  if (options.endpoint) {
    return `${options.endpoint}/.default`;
  }
  if (options.baseUri) {
    return `${options.baseUri}/.default`;
  }
  if (options.credential && !options.credentialScopes) {
    throw new Error(`When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`);
  }
  return void 0;
}
var ServiceClient;
var init_serviceClient = __esm({
  "node_modules/@azure/core-client/dist/browser/serviceClient.js"() {
    init_browser6();
    init_pipeline3();
    init_utils2();
    init_httpClientCache();
    init_operationHelpers();
    init_urlHelpers2();
    init_interfaceHelpers();
    init_log4();
    ServiceClient = class {
      /**
       * The ServiceClient constructor
       * @param options - The service client options that govern the behavior of the client.
       */
      constructor(options = {}) {
        var _a3, _b2;
        this._requestContentType = options.requestContentType;
        this._endpoint = (_a3 = options.endpoint) !== null && _a3 !== void 0 ? _a3 : options.baseUri;
        if (options.baseUri) {
          logger7.warning("The baseUri option for SDK Clients has been deprecated, please use endpoint instead.");
        }
        this._allowInsecureConnection = options.allowInsecureConnection;
        this._httpClient = options.httpClient || getCachedDefaultHttpClient();
        this.pipeline = options.pipeline || createDefaultPipeline2(options);
        if ((_b2 = options.additionalPolicies) === null || _b2 === void 0 ? void 0 : _b2.length) {
          for (const { policy, position } of options.additionalPolicies) {
            const afterPhase = position === "perRetry" ? "Sign" : void 0;
            this.pipeline.addPolicy(policy, {
              afterPhase
            });
          }
        }
      }
      /**
       * Send the provided httpRequest.
       */
      async sendRequest(request) {
        return this.pipeline.sendRequest(this._httpClient, request);
      }
      /**
       * Send an HTTP request that is populated using the provided OperationSpec.
       * @typeParam T - The typed result of the request, based on the OperationSpec.
       * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.
       * @param operationSpec - The OperationSpec to use to populate the httpRequest.
       */
      async sendOperationRequest(operationArguments, operationSpec) {
        const endpoint = operationSpec.baseUrl || this._endpoint;
        if (!endpoint) {
          throw new Error("If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.");
        }
        const url = getRequestUrl(endpoint, operationSpec, operationArguments, this);
        const request = createPipelineRequest2({
          url
        });
        request.method = operationSpec.httpMethod;
        const operationInfo = getOperationRequestInfo(request);
        operationInfo.operationSpec = operationSpec;
        operationInfo.operationArguments = operationArguments;
        const contentType = operationSpec.contentType || this._requestContentType;
        if (contentType && operationSpec.requestBody) {
          request.headers.set("Content-Type", contentType);
        }
        const options = operationArguments.options;
        if (options) {
          const requestOptions = options.requestOptions;
          if (requestOptions) {
            if (requestOptions.timeout) {
              request.timeout = requestOptions.timeout;
            }
            if (requestOptions.onUploadProgress) {
              request.onUploadProgress = requestOptions.onUploadProgress;
            }
            if (requestOptions.onDownloadProgress) {
              request.onDownloadProgress = requestOptions.onDownloadProgress;
            }
            if (requestOptions.shouldDeserialize !== void 0) {
              operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;
            }
            if (requestOptions.allowInsecureConnection) {
              request.allowInsecureConnection = true;
            }
          }
          if (options.abortSignal) {
            request.abortSignal = options.abortSignal;
          }
          if (options.tracingOptions) {
            request.tracingOptions = options.tracingOptions;
          }
        }
        if (this._allowInsecureConnection) {
          request.allowInsecureConnection = true;
        }
        if (request.streamResponseStatusCodes === void 0) {
          request.streamResponseStatusCodes = getStreamingResponseStatusCodes(operationSpec);
        }
        try {
          const rawResponse = await this.sendRequest(request);
          const flatResponse = flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]);
          if (options === null || options === void 0 ? void 0 : options.onResponse) {
            options.onResponse(rawResponse, flatResponse);
          }
          return flatResponse;
        } catch (error) {
          if (typeof error === "object" && (error === null || error === void 0 ? void 0 : error.response)) {
            const rawResponse = error.response;
            const flatResponse = flattenResponse(rawResponse, operationSpec.responses[error.statusCode] || operationSpec.responses["default"]);
            error.details = flatResponse;
            if (options === null || options === void 0 ? void 0 : options.onResponse) {
              options.onResponse(rawResponse, flatResponse, error);
            }
          }
          throw error;
        }
      }
    };
  }
});

// node_modules/@azure/core-client/dist/browser/authorizeRequestOnClaimChallenge.js
var init_authorizeRequestOnClaimChallenge = __esm({
  "node_modules/@azure/core-client/dist/browser/authorizeRequestOnClaimChallenge.js"() {
    init_log4();
    init_base64();
  }
});

// node_modules/@azure/core-client/dist/browser/authorizeRequestOnTenantChallenge.js
var init_authorizeRequestOnTenantChallenge = __esm({
  "node_modules/@azure/core-client/dist/browser/authorizeRequestOnTenantChallenge.js"() {
  }
});

// node_modules/@azure/core-client/dist/browser/index.js
var init_browser7 = __esm({
  "node_modules/@azure/core-client/dist/browser/index.js"() {
    init_serializer();
    init_serviceClient();
    init_pipeline3();
    init_interfaces();
    init_deserializationPolicy();
    init_serializationPolicy();
    init_authorizeRequestOnClaimChallenge();
    init_authorizeRequestOnTenantChallenge();
  }
});

// node_modules/@azure/identity/dist/browser/util/identityTokenEndpoint.js
function getIdentityTokenEndpointSuffix(tenantId) {
  if (tenantId === "adfs") {
    return "oauth2/token";
  } else {
    return "oauth2/v2.0/token";
  }
}
var init_identityTokenEndpoint = __esm({
  "node_modules/@azure/identity/dist/browser/util/identityTokenEndpoint.js"() {
  }
});

// node_modules/@azure/identity/dist/browser/credentials/managedIdentityCredential/utils.js
function parseExpirationTimestamp(body) {
  if (typeof body.expires_on === "number") {
    return body.expires_on * 1e3;
  }
  if (typeof body.expires_on === "string") {
    const asNumber = +body.expires_on;
    if (!isNaN(asNumber)) {
      return asNumber * 1e3;
    }
    const asDate = Date.parse(body.expires_on);
    if (!isNaN(asDate)) {
      return asDate;
    }
  }
  if (typeof body.expires_in === "number") {
    return Date.now() + body.expires_in * 1e3;
  }
  throw new Error(`Failed to parse token expiration from body. expires_in="${body.expires_in}", expires_on="${body.expires_on}"`);
}
function parseRefreshTimestamp(body) {
  if (body.refresh_on) {
    if (typeof body.refresh_on === "number") {
      return body.refresh_on * 1e3;
    }
    if (typeof body.refresh_on === "string") {
      const asNumber = +body.refresh_on;
      if (!isNaN(asNumber)) {
        return asNumber * 1e3;
      }
      const asDate = Date.parse(body.refresh_on);
      if (!isNaN(asDate)) {
        return asDate;
      }
    }
    throw new Error(`Failed to parse refresh_on from body. refresh_on="${body.refresh_on}"`);
  } else {
    return void 0;
  }
}
var init_utils3 = __esm({
  "node_modules/@azure/identity/dist/browser/credentials/managedIdentityCredential/utils.js"() {
  }
});

// node_modules/@azure/identity/dist/browser/client/identityClient.js
function getIdentityClientAuthorityHost(options) {
  let authorityHost = options === null || options === void 0 ? void 0 : options.authorityHost;
  if (isNode) {
    authorityHost = authorityHost !== null && authorityHost !== void 0 ? authorityHost : process.env.AZURE_AUTHORITY_HOST;
  }
  return authorityHost !== null && authorityHost !== void 0 ? authorityHost : DefaultAuthorityHost;
}
var noCorrelationId, IdentityClient;
var init_identityClient = __esm({
  "node_modules/@azure/identity/dist/browser/client/identityClient.js"() {
    init_browser7();
    init_browser4();
    init_browser6();
    init_errors();
    init_identityTokenEndpoint();
    init_constants();
    init_tracing();
    init_logging();
    init_utils3();
    noCorrelationId = "noCorrelationId";
    IdentityClient = class extends ServiceClient {
      constructor(options) {
        var _a3, _b2;
        const packageDetails = `azsdk-js-identity/${SDK_VERSION}`;
        const userAgentPrefix = ((_a3 = options === null || options === void 0 ? void 0 : options.userAgentOptions) === null || _a3 === void 0 ? void 0 : _a3.userAgentPrefix) ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;
        const baseUri = getIdentityClientAuthorityHost(options);
        if (!baseUri.startsWith("https:")) {
          throw new Error("The authorityHost address must use the 'https' protocol.");
        }
        super(Object.assign(Object.assign({ requestContentType: "application/json; charset=utf-8", retryOptions: {
          maxRetries: 3
        } }, options), { userAgentOptions: {
          userAgentPrefix
        }, baseUri }));
        this.allowInsecureConnection = false;
        this.authorityHost = baseUri;
        this.abortControllers = /* @__PURE__ */ new Map();
        this.allowLoggingAccountIdentifiers = (_b2 = options === null || options === void 0 ? void 0 : options.loggingOptions) === null || _b2 === void 0 ? void 0 : _b2.allowLoggingAccountIdentifiers;
        this.tokenCredentialOptions = Object.assign({}, options);
        if (options === null || options === void 0 ? void 0 : options.allowInsecureConnection) {
          this.allowInsecureConnection = options.allowInsecureConnection;
        }
      }
      async sendTokenRequest(request) {
        logger.info(`IdentityClient: sending token request to [${request.url}]`);
        const response = await this.sendRequest(request);
        if (response.bodyAsText && (response.status === 200 || response.status === 201)) {
          const parsedBody = JSON.parse(response.bodyAsText);
          if (!parsedBody.access_token) {
            return null;
          }
          this.logIdentifiers(response);
          const token = {
            accessToken: {
              token: parsedBody.access_token,
              expiresOnTimestamp: parseExpirationTimestamp(parsedBody),
              refreshAfterTimestamp: parseRefreshTimestamp(parsedBody),
              tokenType: "Bearer"
            },
            refreshToken: parsedBody.refresh_token
          };
          logger.info(`IdentityClient: [${request.url}] token acquired, expires on ${token.accessToken.expiresOnTimestamp}`);
          return token;
        } else {
          const error = new AuthenticationError(response.status, response.bodyAsText);
          logger.warning(`IdentityClient: authentication error. HTTP status: ${response.status}, ${error.errorResponse.errorDescription}`);
          throw error;
        }
      }
      async refreshAccessToken(tenantId, clientId, scopes, refreshToken, clientSecret, options = {}) {
        if (refreshToken === void 0) {
          return null;
        }
        logger.info(`IdentityClient: refreshing access token with client ID: ${clientId}, scopes: ${scopes} started`);
        const refreshParams = {
          grant_type: "refresh_token",
          client_id: clientId,
          refresh_token: refreshToken,
          scope: scopes
        };
        if (clientSecret !== void 0) {
          refreshParams.client_secret = clientSecret;
        }
        const query = new URLSearchParams(refreshParams);
        return tracingClient.withSpan("IdentityClient.refreshAccessToken", options, async (updatedOptions) => {
          try {
            const urlSuffix = getIdentityTokenEndpointSuffix(tenantId);
            const request = createPipelineRequest2({
              url: `${this.authorityHost}/${tenantId}/${urlSuffix}`,
              method: "POST",
              body: query.toString(),
              abortSignal: options.abortSignal,
              headers: createHttpHeaders2({
                Accept: "application/json",
                "Content-Type": "application/x-www-form-urlencoded"
              }),
              tracingOptions: updatedOptions.tracingOptions
            });
            const response = await this.sendTokenRequest(request);
            logger.info(`IdentityClient: refreshed token for client ID: ${clientId}`);
            return response;
          } catch (err) {
            if (err.name === AuthenticationErrorName && err.errorResponse.error === "interaction_required") {
              logger.info(`IdentityClient: interaction required for client ID: ${clientId}`);
              return null;
            } else {
              logger.warning(`IdentityClient: failed refreshing token for client ID: ${clientId}: ${err}`);
              throw err;
            }
          }
        });
      }
      // Here is a custom layer that allows us to abort requests that go through MSAL,
      // since MSAL doesn't allow us to pass options all the way through.
      generateAbortSignal(correlationId) {
        const controller = new AbortController();
        const controllers = this.abortControllers.get(correlationId) || [];
        controllers.push(controller);
        this.abortControllers.set(correlationId, controllers);
        const existingOnAbort = controller.signal.onabort;
        controller.signal.onabort = (...params) => {
          this.abortControllers.set(correlationId, void 0);
          if (existingOnAbort) {
            existingOnAbort.apply(controller.signal, params);
          }
        };
        return controller.signal;
      }
      abortRequests(correlationId) {
        const key = correlationId || noCorrelationId;
        const controllers = [
          ...this.abortControllers.get(key) || [],
          // MSAL passes no correlation ID to the get requests...
          ...this.abortControllers.get(noCorrelationId) || []
        ];
        if (!controllers.length) {
          return;
        }
        for (const controller of controllers) {
          controller.abort();
        }
        this.abortControllers.set(key, void 0);
      }
      getCorrelationId(options) {
        var _a3;
        const parameter = (_a3 = options === null || options === void 0 ? void 0 : options.body) === null || _a3 === void 0 ? void 0 : _a3.split("&").map((part) => part.split("=")).find(([key]) => key === "client-request-id");
        return parameter && parameter.length ? parameter[1] || noCorrelationId : noCorrelationId;
      }
      // The MSAL network module methods follow
      async sendGetRequestAsync(url, options) {
        const request = createPipelineRequest2({
          url,
          method: "GET",
          body: options === null || options === void 0 ? void 0 : options.body,
          allowInsecureConnection: this.allowInsecureConnection,
          headers: createHttpHeaders2(options === null || options === void 0 ? void 0 : options.headers),
          abortSignal: this.generateAbortSignal(noCorrelationId)
        });
        const response = await this.sendRequest(request);
        this.logIdentifiers(response);
        return {
          body: response.bodyAsText ? JSON.parse(response.bodyAsText) : void 0,
          headers: response.headers.toJSON(),
          status: response.status
        };
      }
      async sendPostRequestAsync(url, options) {
        const request = createPipelineRequest2({
          url,
          method: "POST",
          body: options === null || options === void 0 ? void 0 : options.body,
          headers: createHttpHeaders2(options === null || options === void 0 ? void 0 : options.headers),
          allowInsecureConnection: this.allowInsecureConnection,
          // MSAL doesn't send the correlation ID on the get requests.
          abortSignal: this.generateAbortSignal(this.getCorrelationId(options))
        });
        const response = await this.sendRequest(request);
        this.logIdentifiers(response);
        return {
          body: response.bodyAsText ? JSON.parse(response.bodyAsText) : void 0,
          headers: response.headers.toJSON(),
          status: response.status
        };
      }
      /**
       *
       * @internal
       */
      getTokenCredentialOptions() {
        return this.tokenCredentialOptions;
      }
      /**
       * If allowLoggingAccountIdentifiers was set on the constructor options
       * we try to log the account identifiers by parsing the received access token.
       *
       * The account identifiers we try to log are:
       * - `appid`: The application or Client Identifier.
       * - `upn`: User Principal Name.
       *   - It might not be available in some authentication scenarios.
       *   - If it's not available, we put a placeholder: "No User Principal Name available".
       * - `tid`: Tenant Identifier.
       * - `oid`: Object Identifier of the authenticated user.
       */
      logIdentifiers(response) {
        if (!this.allowLoggingAccountIdentifiers || !response.bodyAsText) {
          return;
        }
        const unavailableUpn = "No User Principal Name available";
        try {
          const parsed = response.parsedBody || JSON.parse(response.bodyAsText);
          const accessToken = parsed.access_token;
          if (!accessToken) {
            return;
          }
          const base64Metadata = accessToken.split(".")[1];
          const { appid, upn, tid, oid } = JSON.parse(Buffer.from(base64Metadata, "base64").toString("utf8"));
          logger.info(`[Authenticated account] Client ID: ${appid}. Tenant ID: ${tid}. User Principal Name: ${upn || unavailableUpn}. Object ID (user): ${oid}`);
        } catch (e) {
          logger.warning("allowLoggingAccountIdentifiers was set, but we couldn't log the account information. Error:", e.message);
        }
      }
    };
  }
});

// node_modules/@azure/identity/dist/browser/credentials/clientSecretCredential.js
var logger8, ClientSecretCredential;
var init_clientSecretCredential = __esm({
  "node_modules/@azure/identity/dist/browser/credentials/clientSecretCredential.js"() {
    init_browser6();
    init_logging();
    init_tenantIdUtils();
    init_identityClient();
    init_identityTokenEndpoint();
    init_tracing();
    logger8 = credentialLogger("ClientSecretCredential");
    ClientSecretCredential = class {
      /**
       * Creates an instance of the ClientSecretCredential with the details
       * needed to authenticate against Microsoft Entra ID with a client
       * secret.
       *
       * @param tenantId - The Microsoft Entra tenant (directory) ID.
       * @param clientId - The client (application) ID of an App Registration in the tenant.
       * @param clientSecret - A client secret that was generated for the App Registration.
       * @param options - Options for configuring the client which makes the authentication request.
       */
      constructor(tenantId, clientId, clientSecret, options) {
        this.identityClient = new IdentityClient(options);
        this.tenantId = tenantId;
        this.additionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds(options === null || options === void 0 ? void 0 : options.additionallyAllowedTenants);
        this.clientId = clientId;
        this.clientSecret = clientSecret;
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if
       * successful.  If authentication cannot be performed at this time, this method may
       * return null.  If an error occurs during authentication, an {@link AuthenticationError}
       * containing failure details will be thrown.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
          const tenantId = processMultiTenantRequest(this.tenantId, newOptions, this.additionallyAllowedTenantIds);
          const query = new URLSearchParams({
            response_type: "token",
            grant_type: "client_credentials",
            client_id: this.clientId,
            client_secret: this.clientSecret,
            scope: typeof scopes === "string" ? scopes : scopes.join(" ")
          });
          try {
            const urlSuffix = getIdentityTokenEndpointSuffix(tenantId);
            const request = createPipelineRequest2({
              url: `${this.identityClient.authorityHost}/${tenantId}/${urlSuffix}`,
              method: "POST",
              body: query.toString(),
              headers: createHttpHeaders2({
                Accept: "application/json",
                "Content-Type": "application/x-www-form-urlencoded"
              }),
              abortSignal: options && options.abortSignal,
              tracingOptions: newOptions === null || newOptions === void 0 ? void 0 : newOptions.tracingOptions
            });
            const tokenResponse = await this.identityClient.sendTokenRequest(request);
            logger8.getToken.info(formatSuccess(scopes));
            return tokenResponse && tokenResponse.accessToken || null;
          } catch (err) {
            logger8.getToken.info(formatError(scopes, err));
            throw err;
          }
        });
      }
    };
  }
});

// node_modules/@azure/identity/dist/browser/credentials/environmentCredential.js
var BrowserNotSupportedError2, logger9, EnvironmentCredential;
var init_environmentCredential = __esm({
  "node_modules/@azure/identity/dist/browser/credentials/environmentCredential.js"() {
    init_logging();
    BrowserNotSupportedError2 = new Error("EnvironmentCredential is not supported in the browser.");
    logger9 = credentialLogger("EnvironmentCredential");
    EnvironmentCredential = class {
      /**
       * Only available in Node.js
       */
      constructor() {
        logger9.info(formatError("", BrowserNotSupportedError2));
        throw BrowserNotSupportedError2;
      }
      getToken() {
        logger9.getToken.info(formatError("", BrowserNotSupportedError2));
        throw BrowserNotSupportedError2;
      }
    };
  }
});

// node_modules/@azure/identity/dist/browser/credentials/clientCertificateCredential.js
var BrowserNotSupportedError3, logger10, ClientCertificateCredential;
var init_clientCertificateCredential = __esm({
  "node_modules/@azure/identity/dist/browser/credentials/clientCertificateCredential.js"() {
    init_logging();
    BrowserNotSupportedError3 = new Error("ClientCertificateCredential is not supported in the browser.");
    logger10 = credentialLogger("ClientCertificateCredential");
    ClientCertificateCredential = class {
      /**
       * Only available in Node.js
       */
      constructor() {
        logger10.info(formatError("", BrowserNotSupportedError3));
        throw BrowserNotSupportedError3;
      }
      getToken() {
        logger10.getToken.info(formatError("", BrowserNotSupportedError3));
        throw BrowserNotSupportedError3;
      }
    };
  }
});

// node_modules/@azure/identity/dist/browser/credentials/clientAssertionCredential.js
var BrowserNotSupportedError4, logger11, ClientAssertionCredential;
var init_clientAssertionCredential = __esm({
  "node_modules/@azure/identity/dist/browser/credentials/clientAssertionCredential.js"() {
    init_logging();
    BrowserNotSupportedError4 = new Error("ClientAssertionCredential is not supported in the browser.");
    logger11 = credentialLogger("ClientAssertionCredential");
    ClientAssertionCredential = class {
      /**
       * Only available in Node.js
       */
      constructor() {
        logger11.info(formatError("", BrowserNotSupportedError4));
        throw BrowserNotSupportedError4;
      }
      getToken() {
        logger11.getToken.info(formatError("", BrowserNotSupportedError4));
        throw BrowserNotSupportedError4;
      }
    };
  }
});

// node_modules/@azure/identity/dist/browser/credentials/azureCliCredential.js
var BrowserNotSupportedError5, logger12, AzureCliCredential;
var init_azureCliCredential = __esm({
  "node_modules/@azure/identity/dist/browser/credentials/azureCliCredential.js"() {
    init_logging();
    BrowserNotSupportedError5 = new Error("AzureCliCredential is not supported in the browser.");
    logger12 = credentialLogger("AzureCliCredential");
    AzureCliCredential = class {
      /**
       * Only available in Node.js
       */
      constructor() {
        logger12.info(formatError("", BrowserNotSupportedError5));
        throw BrowserNotSupportedError5;
      }
      getToken() {
        logger12.getToken.info(formatError("", BrowserNotSupportedError5));
        throw BrowserNotSupportedError5;
      }
    };
  }
});

// node_modules/@azure/identity/dist/browser/credentials/azureDeveloperCliCredential.js
var BrowserNotSupportedError6, logger13, AzureDeveloperCliCredential;
var init_azureDeveloperCliCredential = __esm({
  "node_modules/@azure/identity/dist/browser/credentials/azureDeveloperCliCredential.js"() {
    init_logging();
    BrowserNotSupportedError6 = new Error("AzureDeveloperCliCredential is not supported in the browser.");
    logger13 = credentialLogger("AzureDeveloperCliCredential");
    AzureDeveloperCliCredential = class {
      /**
       * Only available in Node.js
       */
      constructor() {
        logger13.info(formatError("", BrowserNotSupportedError6));
        throw BrowserNotSupportedError6;
      }
      getToken() {
        logger13.getToken.info(formatError("", BrowserNotSupportedError6));
        throw BrowserNotSupportedError6;
      }
    };
  }
});

// node_modules/@azure/identity/dist/browser/util/scopeUtils.js
function ensureScopes(scopes) {
  return Array.isArray(scopes) ? scopes : [scopes];
}
var init_scopeUtils = __esm({
  "node_modules/@azure/identity/dist/browser/util/scopeUtils.js"() {
    init_logging();
  }
});

// node_modules/@azure/identity/dist/browser/msal/browserFlows/msalBrowserCommon.js
function generateMsalBrowserConfiguration(options) {
  var _a3;
  const tenantId = options.tenantId || DefaultTenantId;
  const authority = getAuthority(tenantId, options.authorityHost);
  return {
    auth: {
      clientId: options.clientId,
      authority,
      knownAuthorities: getKnownAuthorities(tenantId, authority, options.disableInstanceDiscovery),
      // If the users picked redirect as their login style,
      // but they didn't provide a redirectUri,
      // we can try to use the current page we're in as a default value.
      redirectUri: options.redirectUri || (isLocationDefined ? self.location.origin : void 0)
    },
    cache: {
      cacheLocation: "sessionStorage",
      storeAuthStateInCookie: true
      // Set to true to improve the experience on IE11 and Edge.
    },
    system: {
      loggerOptions: {
        loggerCallback: defaultLoggerCallback(options.logger, "Browser"),
        logLevel: getMSALLogLevel(getLogLevel()),
        piiLoggingEnabled: (_a3 = options.loggingOptions) === null || _a3 === void 0 ? void 0 : _a3.enableUnsafeSupportLogging
      }
    }
  };
}
function createMsalBrowserClient(options) {
  var _a3;
  const loginStyle = options.loginStyle;
  if (!options.clientId) {
    throw new CredentialUnavailableError("A client ID is required in browsers");
  }
  const clientId = options.clientId;
  const logger24 = options.logger;
  const tenantId = resolveTenantId(logger24, options.tenantId, options.clientId);
  const additionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds((_a3 = options === null || options === void 0 ? void 0 : options.tokenCredentialOptions) === null || _a3 === void 0 ? void 0 : _a3.additionallyAllowedTenants);
  const authorityHost = options.authorityHost;
  const msalConfig = generateMsalBrowserConfiguration(options);
  const disableAutomaticAuthentication = options.disableAutomaticAuthentication;
  const loginHint = options.loginHint;
  let account;
  if (options.authenticationRecord) {
    account = Object.assign(Object.assign({}, options.authenticationRecord), { tenantId });
  }
  let app;
  async function getApp() {
    if (!app) {
      app = await PublicClientApplication.createPublicClientApplication(msalConfig);
      if (account) {
        app.setActiveAccount(publicToMsal(account));
      }
    }
    return app;
  }
  async function handleBrowserResult(result) {
    try {
      const msalApp = await getApp();
      if (result && result.account) {
        logger24.info(`MSAL Browser V2 authentication successful.`);
        msalApp.setActiveAccount(result.account);
        return msalToPublic(clientId, result.account);
      }
    } catch (e) {
      logger24.info(`Failed to acquire token through MSAL. ${e.message}`);
    }
    return;
  }
  function handleResult(scopes, result, getTokenOptions) {
    var _a4;
    if (result === null || result === void 0 ? void 0 : result.account) {
      account = msalToPublic(clientId, result.account);
    }
    ensureValidMsalToken(scopes, result, getTokenOptions);
    logger24.getToken.info(formatSuccess(scopes));
    return {
      token: result.accessToken,
      expiresOnTimestamp: result.expiresOn.getTime(),
      refreshAfterTimestamp: (_a4 = result.refreshOn) === null || _a4 === void 0 ? void 0 : _a4.getTime(),
      tokenType: "Bearer"
    };
  }
  async function handleRedirect2() {
    const msalApp = await getApp();
    return handleBrowserResult(await msalApp.handleRedirectPromise(redirectHash) || void 0);
  }
  async function getActiveAccount2() {
    const msalApp = await getApp();
    const activeAccount = msalApp.getActiveAccount();
    if (!activeAccount) {
      return;
    }
    return msalToPublic(clientId, activeAccount);
  }
  async function login(scopes = []) {
    const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
    const loginRequest = {
      scopes: arrayScopes,
      loginHint
    };
    const msalApp = await getApp();
    switch (loginStyle) {
      case "redirect": {
        await app.loginRedirect(loginRequest);
        return;
      }
      case "popup":
        return handleBrowserResult(await msalApp.loginPopup(loginRequest));
    }
  }
  async function getTokenSilent(scopes, getTokenOptions) {
    const activeAccount = await getActiveAccount2();
    if (!activeAccount) {
      throw new AuthenticationRequiredError({
        scopes,
        getTokenOptions,
        message: "Silent authentication failed. We couldn't retrieve an active account from the cache."
      });
    }
    const parameters = {
      authority: (getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.authority) || msalConfig.auth.authority,
      correlationId: getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.correlationId,
      claims: getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.claims,
      account: publicToMsal(activeAccount),
      forceRefresh: false,
      scopes
    };
    try {
      logger24.info("Attempting to acquire token silently");
      const msalApp = await getApp();
      const response = await msalApp.acquireTokenSilent(parameters);
      return handleResult(scopes, response);
    } catch (err) {
      throw handleMsalError(scopes, err, options);
    }
  }
  async function getTokenInteractive(scopes, getTokenOptions) {
    const activeAccount = await getActiveAccount2();
    if (!activeAccount) {
      throw new AuthenticationRequiredError({
        scopes,
        getTokenOptions,
        message: "Silent authentication failed. We couldn't retrieve an active account from the cache."
      });
    }
    const parameters = {
      authority: (getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.authority) || msalConfig.auth.authority,
      correlationId: getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.correlationId,
      claims: getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.claims,
      account: publicToMsal(activeAccount),
      loginHint,
      scopes
    };
    const msalApp = await getApp();
    switch (loginStyle) {
      case "redirect":
        await msalApp.acquireTokenRedirect(parameters);
        return { token: "", expiresOnTimestamp: 0, tokenType: "Bearer" };
      case "popup":
        return handleResult(scopes, await app.acquireTokenPopup(parameters));
    }
  }
  async function getToken(scopes, getTokenOptions = {}) {
    const getTokenTenantId = processMultiTenantRequest(tenantId, getTokenOptions, additionallyAllowedTenantIds) || tenantId;
    if (!getTokenOptions.authority) {
      getTokenOptions.authority = getAuthority(getTokenTenantId, authorityHost);
    }
    await handleRedirect2();
    if (!await getActiveAccount2() && !disableAutomaticAuthentication) {
      await login(scopes);
    }
    try {
      return await getTokenSilent(scopes, getTokenOptions);
    } catch (err) {
      if (err.name !== "AuthenticationRequiredError") {
        throw err;
      }
      if (getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.disableAutomaticAuthentication) {
        throw new AuthenticationRequiredError({
          scopes,
          getTokenOptions,
          message: "Automatic authentication has been disabled. You may call the authenticate() method."
        });
      }
      logger24.info(`Silent authentication failed, falling back to interactive method ${loginStyle}`);
      return getTokenInteractive(scopes, getTokenOptions);
    }
  }
  return {
    getActiveAccount: getActiveAccount2,
    getToken
  };
}
var isLocationDefined, redirectHash;
var init_msalBrowserCommon = __esm({
  "node_modules/@azure/identity/dist/browser/msal/browserFlows/msalBrowserCommon.js"() {
    init_dist();
    init_utils();
    init_errors();
    init_browser();
    init_logging();
    init_tenantIdUtils();
    init_constants();
    isLocationDefined = typeof self !== "undefined" && self.location !== void 0;
    redirectHash = isLocationDefined ? self.location.hash : void 0;
  }
});

// node_modules/@azure/identity/dist/browser/credentials/interactiveBrowserCredential.js
var logger14, InteractiveBrowserCredential;
var init_interactiveBrowserCredential = __esm({
  "node_modules/@azure/identity/dist/browser/credentials/interactiveBrowserCredential.js"() {
    init_logging();
    init_tenantIdUtils();
    init_scopeUtils();
    init_tracing();
    init_msalBrowserCommon();
    logger14 = credentialLogger("InteractiveBrowserCredential");
    InteractiveBrowserCredential = class {
      /**
       * Creates an instance of the InteractiveBrowserCredential with the
       * details needed to authenticate against Microsoft Entra ID with
       * a user identity.
       *
       * This credential uses the [Authorization Code Flow](https://learn.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow).
       * On Node.js, it will open a browser window while it listens for a redirect response from the authentication service.
       * On browsers, it authenticates via popups. The `loginStyle` optional parameter can be set to `redirect` to authenticate by redirecting the user to an Azure secure login page, which then will redirect the user back to the web application where the authentication started.
       *
       * It's recommended that the Microsoft Entra Applications used are configured to authenticate using Single Page Applications.
       * More information here: [link](https://learn.microsoft.com/en-us/azure/active-directory/develop/scenario-spa-app-registration#redirect-uri-msaljs-20-with-auth-code-flow).
       *
       * @param options - Options for configuring the client which makes the authentication request.
       */
      constructor(options) {
        if (!(options === null || options === void 0 ? void 0 : options.clientId)) {
          const error = new Error("The parameter `clientId` cannot be left undefined for the `InteractiveBrowserCredential`");
          logger14.info(formatError("", error));
          throw error;
        }
        this.tenantId = options === null || options === void 0 ? void 0 : options.tenantId;
        this.additionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds(options === null || options === void 0 ? void 0 : options.additionallyAllowedTenants);
        const browserOptions = options;
        const loginStyle = browserOptions.loginStyle || "popup";
        const loginStyles = ["redirect", "popup"];
        if (loginStyles.indexOf(loginStyle) === -1) {
          const error = new Error(`Invalid loginStyle: ${browserOptions.loginStyle}. Should be any of the following: ${loginStyles.join(", ")}.`);
          logger14.info(formatError("", error));
          throw error;
        }
        const msalOptions = Object.assign(Object.assign({}, options), { tokenCredentialOptions: options, logger: logger14, loginStyle, redirectUri: typeof options.redirectUri === "function" ? options.redirectUri() : options.redirectUri });
        this.msalClient = createMsalBrowserClient(msalOptions);
        this.disableAutomaticAuthentication = options === null || options === void 0 ? void 0 : options.disableAutomaticAuthentication;
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * If the user provided the option `disableAutomaticAuthentication`,
       * once the token can't be retrieved silently,
       * this method won't attempt to request user interaction to retrieve the token.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
          const tenantId = processMultiTenantRequest(this.tenantId, newOptions, this.additionallyAllowedTenantIds);
          newOptions.tenantId = tenantId;
          const arrayScopes = ensureScopes(scopes);
          return this.msalClient.getToken(arrayScopes, Object.assign(Object.assign({}, newOptions), { disableAutomaticAuthentication: this.disableAutomaticAuthentication }));
        });
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * If the token can't be retrieved silently, this method will require user interaction to retrieve the token.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                  TokenCredential implementation might make.
       */
      async authenticate(scopes, options = {}) {
        return tracingClient.withSpan(`${this.constructor.name}.authenticate`, options, async (newOptions) => {
          const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
          await this.msalClient.getToken(arrayScopes, newOptions);
          return this.msalClient.getActiveAccount();
        });
      }
    };
  }
});

// node_modules/@azure/identity/dist/browser/credentials/managedIdentityCredential/index.js
var BrowserNotSupportedError7, logger15, ManagedIdentityCredential;
var init_managedIdentityCredential = __esm({
  "node_modules/@azure/identity/dist/browser/credentials/managedIdentityCredential/index.js"() {
    init_logging();
    BrowserNotSupportedError7 = new Error("ManagedIdentityCredential is not supported in the browser.");
    logger15 = credentialLogger("ManagedIdentityCredential");
    ManagedIdentityCredential = class {
      constructor() {
        logger15.info(formatError("", BrowserNotSupportedError7));
        throw BrowserNotSupportedError7;
      }
      async getToken() {
        logger15.getToken.info(formatError("", BrowserNotSupportedError7));
        throw BrowserNotSupportedError7;
      }
    };
  }
});

// node_modules/@azure/identity/dist/browser/credentials/deviceCodeCredential.js
var BrowserNotSupportedError8, logger16, DeviceCodeCredential;
var init_deviceCodeCredential = __esm({
  "node_modules/@azure/identity/dist/browser/credentials/deviceCodeCredential.js"() {
    init_logging();
    BrowserNotSupportedError8 = new Error("DeviceCodeCredential is not supported in the browser.");
    logger16 = credentialLogger("DeviceCodeCredential");
    DeviceCodeCredential = class {
      /**
       * Only available in Node.js
       */
      constructor() {
        logger16.info(formatError("", BrowserNotSupportedError8));
        throw BrowserNotSupportedError8;
      }
      getToken() {
        logger16.getToken.info(formatError("", BrowserNotSupportedError8));
        throw BrowserNotSupportedError8;
      }
    };
  }
});

// node_modules/@azure/identity/dist/browser/credentials/azurePipelinesCredential.js
var BrowserNotSupportedError9, logger17, AzurePipelinesCredential;
var init_azurePipelinesCredential = __esm({
  "node_modules/@azure/identity/dist/browser/credentials/azurePipelinesCredential.js"() {
    init_logging();
    BrowserNotSupportedError9 = new Error("AzurePipelinesCredential is not supported in the browser.");
    logger17 = credentialLogger("AzurePipelinesCredential");
    AzurePipelinesCredential = class {
      /**
       * Only available in Node.js
       */
      constructor() {
        logger17.info(formatError("", BrowserNotSupportedError9));
        throw BrowserNotSupportedError9;
      }
      getToken() {
        logger17.getToken.info(formatError("", BrowserNotSupportedError9));
        throw BrowserNotSupportedError9;
      }
    };
  }
});

// node_modules/@azure/identity/dist/browser/credentials/authorizationCodeCredential.js
var BrowserNotSupportedError10, logger18, AuthorizationCodeCredential;
var init_authorizationCodeCredential = __esm({
  "node_modules/@azure/identity/dist/browser/credentials/authorizationCodeCredential.js"() {
    init_logging();
    BrowserNotSupportedError10 = new Error("AuthorizationCodeCredential is not supported in the browser. InteractiveBrowserCredential is more appropriate for this use case.");
    logger18 = credentialLogger("AuthorizationCodeCredential");
    AuthorizationCodeCredential = class {
      constructor() {
        logger18.info(formatError("", BrowserNotSupportedError10));
        throw BrowserNotSupportedError10;
      }
      getToken() {
        logger18.getToken.info(formatError("", BrowserNotSupportedError10));
        throw BrowserNotSupportedError10;
      }
    };
  }
});

// node_modules/@azure/identity/dist/browser/credentials/azurePowerShellCredential.js
var BrowserNotSupportedError11, logger19, AzurePowerShellCredential;
var init_azurePowerShellCredential = __esm({
  "node_modules/@azure/identity/dist/browser/credentials/azurePowerShellCredential.js"() {
    init_logging();
    BrowserNotSupportedError11 = new Error("AzurePowerShellCredential is not supported in the browser.");
    logger19 = credentialLogger("AzurePowerShellCredential");
    AzurePowerShellCredential = class {
      /**
       * Only available in Node.js
       */
      constructor() {
        logger19.info(formatError("", BrowserNotSupportedError11));
        throw BrowserNotSupportedError11;
      }
      getToken() {
        logger19.getToken.info(formatError("", BrowserNotSupportedError11));
        throw BrowserNotSupportedError11;
      }
    };
  }
});

// node_modules/@azure/identity/dist/browser/credentials/usernamePasswordCredential.js
var logger20, UsernamePasswordCredential;
var init_usernamePasswordCredential = __esm({
  "node_modules/@azure/identity/dist/browser/credentials/usernamePasswordCredential.js"() {
    init_tenantIdUtils();
    init_browser6();
    init_logging();
    init_identityClient();
    init_identityTokenEndpoint();
    init_tracing();
    logger20 = credentialLogger("UsernamePasswordCredential");
    UsernamePasswordCredential = class {
      /**
       * Creates an instance of the UsernamePasswordCredential with the details
       * needed to authenticate against Microsoft Entra ID with a username
       * and password.
       *
       * @param tenantIdOrName - The Microsoft Entra tenant (directory) ID or name.
       * @param clientId - The client (application) ID of an App Registration in the tenant.
       * @param username - The user account's e-mail address (user name).
       * @param password - The user account's account password
       * @param options - Options for configuring the client which makes the authentication request.
       *
       */
      constructor(tenantIdOrName, clientId, username, password, options) {
        checkTenantId(logger20, tenantIdOrName);
        this.identityClient = new IdentityClient(options);
        this.tenantId = tenantIdOrName;
        this.additionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds(options === null || options === void 0 ? void 0 : options.additionallyAllowedTenants);
        this.clientId = clientId;
        this.username = username;
        this.password = password;
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if
       * successful.  If authentication cannot be performed at this time, this method may
       * return null.  If an error occurs during authentication, an {@link AuthenticationError}
       * containing failure details will be thrown.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        return tracingClient.withSpan("UsernamePasswordCredential.getToken", options, async (newOptions) => {
          const tenantId = processMultiTenantRequest(this.tenantId, newOptions, this.additionallyAllowedTenantIds);
          newOptions.tenantId = tenantId;
          const urlSuffix = getIdentityTokenEndpointSuffix(this.tenantId);
          const params = new URLSearchParams({
            response_type: "token",
            grant_type: "password",
            client_id: this.clientId,
            username: this.username,
            password: this.password,
            scope: typeof scopes === "string" ? scopes : scopes.join(" ")
          });
          const webResource = createPipelineRequest2({
            url: `${this.identityClient.authorityHost}/${this.tenantId}/${urlSuffix}`,
            method: "POST",
            body: params.toString(),
            headers: createHttpHeaders2({
              Accept: "application/json",
              "Content-Type": "application/x-www-form-urlencoded"
            }),
            abortSignal: options && options.abortSignal,
            tracingOptions: newOptions.tracingOptions
          });
          const tokenResponse = await this.identityClient.sendTokenRequest(webResource);
          logger20.getToken.info(formatSuccess(scopes));
          return tokenResponse && tokenResponse.accessToken || null;
        });
      }
    };
  }
});

// node_modules/@azure/identity/dist/browser/credentials/visualStudioCodeCredential.js
var BrowserNotSupportedError12, logger21, VisualStudioCodeCredential;
var init_visualStudioCodeCredential = __esm({
  "node_modules/@azure/identity/dist/browser/credentials/visualStudioCodeCredential.js"() {
    init_logging();
    BrowserNotSupportedError12 = new Error("VisualStudioCodeCredential is not supported in the browser.");
    logger21 = credentialLogger("VisualStudioCodeCredential");
    VisualStudioCodeCredential = class {
      /**
       * Only available in Node.js
       */
      constructor() {
        logger21.info(formatError("", BrowserNotSupportedError12));
        throw BrowserNotSupportedError12;
      }
      getToken() {
        logger21.getToken.info(formatError("", BrowserNotSupportedError12));
        throw BrowserNotSupportedError12;
      }
    };
  }
});

// node_modules/@azure/identity/dist/browser/credentials/onBehalfOfCredential.js
var credentialName, BrowserNotSupportedError13, logger22, OnBehalfOfCredential;
var init_onBehalfOfCredential = __esm({
  "node_modules/@azure/identity/dist/browser/credentials/onBehalfOfCredential.js"() {
    init_logging();
    credentialName = "OnBehalfOfCredential";
    BrowserNotSupportedError13 = new Error(`${credentialName}: Not supported in the browser.`);
    logger22 = credentialLogger(credentialName);
    OnBehalfOfCredential = class {
      /**
       * Only available in Node.js
       */
      constructor() {
        logger22.info(formatError("", BrowserNotSupportedError13));
        throw BrowserNotSupportedError13;
      }
      getToken() {
        logger22.getToken.info(formatError("", BrowserNotSupportedError13));
        throw BrowserNotSupportedError13;
      }
    };
  }
});

// node_modules/@azure/identity/dist/browser/credentials/workloadIdentityCredential.js
var BrowserNotSupportedError14, logger23, WorkloadIdentityCredential;
var init_workloadIdentityCredential = __esm({
  "node_modules/@azure/identity/dist/browser/credentials/workloadIdentityCredential.js"() {
    init_logging();
    BrowserNotSupportedError14 = new Error("WorkloadIdentityCredential is not supported in the browser.");
    logger23 = credentialLogger("WorkloadIdentityCredential");
    WorkloadIdentityCredential = class {
      /**
       * Only available in Node.js
       */
      constructor() {
        logger23.info(formatError("", BrowserNotSupportedError14));
        throw BrowserNotSupportedError14;
      }
      /**
       * Only available in Node.js
       */
      getToken() {
        logger23.getToken.info(formatError("", BrowserNotSupportedError14));
        throw BrowserNotSupportedError14;
      }
    };
  }
});

// node_modules/@azure/identity/dist/browser/tokenProvider.js
function getBearerTokenProvider(credential, scopes, options) {
  const { abortSignal, tracingOptions } = options || {};
  const pipeline = createEmptyPipeline2();
  pipeline.addPolicy(bearerTokenAuthenticationPolicy({ credential, scopes }));
  async function getRefreshedToken() {
    var _a3;
    const res = await pipeline.sendRequest({
      sendRequest: (request) => Promise.resolve({
        request,
        status: 200,
        headers: request.headers
      })
    }, createPipelineRequest2({
      url: "https://example.com",
      abortSignal,
      tracingOptions
    }));
    const accessToken = (_a3 = res.headers.get("authorization")) === null || _a3 === void 0 ? void 0 : _a3.split(" ")[1];
    if (!accessToken) {
      throw new Error("Failed to get access token");
    }
    return accessToken;
  }
  return getRefreshedToken;
}
var init_tokenProvider = __esm({
  "node_modules/@azure/identity/dist/browser/tokenProvider.js"() {
    init_browser6();
  }
});

// node_modules/@azure/identity/dist/browser/index.js
var browser_exports = {};
__export(browser_exports, {
  AggregateAuthenticationError: () => AggregateAuthenticationError,
  AggregateAuthenticationErrorName: () => AggregateAuthenticationErrorName,
  AuthenticationError: () => AuthenticationError,
  AuthenticationErrorName: () => AuthenticationErrorName,
  AuthenticationRequiredError: () => AuthenticationRequiredError,
  AuthorizationCodeCredential: () => AuthorizationCodeCredential,
  AzureAuthorityHosts: () => AzureAuthorityHosts,
  AzureCliCredential: () => AzureCliCredential,
  AzureDeveloperCliCredential: () => AzureDeveloperCliCredential,
  AzurePipelinesCredential: () => AzurePipelinesCredential,
  AzurePowerShellCredential: () => AzurePowerShellCredential,
  ChainedTokenCredential: () => ChainedTokenCredential,
  ClientAssertionCredential: () => ClientAssertionCredential,
  ClientCertificateCredential: () => ClientCertificateCredential,
  ClientSecretCredential: () => ClientSecretCredential,
  CredentialUnavailableError: () => CredentialUnavailableError,
  CredentialUnavailableErrorName: () => CredentialUnavailableErrorName,
  DefaultAzureCredential: () => DefaultAzureCredential,
  DeviceCodeCredential: () => DeviceCodeCredential,
  EnvironmentCredential: () => EnvironmentCredential,
  InteractiveBrowserCredential: () => InteractiveBrowserCredential,
  ManagedIdentityCredential: () => ManagedIdentityCredential,
  OnBehalfOfCredential: () => OnBehalfOfCredential,
  UsernamePasswordCredential: () => UsernamePasswordCredential,
  VisualStudioCodeCredential: () => VisualStudioCodeCredential,
  WorkloadIdentityCredential: () => WorkloadIdentityCredential,
  deserializeAuthenticationRecord: () => deserializeAuthenticationRecord,
  getBearerTokenProvider: () => getBearerTokenProvider,
  getDefaultAzureCredential: () => getDefaultAzureCredential,
  logger: () => logger,
  serializeAuthenticationRecord: () => serializeAuthenticationRecord,
  useIdentityPlugin: () => useIdentityPlugin
});
function getDefaultAzureCredential() {
  return new DefaultAzureCredential();
}
var init_browser8 = __esm({
  "node_modules/@azure/identity/dist/browser/index.js"() {
    init_consumer();
    init_defaultAzureCredential();
    init_errors();
    init_utils();
    init_chainedTokenCredential();
    init_clientSecretCredential();
    init_defaultAzureCredential();
    init_environmentCredential();
    init_clientCertificateCredential();
    init_clientAssertionCredential();
    init_azureCliCredential();
    init_azureDeveloperCliCredential();
    init_interactiveBrowserCredential();
    init_managedIdentityCredential();
    init_deviceCodeCredential();
    init_azurePipelinesCredential();
    init_authorizationCodeCredential();
    init_azurePowerShellCredential();
    init_usernamePasswordCredential();
    init_visualStudioCodeCredential();
    init_onBehalfOfCredential();
    init_workloadIdentityCredential();
    init_logging();
    init_constants();
    init_tokenProvider();
  }
});

// node_modules/@azure/core-auth/dist/browser/azureKeyCredential.js
var AzureKeyCredential;
var init_azureKeyCredential = __esm({
  "node_modules/@azure/core-auth/dist/browser/azureKeyCredential.js"() {
    AzureKeyCredential = class {
      /**
       * The value of the key to be used in authentication
       */
      get key() {
        return this._key;
      }
      /**
       * Create an instance of an AzureKeyCredential for use
       * with a service client.
       *
       * @param key - The initial value of the key to use in authentication
       */
      constructor(key) {
        if (!key) {
          throw new Error("key must be a non-empty string");
        }
        this._key = key;
      }
      /**
       * Change the value of the key.
       *
       * Updates will take effect upon the next request after
       * updating the key value.
       *
       * @param newKey - The new key value to be used
       */
      update(newKey) {
        this._key = newKey;
      }
    };
  }
});

// node_modules/@azure/core-auth/dist/browser/keyCredential.js
function isKeyCredential(credential) {
  return isObjectWithProperties(credential, ["key"]) && typeof credential.key === "string";
}
var init_keyCredential = __esm({
  "node_modules/@azure/core-auth/dist/browser/keyCredential.js"() {
    init_browser4();
  }
});

// node_modules/@azure/core-auth/dist/browser/azureNamedKeyCredential.js
function isNamedKeyCredential(credential) {
  return isObjectWithProperties(credential, ["name", "key"]) && typeof credential.key === "string" && typeof credential.name === "string";
}
var AzureNamedKeyCredential;
var init_azureNamedKeyCredential = __esm({
  "node_modules/@azure/core-auth/dist/browser/azureNamedKeyCredential.js"() {
    init_browser4();
    AzureNamedKeyCredential = class {
      /**
       * The value of the key to be used in authentication.
       */
      get key() {
        return this._key;
      }
      /**
       * The value of the name to be used in authentication.
       */
      get name() {
        return this._name;
      }
      /**
       * Create an instance of an AzureNamedKeyCredential for use
       * with a service client.
       *
       * @param name - The initial value of the name to use in authentication.
       * @param key - The initial value of the key to use in authentication.
       */
      constructor(name3, key) {
        if (!name3 || !key) {
          throw new TypeError("name and key must be non-empty strings");
        }
        this._name = name3;
        this._key = key;
      }
      /**
       * Change the value of the key.
       *
       * Updates will take effect upon the next request after
       * updating the key value.
       *
       * @param newName - The new name value to be used.
       * @param newKey - The new key value to be used.
       */
      update(newName, newKey) {
        if (!newName || !newKey) {
          throw new TypeError("newName and newKey must be non-empty strings");
        }
        this._name = newName;
        this._key = newKey;
      }
    };
  }
});

// node_modules/@azure/core-auth/dist/browser/azureSASCredential.js
function isSASCredential(credential) {
  return isObjectWithProperties(credential, ["signature"]) && typeof credential.signature === "string";
}
var AzureSASCredential;
var init_azureSASCredential = __esm({
  "node_modules/@azure/core-auth/dist/browser/azureSASCredential.js"() {
    init_browser4();
    AzureSASCredential = class {
      /**
       * The value of the shared access signature to be used in authentication
       */
      get signature() {
        return this._signature;
      }
      /**
       * Create an instance of an AzureSASCredential for use
       * with a service client.
       *
       * @param signature - The initial value of the shared access signature to use in authentication
       */
      constructor(signature) {
        if (!signature) {
          throw new Error("shared access signature must be a non-empty string");
        }
        this._signature = signature;
      }
      /**
       * Change the value of the signature.
       *
       * Updates will take effect upon the next request after
       * updating the signature value.
       *
       * @param newSignature - The new shared access signature value to be used
       */
      update(newSignature) {
        if (!newSignature) {
          throw new Error("shared access signature must be a non-empty string");
        }
        this._signature = newSignature;
      }
    };
  }
});

// node_modules/@azure/core-auth/dist/browser/tokenCredential.js
function isTokenCredential(credential) {
  const castCredential = credential;
  return castCredential && typeof castCredential.getToken === "function" && (castCredential.signRequest === void 0 || castCredential.getToken.length > 0);
}
var init_tokenCredential = __esm({
  "node_modules/@azure/core-auth/dist/browser/tokenCredential.js"() {
  }
});

// node_modules/@azure/core-auth/dist/browser/index.js
var browser_exports2 = {};
__export(browser_exports2, {
  AzureKeyCredential: () => AzureKeyCredential,
  AzureNamedKeyCredential: () => AzureNamedKeyCredential,
  AzureSASCredential: () => AzureSASCredential,
  isKeyCredential: () => isKeyCredential,
  isNamedKeyCredential: () => isNamedKeyCredential,
  isSASCredential: () => isSASCredential,
  isTokenCredential: () => isTokenCredential
});
var init_browser9 = __esm({
  "node_modules/@azure/core-auth/dist/browser/index.js"() {
    init_azureKeyCredential();
    init_keyCredential();
    init_azureNamedKeyCredential();
    init_azureSASCredential();
    init_tokenCredential();
  }
});

// node_modules/tedious/lib/debug.js
var require_debug = __commonJS({
  "node_modules/tedious/lib/debug.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _events = require_events();
    var util = _interopRequireWildcard(require_util());
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
      return n.default = e, t && t.set(e, n), n;
    }
    var Debug = class extends _events.EventEmitter {
      /*
        @options    Which debug details should be sent.
                    data    - dump of packet data
                    payload - details of decoded payload
      */
      constructor({
        data = false,
        payload = false,
        packet = false,
        token = false
      } = {}) {
        super();
        this.options = {
          data,
          payload,
          packet,
          token
        };
        this.indent = "  ";
      }
      packet(direction, packet) {
        if (this.haveListeners() && this.options.packet) {
          this.log("");
          this.log(direction);
          this.log(packet.headerToString(this.indent));
        }
      }
      data(packet) {
        if (this.haveListeners() && this.options.data) {
          this.log(packet.dataToString(this.indent));
        }
      }
      payload(generatePayloadText) {
        if (this.haveListeners() && this.options.payload) {
          this.log(generatePayloadText());
        }
      }
      token(token) {
        if (this.haveListeners() && this.options.token) {
          this.log(util.inspect(token, {
            showHidden: false,
            depth: 5,
            colors: true
          }));
        }
      }
      haveListeners() {
        return this.listeners("debug").length > 0;
      }
      log(text) {
        this.emit("debug", text);
      }
    };
    var _default = exports.default = Debug;
    module.exports = Debug;
  }
});

// node_modules/tedious/lib/errors/abort-error.js
var require_abort_error = __commonJS({
  "node_modules/tedious/lib/errors/abort-error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var AbortError3 = class extends Error {
      constructor() {
        super("The operation was aborted");
        this.code = "ABORT_ERR";
        this.name = "AbortError";
      }
    };
    exports.default = AbortError3;
  }
});

// browser-external:dgram
var require_dgram = __commonJS({
  "browser-external:dgram"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "dgram" has been externalized for browser compatibility. Cannot access "dgram.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:url
var require_node_url = __commonJS({
  "browser-external:node:url"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:url" has been externalized for browser compatibility. Cannot access "node:url.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/tedious/lib/sender.js
var require_sender = __commonJS({
  "node_modules/tedious/lib/sender.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.sendInParallel = sendInParallel;
    exports.sendMessage = sendMessage;
    var _dgram = _interopRequireDefault(require_dgram());
    var _net = _interopRequireDefault(require_net());
    var _nodeUrl = _interopRequireDefault(require_node_url());
    var _abortError = _interopRequireDefault(require_abort_error());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    async function sendInParallel(addresses, port, request, signal) {
      if (signal.aborted) {
        throw new _abortError.default();
      }
      return await new Promise((resolve, reject) => {
        const sockets = [];
        let errorCount = 0;
        const onError = (err) => {
          errorCount++;
          if (errorCount === addresses.length) {
            signal.removeEventListener("abort", onAbort);
            clearSockets();
            reject(err);
          }
        };
        const onMessage = (message) => {
          signal.removeEventListener("abort", onAbort);
          clearSockets();
          resolve(message);
        };
        const onAbort = () => {
          clearSockets();
          reject(new _abortError.default());
        };
        const clearSockets = () => {
          for (const socket of sockets) {
            socket.removeListener("error", onError);
            socket.removeListener("message", onMessage);
            socket.close();
          }
        };
        signal.addEventListener("abort", onAbort, {
          once: true
        });
        for (let j = 0; j < addresses.length; j++) {
          const udpType = addresses[j].family === 6 ? "udp6" : "udp4";
          const socket = _dgram.default.createSocket(udpType);
          sockets.push(socket);
          socket.on("error", onError);
          socket.on("message", onMessage);
          socket.send(request, 0, request.length, port, addresses[j].address);
        }
      });
    }
    async function sendMessage(host, port, lookup, signal, request) {
      if (signal.aborted) {
        throw new _abortError.default();
      }
      let addresses;
      if (_net.default.isIP(host)) {
        addresses = [{
          address: host,
          family: _net.default.isIPv6(host) ? 6 : 4
        }];
      } else {
        addresses = await new Promise((resolve, reject) => {
          const onAbort = () => {
            reject(new _abortError.default());
          };
          const domainInASCII = _nodeUrl.default.domainToASCII(host);
          lookup(domainInASCII === "" ? host : domainInASCII, {
            all: true
          }, (err, addresses2) => {
            signal.removeEventListener("abort", onAbort);
            err ? reject(err) : resolve(addresses2);
          });
        });
      }
      return await sendInParallel(addresses, port, request, signal);
    }
  }
});

// node_modules/tedious/lib/errors/timeout-error.js
var require_timeout_error = __commonJS({
  "node_modules/tedious/lib/errors/timeout-error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TimeoutError = class extends Error {
      constructor() {
        super("The operation was aborted due to timeout");
        this.code = "TIMEOUT_ERR";
        this.name = "TimeoutError";
      }
    };
    exports.default = TimeoutError;
  }
});

// node_modules/tedious/lib/utils/with-timeout.js
var require_with_timeout = __commonJS({
  "node_modules/tedious/lib/utils/with-timeout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.withTimeout = withTimeout;
    var _timeoutError = _interopRequireDefault(require_timeout_error());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    async function withTimeout(timeout, func, signal) {
      const timeoutController = new AbortController();
      const abortCurrentAttempt = () => {
        timeoutController.abort();
      };
      const timer = setTimeout(abortCurrentAttempt, timeout);
      signal == null ? void 0 : signal.addEventListener("abort", abortCurrentAttempt, {
        once: true
      });
      try {
        return await func(timeoutController.signal);
      } catch (err) {
        if (err instanceof Error && err.name === "AbortError" && !(signal && signal.aborted)) {
          throw new _timeoutError.default();
        }
        throw err;
      } finally {
        signal == null ? void 0 : signal.removeEventListener("abort", abortCurrentAttempt);
        clearTimeout(timer);
      }
    }
  }
});

// node_modules/tedious/lib/instance-lookup.js
var require_instance_lookup = __commonJS({
  "node_modules/tedious/lib/instance-lookup.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.instanceLookup = instanceLookup;
    exports.parseBrowserResponse = parseBrowserResponse;
    var _dns = _interopRequireDefault(require_dns());
    var _abortError = _interopRequireDefault(require_abort_error());
    var _sender = require_sender();
    var _withTimeout = require_with_timeout();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var SQL_SERVER_BROWSER_PORT = 1434;
    var TIMEOUT = 2 * 1e3;
    var RETRIES = 3;
    var MYSTERY_HEADER_LENGTH = 3;
    async function instanceLookup(options) {
      const server = options.server;
      if (typeof server !== "string") {
        throw new TypeError('Invalid arguments: "server" must be a string');
      }
      const instanceName = options.instanceName;
      if (typeof instanceName !== "string") {
        throw new TypeError('Invalid arguments: "instanceName" must be a string');
      }
      const timeout = options.timeout === void 0 ? TIMEOUT : options.timeout;
      if (typeof timeout !== "number") {
        throw new TypeError('Invalid arguments: "timeout" must be a number');
      }
      const retries = options.retries === void 0 ? RETRIES : options.retries;
      if (typeof retries !== "number") {
        throw new TypeError('Invalid arguments: "retries" must be a number');
      }
      if (options.lookup !== void 0 && typeof options.lookup !== "function") {
        throw new TypeError('Invalid arguments: "lookup" must be a function');
      }
      const lookup = options.lookup ?? _dns.default.lookup;
      if (options.port !== void 0 && typeof options.port !== "number") {
        throw new TypeError('Invalid arguments: "port" must be a number');
      }
      const port = options.port ?? SQL_SERVER_BROWSER_PORT;
      const signal = options.signal;
      if (signal.aborted) {
        throw new _abortError.default();
      }
      let response;
      for (let i = 0; i <= retries; i++) {
        try {
          response = await (0, _withTimeout.withTimeout)(timeout, async (signal2) => {
            const request = Buffer.from([2]);
            return await (0, _sender.sendMessage)(options.server, port, lookup, signal2, request);
          }, signal);
        } catch (err) {
          if (!signal.aborted && err instanceof Error && err.name === "TimeoutError") {
            continue;
          }
          throw err;
        }
      }
      if (!response) {
        throw new Error("Failed to get response from SQL Server Browser on " + server);
      }
      const message = response.toString("ascii", MYSTERY_HEADER_LENGTH);
      const foundPort = parseBrowserResponse(message, instanceName);
      if (!foundPort) {
        throw new Error("Port for " + instanceName + " not found in " + options.server);
      }
      return foundPort;
    }
    function parseBrowserResponse(response, instanceName) {
      let getPort;
      const instances = response.split(";;");
      for (let i = 0, len = instances.length; i < len; i++) {
        const instance = instances[i];
        const parts = instance.split(";");
        for (let p = 0, partsLen = parts.length; p < partsLen; p += 2) {
          const name3 = parts[p];
          const value = parts[p + 1];
          if (name3 === "tcp" && getPort) {
            const port = parseInt(value, 10);
            return port;
          }
          if (name3 === "InstanceName") {
            if (value.toUpperCase() === instanceName.toUpperCase()) {
              getPort = true;
            } else {
              getPort = false;
            }
          }
        }
      }
    }
  }
});

// node_modules/tedious/lib/transient-error-lookup.js
var require_transient_error_lookup = __commonJS({
  "node_modules/tedious/lib/transient-error-lookup.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TransientErrorLookup = void 0;
    var TransientErrorLookup = class {
      isTransientError(error) {
        const transientErrors = [4060, 10928, 10929, 40197, 40501, 40613];
        return transientErrors.indexOf(error) !== -1;
      }
    };
    exports.TransientErrorLookup = TransientErrorLookup;
  }
});

// node_modules/sprintf-js/src/sprintf.js
var require_sprintf = __commonJS({
  "node_modules/sprintf-js/src/sprintf.js"(exports) {
    !function() {
      "use strict";
      var re = {
        not_string: /[^s]/,
        not_bool: /[^t]/,
        not_type: /[^T]/,
        not_primitive: /[^v]/,
        number: /[diefg]/,
        numeric_arg: /[bcdiefguxX]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[+-]/
      };
      function sprintf(key) {
        return sprintf_format(sprintf_parse(key), arguments);
      }
      function vsprintf(fmt, argv) {
        return sprintf.apply(null, [fmt].concat(argv || []));
      }
      function sprintf_format(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, arg, output = "", i, k, ph, pad, pad_character, pad_length, is_positive, sign2;
        for (i = 0; i < tree_length; i++) {
          if (typeof parse_tree[i] === "string") {
            output += parse_tree[i];
          } else if (typeof parse_tree[i] === "object") {
            ph = parse_tree[i];
            if (ph.keys) {
              arg = argv[cursor];
              for (k = 0; k < ph.keys.length; k++) {
                if (arg == void 0) {
                  throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k - 1]));
                }
                arg = arg[ph.keys[k]];
              }
            } else if (ph.param_no) {
              arg = argv[ph.param_no];
            } else {
              arg = argv[cursor++];
            }
            if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
              arg = arg();
            }
            if (re.numeric_arg.test(ph.type) && (typeof arg !== "number" && isNaN(arg))) {
              throw new TypeError(sprintf("[sprintf] expecting number but found %T", arg));
            }
            if (re.number.test(ph.type)) {
              is_positive = arg >= 0;
            }
            switch (ph.type) {
              case "b":
                arg = parseInt(arg, 10).toString(2);
                break;
              case "c":
                arg = String.fromCharCode(parseInt(arg, 10));
                break;
              case "d":
              case "i":
                arg = parseInt(arg, 10);
                break;
              case "j":
                arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
                break;
              case "e":
                arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
                break;
              case "f":
                arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
                break;
              case "g":
                arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
                break;
              case "o":
                arg = (parseInt(arg, 10) >>> 0).toString(8);
                break;
              case "s":
                arg = String(arg);
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "t":
                arg = String(!!arg);
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "T":
                arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "u":
                arg = parseInt(arg, 10) >>> 0;
                break;
              case "v":
                arg = arg.valueOf();
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "x":
                arg = (parseInt(arg, 10) >>> 0).toString(16);
                break;
              case "X":
                arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
                break;
            }
            if (re.json.test(ph.type)) {
              output += arg;
            } else {
              if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
                sign2 = is_positive ? "+" : "-";
                arg = arg.toString().replace(re.sign, "");
              } else {
                sign2 = "";
              }
              pad_character = ph.pad_char ? ph.pad_char === "0" ? "0" : ph.pad_char.charAt(1) : " ";
              pad_length = ph.width - (sign2 + arg).length;
              pad = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : "" : "";
              output += ph.align ? sign2 + arg + pad : pad_character === "0" ? sign2 + pad + arg : pad + sign2 + arg;
            }
          }
        }
        return output;
      }
      var sprintf_cache = /* @__PURE__ */ Object.create(null);
      function sprintf_parse(fmt) {
        if (sprintf_cache[fmt]) {
          return sprintf_cache[fmt];
        }
        var _fmt = fmt, match, parse_tree = [], arg_names = 0;
        while (_fmt) {
          if ((match = re.text.exec(_fmt)) !== null) {
            parse_tree.push(match[0]);
          } else if ((match = re.modulo.exec(_fmt)) !== null) {
            parse_tree.push("%");
          } else if ((match = re.placeholder.exec(_fmt)) !== null) {
            if (match[2]) {
              arg_names |= 1;
              var field_list = [], replacement_field = match[2], field_match = [];
              if ((field_match = re.key.exec(replacement_field)) !== null) {
                field_list.push(field_match[1]);
                while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                  if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else {
                    throw new SyntaxError("[sprintf] failed to parse named argument key");
                  }
                }
              } else {
                throw new SyntaxError("[sprintf] failed to parse named argument key");
              }
              match[2] = field_list;
            } else {
              arg_names |= 2;
            }
            if (arg_names === 3) {
              throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
            }
            parse_tree.push(
              {
                placeholder: match[0],
                param_no: match[1],
                keys: match[2],
                sign: match[3],
                pad_char: match[4],
                align: match[5],
                width: match[6],
                precision: match[7],
                type: match[8]
              }
            );
          } else {
            throw new SyntaxError("[sprintf] unexpected placeholder");
          }
          _fmt = _fmt.substring(match[0].length);
        }
        return sprintf_cache[fmt] = parse_tree;
      }
      if (typeof exports !== "undefined") {
        exports["sprintf"] = sprintf;
        exports["vsprintf"] = vsprintf;
      }
      if (typeof window !== "undefined") {
        window["sprintf"] = sprintf;
        window["vsprintf"] = vsprintf;
        if (typeof define === "function" && define["amd"]) {
          define(function() {
            return {
              "sprintf": sprintf,
              "vsprintf": vsprintf
            };
          });
        }
      }
    }();
  }
});

// node_modules/tedious/lib/packet.js
var require_packet = __commonJS({
  "node_modules/tedious/lib/packet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TYPE = exports.Packet = exports.OFFSET = exports.HEADER_LENGTH = void 0;
    exports.isPacketComplete = isPacketComplete;
    exports.packetLength = packetLength;
    var _sprintfJs = require_sprintf();
    var HEADER_LENGTH = exports.HEADER_LENGTH = 8;
    var TYPE = exports.TYPE = {
      SQL_BATCH: 1,
      RPC_REQUEST: 3,
      TABULAR_RESULT: 4,
      ATTENTION: 6,
      BULK_LOAD: 7,
      TRANSACTION_MANAGER: 14,
      LOGIN7: 16,
      NTLMAUTH_PKT: 17,
      PRELOGIN: 18,
      FEDAUTH_TOKEN: 8
    };
    var typeByValue = {};
    for (const name3 in TYPE) {
      typeByValue[TYPE[name3]] = name3;
    }
    var STATUS = {
      NORMAL: 0,
      EOM: 1,
      IGNORE: 2,
      RESETCONNECTION: 8,
      RESETCONNECTIONSKIPTRAN: 16
    };
    var OFFSET = exports.OFFSET = {
      Type: 0,
      Status: 1,
      Length: 2,
      SPID: 4,
      PacketID: 6,
      Window: 7
    };
    var DEFAULT_SPID = 0;
    var DEFAULT_PACKETID = 1;
    var DEFAULT_WINDOW = 0;
    var NL = "\n";
    var Packet = class {
      constructor(typeOrBuffer) {
        if (typeOrBuffer instanceof Buffer) {
          this.buffer = typeOrBuffer;
        } else {
          const type = typeOrBuffer;
          this.buffer = Buffer.alloc(HEADER_LENGTH, 0);
          this.buffer.writeUInt8(type, OFFSET.Type);
          this.buffer.writeUInt8(STATUS.NORMAL, OFFSET.Status);
          this.buffer.writeUInt16BE(DEFAULT_SPID, OFFSET.SPID);
          this.buffer.writeUInt8(DEFAULT_PACKETID, OFFSET.PacketID);
          this.buffer.writeUInt8(DEFAULT_WINDOW, OFFSET.Window);
          this.setLength();
        }
      }
      setLength() {
        this.buffer.writeUInt16BE(this.buffer.length, OFFSET.Length);
      }
      length() {
        return this.buffer.readUInt16BE(OFFSET.Length);
      }
      resetConnection(reset) {
        let status = this.buffer.readUInt8(OFFSET.Status);
        if (reset) {
          status |= STATUS.RESETCONNECTION;
        } else {
          status &= 255 - STATUS.RESETCONNECTION;
        }
        this.buffer.writeUInt8(status, OFFSET.Status);
      }
      last(last) {
        let status = this.buffer.readUInt8(OFFSET.Status);
        if (arguments.length > 0) {
          if (last) {
            status |= STATUS.EOM;
          } else {
            status &= 255 - STATUS.EOM;
          }
          this.buffer.writeUInt8(status, OFFSET.Status);
        }
        return this.isLast();
      }
      ignore(last) {
        let status = this.buffer.readUInt8(OFFSET.Status);
        if (last) {
          status |= STATUS.IGNORE;
        } else {
          status &= 255 - STATUS.IGNORE;
        }
        this.buffer.writeUInt8(status, OFFSET.Status);
      }
      isLast() {
        return !!(this.buffer.readUInt8(OFFSET.Status) & STATUS.EOM);
      }
      packetId(packetId) {
        if (packetId) {
          this.buffer.writeUInt8(packetId % 256, OFFSET.PacketID);
        }
        return this.buffer.readUInt8(OFFSET.PacketID);
      }
      addData(data) {
        this.buffer = Buffer.concat([this.buffer, data]);
        this.setLength();
        return this;
      }
      data() {
        return this.buffer.slice(HEADER_LENGTH);
      }
      type() {
        return this.buffer.readUInt8(OFFSET.Type);
      }
      statusAsString() {
        const status = this.buffer.readUInt8(OFFSET.Status);
        const statuses = [];
        for (const name3 in STATUS) {
          const value = STATUS[name3];
          if (status & value) {
            statuses.push(name3);
          } else {
            statuses.push(void 0);
          }
        }
        return statuses.join(" ").trim();
      }
      headerToString(indent = "") {
        const text = (0, _sprintfJs.sprintf)("type:0x%02X(%s), status:0x%02X(%s), length:0x%04X, spid:0x%04X, packetId:0x%02X, window:0x%02X", this.buffer.readUInt8(OFFSET.Type), typeByValue[this.buffer.readUInt8(OFFSET.Type)], this.buffer.readUInt8(OFFSET.Status), this.statusAsString(), this.buffer.readUInt16BE(OFFSET.Length), this.buffer.readUInt16BE(OFFSET.SPID), this.buffer.readUInt8(OFFSET.PacketID), this.buffer.readUInt8(OFFSET.Window));
        return indent + text;
      }
      dataToString(indent = "") {
        const BYTES_PER_GROUP = 4;
        const CHARS_PER_GROUP = 8;
        const BYTES_PER_LINE = 32;
        const data = this.data();
        let dataDump = "";
        let chars = "";
        for (let offset = 0; offset < data.length; offset++) {
          if (offset % BYTES_PER_LINE === 0) {
            dataDump += indent;
            dataDump += (0, _sprintfJs.sprintf)("%04X  ", offset);
          }
          if (data[offset] < 32 || data[offset] > 126) {
            chars += ".";
            if ((offset + 1) % CHARS_PER_GROUP === 0 && !((offset + 1) % BYTES_PER_LINE === 0)) {
              chars += " ";
            }
          } else {
            chars += String.fromCharCode(data[offset]);
          }
          if (data[offset] != null) {
            dataDump += (0, _sprintfJs.sprintf)("%02X", data[offset]);
          }
          if ((offset + 1) % BYTES_PER_GROUP === 0 && !((offset + 1) % BYTES_PER_LINE === 0)) {
            dataDump += " ";
          }
          if ((offset + 1) % BYTES_PER_LINE === 0) {
            dataDump += "  " + chars;
            chars = "";
            if (offset < data.length - 1) {
              dataDump += NL;
            }
          }
        }
        if (chars.length) {
          dataDump += "  " + chars;
        }
        return dataDump;
      }
      toString(indent = "") {
        return this.headerToString(indent) + "\n" + this.dataToString(indent + indent);
      }
      payloadString() {
        return "";
      }
    };
    exports.Packet = Packet;
    function isPacketComplete(potentialPacketBuffer) {
      if (potentialPacketBuffer.length < HEADER_LENGTH) {
        return false;
      } else {
        return potentialPacketBuffer.length >= potentialPacketBuffer.readUInt16BE(OFFSET.Length);
      }
    }
    function packetLength(potentialPacketBuffer) {
      return potentialPacketBuffer.readUInt16BE(OFFSET.Length);
    }
  }
});

// node_modules/tedious/lib/prelogin-payload.js
var require_prelogin_payload = __commonJS({
  "node_modules/tedious/lib/prelogin-payload.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _sprintfJs = require_sprintf();
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var optionBufferSize = 20;
    var TOKEN = {
      VERSION: 0,
      ENCRYPTION: 1,
      INSTOPT: 2,
      THREADID: 3,
      MARS: 4,
      FEDAUTHREQUIRED: 6,
      TERMINATOR: 255
    };
    var ENCRYPT2 = {
      OFF: 0,
      ON: 1,
      NOT_SUP: 2,
      REQ: 3
    };
    var encryptByValue = {};
    for (const name3 in ENCRYPT2) {
      const value = ENCRYPT2[name3];
      encryptByValue[value] = name3;
    }
    var MARS = {
      OFF: 0,
      ON: 1
    };
    var marsByValue = {};
    for (const name3 in MARS) {
      const value = MARS[name3];
      marsByValue[value] = name3;
    }
    var PreloginPayload = class {
      constructor(bufferOrOptions = {
        encrypt: false,
        version: {
          major: 0,
          minor: 0,
          build: 0,
          subbuild: 0
        }
      }) {
        if (bufferOrOptions instanceof Buffer) {
          this.data = bufferOrOptions;
          this.options = {
            encrypt: false,
            version: {
              major: 0,
              minor: 0,
              build: 0,
              subbuild: 0
            }
          };
        } else {
          this.options = bufferOrOptions;
          this.createOptions();
        }
        this.extractOptions();
      }
      createOptions() {
        const options = [this.createVersionOption(), this.createEncryptionOption(), this.createInstanceOption(), this.createThreadIdOption(), this.createMarsOption(), this.createFedAuthOption()];
        let length = 0;
        for (let i = 0, len = options.length; i < len; i++) {
          const option = options[i];
          length += 5 + option.data.length;
        }
        length++;
        this.data = Buffer.alloc(length, 0);
        let optionOffset = 0;
        let optionDataOffset = 5 * options.length + 1;
        for (let j = 0, len = options.length; j < len; j++) {
          const option = options[j];
          this.data.writeUInt8(option.token, optionOffset + 0);
          this.data.writeUInt16BE(optionDataOffset, optionOffset + 1);
          this.data.writeUInt16BE(option.data.length, optionOffset + 3);
          optionOffset += 5;
          option.data.copy(this.data, optionDataOffset);
          optionDataOffset += option.data.length;
        }
        this.data.writeUInt8(TOKEN.TERMINATOR, optionOffset);
      }
      createVersionOption() {
        const buffer = new _writableTrackingBuffer.default(optionBufferSize);
        buffer.writeUInt8(this.options.version.major);
        buffer.writeUInt8(this.options.version.minor);
        buffer.writeUInt16BE(this.options.version.build);
        buffer.writeUInt16BE(this.options.version.subbuild);
        return {
          token: TOKEN.VERSION,
          data: buffer.data
        };
      }
      createEncryptionOption() {
        const buffer = new _writableTrackingBuffer.default(optionBufferSize);
        if (this.options.encrypt) {
          buffer.writeUInt8(ENCRYPT2.ON);
        } else {
          buffer.writeUInt8(ENCRYPT2.NOT_SUP);
        }
        return {
          token: TOKEN.ENCRYPTION,
          data: buffer.data
        };
      }
      createInstanceOption() {
        const buffer = new _writableTrackingBuffer.default(optionBufferSize);
        buffer.writeUInt8(0);
        return {
          token: TOKEN.INSTOPT,
          data: buffer.data
        };
      }
      createThreadIdOption() {
        const buffer = new _writableTrackingBuffer.default(optionBufferSize);
        buffer.writeUInt32BE(0);
        return {
          token: TOKEN.THREADID,
          data: buffer.data
        };
      }
      createMarsOption() {
        const buffer = new _writableTrackingBuffer.default(optionBufferSize);
        buffer.writeUInt8(MARS.OFF);
        return {
          token: TOKEN.MARS,
          data: buffer.data
        };
      }
      createFedAuthOption() {
        const buffer = new _writableTrackingBuffer.default(optionBufferSize);
        buffer.writeUInt8(1);
        return {
          token: TOKEN.FEDAUTHREQUIRED,
          data: buffer.data
        };
      }
      extractOptions() {
        let offset = 0;
        while (this.data[offset] !== TOKEN.TERMINATOR) {
          let dataOffset = this.data.readUInt16BE(offset + 1);
          const dataLength = this.data.readUInt16BE(offset + 3);
          switch (this.data[offset]) {
            case TOKEN.VERSION:
              this.extractVersion(dataOffset);
              break;
            case TOKEN.ENCRYPTION:
              this.extractEncryption(dataOffset);
              break;
            case TOKEN.INSTOPT:
              this.extractInstance(dataOffset);
              break;
            case TOKEN.THREADID:
              if (dataLength > 0) {
                this.extractThreadId(dataOffset);
              }
              break;
            case TOKEN.MARS:
              this.extractMars(dataOffset);
              break;
            case TOKEN.FEDAUTHREQUIRED:
              this.extractFedAuth(dataOffset);
              break;
          }
          offset += 5;
          dataOffset += dataLength;
        }
      }
      extractVersion(offset) {
        this.version = {
          major: this.data.readUInt8(offset + 0),
          minor: this.data.readUInt8(offset + 1),
          build: this.data.readUInt16BE(offset + 2),
          subbuild: this.data.readUInt16BE(offset + 4)
        };
      }
      extractEncryption(offset) {
        this.encryption = this.data.readUInt8(offset);
        this.encryptionString = encryptByValue[this.encryption];
      }
      extractInstance(offset) {
        this.instance = this.data.readUInt8(offset);
      }
      extractThreadId(offset) {
        this.threadId = this.data.readUInt32BE(offset);
      }
      extractMars(offset) {
        this.mars = this.data.readUInt8(offset);
        this.marsString = marsByValue[this.mars];
      }
      extractFedAuth(offset) {
        this.fedAuthRequired = this.data.readUInt8(offset);
      }
      toString(indent = "") {
        return indent + "PreLogin - " + (0, _sprintfJs.sprintf)("version:%d.%d.%d.%d, encryption:0x%02X(%s), instopt:0x%02X, threadId:0x%08X, mars:0x%02X(%s)", this.version.major, this.version.minor, this.version.build, this.version.subbuild, this.encryption ? this.encryption : 0, this.encryptionString ? this.encryptionString : "", this.instance ? this.instance : 0, this.threadId ? this.threadId : 0, this.mars ? this.mars : 0, this.marsString ? this.marsString : "");
      }
    };
    var _default = exports.default = PreloginPayload;
    module.exports = PreloginPayload;
  }
});

// node_modules/tedious/lib/tds-versions.js
var require_tds_versions = __commonJS({
  "node_modules/tedious/lib/tds-versions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.versionsByValue = exports.versions = void 0;
    var versions = exports.versions = {
      "7_1": 1895825409,
      "7_2": 1913192450,
      "7_3_A": 1930035203,
      "7_3_B": 1930100739,
      "7_4": 1946157060,
      "8_0": 134217728
    };
    var versionsByValue = exports.versionsByValue = {};
    for (const name3 in versions) {
      versionsByValue[versions[name3]] = name3;
    }
  }
});

// node_modules/tedious/lib/login7-payload.js
var require_login7_payload = __commonJS({
  "node_modules/tedious/lib/login7-payload.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _sprintfJs = require_sprintf();
    var _tdsVersions = require_tds_versions();
    var FLAGS_1 = {
      ENDIAN_LITTLE: 0,
      ENDIAN_BIG: 1,
      CHARSET_ASCII: 0,
      CHARSET_EBCDIC: 2,
      FLOAT_IEEE_754: 0,
      FLOAT_VAX: 4,
      FLOAT_ND5000: 8,
      BCP_DUMPLOAD_ON: 0,
      BCP_DUMPLOAD_OFF: 16,
      USE_DB_ON: 0,
      USE_DB_OFF: 32,
      INIT_DB_WARN: 0,
      INIT_DB_FATAL: 64,
      SET_LANG_WARN_OFF: 0,
      SET_LANG_WARN_ON: 128
    };
    var FLAGS_2 = {
      INIT_LANG_WARN: 0,
      INIT_LANG_FATAL: 1,
      ODBC_OFF: 0,
      ODBC_ON: 2,
      F_TRAN_BOUNDARY: 4,
      F_CACHE_CONNECT: 8,
      USER_NORMAL: 0,
      USER_SERVER: 16,
      USER_REMUSER: 32,
      USER_SQLREPL: 64,
      INTEGRATED_SECURITY_OFF: 0,
      INTEGRATED_SECURITY_ON: 128
    };
    var TYPE_FLAGS = {
      SQL_DFLT: 0,
      SQL_TSQL: 8,
      OLEDB_OFF: 0,
      OLEDB_ON: 16,
      READ_WRITE_INTENT: 0,
      READ_ONLY_INTENT: 32
    };
    var FLAGS_3 = {
      CHANGE_PASSWORD_NO: 0,
      CHANGE_PASSWORD_YES: 1,
      BINARY_XML: 2,
      SPAWN_USER_INSTANCE: 4,
      UNKNOWN_COLLATION_HANDLING: 8,
      EXTENSION_USED: 16
    };
    var FEDAUTH_OPTIONS = {
      FEATURE_ID: 2,
      LIBRARY_SECURITYTOKEN: 1,
      LIBRARY_ADAL: 2,
      FEDAUTH_YES_ECHO: 1,
      FEDAUTH_NO_ECHO: 0,
      ADAL_WORKFLOW_USER_PASS: 1,
      ADAL_WORKFLOW_INTEGRATED: 2
    };
    var FEATURE_EXT_TERMINATOR = 255;
    var Login7Payload = class {
      constructor({
        tdsVersion,
        packetSize,
        clientProgVer,
        clientPid,
        connectionId,
        clientTimeZone,
        clientLcid
      }) {
        this.tdsVersion = tdsVersion;
        this.packetSize = packetSize;
        this.clientProgVer = clientProgVer;
        this.clientPid = clientPid;
        this.connectionId = connectionId;
        this.clientTimeZone = clientTimeZone;
        this.clientLcid = clientLcid;
        this.readOnlyIntent = false;
        this.initDbFatal = false;
        this.fedAuth = void 0;
        this.userName = void 0;
        this.password = void 0;
        this.serverName = void 0;
        this.appName = void 0;
        this.hostname = void 0;
        this.libraryName = void 0;
        this.language = void 0;
        this.database = void 0;
        this.clientId = void 0;
        this.sspi = void 0;
        this.attachDbFile = void 0;
        this.changePassword = void 0;
      }
      toBuffer() {
        const fixedData = Buffer.alloc(94);
        const buffers = [fixedData];
        let offset = 0;
        let dataOffset = fixedData.length;
        offset = fixedData.writeUInt32LE(0, offset);
        offset = fixedData.writeUInt32LE(this.tdsVersion, offset);
        offset = fixedData.writeUInt32LE(this.packetSize, offset);
        offset = fixedData.writeUInt32LE(this.clientProgVer, offset);
        offset = fixedData.writeUInt32LE(this.clientPid, offset);
        offset = fixedData.writeUInt32LE(this.connectionId, offset);
        offset = fixedData.writeUInt8(this.buildOptionFlags1(), offset);
        offset = fixedData.writeUInt8(this.buildOptionFlags2(), offset);
        offset = fixedData.writeUInt8(this.buildTypeFlags(), offset);
        offset = fixedData.writeUInt8(this.buildOptionFlags3(), offset);
        offset = fixedData.writeInt32LE(this.clientTimeZone, offset);
        offset = fixedData.writeUInt32LE(this.clientLcid, offset);
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.hostname) {
          const buffer = Buffer.from(this.hostname, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(dataOffset, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.userName) {
          const buffer = Buffer.from(this.userName, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.password) {
          const buffer = Buffer.from(this.password, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(this.scramblePassword(buffer));
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.appName) {
          const buffer = Buffer.from(this.appName, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.serverName) {
          const buffer = Buffer.from(this.serverName, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        const extensions = this.buildFeatureExt();
        offset = fixedData.writeUInt16LE(4, offset);
        const extensionOffset = Buffer.alloc(4);
        extensionOffset.writeUInt32LE(dataOffset += 4, 0);
        dataOffset += extensions.length;
        buffers.push(extensionOffset, extensions);
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.libraryName) {
          const buffer = Buffer.from(this.libraryName, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.language) {
          const buffer = Buffer.from(this.language, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.database) {
          const buffer = Buffer.from(this.database, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        if (this.clientId) {
          this.clientId.copy(fixedData, offset, 0, 6);
        }
        offset += 6;
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.sspi) {
          if (this.sspi.length > 65535) {
            offset = fixedData.writeUInt16LE(65535, offset);
          } else {
            offset = fixedData.writeUInt16LE(this.sspi.length, offset);
          }
          buffers.push(this.sspi);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.attachDbFile) {
          const buffer = Buffer.from(this.attachDbFile, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.changePassword) {
          const buffer = Buffer.from(this.changePassword, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        if (this.sspi && this.sspi.length > 65535) {
          fixedData.writeUInt32LE(this.sspi.length, offset);
        } else {
          fixedData.writeUInt32LE(0, offset);
        }
        const data = Buffer.concat(buffers);
        data.writeUInt32LE(data.length, 0);
        return data;
      }
      buildOptionFlags1() {
        let flags1 = FLAGS_1.ENDIAN_LITTLE | FLAGS_1.CHARSET_ASCII | FLAGS_1.FLOAT_IEEE_754 | FLAGS_1.BCP_DUMPLOAD_OFF | FLAGS_1.USE_DB_OFF | FLAGS_1.SET_LANG_WARN_ON;
        if (this.initDbFatal) {
          flags1 |= FLAGS_1.INIT_DB_FATAL;
        } else {
          flags1 |= FLAGS_1.INIT_DB_WARN;
        }
        return flags1;
      }
      buildFeatureExt() {
        const buffers = [];
        const fedAuth = this.fedAuth;
        if (fedAuth) {
          switch (fedAuth.type) {
            case "ADAL":
              const buffer = Buffer.alloc(7);
              buffer.writeUInt8(FEDAUTH_OPTIONS.FEATURE_ID, 0);
              buffer.writeUInt32LE(2, 1);
              buffer.writeUInt8(FEDAUTH_OPTIONS.LIBRARY_ADAL << 1 | (fedAuth.echo ? FEDAUTH_OPTIONS.FEDAUTH_YES_ECHO : FEDAUTH_OPTIONS.FEDAUTH_NO_ECHO), 5);
              buffer.writeUInt8(fedAuth.workflow === "integrated" ? 2 : FEDAUTH_OPTIONS.ADAL_WORKFLOW_USER_PASS, 6);
              buffers.push(buffer);
              break;
            case "SECURITYTOKEN":
              const token = Buffer.from(fedAuth.fedAuthToken, "ucs2");
              const buf = Buffer.alloc(10);
              let offset = 0;
              offset = buf.writeUInt8(FEDAUTH_OPTIONS.FEATURE_ID, offset);
              offset = buf.writeUInt32LE(token.length + 4 + 1, offset);
              offset = buf.writeUInt8(FEDAUTH_OPTIONS.LIBRARY_SECURITYTOKEN << 1 | (fedAuth.echo ? FEDAUTH_OPTIONS.FEDAUTH_YES_ECHO : FEDAUTH_OPTIONS.FEDAUTH_NO_ECHO), offset);
              buf.writeInt32LE(token.length, offset);
              buffers.push(buf);
              buffers.push(token);
              break;
          }
        }
        if (this.tdsVersion >= _tdsVersions.versions["7_4"]) {
          const UTF8_SUPPORT_FEATURE_ID = 10;
          const UTF8_SUPPORT_CLIENT_SUPPORTS_UTF8 = 1;
          const buf = Buffer.alloc(6);
          buf.writeUInt8(UTF8_SUPPORT_FEATURE_ID, 0);
          buf.writeUInt32LE(1, 1);
          buf.writeUInt8(UTF8_SUPPORT_CLIENT_SUPPORTS_UTF8, 5);
          buffers.push(buf);
        }
        buffers.push(Buffer.from([FEATURE_EXT_TERMINATOR]));
        return Buffer.concat(buffers);
      }
      buildOptionFlags2() {
        let flags2 = FLAGS_2.INIT_LANG_WARN | FLAGS_2.ODBC_OFF | FLAGS_2.USER_NORMAL;
        if (this.sspi) {
          flags2 |= FLAGS_2.INTEGRATED_SECURITY_ON;
        } else {
          flags2 |= FLAGS_2.INTEGRATED_SECURITY_OFF;
        }
        return flags2;
      }
      buildTypeFlags() {
        let typeFlags = TYPE_FLAGS.SQL_DFLT | TYPE_FLAGS.OLEDB_OFF;
        if (this.readOnlyIntent) {
          typeFlags |= TYPE_FLAGS.READ_ONLY_INTENT;
        } else {
          typeFlags |= TYPE_FLAGS.READ_WRITE_INTENT;
        }
        return typeFlags;
      }
      buildOptionFlags3() {
        return FLAGS_3.CHANGE_PASSWORD_NO | FLAGS_3.UNKNOWN_COLLATION_HANDLING | FLAGS_3.EXTENSION_USED;
      }
      scramblePassword(password) {
        for (let b = 0, len = password.length; b < len; b++) {
          let byte = password[b];
          const lowNibble = byte & 15;
          const highNibble = byte >> 4;
          byte = lowNibble << 4 | highNibble;
          byte = byte ^ 165;
          password[b] = byte;
        }
        return password;
      }
      toString(indent = "") {
        return indent + "Login7 - " + (0, _sprintfJs.sprintf)("TDS:0x%08X, PacketSize:0x%08X, ClientProgVer:0x%08X, ClientPID:0x%08X, ConnectionID:0x%08X", this.tdsVersion, this.packetSize, this.clientProgVer, this.clientPid, this.connectionId) + "\n" + indent + "         " + (0, _sprintfJs.sprintf)("Flags1:0x%02X, Flags2:0x%02X, TypeFlags:0x%02X, Flags3:0x%02X, ClientTimezone:%d, ClientLCID:0x%08X", this.buildOptionFlags1(), this.buildOptionFlags2(), this.buildTypeFlags(), this.buildOptionFlags3(), this.clientTimeZone, this.clientLcid) + "\n" + indent + "         " + (0, _sprintfJs.sprintf)("Hostname:'%s', Username:'%s', Password:'%s', AppName:'%s', ServerName:'%s', LibraryName:'%s'", this.hostname, this.userName, this.password, this.appName, this.serverName, this.libraryName) + "\n" + indent + "         " + (0, _sprintfJs.sprintf)("Language:'%s', Database:'%s', SSPI:'%s', AttachDbFile:'%s', ChangePassword:'%s'", this.language, this.database, this.sspi, this.attachDbFile, this.changePassword);
      }
    };
    var _default = exports.default = Login7Payload;
    module.exports = Login7Payload;
  }
});

// node_modules/js-md4/src/md4.js
var require_md4 = __commonJS({
  "node_modules/js-md4/src/md4.js"(exports, module) {
    (function() {
      "use strict";
      var root = typeof window === "object" ? window : {};
      var NODE_JS = !root.JS_MD4_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      }
      var COMMON_JS = !root.JS_MD4_NO_COMMON_JS && typeof module === "object" && module.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_MD4_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var EXTRA = [128, 32768, 8388608, -2147483648];
      var SHIFT = [0, 8, 16, 24];
      var OUTPUT_TYPES = ["hex", "array", "digest", "buffer", "arrayBuffer"];
      var blocks = [], buffer8;
      if (ARRAY_BUFFER) {
        var buffer = new ArrayBuffer(68);
        buffer8 = new Uint8Array(buffer);
        blocks = new Uint32Array(buffer);
      }
      var createOutputMethod = function(outputType) {
        return function(message) {
          return new Md4(true).update(message)[outputType]();
        };
      };
      var createMethod = function() {
        var method = createOutputMethod("hex");
        if (NODE_JS) {
          method = nodeWrap(method);
        }
        method.create = function() {
          return new Md4();
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method[type] = createOutputMethod(type);
        }
        return method;
      };
      var nodeWrap = function(method) {
        var crypto = require_crypto();
        var Buffer2 = require_buffer().Buffer;
        var nodeMethod = function(message) {
          if (typeof message === "string") {
            return crypto.createHash("md4").update(message, "utf8").digest("hex");
          } else if (ARRAY_BUFFER && message instanceof ArrayBuffer) {
            message = new Uint8Array(message);
          } else if (message.length === void 0) {
            return method(message);
          }
          return crypto.createHash("md4").update(new Buffer2(message)).digest("hex");
        };
        return nodeMethod;
      };
      function Md4(sharedMemory) {
        if (sharedMemory) {
          blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
          this.blocks = blocks;
          this.buffer8 = buffer8;
        } else {
          if (ARRAY_BUFFER) {
            var buffer2 = new ArrayBuffer(68);
            this.buffer8 = new Uint8Array(buffer2);
            this.blocks = new Uint32Array(buffer2);
          } else {
            this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          }
        }
        this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = 0;
        this.finalized = this.hashed = false;
        this.first = true;
      }
      Md4.prototype.update = function(message) {
        if (this.finalized) {
          return;
        }
        var notString = typeof message !== "string";
        if (notString && ARRAY_BUFFER && message instanceof ArrayBuffer) {
          message = new Uint8Array(message);
        }
        var code, index = 0, i, length = message.length || 0, blocks2 = this.blocks;
        var buffer82 = this.buffer8;
        while (index < length) {
          if (this.hashed) {
            this.hashed = false;
            blocks2[0] = blocks2[16];
            blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
          }
          if (notString) {
            if (ARRAY_BUFFER) {
              for (i = this.start; index < length && i < 64; ++index) {
                buffer82[i++] = message[index];
              }
            } else {
              for (i = this.start; index < length && i < 64; ++index) {
                blocks2[i >> 2] |= message[index] << SHIFT[i++ & 3];
              }
            }
          } else {
            if (ARRAY_BUFFER) {
              for (i = this.start; index < length && i < 64; ++index) {
                code = message.charCodeAt(index);
                if (code < 128) {
                  buffer82[i++] = code;
                } else if (code < 2048) {
                  buffer82[i++] = 192 | code >> 6;
                  buffer82[i++] = 128 | code & 63;
                } else if (code < 55296 || code >= 57344) {
                  buffer82[i++] = 224 | code >> 12;
                  buffer82[i++] = 128 | code >> 6 & 63;
                  buffer82[i++] = 128 | code & 63;
                } else {
                  code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                  buffer82[i++] = 240 | code >> 18;
                  buffer82[i++] = 128 | code >> 12 & 63;
                  buffer82[i++] = 128 | code >> 6 & 63;
                  buffer82[i++] = 128 | code & 63;
                }
              }
            } else {
              for (i = this.start; index < length && i < 64; ++index) {
                code = message.charCodeAt(index);
                if (code < 128) {
                  blocks2[i >> 2] |= code << SHIFT[i++ & 3];
                } else if (code < 2048) {
                  blocks2[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                } else if (code < 55296 || code >= 57344) {
                  blocks2[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                } else {
                  code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                  blocks2[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                }
              }
            }
          }
          this.lastByteIndex = i;
          this.bytes += i - this.start;
          if (i >= 64) {
            this.start = i - 64;
            this.hash();
            this.hashed = true;
          } else {
            this.start = i;
          }
        }
        return this;
      };
      Md4.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks2 = this.blocks, i = this.lastByteIndex;
        blocks2[i >> 2] |= EXTRA[i & 3];
        if (i >= 56) {
          if (!this.hashed) {
            this.hash();
          }
          blocks2[0] = blocks2[16];
          blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
        }
        blocks2[14] = this.bytes << 3;
        this.hash();
      };
      Md4.prototype.hash = function() {
        var a, b, c, d, ab, bc, cd, da, blocks2 = this.blocks;
        if (this.first) {
          a = blocks2[0] - 1;
          a = a << 3 | a >>> 29;
          d = (a & 4023233417 | ~a & 2562383102) + blocks2[1] + 271733878;
          d = d << 7 | d >>> 25;
          c = (d & a | ~d & 4023233417) + blocks2[2] - 1732584194;
          c = c << 11 | c >>> 21;
          b = (c & d | ~c & a) + blocks2[3] - 271733879;
          b = b << 19 | b >>> 13;
        } else {
          a = this.h0;
          b = this.h1;
          c = this.h2;
          d = this.h3;
          a += (b & c | ~b & d) + blocks2[0];
          a = a << 3 | a >>> 29;
          d += (a & b | ~a & c) + blocks2[1];
          d = d << 7 | d >>> 25;
          c += (d & a | ~d & b) + blocks2[2];
          c = c << 11 | c >>> 21;
          b += (c & d | ~c & a) + blocks2[3];
          b = b << 19 | b >>> 13;
        }
        a += (b & c | ~b & d) + blocks2[4];
        a = a << 3 | a >>> 29;
        d += (a & b | ~a & c) + blocks2[5];
        d = d << 7 | d >>> 25;
        c += (d & a | ~d & b) + blocks2[6];
        c = c << 11 | c >>> 21;
        b += (c & d | ~c & a) + blocks2[7];
        b = b << 19 | b >>> 13;
        a += (b & c | ~b & d) + blocks2[8];
        a = a << 3 | a >>> 29;
        d += (a & b | ~a & c) + blocks2[9];
        d = d << 7 | d >>> 25;
        c += (d & a | ~d & b) + blocks2[10];
        c = c << 11 | c >>> 21;
        b += (c & d | ~c & a) + blocks2[11];
        b = b << 19 | b >>> 13;
        a += (b & c | ~b & d) + blocks2[12];
        a = a << 3 | a >>> 29;
        d += (a & b | ~a & c) + blocks2[13];
        d = d << 7 | d >>> 25;
        c += (d & a | ~d & b) + blocks2[14];
        c = c << 11 | c >>> 21;
        b += (c & d | ~c & a) + blocks2[15];
        b = b << 19 | b >>> 13;
        bc = b & c;
        a += (bc | b & d | c & d) + blocks2[0] + 1518500249;
        a = a << 3 | a >>> 29;
        ab = a & b;
        d += (ab | a & c | bc) + blocks2[4] + 1518500249;
        d = d << 5 | d >>> 27;
        da = d & a;
        c += (da | d & b | ab) + blocks2[8] + 1518500249;
        c = c << 9 | c >>> 23;
        cd = c & d;
        b += (cd | c & a | da) + blocks2[12] + 1518500249;
        b = b << 13 | b >>> 19;
        bc = b & c;
        a += (bc | b & d | cd) + blocks2[1] + 1518500249;
        a = a << 3 | a >>> 29;
        ab = a & b;
        d += (ab | a & c | bc) + blocks2[5] + 1518500249;
        d = d << 5 | d >>> 27;
        da = d & a;
        c += (da | d & b | ab) + blocks2[9] + 1518500249;
        c = c << 9 | c >>> 23;
        cd = c & d;
        b += (cd | c & a | da) + blocks2[13] + 1518500249;
        b = b << 13 | b >>> 19;
        bc = b & c;
        a += (bc | b & d | cd) + blocks2[2] + 1518500249;
        a = a << 3 | a >>> 29;
        ab = a & b;
        d += (ab | a & c | bc) + blocks2[6] + 1518500249;
        d = d << 5 | d >>> 27;
        da = d & a;
        c += (da | d & b | ab) + blocks2[10] + 1518500249;
        c = c << 9 | c >>> 23;
        cd = c & d;
        b += (cd | c & a | da) + blocks2[14] + 1518500249;
        b = b << 13 | b >>> 19;
        bc = b & c;
        a += (bc | b & d | cd) + blocks2[3] + 1518500249;
        a = a << 3 | a >>> 29;
        ab = a & b;
        d += (ab | a & c | bc) + blocks2[7] + 1518500249;
        d = d << 5 | d >>> 27;
        da = d & a;
        c += (da | d & b | ab) + blocks2[11] + 1518500249;
        c = c << 9 | c >>> 23;
        b += (c & d | c & a | da) + blocks2[15] + 1518500249;
        b = b << 13 | b >>> 19;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[0] + 1859775393;
        a = a << 3 | a >>> 29;
        d += (bc ^ a) + blocks2[8] + 1859775393;
        d = d << 9 | d >>> 23;
        da = d ^ a;
        c += (da ^ b) + blocks2[4] + 1859775393;
        c = c << 11 | c >>> 21;
        b += (da ^ c) + blocks2[12] + 1859775393;
        b = b << 15 | b >>> 17;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[2] + 1859775393;
        a = a << 3 | a >>> 29;
        d += (bc ^ a) + blocks2[10] + 1859775393;
        d = d << 9 | d >>> 23;
        da = d ^ a;
        c += (da ^ b) + blocks2[6] + 1859775393;
        c = c << 11 | c >>> 21;
        b += (da ^ c) + blocks2[14] + 1859775393;
        b = b << 15 | b >>> 17;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[1] + 1859775393;
        a = a << 3 | a >>> 29;
        d += (bc ^ a) + blocks2[9] + 1859775393;
        d = d << 9 | d >>> 23;
        da = d ^ a;
        c += (da ^ b) + blocks2[5] + 1859775393;
        c = c << 11 | c >>> 21;
        b += (da ^ c) + blocks2[13] + 1859775393;
        b = b << 15 | b >>> 17;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[3] + 1859775393;
        a = a << 3 | a >>> 29;
        d += (bc ^ a) + blocks2[11] + 1859775393;
        d = d << 9 | d >>> 23;
        da = d ^ a;
        c += (da ^ b) + blocks2[7] + 1859775393;
        c = c << 11 | c >>> 21;
        b += (da ^ c) + blocks2[15] + 1859775393;
        b = b << 15 | b >>> 17;
        if (this.first) {
          this.h0 = a + 1732584193 << 0;
          this.h1 = b - 271733879 << 0;
          this.h2 = c - 1732584194 << 0;
          this.h3 = d + 271733878 << 0;
          this.first = false;
        } else {
          this.h0 = this.h0 + a << 0;
          this.h1 = this.h1 + b << 0;
          this.h2 = this.h2 + c << 0;
          this.h3 = this.h3 + d << 0;
        }
      };
      Md4.prototype.hex = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;
        return HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15];
      };
      Md4.prototype.toString = Md4.prototype.hex;
      Md4.prototype.digest = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;
        return [
          h0 & 255,
          h0 >> 8 & 255,
          h0 >> 16 & 255,
          h0 >> 24 & 255,
          h1 & 255,
          h1 >> 8 & 255,
          h1 >> 16 & 255,
          h1 >> 24 & 255,
          h2 & 255,
          h2 >> 8 & 255,
          h2 >> 16 & 255,
          h2 >> 24 & 255,
          h3 & 255,
          h3 >> 8 & 255,
          h3 >> 16 & 255,
          h3 >> 24 & 255
        ];
      };
      Md4.prototype.array = Md4.prototype.digest;
      Md4.prototype.arrayBuffer = function() {
        this.finalize();
        var buffer2 = new ArrayBuffer(16);
        var blocks2 = new Uint32Array(buffer2);
        blocks2[0] = this.h0;
        blocks2[1] = this.h1;
        blocks2[2] = this.h2;
        blocks2[3] = this.h3;
        return buffer2;
      };
      Md4.prototype.buffer = Md4.prototype.arrayBuffer;
      var exports2 = createMethod();
      if (COMMON_JS) {
        module.exports = exports2;
      } else {
        root.md4 = exports2;
        if (AMD) {
          define(function() {
            return exports2;
          });
        }
      }
    })();
  }
});

// node_modules/tedious/lib/ntlm-payload.js
var require_ntlm_payload = __commonJS({
  "node_modules/tedious/lib/ntlm-payload.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    var crypto = _interopRequireWildcard(require_crypto());
    var _jsMd = _interopRequireDefault(require_md4());
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
      return n.default = e, t && t.set(e, n), n;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NTLMResponsePayload = class {
      constructor(loginData) {
        this.data = this.createResponse(loginData);
      }
      toString(indent = "") {
        return indent + "NTLM Auth";
      }
      createResponse(challenge) {
        const client_nonce = this.createClientNonce();
        const lmv2len = 24;
        const ntlmv2len = 16;
        const domain = challenge.domain;
        const username = challenge.userName;
        const password = challenge.password;
        const ntlmData = challenge.ntlmpacket;
        const server_data = ntlmData.target;
        const server_nonce = ntlmData.nonce;
        const bufferLength = 64 + domain.length * 2 + username.length * 2 + lmv2len + ntlmv2len + 8 + 8 + 8 + 4 + server_data.length + 4;
        const data = new _writableTrackingBuffer.default(bufferLength);
        data.position = 0;
        data.writeString("NTLMSSP\0", "utf8");
        data.writeUInt32LE(3);
        const baseIdx = 64;
        const dnIdx = baseIdx;
        const unIdx = dnIdx + domain.length * 2;
        const l2Idx = unIdx + username.length * 2;
        const ntIdx = l2Idx + lmv2len;
        data.writeUInt16LE(lmv2len);
        data.writeUInt16LE(lmv2len);
        data.writeUInt32LE(l2Idx);
        data.writeUInt16LE(ntlmv2len);
        data.writeUInt16LE(ntlmv2len);
        data.writeUInt32LE(ntIdx);
        data.writeUInt16LE(domain.length * 2);
        data.writeUInt16LE(domain.length * 2);
        data.writeUInt32LE(dnIdx);
        data.writeUInt16LE(username.length * 2);
        data.writeUInt16LE(username.length * 2);
        data.writeUInt32LE(unIdx);
        data.writeUInt16LE(0);
        data.writeUInt16LE(0);
        data.writeUInt32LE(baseIdx);
        data.writeUInt16LE(0);
        data.writeUInt16LE(0);
        data.writeUInt32LE(baseIdx);
        data.writeUInt16LE(33281);
        data.writeUInt16LE(8);
        data.writeString(domain, "ucs2");
        data.writeString(username, "ucs2");
        const lmv2Data = this.lmv2Response(domain, username, password, server_nonce, client_nonce);
        data.copyFrom(lmv2Data);
        const genTime = (/* @__PURE__ */ new Date()).getTime();
        const ntlmDataBuffer = this.ntlmv2Response(domain, username, password, server_nonce, server_data, client_nonce, genTime);
        data.copyFrom(ntlmDataBuffer);
        data.writeUInt32LE(257);
        data.writeUInt32LE(0);
        const timestamp = this.createTimestamp(genTime);
        data.copyFrom(timestamp);
        data.copyFrom(client_nonce);
        data.writeUInt32LE(0);
        data.copyFrom(server_data);
        data.writeUInt32LE(0);
        return data.data;
      }
      createClientNonce() {
        const client_nonce = Buffer.alloc(8, 0);
        let nidx = 0;
        while (nidx < 8) {
          client_nonce.writeUInt8(Math.ceil(Math.random() * 255), nidx);
          nidx++;
        }
        return client_nonce;
      }
      ntlmv2Response(domain, user, password, serverNonce, targetInfo, clientNonce, mytime) {
        const timestamp = this.createTimestamp(mytime);
        const hash = this.ntv2Hash(domain, user, password);
        const dataLength = 40 + targetInfo.length;
        const data = Buffer.alloc(dataLength, 0);
        serverNonce.copy(data, 0, 0, 8);
        data.writeUInt32LE(257, 8);
        data.writeUInt32LE(0, 12);
        timestamp.copy(data, 16, 0, 8);
        clientNonce.copy(data, 24, 0, 8);
        data.writeUInt32LE(0, 32);
        targetInfo.copy(data, 36, 0, targetInfo.length);
        data.writeUInt32LE(0, 36 + targetInfo.length);
        return this.hmacMD5(data, hash);
      }
      createTimestamp(time) {
        const tenthsOfAMicrosecond = (BigInt(time) + BigInt(11644473600)) * BigInt(1e7);
        const lo = Number(tenthsOfAMicrosecond & BigInt(4294967295));
        const hi = Number(tenthsOfAMicrosecond >> BigInt(32) & BigInt(4294967295));
        const result = Buffer.alloc(8);
        result.writeUInt32LE(lo, 0);
        result.writeUInt32LE(hi, 4);
        return result;
      }
      lmv2Response(domain, user, password, serverNonce, clientNonce) {
        const hash = this.ntv2Hash(domain, user, password);
        const data = Buffer.alloc(serverNonce.length + clientNonce.length, 0);
        serverNonce.copy(data);
        clientNonce.copy(data, serverNonce.length, 0, clientNonce.length);
        const newhash = this.hmacMD5(data, hash);
        const response = Buffer.alloc(newhash.length + clientNonce.length, 0);
        newhash.copy(response);
        clientNonce.copy(response, newhash.length, 0, clientNonce.length);
        return response;
      }
      ntv2Hash(domain, user, password) {
        const hash = this.ntHash(password);
        const identity = Buffer.from(user.toUpperCase() + domain.toUpperCase(), "ucs2");
        return this.hmacMD5(identity, hash);
      }
      ntHash(text) {
        const unicodeString = Buffer.from(text, "ucs2");
        return Buffer.from(_jsMd.default.arrayBuffer(unicodeString));
      }
      hmacMD5(data, key) {
        return crypto.createHmac("MD5", key).update(data).digest();
      }
    };
    var _default = exports.default = NTLMResponsePayload;
    module.exports = NTLMResponsePayload;
  }
});

// node_modules/tedious/lib/errors.js
var require_errors = __commonJS({
  "node_modules/tedious/lib/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.RequestError = exports.InputError = exports.ConnectionError = void 0;
    var ConnectionError = class extends Error {
      constructor(message, code, options) {
        super(message, options);
        this.code = code;
      }
    };
    exports.ConnectionError = ConnectionError;
    var RequestError = class extends Error {
      constructor(message, code, options) {
        super(message, options);
        this.code = code;
      }
    };
    exports.RequestError = RequestError;
    var InputError = class extends TypeError {
    };
    exports.InputError = InputError;
  }
});

// node_modules/tedious/lib/always-encrypted/types.js
var require_types = __commonJS({
  "node_modules/tedious/lib/always-encrypted/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SQLServerStatementColumnEncryptionSetting = exports.SQLServerEncryptionType = exports.DescribeParameterEncryptionResultSet2 = exports.DescribeParameterEncryptionResultSet1 = void 0;
    var SQLServerEncryptionType = exports.SQLServerEncryptionType = function(SQLServerEncryptionType2) {
      SQLServerEncryptionType2[SQLServerEncryptionType2["Deterministic"] = 1] = "Deterministic";
      SQLServerEncryptionType2[SQLServerEncryptionType2["Randomized"] = 2] = "Randomized";
      SQLServerEncryptionType2[SQLServerEncryptionType2["PlainText"] = 0] = "PlainText";
      return SQLServerEncryptionType2;
    }({});
    var DescribeParameterEncryptionResultSet1 = exports.DescribeParameterEncryptionResultSet1 = function(DescribeParameterEncryptionResultSet12) {
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyOrdinal"] = 0] = "KeyOrdinal";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["DbId"] = 1] = "DbId";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyId"] = 2] = "KeyId";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyVersion"] = 3] = "KeyVersion";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyMdVersion"] = 4] = "KeyMdVersion";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["EncryptedKey"] = 5] = "EncryptedKey";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["ProviderName"] = 6] = "ProviderName";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyPath"] = 7] = "KeyPath";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyEncryptionAlgorithm"] = 8] = "KeyEncryptionAlgorithm";
      return DescribeParameterEncryptionResultSet12;
    }({});
    var DescribeParameterEncryptionResultSet2 = exports.DescribeParameterEncryptionResultSet2 = function(DescribeParameterEncryptionResultSet22) {
      DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["ParameterOrdinal"] = 0] = "ParameterOrdinal";
      DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["ParameterName"] = 1] = "ParameterName";
      DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["ColumnEncryptionAlgorithm"] = 2] = "ColumnEncryptionAlgorithm";
      DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["ColumnEncrytionType"] = 3] = "ColumnEncrytionType";
      DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["ColumnEncryptionKeyOrdinal"] = 4] = "ColumnEncryptionKeyOrdinal";
      DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["NormalizationRuleVersion"] = 5] = "NormalizationRuleVersion";
      return DescribeParameterEncryptionResultSet22;
    }({});
    var SQLServerStatementColumnEncryptionSetting = exports.SQLServerStatementColumnEncryptionSetting = function(SQLServerStatementColumnEncryptionSetting2) {
      SQLServerStatementColumnEncryptionSetting2[SQLServerStatementColumnEncryptionSetting2["UseConnectionSetting"] = 0] = "UseConnectionSetting";
      SQLServerStatementColumnEncryptionSetting2[SQLServerStatementColumnEncryptionSetting2["Enabled"] = 1] = "Enabled";
      SQLServerStatementColumnEncryptionSetting2[SQLServerStatementColumnEncryptionSetting2["ResultSetOnly"] = 2] = "ResultSetOnly";
      SQLServerStatementColumnEncryptionSetting2[SQLServerStatementColumnEncryptionSetting2["Disabled"] = 3] = "Disabled";
      return SQLServerStatementColumnEncryptionSetting2;
    }({});
  }
});

// node_modules/tedious/lib/request.js
var require_request2 = __commonJS({
  "node_modules/tedious/lib/request.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _events = require_events();
    var _errors = require_errors();
    var _types = require_types();
    var Request2 = class extends _events.EventEmitter {
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * This event, describing result set columns, will be emitted before row
       * events are emitted. This event may be emitted multiple times when more
       * than one recordset is produced by the statement.
       *
       * An array like object, where the columns can be accessed either by index
       * or name. Columns with a name that is an integer are not accessible by name,
       * as it would be interpreted as an array index.
       */
      /**
       * The request has been prepared and can be used in subsequent calls to execute and unprepare.
       */
      /**
       * The request encountered an error and has not been prepared.
       */
      /**
       * A row resulting from execution of the SQL statement.
       */
      /**
       * All rows from a result set have been provided (through `row` events).
       *
       * This token is used to indicate the completion of a SQL statement.
       * As multiple SQL statements can be sent to the server in a single SQL batch, multiple `done` can be generated.
       * An `done` event is emitted for each SQL statement in the SQL batch except variable declarations.
       * For execution of SQL statements within stored procedures, `doneProc` and `doneInProc` events are used in place of `done`.
       *
       * If you are using [[Connection.execSql]] then SQL server may treat the multiple calls with the same query as a stored procedure.
       * When this occurs, the `doneProc` and `doneInProc` events may be emitted instead. You must handle both events to ensure complete coverage.
       */
      /**
       * `request.on('doneInProc', function (rowCount, more, rows) { });`
       *
       * Indicates the completion status of a SQL statement within a stored procedure. All rows from a statement
       * in a stored procedure have been provided (through `row` events).
       *
       * This event may also occur when executing multiple calls with the same query using [[execSql]].
       */
      /**
       * Indicates the completion status of a stored procedure. This is also generated for stored procedures
       * executed through SQL statements.\
       * This event may also occur when executing multiple calls with the same query using [[execSql]].
       */
      /**
       * A value for an output parameter (that was added to the request with [[addOutputParameter]]).
       * See also `Using Parameters`.
       */
      /**
       * This event gives the columns by which data is ordered, if `ORDER BY` clause is executed in SQL Server.
       */
      on(event, listener) {
        return super.on(event, listener);
      }
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      emit(event, ...args) {
        return super.emit(event, ...args);
      }
      /**
       * @param sqlTextOrProcedure
       *   The SQL statement to be executed
       *
       * @param callback
       *   The callback to execute once the request has been fully completed.
       */
      constructor(sqlTextOrProcedure, callback, options) {
        super();
        this.sqlTextOrProcedure = sqlTextOrProcedure;
        this.parameters = [];
        this.parametersByName = {};
        this.preparing = false;
        this.handle = void 0;
        this.canceled = false;
        this.paused = false;
        this.error = void 0;
        this.connection = void 0;
        this.timeout = void 0;
        this.userCallback = callback;
        this.statementColumnEncryptionSetting = options && options.statementColumnEncryptionSetting || _types.SQLServerStatementColumnEncryptionSetting.UseConnectionSetting;
        this.cryptoMetadataLoaded = false;
        this.callback = function(err, rowCount, rows) {
          if (this.preparing) {
            this.preparing = false;
            if (err) {
              this.emit("error", err);
            } else {
              this.emit("prepared");
            }
          } else {
            this.userCallback(err, rowCount, rows);
            this.emit("requestCompleted");
          }
        };
      }
      /**
       * @param name
       *   The parameter name. This should correspond to a parameter in the SQL,
       *   or a parameter that a called procedure expects. The name should not start with `@`.
       *
       * @param type
       *   One of the supported data types.
       *
       * @param value
       *   The value that the parameter is to be given. The Javascript type of the
       *   argument should match that documented for data types.
       *
       * @param options
       *   Additional type options. Optional.
       */
      // TODO: `type` must be a valid TDS value type
      addParameter(name3, type, value, options) {
        const {
          output = false,
          length,
          precision,
          scale
        } = options ?? {};
        const parameter = {
          type,
          name: name3,
          value,
          output,
          length,
          precision,
          scale
        };
        this.parameters.push(parameter);
        this.parametersByName[name3] = parameter;
      }
      /**
       * @param name
       *   The parameter name. This should correspond to a parameter in the SQL,
       *   or a parameter that a called procedure expects.
       *
       * @param type
       *   One of the supported data types.
       *
       * @param value
       *   The value that the parameter is to be given. The Javascript type of the
       *   argument should match that documented for data types
       *
       * @param options
       *   Additional type options. Optional.
       */
      addOutputParameter(name3, type, value, options) {
        this.addParameter(name3, type, value, {
          ...options,
          output: true
        });
      }
      /**
       * @private
       */
      makeParamsParameter(parameters) {
        let paramsParameter = "";
        for (let i = 0, len = parameters.length; i < len; i++) {
          const parameter = parameters[i];
          if (paramsParameter.length > 0) {
            paramsParameter += ", ";
          }
          paramsParameter += "@" + parameter.name + " ";
          paramsParameter += parameter.type.declaration(parameter);
          if (parameter.output) {
            paramsParameter += " OUTPUT";
          }
        }
        return paramsParameter;
      }
      /**
       * @private
       */
      validateParameters(collation) {
        for (let i = 0, len = this.parameters.length; i < len; i++) {
          const parameter = this.parameters[i];
          try {
            parameter.value = parameter.type.validate(parameter.value, collation);
          } catch (error) {
            throw new _errors.RequestError("Validation failed for parameter '" + parameter.name + "'. " + error.message, "EPARAM", {
              cause: error
            });
          }
        }
      }
      /**
       * Temporarily suspends the flow of data from the database. No more `row` events will be emitted until [[resume] is called.
       * If this request is already in a paused state, calling [[pause]] has no effect.
       */
      pause() {
        if (this.paused) {
          return;
        }
        this.emit("pause");
        this.paused = true;
      }
      /**
       * Resumes the flow of data from the database.
       * If this request is not in a paused state, calling [[resume]] has no effect.
       */
      resume() {
        if (!this.paused) {
          return;
        }
        this.paused = false;
        this.emit("resume");
      }
      /**
       * Cancels a request while waiting for a server response.
       */
      cancel() {
        if (this.canceled) {
          return;
        }
        this.canceled = true;
        this.emit("cancel");
      }
      /**
       * Sets a timeout for this request.
       *
       * @param timeout
       *   The number of milliseconds before the request is considered failed,
       *   or `0` for no timeout. When no timeout is set for the request,
       *   the [[ConnectionOptions.requestTimeout]] of the [[Connection]] is used.
       */
      setTimeout(timeout) {
        this.timeout = timeout;
      }
    };
    var _default = exports.default = Request2;
    module.exports = Request2;
  }
});

// node_modules/tedious/lib/all-headers.js
var require_all_headers = __commonJS({
  "node_modules/tedious/lib/all-headers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.writeToTrackingBuffer = writeToTrackingBuffer;
    var TYPE = {
      QUERY_NOTIFICATIONS: 1,
      TXN_DESCRIPTOR: 2,
      TRACE_ACTIVITY: 3
    };
    var TXNDESCRIPTOR_HEADER_DATA_LEN = 4 + 8;
    var TXNDESCRIPTOR_HEADER_LEN = 4 + 2 + TXNDESCRIPTOR_HEADER_DATA_LEN;
    function writeToTrackingBuffer(buffer, txnDescriptor, outstandingRequestCount) {
      buffer.writeUInt32LE(0);
      buffer.writeUInt32LE(TXNDESCRIPTOR_HEADER_LEN);
      buffer.writeUInt16LE(TYPE.TXN_DESCRIPTOR);
      buffer.writeBuffer(txnDescriptor);
      buffer.writeUInt32LE(outstandingRequestCount);
      const data = buffer.data;
      data.writeUInt32LE(data.length, 0);
      return buffer;
    }
  }
});

// node_modules/tedious/lib/rpcrequest-payload.js
var require_rpcrequest_payload = __commonJS({
  "node_modules/tedious/lib/rpcrequest-payload.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    var _allHeaders = require_all_headers();
    var _errors = require_errors();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var STATUS = {
      BY_REF_VALUE: 1,
      DEFAULT_VALUE: 2
    };
    var RpcRequestPayload = class {
      constructor(procedure, parameters, txnDescriptor, options, collation) {
        this.procedure = procedure;
        this.parameters = parameters;
        this.options = options;
        this.txnDescriptor = txnDescriptor;
        this.collation = collation;
      }
      [Symbol.iterator]() {
        return this.generateData();
      }
      *generateData() {
        const buffer = new _writableTrackingBuffer.default(500);
        if (this.options.tdsVersion >= "7_2") {
          const outstandingRequestCount = 1;
          (0, _allHeaders.writeToTrackingBuffer)(buffer, this.txnDescriptor, outstandingRequestCount);
        }
        if (typeof this.procedure === "string") {
          buffer.writeUsVarchar(this.procedure);
        } else {
          buffer.writeUShort(65535);
          buffer.writeUShort(this.procedure);
        }
        const optionFlags = 0;
        buffer.writeUInt16LE(optionFlags);
        yield buffer.data;
        const parametersLength = this.parameters.length;
        for (let i = 0; i < parametersLength; i++) {
          yield* this.generateParameterData(this.parameters[i]);
        }
      }
      toString(indent = "") {
        return indent + ("RPC Request - " + this.procedure);
      }
      *generateParameterData(parameter) {
        const buffer = new _writableTrackingBuffer.default(1 + 2 + Buffer.byteLength(parameter.name, "ucs-2") + 1);
        if (parameter.name) {
          buffer.writeBVarchar("@" + parameter.name);
        } else {
          buffer.writeBVarchar("");
        }
        let statusFlags = 0;
        if (parameter.output) {
          statusFlags |= STATUS.BY_REF_VALUE;
        }
        buffer.writeUInt8(statusFlags);
        yield buffer.data;
        const param = {
          value: parameter.value
        };
        const type = parameter.type;
        if ((type.id & 48) === 32) {
          if (parameter.length) {
            param.length = parameter.length;
          } else if (type.resolveLength) {
            param.length = type.resolveLength(parameter);
          }
        }
        if (parameter.precision) {
          param.precision = parameter.precision;
        } else if (type.resolvePrecision) {
          param.precision = type.resolvePrecision(parameter);
        }
        if (parameter.scale) {
          param.scale = parameter.scale;
        } else if (type.resolveScale) {
          param.scale = type.resolveScale(parameter);
        }
        if (this.collation) {
          param.collation = this.collation;
        }
        yield type.generateTypeInfo(param, this.options);
        yield type.generateParameterLength(param, this.options);
        try {
          yield* type.generateParameterData(param, this.options);
        } catch (error) {
          throw new _errors.InputError(`Input parameter '${parameter.name}' could not be validated`, {
            cause: error
          });
        }
      }
    };
    var _default = exports.default = RpcRequestPayload;
    module.exports = RpcRequestPayload;
  }
});

// node_modules/tedious/lib/sqlbatch-payload.js
var require_sqlbatch_payload = __commonJS({
  "node_modules/tedious/lib/sqlbatch-payload.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    var _allHeaders = require_all_headers();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var SqlBatchPayload = class {
      constructor(sqlText, txnDescriptor, options) {
        this.sqlText = sqlText;
        this.txnDescriptor = txnDescriptor;
        this.options = options;
      }
      *[Symbol.iterator]() {
        if (this.options.tdsVersion >= "7_2") {
          const buffer = new _writableTrackingBuffer.default(18, "ucs2");
          const outstandingRequestCount = 1;
          (0, _allHeaders.writeToTrackingBuffer)(buffer, this.txnDescriptor, outstandingRequestCount);
          yield buffer.data;
        }
        yield Buffer.from(this.sqlText, "ucs2");
      }
      toString(indent = "") {
        return indent + ("SQL Batch - " + this.sqlText);
      }
    };
    var _default = exports.default = SqlBatchPayload;
    module.exports = SqlBatchPayload;
  }
});

// node_modules/native-duplexpair/index.js
var require_native_duplexpair = __commonJS({
  "node_modules/native-duplexpair/index.js"(exports, module) {
    "use strict";
    var Duplex = require_stream().Duplex;
    var kCallback = Symbol("Callback");
    var kOtherSide = Symbol("Other");
    var DuplexSocket = class extends Duplex {
      constructor(options) {
        super(options);
        this[kCallback] = null;
        this[kOtherSide] = null;
      }
      _read() {
        const callback = this[kCallback];
        if (callback) {
          this[kCallback] = null;
          callback();
        }
      }
      _write(chunk, encoding, callback) {
        this[kOtherSide][kCallback] = callback;
        this[kOtherSide].push(chunk);
      }
      _final(callback) {
        this[kOtherSide].on("end", callback);
        this[kOtherSide].push(null);
      }
    };
    var DuplexPair = class {
      constructor(options) {
        this.socket1 = new DuplexSocket(options);
        this.socket2 = new DuplexSocket(options);
        this.socket1[kOtherSide] = this.socket2;
        this.socket2[kOtherSide] = this.socket1;
      }
    };
    module.exports = DuplexPair;
  }
});

// node_modules/tedious/lib/message.js
var require_message = __commonJS({
  "node_modules/tedious/lib/message.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _stream = require_stream();
    var Message = class extends _stream.PassThrough {
      constructor({
        type,
        resetConnection = false
      }) {
        super();
        this.type = type;
        this.resetConnection = resetConnection;
        this.ignore = false;
      }
    };
    var _default = exports.default = Message;
    module.exports = Message;
  }
});

// node_modules/readable-stream/lib/ours/primordials.js
var require_primordials = __commonJS({
  "node_modules/readable-stream/lib/ours/primordials.js"(exports, module) {
    "use strict";
    var AggregateError2 = class extends Error {
      constructor(errors) {
        if (!Array.isArray(errors)) {
          throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
        }
        let message = "";
        for (let i = 0; i < errors.length; i++) {
          message += `    ${errors[i].stack}
`;
        }
        super(message);
        this.name = "AggregateError";
        this.errors = errors;
      }
    };
    module.exports = {
      AggregateError: AggregateError2,
      ArrayIsArray(self2) {
        return Array.isArray(self2);
      },
      ArrayPrototypeIncludes(self2, el) {
        return self2.includes(el);
      },
      ArrayPrototypeIndexOf(self2, el) {
        return self2.indexOf(el);
      },
      ArrayPrototypeJoin(self2, sep) {
        return self2.join(sep);
      },
      ArrayPrototypeMap(self2, fn) {
        return self2.map(fn);
      },
      ArrayPrototypePop(self2, el) {
        return self2.pop(el);
      },
      ArrayPrototypePush(self2, el) {
        return self2.push(el);
      },
      ArrayPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      Error,
      FunctionPrototypeCall(fn, thisArgs, ...args) {
        return fn.call(thisArgs, ...args);
      },
      FunctionPrototypeSymbolHasInstance(self2, instance) {
        return Function.prototype[Symbol.hasInstance].call(self2, instance);
      },
      MathFloor: Math.floor,
      Number,
      NumberIsInteger: Number.isInteger,
      NumberIsNaN: Number.isNaN,
      NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
      NumberParseInt: Number.parseInt,
      ObjectDefineProperties(self2, props) {
        return Object.defineProperties(self2, props);
      },
      ObjectDefineProperty(self2, name3, prop) {
        return Object.defineProperty(self2, name3, prop);
      },
      ObjectGetOwnPropertyDescriptor(self2, name3) {
        return Object.getOwnPropertyDescriptor(self2, name3);
      },
      ObjectKeys(obj) {
        return Object.keys(obj);
      },
      ObjectSetPrototypeOf(target, proto) {
        return Object.setPrototypeOf(target, proto);
      },
      Promise,
      PromisePrototypeCatch(self2, fn) {
        return self2.catch(fn);
      },
      PromisePrototypeThen(self2, thenFn, catchFn) {
        return self2.then(thenFn, catchFn);
      },
      PromiseReject(err) {
        return Promise.reject(err);
      },
      PromiseResolve(val) {
        return Promise.resolve(val);
      },
      ReflectApply: Reflect.apply,
      RegExpPrototypeTest(self2, value) {
        return self2.test(value);
      },
      SafeSet: Set,
      String,
      StringPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      StringPrototypeToLowerCase(self2) {
        return self2.toLowerCase();
      },
      StringPrototypeToUpperCase(self2) {
        return self2.toUpperCase();
      },
      StringPrototypeTrim(self2) {
        return self2.trim();
      },
      Symbol,
      SymbolFor: Symbol.for,
      SymbolAsyncIterator: Symbol.asyncIterator,
      SymbolHasInstance: Symbol.hasInstance,
      SymbolIterator: Symbol.iterator,
      SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
      SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
      TypedArrayPrototypeSet(self2, buf, len) {
        return self2.set(buf, len);
      },
      Boolean,
      Uint8Array
    };
  }
});

// node_modules/readable-stream/lib/ours/util/inspect.js
var require_inspect = __commonJS({
  "node_modules/readable-stream/lib/ours/util/inspect.js"(exports, module) {
    "use strict";
    module.exports = {
      format(format, ...args) {
        return format.replace(/%([sdifj])/g, function(...[_unused, type]) {
          const replacement = args.shift();
          if (type === "f") {
            return replacement.toFixed(6);
          } else if (type === "j") {
            return JSON.stringify(replacement);
          } else if (type === "s" && typeof replacement === "object") {
            const ctor = replacement.constructor !== Object ? replacement.constructor.name : "";
            return `${ctor} {}`.trim();
          } else {
            return replacement.toString();
          }
        });
      },
      inspect(value) {
        switch (typeof value) {
          case "string":
            if (value.includes("'")) {
              if (!value.includes('"')) {
                return `"${value}"`;
              } else if (!value.includes("`") && !value.includes("${")) {
                return `\`${value}\``;
              }
            }
            return `'${value}'`;
          case "number":
            if (isNaN(value)) {
              return "NaN";
            } else if (Object.is(value, -0)) {
              return String(value);
            }
            return value;
          case "bigint":
            return `${String(value)}n`;
          case "boolean":
          case "undefined":
            return String(value);
          case "object":
            return "{}";
        }
      }
    };
  }
});

// node_modules/readable-stream/lib/ours/errors.js
var require_errors2 = __commonJS({
  "node_modules/readable-stream/lib/ours/errors.js"(exports, module) {
    "use strict";
    var { format, inspect } = require_inspect();
    var { AggregateError: CustomAggregateError } = require_primordials();
    var AggregateError2 = globalThis.AggregateError || CustomAggregateError;
    var kIsNodeError = Symbol("kIsNodeError");
    var kTypes = [
      "string",
      "function",
      "number",
      "object",
      // Accept 'Function' and 'Object' as alternative to the lower cased version.
      "Function",
      "Object",
      "boolean",
      "bigint",
      "symbol"
    ];
    var classRegExp = /^([A-Z][a-z0-9]*)+$/;
    var nodeInternalPrefix = "__node_internal_";
    var codes = {};
    function assert2(value, message) {
      if (!value) {
        throw new codes.ERR_INTERNAL_ASSERTION(message);
      }
    }
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function getMessage(key, msg, args) {
      if (typeof msg === "function") {
        assert2(
          msg.length <= args.length,
          // Default options do not count.
          `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`
        );
        return msg(...args);
      }
      const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
      assert2(
        expectedLength === args.length,
        `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`
      );
      if (args.length === 0) {
        return msg;
      }
      return format(msg, ...args);
    }
    function E(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      class NodeError extends Base {
        constructor(...args) {
          super(getMessage(code, message, args));
        }
        toString() {
          return `${this.name} [${code}]: ${this.message}`;
        }
      }
      Object.defineProperties(NodeError.prototype, {
        name: {
          value: Base.name,
          writable: true,
          enumerable: false,
          configurable: true
        },
        toString: {
          value() {
            return `${this.name} [${code}]: ${this.message}`;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      NodeError.prototype.code = code;
      NodeError.prototype[kIsNodeError] = true;
      codes[code] = NodeError;
    }
    function hideStackFrames(fn) {
      const hidden = nodeInternalPrefix + fn.name;
      Object.defineProperty(fn, "name", {
        value: hidden
      });
      return fn;
    }
    function aggregateTwoErrors(innerError, outerError) {
      if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors)) {
          outerError.errors.push(innerError);
          return outerError;
        }
        const err = new AggregateError2([outerError, innerError], outerError.message);
        err.code = outerError.code;
        return err;
      }
      return innerError || outerError;
    }
    var AbortError3 = class extends Error {
      constructor(message = "The operation was aborted", options = void 0) {
        if (options !== void 0 && typeof options !== "object") {
          throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
        super(message, options);
        this.code = "ABORT_ERR";
        this.name = "AbortError";
      }
    };
    E("ERR_ASSERTION", "%s", Error);
    E(
      "ERR_INVALID_ARG_TYPE",
      (name3, expected, actual) => {
        assert2(typeof name3 === "string", "'name' must be a string");
        if (!Array.isArray(expected)) {
          expected = [expected];
        }
        let msg = "The ";
        if (name3.endsWith(" argument")) {
          msg += `${name3} `;
        } else {
          msg += `"${name3}" ${name3.includes(".") ? "property" : "argument"} `;
        }
        msg += "must be ";
        const types = [];
        const instances = [];
        const other = [];
        for (const value of expected) {
          assert2(typeof value === "string", "All expected entries have to be of type string");
          if (kTypes.includes(value)) {
            types.push(value.toLowerCase());
          } else if (classRegExp.test(value)) {
            instances.push(value);
          } else {
            assert2(value !== "object", 'The value "object" should be written as "Object"');
            other.push(value);
          }
        }
        if (instances.length > 0) {
          const pos = types.indexOf("object");
          if (pos !== -1) {
            types.splice(types, pos, 1);
            instances.push("Object");
          }
        }
        if (types.length > 0) {
          switch (types.length) {
            case 1:
              msg += `of type ${types[0]}`;
              break;
            case 2:
              msg += `one of type ${types[0]} or ${types[1]}`;
              break;
            default: {
              const last = types.pop();
              msg += `one of type ${types.join(", ")}, or ${last}`;
            }
          }
          if (instances.length > 0 || other.length > 0) {
            msg += " or ";
          }
        }
        if (instances.length > 0) {
          switch (instances.length) {
            case 1:
              msg += `an instance of ${instances[0]}`;
              break;
            case 2:
              msg += `an instance of ${instances[0]} or ${instances[1]}`;
              break;
            default: {
              const last = instances.pop();
              msg += `an instance of ${instances.join(", ")}, or ${last}`;
            }
          }
          if (other.length > 0) {
            msg += " or ";
          }
        }
        switch (other.length) {
          case 0:
            break;
          case 1:
            if (other[0].toLowerCase() !== other[0]) {
              msg += "an ";
            }
            msg += `${other[0]}`;
            break;
          case 2:
            msg += `one of ${other[0]} or ${other[1]}`;
            break;
          default: {
            const last = other.pop();
            msg += `one of ${other.join(", ")}, or ${last}`;
          }
        }
        if (actual == null) {
          msg += `. Received ${actual}`;
        } else if (typeof actual === "function" && actual.name) {
          msg += `. Received function ${actual.name}`;
        } else if (typeof actual === "object") {
          var _actual$constructor;
          if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== void 0 && _actual$constructor.name) {
            msg += `. Received an instance of ${actual.constructor.name}`;
          } else {
            const inspected = inspect(actual, {
              depth: -1
            });
            msg += `. Received ${inspected}`;
          }
        } else {
          let inspected = inspect(actual, {
            colors: false
          });
          if (inspected.length > 25) {
            inspected = `${inspected.slice(0, 25)}...`;
          }
          msg += `. Received type ${typeof actual} (${inspected})`;
        }
        return msg;
      },
      TypeError
    );
    E(
      "ERR_INVALID_ARG_VALUE",
      (name3, value, reason = "is invalid") => {
        let inspected = inspect(value);
        if (inspected.length > 128) {
          inspected = inspected.slice(0, 128) + "...";
        }
        const type = name3.includes(".") ? "property" : "argument";
        return `The ${type} '${name3}' ${reason}. Received ${inspected}`;
      },
      TypeError
    );
    E(
      "ERR_INVALID_RETURN_VALUE",
      (input, name3, value) => {
        var _value$constructor;
        const type = value !== null && value !== void 0 && (_value$constructor = value.constructor) !== null && _value$constructor !== void 0 && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;
        return `Expected ${input} to be returned from the "${name3}" function but got ${type}.`;
      },
      TypeError
    );
    E(
      "ERR_MISSING_ARGS",
      (...args) => {
        assert2(args.length > 0, "At least one arg needs to be specified");
        let msg;
        const len = args.length;
        args = (Array.isArray(args) ? args : [args]).map((a) => `"${a}"`).join(" or ");
        switch (len) {
          case 1:
            msg += `The ${args[0]} argument`;
            break;
          case 2:
            msg += `The ${args[0]} and ${args[1]} arguments`;
            break;
          default:
            {
              const last = args.pop();
              msg += `The ${args.join(", ")}, and ${last} arguments`;
            }
            break;
        }
        return `${msg} must be specified`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      (str, range, input) => {
        assert2(range, 'Missing "range" argument');
        let received;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          const limit = BigInt(2) ** BigInt(32);
          if (input > limit || input < -limit) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        } else {
          received = inspect(input);
        }
        return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`;
      },
      RangeError
    );
    E("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    E("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    E("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    E("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    E("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    E("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    E("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    E("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    E("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    E("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    E("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    module.exports = {
      AbortError: AbortError3,
      aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
      hideStackFrames,
      codes
    };
  }
});

// node_modules/abort-controller/browser.js
var require_browser2 = __commonJS({
  "node_modules/abort-controller/browser.js"(exports, module) {
    "use strict";
    var { AbortController: AbortController2, AbortSignal: AbortSignal2 } = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : (
      /* otherwise */
      void 0
    );
    module.exports = AbortController2;
    module.exports.AbortSignal = AbortSignal2;
    module.exports.default = AbortController2;
  }
});

// node_modules/readable-stream/lib/ours/util.js
var require_util2 = __commonJS({
  "node_modules/readable-stream/lib/ours/util.js"(exports, module) {
    "use strict";
    var bufferModule = require_buffer();
    var { format, inspect } = require_inspect();
    var {
      codes: { ERR_INVALID_ARG_TYPE }
    } = require_errors2();
    var { kResistStopPropagation, AggregateError: AggregateError2, SymbolDispose } = require_primordials();
    var AbortSignal2 = globalThis.AbortSignal || require_browser2().AbortSignal;
    var AbortController2 = globalThis.AbortController || require_browser2().AbortController;
    var AsyncFunction = Object.getPrototypeOf(async function() {
    }).constructor;
    var Blob2 = globalThis.Blob || bufferModule.Blob;
    var isBlob3 = typeof Blob2 !== "undefined" ? function isBlob4(b) {
      return b instanceof Blob2;
    } : function isBlob4(b) {
      return false;
    };
    var validateAbortSignal = (signal, name3) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE(name3, "AbortSignal", signal);
      }
    };
    var validateFunction = (value, name3) => {
      if (typeof value !== "function") {
        throw new ERR_INVALID_ARG_TYPE(name3, "Function", value);
      }
    };
    module.exports = {
      AggregateError: AggregateError2,
      kEmptyObject: Object.freeze({}),
      once(callback) {
        let called = false;
        return function(...args) {
          if (called) {
            return;
          }
          called = true;
          callback.apply(this, args);
        };
      },
      createDeferredPromise: function() {
        let resolve;
        let reject;
        const promise = new Promise((res, rej) => {
          resolve = res;
          reject = rej;
        });
        return {
          promise,
          resolve,
          reject
        };
      },
      promisify(fn) {
        return new Promise((resolve, reject) => {
          fn((err, ...args) => {
            if (err) {
              return reject(err);
            }
            return resolve(...args);
          });
        });
      },
      debuglog() {
        return function() {
        };
      },
      format,
      inspect,
      types: {
        isAsyncFunction(fn) {
          return fn instanceof AsyncFunction;
        },
        isArrayBufferView(arr) {
          return ArrayBuffer.isView(arr);
        }
      },
      isBlob: isBlob3,
      deprecate(fn, message) {
        return fn;
      },
      addAbortListener: require_events().addAbortListener || function addAbortListener(signal, listener) {
        if (signal === void 0) {
          throw new ERR_INVALID_ARG_TYPE("signal", "AbortSignal", signal);
        }
        validateAbortSignal(signal, "signal");
        validateFunction(listener, "listener");
        let removeEventListener;
        if (signal.aborted) {
          queueMicrotask(() => listener());
        } else {
          signal.addEventListener("abort", listener, {
            __proto__: null,
            once: true,
            [kResistStopPropagation]: true
          });
          removeEventListener = () => {
            signal.removeEventListener("abort", listener);
          };
        }
        return {
          __proto__: null,
          [SymbolDispose]() {
            var _removeEventListener;
            (_removeEventListener = removeEventListener) === null || _removeEventListener === void 0 ? void 0 : _removeEventListener();
          }
        };
      },
      AbortSignalAny: AbortSignal2.any || function AbortSignalAny(signals) {
        if (signals.length === 1) {
          return signals[0];
        }
        const ac = new AbortController2();
        const abort = () => ac.abort();
        signals.forEach((signal) => {
          validateAbortSignal(signal, "signals");
          signal.addEventListener("abort", abort, {
            once: true
          });
        });
        ac.signal.addEventListener(
          "abort",
          () => {
            signals.forEach((signal) => signal.removeEventListener("abort", abort));
          },
          {
            once: true
          }
        );
        return ac.signal;
      }
    };
    module.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  }
});

// node_modules/readable-stream/lib/internal/validators.js
var require_validators = __commonJS({
  "node_modules/readable-stream/lib/internal/validators.js"(exports, module) {
    "use strict";
    var {
      ArrayIsArray,
      ArrayPrototypeIncludes,
      ArrayPrototypeJoin,
      ArrayPrototypeMap,
      NumberIsInteger,
      NumberIsNaN,
      NumberMAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER,
      NumberParseInt,
      ObjectPrototypeHasOwnProperty,
      RegExpPrototypeExec,
      String: String2,
      StringPrototypeToUpperCase,
      StringPrototypeTrim
    } = require_primordials();
    var {
      hideStackFrames,
      codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }
    } = require_errors2();
    var { normalizeEncoding } = require_util2();
    var { isAsyncFunction, isArrayBufferView } = require_util2().types;
    var signals = {};
    function isInt32(value) {
      return value === (value | 0);
    }
    function isUint32(value) {
      return value === value >>> 0;
    }
    var octalReg = /^[0-7]+$/;
    var modeDesc = "must be a 32-bit unsigned integer or an octal string";
    function parseFileMode(value, name3, def) {
      if (typeof value === "undefined") {
        value = def;
      }
      if (typeof value === "string") {
        if (RegExpPrototypeExec(octalReg, value) === null) {
          throw new ERR_INVALID_ARG_VALUE(name3, value, modeDesc);
        }
        value = NumberParseInt(value, 8);
      }
      validateUint32(value, name3);
      return value;
    }
    var validateInteger = hideStackFrames((value, name3, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
      if (typeof value !== "number") throw new ERR_INVALID_ARG_TYPE(name3, "number", value);
      if (!NumberIsInteger(value)) throw new ERR_OUT_OF_RANGE(name3, "an integer", value);
      if (value < min || value > max) throw new ERR_OUT_OF_RANGE(name3, `>= ${min} && <= ${max}`, value);
    });
    var validateInt32 = hideStackFrames((value, name3, min = -2147483648, max = 2147483647) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE(name3, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name3, "an integer", value);
      }
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name3, `>= ${min} && <= ${max}`, value);
      }
    });
    var validateUint32 = hideStackFrames((value, name3, positive = false) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE(name3, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name3, "an integer", value);
      }
      const min = positive ? 1 : 0;
      const max = 4294967295;
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name3, `>= ${min} && <= ${max}`, value);
      }
    });
    function validateString(value, name3) {
      if (typeof value !== "string") throw new ERR_INVALID_ARG_TYPE(name3, "string", value);
    }
    function validateNumber(value, name3, min = void 0, max) {
      if (typeof value !== "number") throw new ERR_INVALID_ARG_TYPE(name3, "number", value);
      if (min != null && value < min || max != null && value > max || (min != null || max != null) && NumberIsNaN(value)) {
        throw new ERR_OUT_OF_RANGE(
          name3,
          `${min != null ? `>= ${min}` : ""}${min != null && max != null ? " && " : ""}${max != null ? `<= ${max}` : ""}`,
          value
        );
      }
    }
    var validateOneOf = hideStackFrames((value, name3, oneOf) => {
      if (!ArrayPrototypeIncludes(oneOf, value)) {
        const allowed = ArrayPrototypeJoin(
          ArrayPrototypeMap(oneOf, (v) => typeof v === "string" ? `'${v}'` : String2(v)),
          ", "
        );
        const reason = "must be one of: " + allowed;
        throw new ERR_INVALID_ARG_VALUE(name3, value, reason);
      }
    });
    function validateBoolean(value, name3) {
      if (typeof value !== "boolean") throw new ERR_INVALID_ARG_TYPE(name3, "boolean", value);
    }
    function getOwnPropertyValueOrDefault(options, key, defaultValue) {
      return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];
    }
    var validateObject = hideStackFrames((value, name3, options = null) => {
      const allowArray = getOwnPropertyValueOrDefault(options, "allowArray", false);
      const allowFunction = getOwnPropertyValueOrDefault(options, "allowFunction", false);
      const nullable = getOwnPropertyValueOrDefault(options, "nullable", false);
      if (!nullable && value === null || !allowArray && ArrayIsArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new ERR_INVALID_ARG_TYPE(name3, "Object", value);
      }
    });
    var validateDictionary = hideStackFrames((value, name3) => {
      if (value != null && typeof value !== "object" && typeof value !== "function") {
        throw new ERR_INVALID_ARG_TYPE(name3, "a dictionary", value);
      }
    });
    var validateArray = hideStackFrames((value, name3, minLength = 0) => {
      if (!ArrayIsArray(value)) {
        throw new ERR_INVALID_ARG_TYPE(name3, "Array", value);
      }
      if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new ERR_INVALID_ARG_VALUE(name3, value, reason);
      }
    });
    function validateStringArray(value, name3) {
      validateArray(value, name3);
      for (let i = 0; i < value.length; i++) {
        validateString(value[i], `${name3}[${i}]`);
      }
    }
    function validateBooleanArray(value, name3) {
      validateArray(value, name3);
      for (let i = 0; i < value.length; i++) {
        validateBoolean(value[i], `${name3}[${i}]`);
      }
    }
    function validateAbortSignalArray(value, name3) {
      validateArray(value, name3);
      for (let i = 0; i < value.length; i++) {
        const signal = value[i];
        const indexedName = `${name3}[${i}]`;
        if (signal == null) {
          throw new ERR_INVALID_ARG_TYPE(indexedName, "AbortSignal", signal);
        }
        validateAbortSignal(signal, indexedName);
      }
    }
    function validateSignalName(signal, name3 = "signal") {
      validateString(signal, name3);
      if (signals[signal] === void 0) {
        if (signals[StringPrototypeToUpperCase(signal)] !== void 0) {
          throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
        }
        throw new ERR_UNKNOWN_SIGNAL(signal);
      }
    }
    var validateBuffer = hideStackFrames((buffer, name3 = "buffer") => {
      if (!isArrayBufferView(buffer)) {
        throw new ERR_INVALID_ARG_TYPE(name3, ["Buffer", "TypedArray", "DataView"], buffer);
      }
    });
    function validateEncoding(data, encoding) {
      const normalizedEncoding = normalizeEncoding(encoding);
      const length = data.length;
      if (normalizedEncoding === "hex" && length % 2 !== 0) {
        throw new ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
      }
    }
    function validatePort(port, name3 = "Port", allowZero = true) {
      if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero) {
        throw new ERR_SOCKET_BAD_PORT(name3, port, allowZero);
      }
      return port | 0;
    }
    var validateAbortSignal = hideStackFrames((signal, name3) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE(name3, "AbortSignal", signal);
      }
    });
    var validateFunction = hideStackFrames((value, name3) => {
      if (typeof value !== "function") throw new ERR_INVALID_ARG_TYPE(name3, "Function", value);
    });
    var validatePlainFunction = hideStackFrames((value, name3) => {
      if (typeof value !== "function" || isAsyncFunction(value)) throw new ERR_INVALID_ARG_TYPE(name3, "Function", value);
    });
    var validateUndefined = hideStackFrames((value, name3) => {
      if (value !== void 0) throw new ERR_INVALID_ARG_TYPE(name3, "undefined", value);
    });
    function validateUnion(value, name3, union) {
      if (!ArrayPrototypeIncludes(union, value)) {
        throw new ERR_INVALID_ARG_TYPE(name3, `('${ArrayPrototypeJoin(union, "|")}')`, value);
      }
    }
    var linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
    function validateLinkHeaderFormat(value, name3) {
      if (typeof value === "undefined" || !RegExpPrototypeExec(linkValueRegExp, value)) {
        throw new ERR_INVALID_ARG_VALUE(
          name3,
          value,
          'must be an array or string of format "</styles.css>; rel=preload; as=style"'
        );
      }
    }
    function validateLinkHeaderValue(hints) {
      if (typeof hints === "string") {
        validateLinkHeaderFormat(hints, "hints");
        return hints;
      } else if (ArrayIsArray(hints)) {
        const hintsLength = hints.length;
        let result = "";
        if (hintsLength === 0) {
          return result;
        }
        for (let i = 0; i < hintsLength; i++) {
          const link = hints[i];
          validateLinkHeaderFormat(link, "hints");
          result += link;
          if (i !== hintsLength - 1) {
            result += ", ";
          }
        }
        return result;
      }
      throw new ERR_INVALID_ARG_VALUE(
        "hints",
        hints,
        'must be an array or string of format "</styles.css>; rel=preload; as=style"'
      );
    }
    module.exports = {
      isInt32,
      isUint32,
      parseFileMode,
      validateArray,
      validateStringArray,
      validateBooleanArray,
      validateAbortSignalArray,
      validateBoolean,
      validateBuffer,
      validateDictionary,
      validateEncoding,
      validateFunction,
      validateInt32,
      validateInteger,
      validateNumber,
      validateObject,
      validateOneOf,
      validatePlainFunction,
      validatePort,
      validateSignalName,
      validateString,
      validateUint32,
      validateUndefined,
      validateUnion,
      validateAbortSignal,
      validateLinkHeaderValue
    };
  }
});

// node_modules/process/browser.js
var require_browser3 = __commonJS({
  "node_modules/process/browser.js"(exports, module) {
    var process2 = module.exports = {};
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
      throw new Error("setTimeout has not been defined");
    }
    function defaultClearTimeout() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        if (typeof setTimeout === "function") {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === "function") {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
      }
    })();
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout(fun, 0);
      } catch (e) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e2) {
          return cachedSetTimeout.call(this, fun, 0);
        }
      }
    }
    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
      }
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        return cachedClearTimeout(marker);
      } catch (e) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e2) {
          return cachedClearTimeout.call(this, marker);
        }
      }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }
      draining = false;
      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }
      if (queue.length) {
        drainQueue();
      }
    }
    function drainQueue() {
      if (draining) {
        return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
      var len = queue.length;
      while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }
        queueIndex = -1;
        len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }
    process2.nextTick = function(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    };
    function Item(fun, array) {
      this.fun = fun;
      this.array = array;
    }
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    process2.title = "browser";
    process2.browser = true;
    process2.env = {};
    process2.argv = [];
    process2.version = "";
    process2.versions = {};
    function noop() {
    }
    process2.on = noop;
    process2.addListener = noop;
    process2.once = noop;
    process2.off = noop;
    process2.removeListener = noop;
    process2.removeAllListeners = noop;
    process2.emit = noop;
    process2.prependListener = noop;
    process2.prependOnceListener = noop;
    process2.listeners = function(name3) {
      return [];
    };
    process2.binding = function(name3) {
      throw new Error("process.binding is not supported");
    };
    process2.cwd = function() {
      return "/";
    };
    process2.chdir = function(dir) {
      throw new Error("process.chdir is not supported");
    };
    process2.umask = function() {
      return 0;
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/utils.js
var require_utils3 = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/utils.js"(exports, module) {
    "use strict";
    var { SymbolAsyncIterator, SymbolIterator, SymbolFor } = require_primordials();
    var kIsDestroyed = SymbolFor("nodejs.stream.destroyed");
    var kIsErrored = SymbolFor("nodejs.stream.errored");
    var kIsReadable = SymbolFor("nodejs.stream.readable");
    var kIsWritable = SymbolFor("nodejs.stream.writable");
    var kIsDisturbed = SymbolFor("nodejs.stream.disturbed");
    var kIsClosedPromise = SymbolFor("nodejs.webstream.isClosedPromise");
    var kControllerErrorFunction = SymbolFor("nodejs.webstream.controllerErrorFunction");
    function isReadableNodeStream(obj, strict = false) {
      var _obj$_readableState;
      return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === void 0 ? void 0 : _obj$_readableState.readable) !== false) && // Duplex
      (!obj._writableState || obj._readableState));
    }
    function isWritableNodeStream(obj) {
      var _obj$_writableState;
      return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === void 0 ? void 0 : _obj$_writableState.writable) !== false));
    }
    function isDuplexNodeStream(obj) {
      return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
    }
    function isNodeStream(obj) {
      return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
    }
    function isReadableStream2(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.pipeThrough === "function" && typeof obj.getReader === "function" && typeof obj.cancel === "function");
    }
    function isWritableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === "function" && typeof obj.abort === "function");
    }
    function isTransformStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.readable === "object" && typeof obj.writable === "object");
    }
    function isWebStream(obj) {
      return isReadableStream2(obj) || isWritableStream(obj) || isTransformStream(obj);
    }
    function isIterable(obj, isAsync) {
      if (obj == null) return false;
      if (isAsync === true) return typeof obj[SymbolAsyncIterator] === "function";
      if (isAsync === false) return typeof obj[SymbolIterator] === "function";
      return typeof obj[SymbolAsyncIterator] === "function" || typeof obj[SymbolIterator] === "function";
    }
    function isDestroyed(stream) {
      if (!isNodeStream(stream)) return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state3 = wState || rState;
      return !!(stream.destroyed || stream[kIsDestroyed] || state3 !== null && state3 !== void 0 && state3.destroyed);
    }
    function isWritableEnded(stream) {
      if (!isWritableNodeStream(stream)) return null;
      if (stream.writableEnded === true) return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored) return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.ended) !== "boolean") return null;
      return wState.ended;
    }
    function isWritableFinished(stream, strict) {
      if (!isWritableNodeStream(stream)) return null;
      if (stream.writableFinished === true) return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored) return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.finished) !== "boolean") return null;
      return !!(wState.finished || strict === false && wState.ended === true && wState.length === 0);
    }
    function isReadableEnded(stream) {
      if (!isReadableNodeStream(stream)) return null;
      if (stream.readableEnded === true) return true;
      const rState = stream._readableState;
      if (!rState || rState.errored) return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.ended) !== "boolean") return null;
      return rState.ended;
    }
    function isReadableFinished(stream, strict) {
      if (!isReadableNodeStream(stream)) return null;
      const rState = stream._readableState;
      if (rState !== null && rState !== void 0 && rState.errored) return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.endEmitted) !== "boolean") return null;
      return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
    }
    function isReadable(stream) {
      if (stream && stream[kIsReadable] != null) return stream[kIsReadable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.readable) !== "boolean") return null;
      if (isDestroyed(stream)) return false;
      return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);
    }
    function isWritable(stream) {
      if (stream && stream[kIsWritable] != null) return stream[kIsWritable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.writable) !== "boolean") return null;
      if (isDestroyed(stream)) return false;
      return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);
    }
    function isFinished(stream, opts) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (isDestroyed(stream)) {
        return true;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.readable) !== false && isReadable(stream)) {
        return false;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.writable) !== false && isWritable(stream)) {
        return false;
      }
      return true;
    }
    function isWritableErrored(stream) {
      var _stream$_writableStat, _stream$_writableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.writableErrored) {
        return stream.writableErrored;
      }
      return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === void 0 ? void 0 : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== void 0 ? _stream$_writableStat : null;
    }
    function isReadableErrored(stream) {
      var _stream$_readableStat, _stream$_readableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.readableErrored) {
        return stream.readableErrored;
      }
      return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === void 0 ? void 0 : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== void 0 ? _stream$_readableStat : null;
    }
    function isClosed(stream) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (typeof stream.closed === "boolean") {
        return stream.closed;
      }
      const wState = stream._writableState;
      const rState = stream._readableState;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.closed) === "boolean" || typeof (rState === null || rState === void 0 ? void 0 : rState.closed) === "boolean") {
        return (wState === null || wState === void 0 ? void 0 : wState.closed) || (rState === null || rState === void 0 ? void 0 : rState.closed);
      }
      if (typeof stream._closed === "boolean" && isOutgoingMessage(stream)) {
        return stream._closed;
      }
      return null;
    }
    function isOutgoingMessage(stream) {
      return typeof stream._closed === "boolean" && typeof stream._defaultKeepAlive === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean";
    }
    function isServerResponse(stream) {
      return typeof stream._sent100 === "boolean" && isOutgoingMessage(stream);
    }
    function isServerRequest(stream) {
      var _stream$req;
      return typeof stream._consuming === "boolean" && typeof stream._dumped === "boolean" && ((_stream$req = stream.req) === null || _stream$req === void 0 ? void 0 : _stream$req.upgradeOrConnect) === void 0;
    }
    function willEmitClose(stream) {
      if (!isNodeStream(stream)) return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state3 = wState || rState;
      return !state3 && isServerResponse(stream) || !!(state3 && state3.autoDestroy && state3.emitClose && state3.closed === false);
    }
    function isDisturbed(stream) {
      var _stream$kIsDisturbed;
      return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== void 0 ? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));
    }
    function isErrored(stream) {
      var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
      return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== void 0 ? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== void 0 ? _ref5 : stream.writableErrored) !== null && _ref4 !== void 0 ? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === void 0 ? void 0 : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== void 0 ? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === void 0 ? void 0 : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== void 0 ? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === void 0 ? void 0 : _stream$_readableStat4.errored) !== null && _ref !== void 0 ? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === void 0 ? void 0 : _stream$_writableStat4.errored));
    }
    module.exports = {
      isDestroyed,
      kIsDestroyed,
      isDisturbed,
      kIsDisturbed,
      isErrored,
      kIsErrored,
      isReadable,
      kIsReadable,
      kIsClosedPromise,
      kControllerErrorFunction,
      kIsWritable,
      isClosed,
      isDuplexNodeStream,
      isFinished,
      isIterable,
      isReadableNodeStream,
      isReadableStream: isReadableStream2,
      isReadableEnded,
      isReadableFinished,
      isReadableErrored,
      isNodeStream,
      isWebStream,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableEnded,
      isWritableFinished,
      isWritableErrored,
      isServerRequest,
      isServerResponse,
      willEmitClose,
      isTransformStream
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
    "use strict";
    var process2 = require_browser3();
    var { AbortError: AbortError3, codes } = require_errors2();
    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes;
    var { kEmptyObject, once } = require_util2();
    var { validateAbortSignal, validateFunction, validateObject, validateBoolean } = require_validators();
    var { Promise: Promise2, PromisePrototypeThen, SymbolDispose } = require_primordials();
    var {
      isClosed,
      isReadable,
      isReadableNodeStream,
      isReadableStream: isReadableStream2,
      isReadableFinished,
      isReadableErrored,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableFinished,
      isWritableErrored,
      isNodeStream,
      willEmitClose: _willEmitClose,
      kIsClosedPromise
    } = require_utils3();
    var addAbortListener;
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    var nop = () => {
    };
    function eos(stream, options, callback) {
      var _options$readable, _options$writable;
      if (arguments.length === 2) {
        callback = options;
        options = kEmptyObject;
      } else if (options == null) {
        options = kEmptyObject;
      } else {
        validateObject(options, "options");
      }
      validateFunction(callback, "callback");
      validateAbortSignal(options.signal, "options.signal");
      callback = once(callback);
      if (isReadableStream2(stream) || isWritableStream(stream)) {
        return eosWeb(stream, options, callback);
      }
      if (!isNodeStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      const readable = (_options$readable = options.readable) !== null && _options$readable !== void 0 ? _options$readable : isReadableNodeStream(stream);
      const writable = (_options$writable = options.writable) !== null && _options$writable !== void 0 ? _options$writable : isWritableNodeStream(stream);
      const wState = stream._writableState;
      const rState = stream._readableState;
      const onlegacyfinish = () => {
        if (!stream.writable) {
          onfinish();
        }
      };
      let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable;
      let writableFinished = isWritableFinished(stream, false);
      const onfinish = () => {
        writableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.readable || readable)) {
          return;
        }
        if (!readable || readableFinished) {
          callback.call(stream);
        }
      };
      let readableFinished = isReadableFinished(stream, false);
      const onend = () => {
        readableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.writable || writable)) {
          return;
        }
        if (!writable || writableFinished) {
          callback.call(stream);
        }
      };
      const onerror = (err) => {
        callback.call(stream, err);
      };
      let closed = isClosed(stream);
      const onclose = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
          if (!isReadableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        if (writable && !writableFinished) {
          if (!isWritableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        callback.call(stream);
      };
      const onclosed = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        callback.call(stream);
      };
      const onrequest = () => {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        if (!willEmitClose) {
          stream.on("abort", onclose);
        }
        if (stream.req) {
          onrequest();
        } else {
          stream.on("request", onrequest);
        }
      } else if (writable && !wState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (!willEmitClose && typeof stream.aborted === "boolean") {
        stream.on("aborted", onclose);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (options.error !== false) {
        stream.on("error", onerror);
      }
      stream.on("close", onclose);
      if (closed) {
        process2.nextTick(onclose);
      } else if (wState !== null && wState !== void 0 && wState.errorEmitted || rState !== null && rState !== void 0 && rState.errorEmitted) {
        if (!willEmitClose) {
          process2.nextTick(onclosed);
        }
      } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === false)) {
        process2.nextTick(onclosed);
      } else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === false)) {
        process2.nextTick(onclosed);
      } else if (rState && stream.req && stream.aborted) {
        process2.nextTick(onclosed);
      }
      const cleanup = () => {
        callback = nop;
        stream.removeListener("aborted", onclose);
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
      if (options.signal && !closed) {
        const abort = () => {
          const endCallback = callback;
          cleanup();
          endCallback.call(
            stream,
            new AbortError3(void 0, {
              cause: options.signal.reason
            })
          );
        };
        if (options.signal.aborted) {
          process2.nextTick(abort);
        } else {
          addAbortListener = addAbortListener || require_util2().addAbortListener;
          const disposable = addAbortListener(options.signal, abort);
          const originalCallback = callback;
          callback = once((...args) => {
            disposable[SymbolDispose]();
            originalCallback.apply(stream, args);
          });
        }
      }
      return cleanup;
    }
    function eosWeb(stream, options, callback) {
      let isAborted = false;
      let abort = nop;
      if (options.signal) {
        abort = () => {
          isAborted = true;
          callback.call(
            stream,
            new AbortError3(void 0, {
              cause: options.signal.reason
            })
          );
        };
        if (options.signal.aborted) {
          process2.nextTick(abort);
        } else {
          addAbortListener = addAbortListener || require_util2().addAbortListener;
          const disposable = addAbortListener(options.signal, abort);
          const originalCallback = callback;
          callback = once((...args) => {
            disposable[SymbolDispose]();
            originalCallback.apply(stream, args);
          });
        }
      }
      const resolverFn = (...args) => {
        if (!isAborted) {
          process2.nextTick(() => callback.apply(stream, args));
        }
      };
      PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn);
      return nop;
    }
    function finished(stream, opts) {
      var _opts;
      let autoCleanup = false;
      if (opts === null) {
        opts = kEmptyObject;
      }
      if ((_opts = opts) !== null && _opts !== void 0 && _opts.cleanup) {
        validateBoolean(opts.cleanup, "cleanup");
        autoCleanup = opts.cleanup;
      }
      return new Promise2((resolve, reject) => {
        const cleanup = eos(stream, opts, (err) => {
          if (autoCleanup) {
            cleanup();
          }
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
    }
    module.exports = eos;
    module.exports.finished = finished;
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
    "use strict";
    var process2 = require_browser3();
    var {
      aggregateTwoErrors,
      codes: { ERR_MULTIPLE_CALLBACK },
      AbortError: AbortError3
    } = require_errors2();
    var { Symbol: Symbol2 } = require_primordials();
    var { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils3();
    var kDestroy = Symbol2("kDestroy");
    var kConstruct = Symbol2("kConstruct");
    function checkError(err, w, r) {
      if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
      }
    }
    function destroy2(err, cb) {
      const r = this._readableState;
      const w = this._writableState;
      const s = w || r;
      if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
        if (typeof cb === "function") {
          cb();
        }
        return this;
      }
      checkError(err, w, r);
      if (w) {
        w.destroyed = true;
      }
      if (r) {
        r.destroyed = true;
      }
      if (!s.constructed) {
        this.once(kDestroy, function(er) {
          _destroy(this, aggregateTwoErrors(er, err), cb);
        });
      } else {
        _destroy(this, err, cb);
      }
      return this;
    }
    function _destroy(self2, err, cb) {
      let called = false;
      function onDestroy(err2) {
        if (called) {
          return;
        }
        called = true;
        const r = self2._readableState;
        const w = self2._writableState;
        checkError(err2, w, r);
        if (w) {
          w.closed = true;
        }
        if (r) {
          r.closed = true;
        }
        if (typeof cb === "function") {
          cb(err2);
        }
        if (err2) {
          process2.nextTick(emitErrorCloseNT, self2, err2);
        } else {
          process2.nextTick(emitCloseNT, self2);
        }
      }
      try {
        self2._destroy(err || null, onDestroy);
      } catch (err2) {
        onDestroy(err2);
      }
    }
    function emitErrorCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      const r = self2._readableState;
      const w = self2._writableState;
      if (w) {
        w.closeEmitted = true;
      }
      if (r) {
        r.closeEmitted = true;
      }
      if (w !== null && w !== void 0 && w.emitClose || r !== null && r !== void 0 && r.emitClose) {
        self2.emit("close");
      }
    }
    function emitErrorNT(self2, err) {
      const r = self2._readableState;
      const w = self2._writableState;
      if (w !== null && w !== void 0 && w.errorEmitted || r !== null && r !== void 0 && r.errorEmitted) {
        return;
      }
      if (w) {
        w.errorEmitted = true;
      }
      if (r) {
        r.errorEmitted = true;
      }
      self2.emit("error", err);
    }
    function undestroy() {
      const r = this._readableState;
      const w = this._writableState;
      if (r) {
        r.constructed = true;
        r.closed = false;
        r.closeEmitted = false;
        r.destroyed = false;
        r.errored = null;
        r.errorEmitted = false;
        r.reading = false;
        r.ended = r.readable === false;
        r.endEmitted = r.readable === false;
      }
      if (w) {
        w.constructed = true;
        w.destroyed = false;
        w.closed = false;
        w.closeEmitted = false;
        w.errored = null;
        w.errorEmitted = false;
        w.finalCalled = false;
        w.prefinished = false;
        w.ended = w.writable === false;
        w.ending = w.writable === false;
        w.finished = w.writable === false;
      }
    }
    function errorOrDestroy(stream, err, sync) {
      const r = stream._readableState;
      const w = stream._writableState;
      if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
        return this;
      }
      if (r !== null && r !== void 0 && r.autoDestroy || w !== null && w !== void 0 && w.autoDestroy)
        stream.destroy(err);
      else if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
        if (sync) {
          process2.nextTick(emitErrorNT, stream, err);
        } else {
          emitErrorNT(stream, err);
        }
      }
    }
    function construct(stream, cb) {
      if (typeof stream._construct !== "function") {
        return;
      }
      const r = stream._readableState;
      const w = stream._writableState;
      if (r) {
        r.constructed = false;
      }
      if (w) {
        w.constructed = false;
      }
      stream.once(kConstruct, cb);
      if (stream.listenerCount(kConstruct) > 1) {
        return;
      }
      process2.nextTick(constructNT, stream);
    }
    function constructNT(stream) {
      let called = false;
      function onConstruct(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : new ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        const r = stream._readableState;
        const w = stream._writableState;
        const s = w || r;
        if (r) {
          r.constructed = true;
        }
        if (w) {
          w.constructed = true;
        }
        if (s.destroyed) {
          stream.emit(kDestroy, err);
        } else if (err) {
          errorOrDestroy(stream, err, true);
        } else {
          process2.nextTick(emitConstructNT, stream);
        }
      }
      try {
        stream._construct((err) => {
          process2.nextTick(onConstruct, err);
        });
      } catch (err) {
        process2.nextTick(onConstruct, err);
      }
    }
    function emitConstructNT(stream) {
      stream.emit(kConstruct);
    }
    function isRequest(stream) {
      return (stream === null || stream === void 0 ? void 0 : stream.setHeader) && typeof stream.abort === "function";
    }
    function emitCloseLegacy(stream) {
      stream.emit("close");
    }
    function emitErrorCloseLegacy(stream, err) {
      stream.emit("error", err);
      process2.nextTick(emitCloseLegacy, stream);
    }
    function destroyer(stream, err) {
      if (!stream || isDestroyed(stream)) {
        return;
      }
      if (!err && !isFinished(stream)) {
        err = new AbortError3();
      }
      if (isServerRequest(stream)) {
        stream.socket = null;
        stream.destroy(err);
      } else if (isRequest(stream)) {
        stream.abort();
      } else if (isRequest(stream.req)) {
        stream.req.abort();
      } else if (typeof stream.destroy === "function") {
        stream.destroy(err);
      } else if (typeof stream.close === "function") {
        stream.close();
      } else if (err) {
        process2.nextTick(emitErrorCloseLegacy, stream, err);
      } else {
        process2.nextTick(emitCloseLegacy, stream);
      }
      if (!stream.destroyed) {
        stream[kIsDestroyed] = true;
      }
    }
    module.exports = {
      construct,
      destroyer,
      destroy: destroy2,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/legacy.js
var require_legacy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/legacy.js"(exports, module) {
    "use strict";
    var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials();
    var { EventEmitter: EE } = require_events();
    function Stream(opts) {
      EE.call(this, opts);
    }
    ObjectSetPrototypeOf(Stream.prototype, EE.prototype);
    ObjectSetPrototypeOf(Stream, EE);
    Stream.prototype.pipe = function(dest, options) {
      const source = this;
      function ondata(chunk) {
        if (dest.writable && dest.write(chunk) === false && source.pause) {
          source.pause();
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
      }
      let didOnEnd = false;
      function onend() {
        if (didOnEnd) return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;
        if (typeof dest.destroy === "function") dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, "error") === 0) {
          this.emit("error", er);
        }
      }
      prependListener(source, "error", onerror);
      prependListener(dest, "error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
      else if (ArrayIsArray(emitter._events[event])) emitter._events[event].unshift(fn);
      else emitter._events[event] = [fn, emitter._events[event]];
    }
    module.exports = {
      Stream,
      prependListener
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/add-abort-signal.js
var require_add_abort_signal = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/add-abort-signal.js"(exports, module) {
    "use strict";
    var { SymbolDispose } = require_primordials();
    var { AbortError: AbortError3, codes } = require_errors2();
    var { isNodeStream, isWebStream, kControllerErrorFunction } = require_utils3();
    var eos = require_end_of_stream();
    var { ERR_INVALID_ARG_TYPE } = codes;
    var addAbortListener;
    var validateAbortSignal = (signal, name3) => {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        throw new ERR_INVALID_ARG_TYPE(name3, "AbortSignal", signal);
      }
    };
    module.exports.addAbortSignal = function addAbortSignal(signal, stream) {
      validateAbortSignal(signal, "signal");
      if (!isNodeStream(stream) && !isWebStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      return module.exports.addAbortSignalNoValidate(signal, stream);
    };
    module.exports.addAbortSignalNoValidate = function(signal, stream) {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        return stream;
      }
      const onAbort = isNodeStream(stream) ? () => {
        stream.destroy(
          new AbortError3(void 0, {
            cause: signal.reason
          })
        );
      } : () => {
        stream[kControllerErrorFunction](
          new AbortError3(void 0, {
            cause: signal.reason
          })
        );
      };
      if (signal.aborted) {
        onAbort();
      } else {
        addAbortListener = addAbortListener || require_util2().addAbortListener;
        const disposable = addAbortListener(signal, onAbort);
        eos(stream, disposable[SymbolDispose]);
      }
      return stream;
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
    "use strict";
    var { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array: Uint8Array2 } = require_primordials();
    var { Buffer: Buffer2 } = require_buffer();
    var { inspect } = require_util2();
    module.exports = class BufferList {
      constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      push(v) {
        const entry = {
          data: v,
          next: null
        };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      }
      unshift(v) {
        const entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      }
      shift() {
        if (this.length === 0) return;
        const ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      }
      clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
      join(s) {
        if (this.length === 0) return "";
        let p = this.head;
        let ret = "" + p.data;
        while ((p = p.next) !== null) ret += s + p.data;
        return ret;
      }
      concat(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        const ret = Buffer2.allocUnsafe(n >>> 0);
        let p = this.head;
        let i = 0;
        while (p) {
          TypedArrayPrototypeSet(ret, p.data, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
      consume(n, hasStrings) {
        const data = this.head.data;
        if (n < data.length) {
          const slice = data.slice(0, n);
          this.head.data = data.slice(n);
          return slice;
        }
        if (n === data.length) {
          return this.shift();
        }
        return hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      first() {
        return this.head.data;
      }
      *[SymbolIterator]() {
        for (let p = this.head; p; p = p.next) {
          yield p.data;
        }
      }
      // Consumes a specified amount of characters from the buffered data.
      _getString(n) {
        let ret = "";
        let p = this.head;
        let c = 0;
        do {
          const str = p.data;
          if (n > str.length) {
            ret += str;
            n -= str.length;
          } else {
            if (n === str.length) {
              ret += str;
              ++c;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              ret += StringPrototypeSlice(str, 0, n);
              this.head = p;
              p.data = StringPrototypeSlice(str, n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
      _getBuffer(n) {
        const ret = Buffer2.allocUnsafe(n);
        const retLen = n;
        let p = this.head;
        let c = 0;
        do {
          const buf = p.data;
          if (n > buf.length) {
            TypedArrayPrototypeSet(ret, buf, retLen - n);
            n -= buf.length;
          } else {
            if (n === buf.length) {
              TypedArrayPrototypeSet(ret, buf, retLen - n);
              ++c;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              TypedArrayPrototypeSet(ret, new Uint8Array2(buf.buffer, buf.byteOffset, n), retLen - n);
              this.head = p;
              p.data = buf.slice(n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
      [Symbol.for("nodejs.util.inspect.custom")](_2, options) {
        return inspect(this, {
          ...options,
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        });
      }
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
    "use strict";
    var { MathFloor, NumberIsInteger } = require_primordials();
    var { validateInteger } = require_validators();
    var { ERR_INVALID_ARG_VALUE } = require_errors2().codes;
    var defaultHighWaterMarkBytes = 16 * 1024;
    var defaultHighWaterMarkObjectMode = 16;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getDefaultHighWaterMark(objectMode) {
      return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes;
    }
    function setDefaultHighWaterMark(objectMode, value) {
      validateInteger(value, "value", 0);
      if (objectMode) {
        defaultHighWaterMarkObjectMode = value;
      } else {
        defaultHighWaterMarkBytes = value;
      }
    }
    function getHighWaterMark(state3, options, duplexKey, isDuplex) {
      const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!NumberIsInteger(hwm) || hwm < 0) {
          const name3 = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
          throw new ERR_INVALID_ARG_VALUE(name3, hwm);
        }
        return MathFloor(hwm);
      }
      return getDefaultHighWaterMark(state3.objectMode);
    }
    module.exports = {
      getHighWaterMark,
      getDefaultHighWaterMark,
      setDefaultHighWaterMark
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/from.js"(exports, module) {
    "use strict";
    var process2 = require_browser3();
    var { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials();
    var { Buffer: Buffer2 } = require_buffer();
    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } = require_errors2().codes;
    function from(Readable, iterable, opts) {
      let iterator;
      if (typeof iterable === "string" || iterable instanceof Buffer2) {
        return new Readable({
          objectMode: true,
          ...opts,
          read() {
            this.push(iterable);
            this.push(null);
          }
        });
      }
      let isAsync;
      if (iterable && iterable[SymbolAsyncIterator]) {
        isAsync = true;
        iterator = iterable[SymbolAsyncIterator]();
      } else if (iterable && iterable[SymbolIterator]) {
        isAsync = false;
        iterator = iterable[SymbolIterator]();
      } else {
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      }
      const readable = new Readable({
        objectMode: true,
        highWaterMark: 1,
        // TODO(ronag): What options should be allowed?
        ...opts
      });
      let reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      readable._destroy = function(error, cb) {
        PromisePrototypeThen(
          close(error),
          () => process2.nextTick(cb, error),
          // nextTick is here in case cb throws
          (e) => process2.nextTick(cb, e || error)
        );
      };
      async function close(error) {
        const hadError = error !== void 0 && error !== null;
        const hasThrow = typeof iterator.throw === "function";
        if (hadError && hasThrow) {
          const { value, done } = await iterator.throw(error);
          await value;
          if (done) {
            return;
          }
        }
        if (typeof iterator.return === "function") {
          const { value } = await iterator.return();
          await value;
        }
      }
      async function next() {
        for (; ; ) {
          try {
            const { value, done } = isAsync ? await iterator.next() : iterator.next();
            if (done) {
              readable.push(null);
            } else {
              const res = value && typeof value.then === "function" ? await value : value;
              if (res === null) {
                reading = false;
                throw new ERR_STREAM_NULL_VALUES();
              } else if (readable.push(res)) {
                continue;
              } else {
                reading = false;
              }
            }
          } catch (err) {
            readable.destroy(err);
          }
          break;
        }
      }
      return readable;
    }
    module.exports = from;
  }
});

// node_modules/readable-stream/lib/internal/streams/readable.js
var require_readable = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/readable.js"(exports, module) {
    "use strict";
    var process2 = require_browser3();
    var {
      ArrayPrototypeIndexOf,
      NumberIsInteger,
      NumberIsNaN,
      NumberParseInt,
      ObjectDefineProperties,
      ObjectKeys,
      ObjectSetPrototypeOf,
      Promise: Promise2,
      SafeSet,
      SymbolAsyncDispose,
      SymbolAsyncIterator,
      Symbol: Symbol2
    } = require_primordials();
    module.exports = Readable;
    Readable.ReadableState = ReadableState;
    var { EventEmitter: EE } = require_events();
    var { Stream, prependListener } = require_legacy();
    var { Buffer: Buffer2 } = require_buffer();
    var { addAbortSignal } = require_add_abort_signal();
    var eos = require_end_of_stream();
    var debug = require_util2().debuglog("stream", (fn) => {
      debug = fn;
    });
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
    var {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE,
        ERR_METHOD_NOT_IMPLEMENTED,
        ERR_OUT_OF_RANGE,
        ERR_STREAM_PUSH_AFTER_EOF,
        ERR_STREAM_UNSHIFT_AFTER_END_EVENT
      },
      AbortError: AbortError3
    } = require_errors2();
    var { validateObject } = require_validators();
    var kPaused = Symbol2("kPaused");
    var { StringDecoder } = require_string_decoder();
    var from = require_from();
    ObjectSetPrototypeOf(Readable.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Readable, Stream);
    var nop = () => {
    };
    var { errorOrDestroy } = destroyImpl;
    var kObjectMode = 1 << 0;
    var kEnded = 1 << 1;
    var kEndEmitted = 1 << 2;
    var kReading = 1 << 3;
    var kConstructed = 1 << 4;
    var kSync = 1 << 5;
    var kNeedReadable = 1 << 6;
    var kEmittedReadable = 1 << 7;
    var kReadableListening = 1 << 8;
    var kResumeScheduled = 1 << 9;
    var kErrorEmitted = 1 << 10;
    var kEmitClose = 1 << 11;
    var kAutoDestroy = 1 << 12;
    var kDestroyed = 1 << 13;
    var kClosed = 1 << 14;
    var kCloseEmitted = 1 << 15;
    var kMultiAwaitDrain = 1 << 16;
    var kReadingMore = 1 << 17;
    var kDataEmitted = 1 << 18;
    function makeBitMapDescriptor(bit) {
      return {
        enumerable: false,
        get() {
          return (this.state & bit) !== 0;
        },
        set(value) {
          if (value) this.state |= bit;
          else this.state &= ~bit;
        }
      };
    }
    ObjectDefineProperties(ReadableState.prototype, {
      objectMode: makeBitMapDescriptor(kObjectMode),
      ended: makeBitMapDescriptor(kEnded),
      endEmitted: makeBitMapDescriptor(kEndEmitted),
      reading: makeBitMapDescriptor(kReading),
      // Stream is still being constructed and cannot be
      // destroyed until construction finished or failed.
      // Async construction is opt in, therefore we start as
      // constructed.
      constructed: makeBitMapDescriptor(kConstructed),
      // A flag to be able to tell if the event 'readable'/'data' is emitted
      // immediately, or on a later tick.  We set this to true at first, because
      // any actions that shouldn't happen until "later" should generally also
      // not happen before the first read call.
      sync: makeBitMapDescriptor(kSync),
      // Whenever we return null, then we set a flag to say
      // that we're awaiting a 'readable' event emission.
      needReadable: makeBitMapDescriptor(kNeedReadable),
      emittedReadable: makeBitMapDescriptor(kEmittedReadable),
      readableListening: makeBitMapDescriptor(kReadableListening),
      resumeScheduled: makeBitMapDescriptor(kResumeScheduled),
      // True if the error was already emitted and should not be thrown again.
      errorEmitted: makeBitMapDescriptor(kErrorEmitted),
      emitClose: makeBitMapDescriptor(kEmitClose),
      autoDestroy: makeBitMapDescriptor(kAutoDestroy),
      // Has it been destroyed.
      destroyed: makeBitMapDescriptor(kDestroyed),
      // Indicates whether the stream has finished destroying.
      closed: makeBitMapDescriptor(kClosed),
      // True if close has been emitted or would have been emitted
      // depending on emitClose.
      closeEmitted: makeBitMapDescriptor(kCloseEmitted),
      multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),
      // If true, a maybeReadMore has been scheduled.
      readingMore: makeBitMapDescriptor(kReadingMore),
      dataEmitted: makeBitMapDescriptor(kDataEmitted)
    });
    function ReadableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof require_duplex();
      this.state = kEmitClose | kAutoDestroy | kConstructed | kSync;
      if (options && options.objectMode) this.state |= kObjectMode;
      if (isDuplex && options && options.readableObjectMode) this.state |= kObjectMode;
      this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = [];
      this.flowing = null;
      this[kPaused] = null;
      if (options && options.emitClose === false) this.state &= ~kEmitClose;
      if (options && options.autoDestroy === false) this.state &= ~kAutoDestroy;
      this.errored = null;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.awaitDrainWriters = null;
      this.decoder = null;
      this.encoding = null;
      if (options && options.encoding) {
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      if (!(this instanceof Readable)) return new Readable(options);
      const isDuplex = this instanceof require_duplex();
      this._readableState = new ReadableState(options, this, isDuplex);
      if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.construct === "function") this._construct = options.construct;
        if (options.signal && !isDuplex) addAbortSignal(options.signal, this);
      }
      Stream.call(this, options);
      destroyImpl.construct(this, () => {
        if (this._readableState.needReadable) {
          maybeReadMore(this, this._readableState);
        }
      });
    }
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    Readable.prototype[SymbolAsyncDispose] = function() {
      let error;
      if (!this.destroyed) {
        error = this.readableEnded ? null : new AbortError3();
        this.destroy(error);
      }
      return new Promise2((resolve, reject) => eos(this, (err) => err && err !== error ? reject(err) : resolve(null)));
    };
    Readable.prototype.push = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, true);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront) {
      debug("readableAddChunk", chunk);
      const state3 = stream._readableState;
      let err;
      if ((state3.state & kObjectMode) === 0) {
        if (typeof chunk === "string") {
          encoding = encoding || state3.defaultEncoding;
          if (state3.encoding !== encoding) {
            if (addToFront && state3.encoding) {
              chunk = Buffer2.from(chunk, encoding).toString(state3.encoding);
            } else {
              chunk = Buffer2.from(chunk, encoding);
              encoding = "";
            }
          }
        } else if (chunk instanceof Buffer2) {
          encoding = "";
        } else if (Stream._isUint8Array(chunk)) {
          chunk = Stream._uint8ArrayToBuffer(chunk);
          encoding = "";
        } else if (chunk != null) {
          err = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      if (err) {
        errorOrDestroy(stream, err);
      } else if (chunk === null) {
        state3.state &= ~kReading;
        onEofChunk(stream, state3);
      } else if ((state3.state & kObjectMode) !== 0 || chunk && chunk.length > 0) {
        if (addToFront) {
          if ((state3.state & kEndEmitted) !== 0) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else if (state3.destroyed || state3.errored) return false;
          else addChunk(stream, state3, chunk, true);
        } else if (state3.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state3.destroyed || state3.errored) {
          return false;
        } else {
          state3.state &= ~kReading;
          if (state3.decoder && !encoding) {
            chunk = state3.decoder.write(chunk);
            if (state3.objectMode || chunk.length !== 0) addChunk(stream, state3, chunk, false);
            else maybeReadMore(stream, state3);
          } else {
            addChunk(stream, state3, chunk, false);
          }
        }
      } else if (!addToFront) {
        state3.state &= ~kReading;
        maybeReadMore(stream, state3);
      }
      return !state3.ended && (state3.length < state3.highWaterMark || state3.length === 0);
    }
    function addChunk(stream, state3, chunk, addToFront) {
      if (state3.flowing && state3.length === 0 && !state3.sync && stream.listenerCount("data") > 0) {
        if ((state3.state & kMultiAwaitDrain) !== 0) {
          state3.awaitDrainWriters.clear();
        } else {
          state3.awaitDrainWriters = null;
        }
        state3.dataEmitted = true;
        stream.emit("data", chunk);
      } else {
        state3.length += state3.objectMode ? 1 : chunk.length;
        if (addToFront) state3.buffer.unshift(chunk);
        else state3.buffer.push(chunk);
        if ((state3.state & kNeedReadable) !== 0) emitReadable(stream);
      }
      maybeReadMore(stream, state3);
    }
    Readable.prototype.isPaused = function() {
      const state3 = this._readableState;
      return state3[kPaused] === true || state3.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      const decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      const buffer = this._readableState.buffer;
      let content = "";
      for (const data of buffer) {
        content += decoder.write(data);
      }
      buffer.clear();
      if (content !== "") buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n > MAX_HWM) {
        throw new ERR_OUT_OF_RANGE("size", "<= 1GiB", n);
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state3) {
      if (n <= 0 || state3.length === 0 && state3.ended) return 0;
      if ((state3.state & kObjectMode) !== 0) return 1;
      if (NumberIsNaN(n)) {
        if (state3.flowing && state3.length) return state3.buffer.first().length;
        return state3.length;
      }
      if (n <= state3.length) return n;
      return state3.ended ? state3.length : 0;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      if (n === void 0) {
        n = NaN;
      } else if (!NumberIsInteger(n)) {
        n = NumberParseInt(n, 10);
      }
      const state3 = this._readableState;
      const nOrig = n;
      if (n > state3.highWaterMark) state3.highWaterMark = computeNewHighWaterMark(n);
      if (n !== 0) state3.state &= ~kEmittedReadable;
      if (n === 0 && state3.needReadable && ((state3.highWaterMark !== 0 ? state3.length >= state3.highWaterMark : state3.length > 0) || state3.ended)) {
        debug("read: emitReadable", state3.length, state3.ended);
        if (state3.length === 0 && state3.ended) endReadable(this);
        else emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state3);
      if (n === 0 && state3.ended) {
        if (state3.length === 0) endReadable(this);
        return null;
      }
      let doRead = (state3.state & kNeedReadable) !== 0;
      debug("need readable", doRead);
      if (state3.length === 0 || state3.length - n < state3.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state3.ended || state3.reading || state3.destroyed || state3.errored || !state3.constructed) {
        doRead = false;
        debug("reading, ended or constructing", doRead);
      } else if (doRead) {
        debug("do read");
        state3.state |= kReading | kSync;
        if (state3.length === 0) state3.state |= kNeedReadable;
        try {
          this._read(state3.highWaterMark);
        } catch (err) {
          errorOrDestroy(this, err);
        }
        state3.state &= ~kSync;
        if (!state3.reading) n = howMuchToRead(nOrig, state3);
      }
      let ret;
      if (n > 0) ret = fromList(n, state3);
      else ret = null;
      if (ret === null) {
        state3.needReadable = state3.length <= state3.highWaterMark;
        n = 0;
      } else {
        state3.length -= n;
        if (state3.multiAwaitDrain) {
          state3.awaitDrainWriters.clear();
        } else {
          state3.awaitDrainWriters = null;
        }
      }
      if (state3.length === 0) {
        if (!state3.ended) state3.needReadable = true;
        if (nOrig !== n && state3.ended) endReadable(this);
      }
      if (ret !== null && !state3.errorEmitted && !state3.closeEmitted) {
        state3.dataEmitted = true;
        this.emit("data", ret);
      }
      return ret;
    };
    function onEofChunk(stream, state3) {
      debug("onEofChunk");
      if (state3.ended) return;
      if (state3.decoder) {
        const chunk = state3.decoder.end();
        if (chunk && chunk.length) {
          state3.buffer.push(chunk);
          state3.length += state3.objectMode ? 1 : chunk.length;
        }
      }
      state3.ended = true;
      if (state3.sync) {
        emitReadable(stream);
      } else {
        state3.needReadable = false;
        state3.emittedReadable = true;
        emitReadable_(stream);
      }
    }
    function emitReadable(stream) {
      const state3 = stream._readableState;
      debug("emitReadable", state3.needReadable, state3.emittedReadable);
      state3.needReadable = false;
      if (!state3.emittedReadable) {
        debug("emitReadable", state3.flowing);
        state3.emittedReadable = true;
        process2.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      const state3 = stream._readableState;
      debug("emitReadable_", state3.destroyed, state3.length, state3.ended);
      if (!state3.destroyed && !state3.errored && (state3.length || state3.ended)) {
        stream.emit("readable");
        state3.emittedReadable = false;
      }
      state3.needReadable = !state3.flowing && !state3.ended && state3.length <= state3.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state3) {
      if (!state3.readingMore && state3.constructed) {
        state3.readingMore = true;
        process2.nextTick(maybeReadMore_, stream, state3);
      }
    }
    function maybeReadMore_(stream, state3) {
      while (!state3.reading && !state3.ended && (state3.length < state3.highWaterMark || state3.flowing && state3.length === 0)) {
        const len = state3.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state3.length)
          break;
      }
      state3.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      const src = this;
      const state3 = this._readableState;
      if (state3.pipes.length === 1) {
        if (!state3.multiAwaitDrain) {
          state3.multiAwaitDrain = true;
          state3.awaitDrainWriters = new SafeSet(state3.awaitDrainWriters ? [state3.awaitDrainWriters] : []);
        }
      }
      state3.pipes.push(dest);
      debug("pipe count=%d opts=%j", state3.pipes.length, pipeOpts);
      const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process2.stdout && dest !== process2.stderr;
      const endFn = doEnd ? onend : unpipe;
      if (state3.endEmitted) process2.nextTick(endFn);
      else src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      let ondrain;
      let cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        if (ondrain) {
          dest.removeListener("drain", ondrain);
        }
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (ondrain && state3.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      function pause() {
        if (!cleanedUp) {
          if (state3.pipes.length === 1 && state3.pipes[0] === dest) {
            debug("false write response, pause", 0);
            state3.awaitDrainWriters = dest;
            state3.multiAwaitDrain = false;
          } else if (state3.pipes.length > 1 && state3.pipes.includes(dest)) {
            debug("false write response, pause", state3.awaitDrainWriters.size);
            state3.awaitDrainWriters.add(dest);
          }
          src.pause();
        }
        if (!ondrain) {
          ondrain = pipeOnDrain(src, dest);
          dest.on("drain", ondrain);
        }
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        const ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (dest.listenerCount("error") === 0) {
          const s = dest._writableState || dest._readableState;
          if (s && !s.errorEmitted) {
            errorOrDestroy(dest, er);
          } else {
            dest.emit("error", er);
          }
        }
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (dest.writableNeedDrain === true) {
        pause();
      } else if (!state3.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src, dest) {
      return function pipeOnDrainFunctionResult() {
        const state3 = src._readableState;
        if (state3.awaitDrainWriters === dest) {
          debug("pipeOnDrain", 1);
          state3.awaitDrainWriters = null;
        } else if (state3.multiAwaitDrain) {
          debug("pipeOnDrain", state3.awaitDrainWriters.size);
          state3.awaitDrainWriters.delete(dest);
        }
        if ((!state3.awaitDrainWriters || state3.awaitDrainWriters.size === 0) && src.listenerCount("data")) {
          src.resume();
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      const state3 = this._readableState;
      const unpipeInfo = {
        hasUnpiped: false
      };
      if (state3.pipes.length === 0) return this;
      if (!dest) {
        const dests = state3.pipes;
        state3.pipes = [];
        this.pause();
        for (let i = 0; i < dests.length; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      const index = ArrayPrototypeIndexOf(state3.pipes, dest);
      if (index === -1) return this;
      state3.pipes.splice(index, 1);
      if (state3.pipes.length === 0) this.pause();
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      const res = Stream.prototype.on.call(this, ev, fn);
      const state3 = this._readableState;
      if (ev === "data") {
        state3.readableListening = this.listenerCount("readable") > 0;
        if (state3.flowing !== false) this.resume();
      } else if (ev === "readable") {
        if (!state3.endEmitted && !state3.readableListening) {
          state3.readableListening = state3.needReadable = true;
          state3.flowing = false;
          state3.emittedReadable = false;
          debug("on readable", state3.length, state3.reading);
          if (state3.length) {
            emitReadable(this);
          } else if (!state3.reading) {
            process2.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      const res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process2.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.off = Readable.prototype.removeListener;
    Readable.prototype.removeAllListeners = function(ev) {
      const res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process2.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      const state3 = self2._readableState;
      state3.readableListening = self2.listenerCount("readable") > 0;
      if (state3.resumeScheduled && state3[kPaused] === false) {
        state3.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      } else if (!state3.readableListening) {
        state3.flowing = null;
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      const state3 = this._readableState;
      if (!state3.flowing) {
        debug("resume");
        state3.flowing = !state3.readableListening;
        resume(this, state3);
      }
      state3[kPaused] = false;
      return this;
    };
    function resume(stream, state3) {
      if (!state3.resumeScheduled) {
        state3.resumeScheduled = true;
        process2.nextTick(resume_, stream, state3);
      }
    }
    function resume_(stream, state3) {
      debug("resume", state3.reading);
      if (!state3.reading) {
        stream.read(0);
      }
      state3.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state3.flowing && !state3.reading) stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState[kPaused] = true;
      return this;
    };
    function flow(stream) {
      const state3 = stream._readableState;
      debug("flow", state3.flowing);
      while (state3.flowing && stream.read() !== null) ;
    }
    Readable.prototype.wrap = function(stream) {
      let paused = false;
      stream.on("data", (chunk) => {
        if (!this.push(chunk) && stream.pause) {
          paused = true;
          stream.pause();
        }
      });
      stream.on("end", () => {
        this.push(null);
      });
      stream.on("error", (err) => {
        errorOrDestroy(this, err);
      });
      stream.on("close", () => {
        this.destroy();
      });
      stream.on("destroy", () => {
        this.destroy();
      });
      this._read = () => {
        if (paused && stream.resume) {
          paused = false;
          stream.resume();
        }
      };
      const streamKeys = ObjectKeys(stream);
      for (let j = 1; j < streamKeys.length; j++) {
        const i = streamKeys[j];
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = stream[i].bind(stream);
        }
      }
      return this;
    };
    Readable.prototype[SymbolAsyncIterator] = function() {
      return streamToAsyncIterator(this);
    };
    Readable.prototype.iterator = function(options) {
      if (options !== void 0) {
        validateObject(options, "options");
      }
      return streamToAsyncIterator(this, options);
    };
    function streamToAsyncIterator(stream, options) {
      if (typeof stream.read !== "function") {
        stream = Readable.wrap(stream, {
          objectMode: true
        });
      }
      const iter = createAsyncIterator(stream, options);
      iter.stream = stream;
      return iter;
    }
    async function* createAsyncIterator(stream, options) {
      let callback = nop;
      function next(resolve) {
        if (this === stream) {
          callback();
          callback = nop;
        } else {
          callback = resolve;
        }
      }
      stream.on("readable", next);
      let error;
      const cleanup = eos(
        stream,
        {
          writable: false
        },
        (err) => {
          error = err ? aggregateTwoErrors(error, err) : null;
          callback();
          callback = nop;
        }
      );
      try {
        while (true) {
          const chunk = stream.destroyed ? null : stream.read();
          if (chunk !== null) {
            yield chunk;
          } else if (error) {
            throw error;
          } else if (error === null) {
            return;
          } else {
            await new Promise2(next);
          }
        }
      } catch (err) {
        error = aggregateTwoErrors(error, err);
        throw error;
      } finally {
        if ((error || (options === null || options === void 0 ? void 0 : options.destroyOnReturn) !== false) && (error === void 0 || stream._readableState.autoDestroy)) {
          destroyImpl.destroyer(stream, null);
        } else {
          stream.off("readable", next);
          cleanup();
        }
      }
    }
    ObjectDefineProperties(Readable.prototype, {
      readable: {
        __proto__: null,
        get() {
          const r = this._readableState;
          return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
        },
        set(val) {
          if (this._readableState) {
            this._readableState.readable = !!val;
          }
        }
      },
      readableDidRead: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.dataEmitted;
        }
      },
      readableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
        }
      },
      readableHighWaterMark: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.highWaterMark;
        }
      },
      readableBuffer: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState && this._readableState.buffer;
        }
      },
      readableFlowing: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.flowing;
        },
        set: function(state3) {
          if (this._readableState) {
            this._readableState.flowing = state3;
          }
        }
      },
      readableLength: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState.length;
        }
      },
      readableObjectMode: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.objectMode : false;
        }
      },
      readableEncoding: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.encoding : null;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.errored : null;
        }
      },
      closed: {
        __proto__: null,
        get() {
          return this._readableState ? this._readableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.destroyed : false;
        },
        set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      },
      readableEnded: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.endEmitted : false;
        }
      }
    });
    ObjectDefineProperties(ReadableState.prototype, {
      // Legacy getter for `pipesCount`.
      pipesCount: {
        __proto__: null,
        get() {
          return this.pipes.length;
        }
      },
      // Legacy property for `paused`.
      paused: {
        __proto__: null,
        get() {
          return this[kPaused] !== false;
        },
        set(value) {
          this[kPaused] = !!value;
        }
      }
    });
    Readable._fromList = fromList;
    function fromList(n, state3) {
      if (state3.length === 0) return null;
      let ret;
      if (state3.objectMode) ret = state3.buffer.shift();
      else if (!n || n >= state3.length) {
        if (state3.decoder) ret = state3.buffer.join("");
        else if (state3.buffer.length === 1) ret = state3.buffer.first();
        else ret = state3.buffer.concat(state3.length);
        state3.buffer.clear();
      } else {
        ret = state3.buffer.consume(n, state3.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      const state3 = stream._readableState;
      debug("endReadable", state3.endEmitted);
      if (!state3.endEmitted) {
        state3.ended = true;
        process2.nextTick(endReadableNT, state3, stream);
      }
    }
    function endReadableNT(state3, stream) {
      debug("endReadableNT", state3.endEmitted, state3.length);
      if (!state3.errored && !state3.closeEmitted && !state3.endEmitted && state3.length === 0) {
        state3.endEmitted = true;
        stream.emit("end");
        if (stream.writable && stream.allowHalfOpen === false) {
          process2.nextTick(endWritableNT, stream);
        } else if (state3.autoDestroy) {
          const wState = stream._writableState;
          const autoDestroy = !wState || wState.autoDestroy && // We don't expect the writable to ever 'finish'
          // if writable is explicitly set to false.
          (wState.finished || wState.writable === false);
          if (autoDestroy) {
            stream.destroy();
          }
        }
      }
    }
    function endWritableNT(stream) {
      const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
      if (writable) {
        stream.end();
      }
    }
    Readable.from = function(iterable, opts) {
      return from(Readable, iterable, opts);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0) webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Readable.fromWeb = function(readableStream, options) {
      return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);
    };
    Readable.toWeb = function(streamReadable, options) {
      return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);
    };
    Readable.wrap = function(src, options) {
      var _ref, _src$readableObjectMo;
      return new Readable({
        objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== void 0 ? _src$readableObjectMo : src.objectMode) !== null && _ref !== void 0 ? _ref : true,
        ...options,
        destroy(err, callback) {
          destroyImpl.destroyer(src, err);
          callback(err);
        }
      }).wrap(src);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/writable.js
var require_writable = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/writable.js"(exports, module) {
    "use strict";
    var process2 = require_browser3();
    var {
      ArrayPrototypeSlice,
      Error: Error2,
      FunctionPrototypeSymbolHasInstance,
      ObjectDefineProperty,
      ObjectDefineProperties,
      ObjectSetPrototypeOf,
      StringPrototypeToLowerCase,
      Symbol: Symbol2,
      SymbolHasInstance
    } = require_primordials();
    module.exports = Writable;
    Writable.WritableState = WritableState;
    var { EventEmitter: EE } = require_events();
    var Stream = require_legacy().Stream;
    var { Buffer: Buffer2 } = require_buffer();
    var destroyImpl = require_destroy();
    var { addAbortSignal } = require_add_abort_signal();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
    var {
      ERR_INVALID_ARG_TYPE,
      ERR_METHOD_NOT_IMPLEMENTED,
      ERR_MULTIPLE_CALLBACK,
      ERR_STREAM_CANNOT_PIPE,
      ERR_STREAM_DESTROYED,
      ERR_STREAM_ALREADY_FINISHED,
      ERR_STREAM_NULL_VALUES,
      ERR_STREAM_WRITE_AFTER_END,
      ERR_UNKNOWN_ENCODING
    } = require_errors2().codes;
    var { errorOrDestroy } = destroyImpl;
    ObjectSetPrototypeOf(Writable.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Writable, Stream);
    function nop() {
    }
    var kOnFinished = Symbol2("kOnFinished");
    function WritableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof require_duplex();
      this.objectMode = !!(options && options.objectMode);
      if (isDuplex) this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
      this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      const noDecode = !!(options && options.decodeStrings === false);
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = onwrite.bind(void 0, stream);
      this.writecb = null;
      this.writelen = 0;
      this.afterWriteTickInfo = null;
      resetBuffer(this);
      this.pendingcb = 0;
      this.constructed = true;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = !options || options.emitClose !== false;
      this.autoDestroy = !options || options.autoDestroy !== false;
      this.errored = null;
      this.closed = false;
      this.closeEmitted = false;
      this[kOnFinished] = [];
    }
    function resetBuffer(state3) {
      state3.buffered = [];
      state3.bufferedIndex = 0;
      state3.allBuffers = true;
      state3.allNoop = true;
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);
    };
    ObjectDefineProperty(WritableState.prototype, "bufferedRequestCount", {
      __proto__: null,
      get() {
        return this.buffered.length - this.bufferedIndex;
      }
    });
    function Writable(options) {
      const isDuplex = this instanceof require_duplex();
      if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this)) return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
        if (typeof options.construct === "function") this._construct = options.construct;
        if (options.signal) addAbortSignal(options.signal, this);
      }
      Stream.call(this, options);
      destroyImpl.construct(this, () => {
        const state3 = this._writableState;
        if (!state3.writing) {
          clearBuffer(this, state3);
        }
        finishMaybe(this, state3);
      });
    }
    ObjectDefineProperty(Writable, SymbolHasInstance, {
      __proto__: null,
      value: function(object) {
        if (FunctionPrototypeSymbolHasInstance(this, object)) return true;
        if (this !== Writable) return false;
        return object && object._writableState instanceof WritableState;
      }
    });
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function _write(stream, chunk, encoding, cb) {
      const state3 = stream._writableState;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = state3.defaultEncoding;
      } else {
        if (!encoding) encoding = state3.defaultEncoding;
        else if (encoding !== "buffer" && !Buffer2.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);
        if (typeof cb !== "function") cb = nop;
      }
      if (chunk === null) {
        throw new ERR_STREAM_NULL_VALUES();
      } else if (!state3.objectMode) {
        if (typeof chunk === "string") {
          if (state3.decodeStrings !== false) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "buffer";
          }
        } else if (chunk instanceof Buffer2) {
          encoding = "buffer";
        } else if (Stream._isUint8Array(chunk)) {
          chunk = Stream._uint8ArrayToBuffer(chunk);
          encoding = "buffer";
        } else {
          throw new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      let err;
      if (state3.ending) {
        err = new ERR_STREAM_WRITE_AFTER_END();
      } else if (state3.destroyed) {
        err = new ERR_STREAM_DESTROYED("write");
      }
      if (err) {
        process2.nextTick(cb, err);
        errorOrDestroy(stream, err, true);
        return err;
      }
      state3.pendingcb++;
      return writeOrBuffer(stream, state3, chunk, encoding, cb);
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      return _write(this, chunk, encoding, cb) === true;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      const state3 = this._writableState;
      if (state3.corked) {
        state3.corked--;
        if (!state3.writing) clearBuffer(this, state3);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string") encoding = StringPrototypeToLowerCase(encoding);
      if (!Buffer2.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function writeOrBuffer(stream, state3, chunk, encoding, callback) {
      const len = state3.objectMode ? 1 : chunk.length;
      state3.length += len;
      const ret = state3.length < state3.highWaterMark;
      if (!ret) state3.needDrain = true;
      if (state3.writing || state3.corked || state3.errored || !state3.constructed) {
        state3.buffered.push({
          chunk,
          encoding,
          callback
        });
        if (state3.allBuffers && encoding !== "buffer") {
          state3.allBuffers = false;
        }
        if (state3.allNoop && callback !== nop) {
          state3.allNoop = false;
        }
      } else {
        state3.writelen = len;
        state3.writecb = callback;
        state3.writing = true;
        state3.sync = true;
        stream._write(chunk, encoding, state3.onwrite);
        state3.sync = false;
      }
      return ret && !state3.errored && !state3.destroyed;
    }
    function doWrite(stream, state3, writev, len, chunk, encoding, cb) {
      state3.writelen = len;
      state3.writecb = cb;
      state3.writing = true;
      state3.sync = true;
      if (state3.destroyed) state3.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev) stream._writev(chunk, state3.onwrite);
      else stream._write(chunk, encoding, state3.onwrite);
      state3.sync = false;
    }
    function onwriteError(stream, state3, er, cb) {
      --state3.pendingcb;
      cb(er);
      errorBuffer(state3);
      errorOrDestroy(stream, er);
    }
    function onwrite(stream, er) {
      const state3 = stream._writableState;
      const sync = state3.sync;
      const cb = state3.writecb;
      if (typeof cb !== "function") {
        errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());
        return;
      }
      state3.writing = false;
      state3.writecb = null;
      state3.length -= state3.writelen;
      state3.writelen = 0;
      if (er) {
        er.stack;
        if (!state3.errored) {
          state3.errored = er;
        }
        if (stream._readableState && !stream._readableState.errored) {
          stream._readableState.errored = er;
        }
        if (sync) {
          process2.nextTick(onwriteError, stream, state3, er, cb);
        } else {
          onwriteError(stream, state3, er, cb);
        }
      } else {
        if (state3.buffered.length > state3.bufferedIndex) {
          clearBuffer(stream, state3);
        }
        if (sync) {
          if (state3.afterWriteTickInfo !== null && state3.afterWriteTickInfo.cb === cb) {
            state3.afterWriteTickInfo.count++;
          } else {
            state3.afterWriteTickInfo = {
              count: 1,
              cb,
              stream,
              state: state3
            };
            process2.nextTick(afterWriteTick, state3.afterWriteTickInfo);
          }
        } else {
          afterWrite(stream, state3, 1, cb);
        }
      }
    }
    function afterWriteTick({ stream, state: state3, count, cb }) {
      state3.afterWriteTickInfo = null;
      return afterWrite(stream, state3, count, cb);
    }
    function afterWrite(stream, state3, count, cb) {
      const needDrain = !state3.ending && !stream.destroyed && state3.length === 0 && state3.needDrain;
      if (needDrain) {
        state3.needDrain = false;
        stream.emit("drain");
      }
      while (count-- > 0) {
        state3.pendingcb--;
        cb();
      }
      if (state3.destroyed) {
        errorBuffer(state3);
      }
      finishMaybe(stream, state3);
    }
    function errorBuffer(state3) {
      if (state3.writing) {
        return;
      }
      for (let n = state3.bufferedIndex; n < state3.buffered.length; ++n) {
        var _state$errored;
        const { chunk, callback } = state3.buffered[n];
        const len = state3.objectMode ? 1 : chunk.length;
        state3.length -= len;
        callback(
          (_state$errored = state3.errored) !== null && _state$errored !== void 0 ? _state$errored : new ERR_STREAM_DESTROYED("write")
        );
      }
      const onfinishCallbacks = state3[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        var _state$errored2;
        onfinishCallbacks[i](
          (_state$errored2 = state3.errored) !== null && _state$errored2 !== void 0 ? _state$errored2 : new ERR_STREAM_DESTROYED("end")
        );
      }
      resetBuffer(state3);
    }
    function clearBuffer(stream, state3) {
      if (state3.corked || state3.bufferProcessing || state3.destroyed || !state3.constructed) {
        return;
      }
      const { buffered, bufferedIndex, objectMode } = state3;
      const bufferedLength = buffered.length - bufferedIndex;
      if (!bufferedLength) {
        return;
      }
      let i = bufferedIndex;
      state3.bufferProcessing = true;
      if (bufferedLength > 1 && stream._writev) {
        state3.pendingcb -= bufferedLength - 1;
        const callback = state3.allNoop ? nop : (err) => {
          for (let n = i; n < buffered.length; ++n) {
            buffered[n].callback(err);
          }
        };
        const chunks = state3.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i);
        chunks.allBuffers = state3.allBuffers;
        doWrite(stream, state3, true, state3.length, chunks, "", callback);
        resetBuffer(state3);
      } else {
        do {
          const { chunk, encoding, callback } = buffered[i];
          buffered[i++] = null;
          const len = objectMode ? 1 : chunk.length;
          doWrite(stream, state3, false, len, chunk, encoding, callback);
        } while (i < buffered.length && !state3.writing);
        if (i === buffered.length) {
          resetBuffer(state3);
        } else if (i > 256) {
          buffered.splice(0, i);
          state3.bufferedIndex = 0;
        } else {
          state3.bufferedIndex = i;
        }
      }
      state3.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      if (this._writev) {
        this._writev(
          [
            {
              chunk,
              encoding
            }
          ],
          cb
        );
      } else {
        throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
      }
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      const state3 = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      let err;
      if (chunk !== null && chunk !== void 0) {
        const ret = _write(this, chunk, encoding);
        if (ret instanceof Error2) {
          err = ret;
        }
      }
      if (state3.corked) {
        state3.corked = 1;
        this.uncork();
      }
      if (err) {
      } else if (!state3.errored && !state3.ending) {
        state3.ending = true;
        finishMaybe(this, state3, true);
        state3.ended = true;
      } else if (state3.finished) {
        err = new ERR_STREAM_ALREADY_FINISHED("end");
      } else if (state3.destroyed) {
        err = new ERR_STREAM_DESTROYED("end");
      }
      if (typeof cb === "function") {
        if (err || state3.finished) {
          process2.nextTick(cb, err);
        } else {
          state3[kOnFinished].push(cb);
        }
      }
      return this;
    };
    function needFinish(state3) {
      return state3.ending && !state3.destroyed && state3.constructed && state3.length === 0 && !state3.errored && state3.buffered.length === 0 && !state3.finished && !state3.writing && !state3.errorEmitted && !state3.closeEmitted;
    }
    function callFinal(stream, state3) {
      let called = false;
      function onFinish(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        state3.pendingcb--;
        if (err) {
          const onfinishCallbacks = state3[kOnFinished].splice(0);
          for (let i = 0; i < onfinishCallbacks.length; i++) {
            onfinishCallbacks[i](err);
          }
          errorOrDestroy(stream, err, state3.sync);
        } else if (needFinish(state3)) {
          state3.prefinished = true;
          stream.emit("prefinish");
          state3.pendingcb++;
          process2.nextTick(finish, stream, state3);
        }
      }
      state3.sync = true;
      state3.pendingcb++;
      try {
        stream._final(onFinish);
      } catch (err) {
        onFinish(err);
      }
      state3.sync = false;
    }
    function prefinish(stream, state3) {
      if (!state3.prefinished && !state3.finalCalled) {
        if (typeof stream._final === "function" && !state3.destroyed) {
          state3.finalCalled = true;
          callFinal(stream, state3);
        } else {
          state3.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state3, sync) {
      if (needFinish(state3)) {
        prefinish(stream, state3);
        if (state3.pendingcb === 0) {
          if (sync) {
            state3.pendingcb++;
            process2.nextTick(
              (stream2, state4) => {
                if (needFinish(state4)) {
                  finish(stream2, state4);
                } else {
                  state4.pendingcb--;
                }
              },
              stream,
              state3
            );
          } else if (needFinish(state3)) {
            state3.pendingcb++;
            finish(stream, state3);
          }
        }
      }
    }
    function finish(stream, state3) {
      state3.pendingcb--;
      state3.finished = true;
      const onfinishCallbacks = state3[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        onfinishCallbacks[i]();
      }
      stream.emit("finish");
      if (state3.autoDestroy) {
        const rState = stream._readableState;
        const autoDestroy = !rState || rState.autoDestroy && // We don't expect the readable to ever 'end'
        // if readable is explicitly set to false.
        (rState.endEmitted || rState.readable === false);
        if (autoDestroy) {
          stream.destroy();
        }
      }
    }
    ObjectDefineProperties(Writable.prototype, {
      closed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.destroyed : false;
        },
        set(value) {
          if (this._writableState) {
            this._writableState.destroyed = value;
          }
        }
      },
      writable: {
        __proto__: null,
        get() {
          const w = this._writableState;
          return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
        },
        set(val) {
          if (this._writableState) {
            this._writableState.writable = !!val;
          }
        }
      },
      writableFinished: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.finished : false;
        }
      },
      writableObjectMode: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.objectMode : false;
        }
      },
      writableBuffer: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.getBuffer();
        }
      },
      writableEnded: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.ending : false;
        }
      },
      writableNeedDrain: {
        __proto__: null,
        get() {
          const wState = this._writableState;
          if (!wState) return false;
          return !wState.destroyed && !wState.ending && wState.needDrain;
        }
      },
      writableHighWaterMark: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.highWaterMark;
        }
      },
      writableCorked: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.corked : 0;
        }
      },
      writableLength: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.length;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._writableState ? this._writableState.errored : null;
        }
      },
      writableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
        }
      }
    });
    var destroy2 = destroyImpl.destroy;
    Writable.prototype.destroy = function(err, cb) {
      const state3 = this._writableState;
      if (!state3.destroyed && (state3.bufferedIndex < state3.buffered.length || state3[kOnFinished].length)) {
        process2.nextTick(errorBuffer, state3);
      }
      destroy2.call(this, err, cb);
      return this;
    };
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Writable.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0) webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Writable.fromWeb = function(writableStream, options) {
      return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);
    };
    Writable.toWeb = function(streamWritable) {
      return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/duplexify.js
var require_duplexify = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/duplexify.js"(exports, module) {
    var process2 = require_browser3();
    var bufferModule = require_buffer();
    var {
      isReadable,
      isWritable,
      isIterable,
      isNodeStream,
      isReadableNodeStream,
      isWritableNodeStream,
      isDuplexNodeStream,
      isReadableStream: isReadableStream2,
      isWritableStream
    } = require_utils3();
    var eos = require_end_of_stream();
    var {
      AbortError: AbortError3,
      codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE }
    } = require_errors2();
    var { destroyer } = require_destroy();
    var Duplex = require_duplex();
    var Readable = require_readable();
    var Writable = require_writable();
    var { createDeferredPromise } = require_util2();
    var from = require_from();
    var Blob2 = globalThis.Blob || bufferModule.Blob;
    var isBlob3 = typeof Blob2 !== "undefined" ? function isBlob4(b) {
      return b instanceof Blob2;
    } : function isBlob4(b) {
      return false;
    };
    var AbortController2 = globalThis.AbortController || require_browser2().AbortController;
    var { FunctionPrototypeCall } = require_primordials();
    var Duplexify = class extends Duplex {
      constructor(options) {
        super(options);
        if ((options === null || options === void 0 ? void 0 : options.readable) === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if ((options === null || options === void 0 ? void 0 : options.writable) === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      }
    };
    module.exports = function duplexify(body, name3) {
      if (isDuplexNodeStream(body)) {
        return body;
      }
      if (isReadableNodeStream(body)) {
        return _duplexify({
          readable: body
        });
      }
      if (isWritableNodeStream(body)) {
        return _duplexify({
          writable: body
        });
      }
      if (isNodeStream(body)) {
        return _duplexify({
          writable: false,
          readable: false
        });
      }
      if (isReadableStream2(body)) {
        return _duplexify({
          readable: Readable.fromWeb(body)
        });
      }
      if (isWritableStream(body)) {
        return _duplexify({
          writable: Writable.fromWeb(body)
        });
      }
      if (typeof body === "function") {
        const { value, write, final, destroy: destroy2 } = fromAsyncGen(body);
        if (isIterable(value)) {
          return from(Duplexify, value, {
            // TODO (ronag): highWaterMark?
            objectMode: true,
            write,
            final,
            destroy: destroy2
          });
        }
        const then2 = value === null || value === void 0 ? void 0 : value.then;
        if (typeof then2 === "function") {
          let d;
          const promise = FunctionPrototypeCall(
            then2,
            value,
            (val) => {
              if (val != null) {
                throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
              }
            },
            (err) => {
              destroyer(d, err);
            }
          );
          return d = new Duplexify({
            // TODO (ronag): highWaterMark?
            objectMode: true,
            readable: false,
            write,
            final(cb) {
              final(async () => {
                try {
                  await promise;
                  process2.nextTick(cb, null);
                } catch (err) {
                  process2.nextTick(cb, err);
                }
              });
            },
            destroy: destroy2
          });
        }
        throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name3, value);
      }
      if (isBlob3(body)) {
        return duplexify(body.arrayBuffer());
      }
      if (isIterable(body)) {
        return from(Duplexify, body, {
          // TODO (ronag): highWaterMark?
          objectMode: true,
          writable: false
        });
      }
      if (isReadableStream2(body === null || body === void 0 ? void 0 : body.readable) && isWritableStream(body === null || body === void 0 ? void 0 : body.writable)) {
        return Duplexify.fromWeb(body);
      }
      if (typeof (body === null || body === void 0 ? void 0 : body.writable) === "object" || typeof (body === null || body === void 0 ? void 0 : body.readable) === "object") {
        const readable = body !== null && body !== void 0 && body.readable ? isReadableNodeStream(body === null || body === void 0 ? void 0 : body.readable) ? body === null || body === void 0 ? void 0 : body.readable : duplexify(body.readable) : void 0;
        const writable = body !== null && body !== void 0 && body.writable ? isWritableNodeStream(body === null || body === void 0 ? void 0 : body.writable) ? body === null || body === void 0 ? void 0 : body.writable : duplexify(body.writable) : void 0;
        return _duplexify({
          readable,
          writable
        });
      }
      const then = body === null || body === void 0 ? void 0 : body.then;
      if (typeof then === "function") {
        let d;
        FunctionPrototypeCall(
          then,
          body,
          (val) => {
            if (val != null) {
              d.push(val);
            }
            d.push(null);
          },
          (err) => {
            destroyer(d, err);
          }
        );
        return d = new Duplexify({
          objectMode: true,
          writable: false,
          read() {
          }
        });
      }
      throw new ERR_INVALID_ARG_TYPE(
        name3,
        [
          "Blob",
          "ReadableStream",
          "WritableStream",
          "Stream",
          "Iterable",
          "AsyncIterable",
          "Function",
          "{ readable, writable } pair",
          "Promise"
        ],
        body
      );
    };
    function fromAsyncGen(fn) {
      let { promise, resolve } = createDeferredPromise();
      const ac = new AbortController2();
      const signal = ac.signal;
      const value = fn(
        async function* () {
          while (true) {
            const _promise = promise;
            promise = null;
            const { chunk, done, cb } = await _promise;
            process2.nextTick(cb);
            if (done) return;
            if (signal.aborted)
              throw new AbortError3(void 0, {
                cause: signal.reason
              });
            ({ promise, resolve } = createDeferredPromise());
            yield chunk;
          }
        }(),
        {
          signal
        }
      );
      return {
        value,
        write(chunk, encoding, cb) {
          const _resolve = resolve;
          resolve = null;
          _resolve({
            chunk,
            done: false,
            cb
          });
        },
        final(cb) {
          const _resolve = resolve;
          resolve = null;
          _resolve({
            done: true,
            cb
          });
        },
        destroy(err, cb) {
          ac.abort();
          cb(err);
        }
      };
    }
    function _duplexify(pair) {
      const r = pair.readable && typeof pair.readable.read !== "function" ? Readable.wrap(pair.readable) : pair.readable;
      const w = pair.writable;
      let readable = !!isReadable(r);
      let writable = !!isWritable(w);
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        }
      }
      d = new Duplexify({
        // TODO (ronag): highWaterMark?
        readableObjectMode: !!(r !== null && r !== void 0 && r.readableObjectMode),
        writableObjectMode: !!(w !== null && w !== void 0 && w.writableObjectMode),
        readable,
        writable
      });
      if (writable) {
        eos(w, (err) => {
          writable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        d._write = function(chunk, encoding, callback) {
          if (w.write(chunk, encoding)) {
            callback();
          } else {
            ondrain = callback;
          }
        };
        d._final = function(callback) {
          w.end();
          onfinish = callback;
        };
        w.on("drain", function() {
          if (ondrain) {
            const cb = ondrain;
            ondrain = null;
            cb();
          }
        });
        w.on("finish", function() {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        eos(r, (err) => {
          readable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        r.on("readable", function() {
          if (onreadable) {
            const cb = onreadable;
            onreadable = null;
            cb();
          }
        });
        r.on("end", function() {
          d.push(null);
        });
        d._read = function() {
          while (true) {
            const buf = r.read();
            if (buf === null) {
              onreadable = d._read;
              return;
            }
            if (!d.push(buf)) {
              return;
            }
          }
        };
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError3();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          destroyer(w, err);
          destroyer(r, err);
        }
      };
      return d;
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/duplex.js
var require_duplex = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/duplex.js"(exports, module) {
    "use strict";
    var {
      ObjectDefineProperties,
      ObjectGetOwnPropertyDescriptor,
      ObjectKeys,
      ObjectSetPrototypeOf
    } = require_primordials();
    module.exports = Duplex;
    var Readable = require_readable();
    var Writable = require_writable();
    ObjectSetPrototypeOf(Duplex.prototype, Readable.prototype);
    ObjectSetPrototypeOf(Duplex, Readable);
    {
      const keys = ObjectKeys(Writable.prototype);
      for (let i = 0; i < keys.length; i++) {
        const method = keys[i];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options) {
        this.allowHalfOpen = options.allowHalfOpen !== false;
        if (options.readable === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if (options.writable === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      } else {
        this.allowHalfOpen = true;
      }
    }
    ObjectDefineProperties(Duplex.prototype, {
      writable: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writable")
      },
      writableHighWaterMark: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark")
      },
      writableObjectMode: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableObjectMode")
      },
      writableBuffer: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableBuffer")
      },
      writableLength: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableLength")
      },
      writableFinished: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableFinished")
      },
      writableCorked: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableCorked")
      },
      writableEnded: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableEnded")
      },
      writableNeedDrain: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain")
      },
      destroyed: {
        __proto__: null,
        get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set(value) {
          if (this._readableState && this._writableState) {
            this._readableState.destroyed = value;
            this._writableState.destroyed = value;
          }
        }
      }
    });
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0) webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Duplex.fromWeb = function(pair, options) {
      return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
    };
    Duplex.toWeb = function(duplex) {
      return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);
    };
    var duplexify;
    Duplex.from = function(body) {
      if (!duplexify) {
        duplexify = require_duplexify();
      }
      return duplexify(body, "body");
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/transform.js
var require_transform = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/transform.js"(exports, module) {
    "use strict";
    var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials();
    module.exports = Transform;
    var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors2().codes;
    var Duplex = require_duplex();
    var { getHighWaterMark } = require_state();
    ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype);
    ObjectSetPrototypeOf(Transform, Duplex);
    var kCallback = Symbol2("kCallback");
    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);
      const readableHighWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", true) : null;
      if (readableHighWaterMark === 0) {
        options = {
          ...options,
          highWaterMark: null,
          readableHighWaterMark,
          // TODO (ronag): 0 is not optimal since we have
          // a "bug" where we check needDrain before calling _write and not after.
          // Refs: https://github.com/nodejs/node/pull/32887
          // Refs: https://github.com/nodejs/node/pull/35941
          writableHighWaterMark: options.writableHighWaterMark || 0
        };
      }
      Duplex.call(this, options);
      this._readableState.sync = false;
      this[kCallback] = null;
      if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function final(cb) {
      if (typeof this._flush === "function" && !this.destroyed) {
        this._flush((er, data) => {
          if (er) {
            if (cb) {
              cb(er);
            } else {
              this.destroy(er);
            }
            return;
          }
          if (data != null) {
            this.push(data);
          }
          this.push(null);
          if (cb) {
            cb();
          }
        });
      } else {
        this.push(null);
        if (cb) {
          cb();
        }
      }
    }
    function prefinish() {
      if (this._final !== final) {
        final.call(this);
      }
    }
    Transform.prototype._final = final;
    Transform.prototype._transform = function(chunk, encoding, callback) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
    };
    Transform.prototype._write = function(chunk, encoding, callback) {
      const rState = this._readableState;
      const wState = this._writableState;
      const length = rState.length;
      this._transform(chunk, encoding, (err, val) => {
        if (err) {
          callback(err);
          return;
        }
        if (val != null) {
          this.push(val);
        }
        if (wState.ended || // Backwards compat.
        length === rState.length || // Backwards compat.
        rState.length < rState.highWaterMark) {
          callback();
        } else {
          this[kCallback] = callback;
        }
      });
    };
    Transform.prototype._read = function() {
      if (this[kCallback]) {
        const callback = this[kCallback];
        this[kCallback] = null;
        callback();
      }
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/passthrough.js
var require_passthrough = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/passthrough.js"(exports, module) {
    "use strict";
    var { ObjectSetPrototypeOf } = require_primordials();
    module.exports = PassThrough;
    var Transform = require_transform();
    ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype);
    ObjectSetPrototypeOf(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough)) return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
    var process2 = require_browser3();
    var { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator, SymbolDispose } = require_primordials();
    var eos = require_end_of_stream();
    var { once } = require_util2();
    var destroyImpl = require_destroy();
    var Duplex = require_duplex();
    var {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE,
        ERR_INVALID_RETURN_VALUE,
        ERR_MISSING_ARGS,
        ERR_STREAM_DESTROYED,
        ERR_STREAM_PREMATURE_CLOSE
      },
      AbortError: AbortError3
    } = require_errors2();
    var { validateFunction, validateAbortSignal } = require_validators();
    var {
      isIterable,
      isReadable,
      isReadableNodeStream,
      isNodeStream,
      isTransformStream,
      isWebStream,
      isReadableStream: isReadableStream2,
      isReadableFinished
    } = require_utils3();
    var AbortController2 = globalThis.AbortController || require_browser2().AbortController;
    var PassThrough;
    var Readable;
    var addAbortListener;
    function destroyer(stream, reading, writing) {
      let finished = false;
      stream.on("close", () => {
        finished = true;
      });
      const cleanup = eos(
        stream,
        {
          readable: reading,
          writable: writing
        },
        (err) => {
          finished = !err;
        }
      );
      return {
        destroy: (err) => {
          if (finished) return;
          finished = true;
          destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED("pipe"));
        },
        cleanup
      };
    }
    function popCallback(streams) {
      validateFunction(streams[streams.length - 1], "streams[stream.length - 1]");
      return streams.pop();
    }
    function makeAsyncIterable(val) {
      if (isIterable(val)) {
        return val;
      } else if (isReadableNodeStream(val)) {
        return fromReadable(val);
      }
      throw new ERR_INVALID_ARG_TYPE("val", ["Readable", "Iterable", "AsyncIterable"], val);
    }
    async function* fromReadable(val) {
      if (!Readable) {
        Readable = require_readable();
      }
      yield* Readable.prototype[SymbolAsyncIterator].call(val);
    }
    async function pumpToNode(iterable, writable, finish, { end }) {
      let error;
      let onresolve = null;
      const resume = (err) => {
        if (err) {
          error = err;
        }
        if (onresolve) {
          const callback = onresolve;
          onresolve = null;
          callback();
        }
      };
      const wait = () => new Promise2((resolve, reject) => {
        if (error) {
          reject(error);
        } else {
          onresolve = () => {
            if (error) {
              reject(error);
            } else {
              resolve();
            }
          };
        }
      });
      writable.on("drain", resume);
      const cleanup = eos(
        writable,
        {
          readable: false
        },
        resume
      );
      try {
        if (writable.writableNeedDrain) {
          await wait();
        }
        for await (const chunk of iterable) {
          if (!writable.write(chunk)) {
            await wait();
          }
        }
        if (end) {
          writable.end();
          await wait();
        }
        finish();
      } catch (err) {
        finish(error !== err ? aggregateTwoErrors(error, err) : err);
      } finally {
        cleanup();
        writable.off("drain", resume);
      }
    }
    async function pumpToWeb(readable, writable, finish, { end }) {
      if (isTransformStream(writable)) {
        writable = writable.writable;
      }
      const writer = writable.getWriter();
      try {
        for await (const chunk of readable) {
          await writer.ready;
          writer.write(chunk).catch(() => {
          });
        }
        await writer.ready;
        if (end) {
          await writer.close();
        }
        finish();
      } catch (err) {
        try {
          await writer.abort(err);
          finish(err);
        } catch (err2) {
          finish(err2);
        }
      }
    }
    function pipeline(...streams) {
      return pipelineImpl(streams, once(popCallback(streams)));
    }
    function pipelineImpl(streams, callback, opts) {
      if (streams.length === 1 && ArrayIsArray(streams[0])) {
        streams = streams[0];
      }
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      const ac = new AbortController2();
      const signal = ac.signal;
      const outerSignal = opts === null || opts === void 0 ? void 0 : opts.signal;
      const lastStreamCleanup = [];
      validateAbortSignal(outerSignal, "options.signal");
      function abort() {
        finishImpl(new AbortError3());
      }
      addAbortListener = addAbortListener || require_util2().addAbortListener;
      let disposable;
      if (outerSignal) {
        disposable = addAbortListener(outerSignal, abort);
      }
      let error;
      let value;
      const destroys = [];
      let finishCount = 0;
      function finish(err) {
        finishImpl(err, --finishCount === 0);
      }
      function finishImpl(err, final) {
        var _disposable;
        if (err && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE")) {
          error = err;
        }
        if (!error && !final) {
          return;
        }
        while (destroys.length) {
          destroys.shift()(error);
        }
        ;
        (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable[SymbolDispose]();
        ac.abort();
        if (final) {
          if (!error) {
            lastStreamCleanup.forEach((fn) => fn());
          }
          process2.nextTick(callback, error, value);
        }
      }
      let ret;
      for (let i = 0; i < streams.length; i++) {
        const stream = streams[i];
        const reading = i < streams.length - 1;
        const writing = i > 0;
        const end = reading || (opts === null || opts === void 0 ? void 0 : opts.end) !== false;
        const isLastStream = i === streams.length - 1;
        if (isNodeStream(stream)) {
          let onError2 = function(err) {
            if (err && err.name !== "AbortError" && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
              finish(err);
            }
          };
          var onError = onError2;
          if (end) {
            const { destroy: destroy2, cleanup } = destroyer(stream, reading, writing);
            destroys.push(destroy2);
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
          stream.on("error", onError2);
          if (isReadable(stream) && isLastStream) {
            lastStreamCleanup.push(() => {
              stream.removeListener("error", onError2);
            });
          }
        }
        if (i === 0) {
          if (typeof stream === "function") {
            ret = stream({
              signal
            });
            if (!isIterable(ret)) {
              throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
            }
          } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {
            ret = stream;
          } else {
            ret = Duplex.from(stream);
          }
        } else if (typeof stream === "function") {
          if (isTransformStream(ret)) {
            var _ret;
            ret = makeAsyncIterable((_ret = ret) === null || _ret === void 0 ? void 0 : _ret.readable);
          } else {
            ret = makeAsyncIterable(ret);
          }
          ret = stream(ret, {
            signal
          });
          if (reading) {
            if (!isIterable(ret, true)) {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i - 1}]`, ret);
            }
          } else {
            var _ret2;
            if (!PassThrough) {
              PassThrough = require_passthrough();
            }
            const pt = new PassThrough({
              objectMode: true
            });
            const then = (_ret2 = ret) === null || _ret2 === void 0 ? void 0 : _ret2.then;
            if (typeof then === "function") {
              finishCount++;
              then.call(
                ret,
                (val) => {
                  value = val;
                  if (val != null) {
                    pt.write(val);
                  }
                  if (end) {
                    pt.end();
                  }
                  process2.nextTick(finish);
                },
                (err) => {
                  pt.destroy(err);
                  process2.nextTick(finish, err);
                }
              );
            } else if (isIterable(ret, true)) {
              finishCount++;
              pumpToNode(ret, pt, finish, {
                end
              });
            } else if (isReadableStream2(ret) || isTransformStream(ret)) {
              const toRead = ret.readable || ret;
              finishCount++;
              pumpToNode(toRead, pt, finish, {
                end
              });
            } else {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
            }
            ret = pt;
            const { destroy: destroy2, cleanup } = destroyer(ret, false, true);
            destroys.push(destroy2);
            if (isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
        } else if (isNodeStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount += 2;
            const cleanup = pipe(ret, stream, finish, {
              end
            });
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          } else if (isTransformStream(ret) || isReadableStream2(ret)) {
            const toRead = ret.readable || ret;
            finishCount++;
            pumpToNode(toRead, stream, finish, {
              end
            });
          } else if (isIterable(ret)) {
            finishCount++;
            pumpToNode(ret, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE(
              "val",
              ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
              ret
            );
          }
          ret = stream;
        } else if (isWebStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount++;
            pumpToWeb(makeAsyncIterable(ret), stream, finish, {
              end
            });
          } else if (isReadableStream2(ret) || isIterable(ret)) {
            finishCount++;
            pumpToWeb(ret, stream, finish, {
              end
            });
          } else if (isTransformStream(ret)) {
            finishCount++;
            pumpToWeb(ret.readable, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE(
              "val",
              ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
              ret
            );
          }
          ret = stream;
        } else {
          ret = Duplex.from(stream);
        }
      }
      if (signal !== null && signal !== void 0 && signal.aborted || outerSignal !== null && outerSignal !== void 0 && outerSignal.aborted) {
        process2.nextTick(abort);
      }
      return ret;
    }
    function pipe(src, dst, finish, { end }) {
      let ended = false;
      dst.on("close", () => {
        if (!ended) {
          finish(new ERR_STREAM_PREMATURE_CLOSE());
        }
      });
      src.pipe(dst, {
        end: false
      });
      if (end) {
        let endFn2 = function() {
          ended = true;
          dst.end();
        };
        var endFn = endFn2;
        if (isReadableFinished(src)) {
          process2.nextTick(endFn2);
        } else {
          src.once("end", endFn2);
        }
      } else {
        finish();
      }
      eos(
        src,
        {
          readable: true,
          writable: false
        },
        (err) => {
          const rState = src._readableState;
          if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
            src.once("end", finish).once("error", finish);
          } else {
            finish(err);
          }
        }
      );
      return eos(
        dst,
        {
          readable: false,
          writable: true
        },
        finish
      );
    }
    module.exports = {
      pipelineImpl,
      pipeline
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/compose.js
var require_compose = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/compose.js"(exports, module) {
    "use strict";
    var { pipeline } = require_pipeline();
    var Duplex = require_duplex();
    var { destroyer } = require_destroy();
    var {
      isNodeStream,
      isReadable,
      isWritable,
      isWebStream,
      isTransformStream,
      isWritableStream,
      isReadableStream: isReadableStream2
    } = require_utils3();
    var {
      AbortError: AbortError3,
      codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }
    } = require_errors2();
    var eos = require_end_of_stream();
    module.exports = function compose(...streams) {
      if (streams.length === 0) {
        throw new ERR_MISSING_ARGS("streams");
      }
      if (streams.length === 1) {
        return Duplex.from(streams[0]);
      }
      const orgStreams = [...streams];
      if (typeof streams[0] === "function") {
        streams[0] = Duplex.from(streams[0]);
      }
      if (typeof streams[streams.length - 1] === "function") {
        const idx = streams.length - 1;
        streams[idx] = Duplex.from(streams[idx]);
      }
      for (let n = 0; n < streams.length; ++n) {
        if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {
          continue;
        }
        if (n < streams.length - 1 && !(isReadable(streams[n]) || isReadableStream2(streams[n]) || isTransformStream(streams[n]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
        }
        if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
        }
      }
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        } else if (!readable && !writable) {
          d.destroy();
        }
      }
      const head = streams[0];
      const tail = pipeline(streams, onfinished);
      const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head));
      const readable = !!(isReadable(tail) || isReadableStream2(tail) || isTransformStream(tail));
      d = new Duplex({
        // TODO (ronag): highWaterMark?
        writableObjectMode: !!(head !== null && head !== void 0 && head.writableObjectMode),
        readableObjectMode: !!(tail !== null && tail !== void 0 && tail.readableObjectMode),
        writable,
        readable
      });
      if (writable) {
        if (isNodeStream(head)) {
          d._write = function(chunk, encoding, callback) {
            if (head.write(chunk, encoding)) {
              callback();
            } else {
              ondrain = callback;
            }
          };
          d._final = function(callback) {
            head.end();
            onfinish = callback;
          };
          head.on("drain", function() {
            if (ondrain) {
              const cb = ondrain;
              ondrain = null;
              cb();
            }
          });
        } else if (isWebStream(head)) {
          const writable2 = isTransformStream(head) ? head.writable : head;
          const writer = writable2.getWriter();
          d._write = async function(chunk, encoding, callback) {
            try {
              await writer.ready;
              writer.write(chunk).catch(() => {
              });
              callback();
            } catch (err) {
              callback(err);
            }
          };
          d._final = async function(callback) {
            try {
              await writer.ready;
              writer.close().catch(() => {
              });
              onfinish = callback;
            } catch (err) {
              callback(err);
            }
          };
        }
        const toRead = isTransformStream(tail) ? tail.readable : tail;
        eos(toRead, () => {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        if (isNodeStream(tail)) {
          tail.on("readable", function() {
            if (onreadable) {
              const cb = onreadable;
              onreadable = null;
              cb();
            }
          });
          tail.on("end", function() {
            d.push(null);
          });
          d._read = function() {
            while (true) {
              const buf = tail.read();
              if (buf === null) {
                onreadable = d._read;
                return;
              }
              if (!d.push(buf)) {
                return;
              }
            }
          };
        } else if (isWebStream(tail)) {
          const readable2 = isTransformStream(tail) ? tail.readable : tail;
          const reader = readable2.getReader();
          d._read = async function() {
            while (true) {
              try {
                const { value, done } = await reader.read();
                if (!d.push(value)) {
                  return;
                }
                if (done) {
                  d.push(null);
                  return;
                }
              } catch {
                return;
              }
            }
          };
        }
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError3();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          if (isNodeStream(tail)) {
            destroyer(tail, err);
          }
        }
      };
      return d;
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/operators.js
var require_operators = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/operators.js"(exports, module) {
    "use strict";
    var AbortController2 = globalThis.AbortController || require_browser2().AbortController;
    var {
      codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },
      AbortError: AbortError3
    } = require_errors2();
    var { validateAbortSignal, validateInteger, validateObject } = require_validators();
    var kWeakHandler = require_primordials().Symbol("kWeak");
    var kResistStopPropagation = require_primordials().Symbol("kResistStopPropagation");
    var { finished } = require_end_of_stream();
    var staticCompose = require_compose();
    var { addAbortSignalNoValidate } = require_add_abort_signal();
    var { isWritable, isNodeStream } = require_utils3();
    var { deprecate } = require_util2();
    var {
      ArrayPrototypePush,
      Boolean: Boolean2,
      MathFloor,
      Number: Number2,
      NumberIsNaN,
      Promise: Promise2,
      PromiseReject,
      PromiseResolve,
      PromisePrototypeThen,
      Symbol: Symbol2
    } = require_primordials();
    var kEmpty = Symbol2("kEmpty");
    var kEof = Symbol2("kEof");
    function compose(stream, options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      if (isNodeStream(stream) && !isWritable(stream)) {
        throw new ERR_INVALID_ARG_VALUE("stream", stream, "must be writable");
      }
      const composedStream = staticCompose(this, stream);
      if (options !== null && options !== void 0 && options.signal) {
        addAbortSignalNoValidate(options.signal, composedStream);
      }
      return composedStream;
    }
    function map(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let concurrency = 1;
      if ((options === null || options === void 0 ? void 0 : options.concurrency) != null) {
        concurrency = MathFloor(options.concurrency);
      }
      let highWaterMark = concurrency - 1;
      if ((options === null || options === void 0 ? void 0 : options.highWaterMark) != null) {
        highWaterMark = MathFloor(options.highWaterMark);
      }
      validateInteger(concurrency, "options.concurrency", 1);
      validateInteger(highWaterMark, "options.highWaterMark", 0);
      highWaterMark += concurrency;
      return (async function* map2() {
        const signal = require_util2().AbortSignalAny(
          [options === null || options === void 0 ? void 0 : options.signal].filter(Boolean2)
        );
        const stream = this;
        const queue = [];
        const signalOpt = {
          signal
        };
        let next;
        let resume;
        let done = false;
        let cnt = 0;
        function onCatch() {
          done = true;
          afterItemProcessed();
        }
        function afterItemProcessed() {
          cnt -= 1;
          maybeResume();
        }
        function maybeResume() {
          if (resume && !done && cnt < concurrency && queue.length < highWaterMark) {
            resume();
            resume = null;
          }
        }
        async function pump() {
          try {
            for await (let val of stream) {
              if (done) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError3();
              }
              try {
                val = fn(val, signalOpt);
                if (val === kEmpty) {
                  continue;
                }
                val = PromiseResolve(val);
              } catch (err) {
                val = PromiseReject(err);
              }
              cnt += 1;
              PromisePrototypeThen(val, afterItemProcessed, onCatch);
              queue.push(val);
              if (next) {
                next();
                next = null;
              }
              if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) {
                await new Promise2((resolve) => {
                  resume = resolve;
                });
              }
            }
            queue.push(kEof);
          } catch (err) {
            const val = PromiseReject(err);
            PromisePrototypeThen(val, afterItemProcessed, onCatch);
            queue.push(val);
          } finally {
            done = true;
            if (next) {
              next();
              next = null;
            }
          }
        }
        pump();
        try {
          while (true) {
            while (queue.length > 0) {
              const val = await queue[0];
              if (val === kEof) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError3();
              }
              if (val !== kEmpty) {
                yield val;
              }
              queue.shift();
              maybeResume();
            }
            await new Promise2((resolve) => {
              next = resolve;
            });
          }
        } finally {
          done = true;
          if (resume) {
            resume();
            resume = null;
          }
        }
      }).call(this);
    }
    function asIndexedPairs(options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      return (async function* asIndexedPairs2() {
        let index = 0;
        for await (const val of this) {
          var _options$signal;
          if (options !== null && options !== void 0 && (_options$signal = options.signal) !== null && _options$signal !== void 0 && _options$signal.aborted) {
            throw new AbortError3({
              cause: options.signal.reason
            });
          }
          yield [index++, val];
        }
      }).call(this);
    }
    async function some(fn, options = void 0) {
      for await (const unused of filter.call(this, fn, options)) {
        return true;
      }
      return false;
    }
    async function every(fn, options = void 0) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      return !await some.call(
        this,
        async (...args) => {
          return !await fn(...args);
        },
        options
      );
    }
    async function find(fn, options) {
      for await (const result of filter.call(this, fn, options)) {
        return result;
      }
      return void 0;
    }
    async function forEach(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      async function forEachFn(value, options2) {
        await fn(value, options2);
        return kEmpty;
      }
      for await (const unused of map.call(this, forEachFn, options)) ;
    }
    function filter(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      async function filterFn(value, options2) {
        if (await fn(value, options2)) {
          return value;
        }
        return kEmpty;
      }
      return map.call(this, filterFn, options);
    }
    var ReduceAwareErrMissingArgs = class extends ERR_MISSING_ARGS {
      constructor() {
        super("reduce");
        this.message = "Reduce of an empty stream requires an initial value";
      }
    };
    async function reduce(reducer, initialValue, options) {
      var _options$signal2;
      if (typeof reducer !== "function") {
        throw new ERR_INVALID_ARG_TYPE("reducer", ["Function", "AsyncFunction"], reducer);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let hasInitialValue = arguments.length > 1;
      if (options !== null && options !== void 0 && (_options$signal2 = options.signal) !== null && _options$signal2 !== void 0 && _options$signal2.aborted) {
        const err = new AbortError3(void 0, {
          cause: options.signal.reason
        });
        this.once("error", () => {
        });
        await finished(this.destroy(err));
        throw err;
      }
      const ac = new AbortController2();
      const signal = ac.signal;
      if (options !== null && options !== void 0 && options.signal) {
        const opts = {
          once: true,
          [kWeakHandler]: this,
          [kResistStopPropagation]: true
        };
        options.signal.addEventListener("abort", () => ac.abort(), opts);
      }
      let gotAnyItemFromStream = false;
      try {
        for await (const value of this) {
          var _options$signal3;
          gotAnyItemFromStream = true;
          if (options !== null && options !== void 0 && (_options$signal3 = options.signal) !== null && _options$signal3 !== void 0 && _options$signal3.aborted) {
            throw new AbortError3();
          }
          if (!hasInitialValue) {
            initialValue = value;
            hasInitialValue = true;
          } else {
            initialValue = await reducer(initialValue, value, {
              signal
            });
          }
        }
        if (!gotAnyItemFromStream && !hasInitialValue) {
          throw new ReduceAwareErrMissingArgs();
        }
      } finally {
        ac.abort();
      }
      return initialValue;
    }
    async function toArray(options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      const result = [];
      for await (const val of this) {
        var _options$signal4;
        if (options !== null && options !== void 0 && (_options$signal4 = options.signal) !== null && _options$signal4 !== void 0 && _options$signal4.aborted) {
          throw new AbortError3(void 0, {
            cause: options.signal.reason
          });
        }
        ArrayPrototypePush(result, val);
      }
      return result;
    }
    function flatMap(fn, options) {
      const values = map.call(this, fn, options);
      return (async function* flatMap2() {
        for await (const val of values) {
          yield* val;
        }
      }).call(this);
    }
    function toIntegerOrInfinity(number) {
      number = Number2(number);
      if (NumberIsNaN(number)) {
        return 0;
      }
      if (number < 0) {
        throw new ERR_OUT_OF_RANGE("number", ">= 0", number);
      }
      return number;
    }
    function drop(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return (async function* drop2() {
        var _options$signal5;
        if (options !== null && options !== void 0 && (_options$signal5 = options.signal) !== null && _options$signal5 !== void 0 && _options$signal5.aborted) {
          throw new AbortError3();
        }
        for await (const val of this) {
          var _options$signal6;
          if (options !== null && options !== void 0 && (_options$signal6 = options.signal) !== null && _options$signal6 !== void 0 && _options$signal6.aborted) {
            throw new AbortError3();
          }
          if (number-- <= 0) {
            yield val;
          }
        }
      }).call(this);
    }
    function take(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return (async function* take2() {
        var _options$signal7;
        if (options !== null && options !== void 0 && (_options$signal7 = options.signal) !== null && _options$signal7 !== void 0 && _options$signal7.aborted) {
          throw new AbortError3();
        }
        for await (const val of this) {
          var _options$signal8;
          if (options !== null && options !== void 0 && (_options$signal8 = options.signal) !== null && _options$signal8 !== void 0 && _options$signal8.aborted) {
            throw new AbortError3();
          }
          if (number-- > 0) {
            yield val;
          }
          if (number <= 0) {
            return;
          }
        }
      }).call(this);
    }
    module.exports.streamReturningOperators = {
      asIndexedPairs: deprecate(asIndexedPairs, "readable.asIndexedPairs will be removed in a future version."),
      drop,
      filter,
      flatMap,
      map,
      take,
      compose
    };
    module.exports.promiseReturningOperators = {
      every,
      forEach,
      reduce,
      toArray,
      some,
      find
    };
  }
});

// node_modules/readable-stream/lib/stream/promises.js
var require_promises = __commonJS({
  "node_modules/readable-stream/lib/stream/promises.js"(exports, module) {
    "use strict";
    var { ArrayPrototypePop, Promise: Promise2 } = require_primordials();
    var { isIterable, isNodeStream, isWebStream } = require_utils3();
    var { pipelineImpl: pl } = require_pipeline();
    var { finished } = require_end_of_stream();
    require_stream2();
    function pipeline(...streams) {
      return new Promise2((resolve, reject) => {
        let signal;
        let end;
        const lastArg = streams[streams.length - 1];
        if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg) && !isWebStream(lastArg)) {
          const options = ArrayPrototypePop(streams);
          signal = options.signal;
          end = options.end;
        }
        pl(
          streams,
          (err, value) => {
            if (err) {
              reject(err);
            } else {
              resolve(value);
            }
          },
          {
            signal,
            end
          }
        );
      });
    }
    module.exports = {
      finished,
      pipeline
    };
  }
});

// node_modules/readable-stream/lib/stream.js
var require_stream2 = __commonJS({
  "node_modules/readable-stream/lib/stream.js"(exports, module) {
    "use strict";
    var { Buffer: Buffer2 } = require_buffer();
    var { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials();
    var {
      promisify: { custom: customPromisify }
    } = require_util2();
    var { streamReturningOperators, promiseReturningOperators } = require_operators();
    var {
      codes: { ERR_ILLEGAL_CONSTRUCTOR }
    } = require_errors2();
    var compose = require_compose();
    var { setDefaultHighWaterMark, getDefaultHighWaterMark } = require_state();
    var { pipeline } = require_pipeline();
    var { destroyer } = require_destroy();
    var eos = require_end_of_stream();
    var promises = require_promises();
    var utils = require_utils3();
    var Stream = module.exports = require_legacy().Stream;
    Stream.isDestroyed = utils.isDestroyed;
    Stream.isDisturbed = utils.isDisturbed;
    Stream.isErrored = utils.isErrored;
    Stream.isReadable = utils.isReadable;
    Stream.isWritable = utils.isWritable;
    Stream.Readable = require_readable();
    for (const key of ObjectKeys(streamReturningOperators)) {
      let fn = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return Stream.Readable.from(ReflectApply(op, this, args));
      };
      const op = streamReturningOperators[key];
      ObjectDefineProperty(fn, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream.Readable.prototype, key, {
        __proto__: null,
        value: fn,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    for (const key of ObjectKeys(promiseReturningOperators)) {
      let fn = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return ReflectApply(op, this, args);
      };
      const op = promiseReturningOperators[key];
      ObjectDefineProperty(fn, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream.Readable.prototype, key, {
        __proto__: null,
        value: fn,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    Stream.Writable = require_writable();
    Stream.Duplex = require_duplex();
    Stream.Transform = require_transform();
    Stream.PassThrough = require_passthrough();
    Stream.pipeline = pipeline;
    var { addAbortSignal } = require_add_abort_signal();
    Stream.addAbortSignal = addAbortSignal;
    Stream.finished = eos;
    Stream.destroy = destroyer;
    Stream.compose = compose;
    Stream.setDefaultHighWaterMark = setDefaultHighWaterMark;
    Stream.getDefaultHighWaterMark = getDefaultHighWaterMark;
    ObjectDefineProperty(Stream, "promises", {
      __proto__: null,
      configurable: true,
      enumerable: true,
      get() {
        return promises;
      }
    });
    ObjectDefineProperty(pipeline, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises.pipeline;
      }
    });
    ObjectDefineProperty(eos, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises.finished;
      }
    });
    Stream.Stream = Stream;
    Stream._isUint8Array = function isUint8Array(value) {
      return value instanceof Uint8Array;
    };
    Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    };
  }
});

// node_modules/readable-stream/lib/ours/browser.js
var require_browser4 = __commonJS({
  "node_modules/readable-stream/lib/ours/browser.js"(exports, module) {
    "use strict";
    var CustomStream = require_stream2();
    var promises = require_promises();
    var originalDestroy = CustomStream.Readable.destroy;
    module.exports = CustomStream.Readable;
    module.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;
    module.exports._isUint8Array = CustomStream._isUint8Array;
    module.exports.isDisturbed = CustomStream.isDisturbed;
    module.exports.isErrored = CustomStream.isErrored;
    module.exports.isReadable = CustomStream.isReadable;
    module.exports.Readable = CustomStream.Readable;
    module.exports.Writable = CustomStream.Writable;
    module.exports.Duplex = CustomStream.Duplex;
    module.exports.Transform = CustomStream.Transform;
    module.exports.PassThrough = CustomStream.PassThrough;
    module.exports.addAbortSignal = CustomStream.addAbortSignal;
    module.exports.finished = CustomStream.finished;
    module.exports.destroy = CustomStream.destroy;
    module.exports.destroy = originalDestroy;
    module.exports.pipeline = CustomStream.pipeline;
    module.exports.compose = CustomStream.compose;
    Object.defineProperty(CustomStream, "promises", {
      configurable: true,
      enumerable: true,
      get() {
        return promises;
      }
    });
    module.exports.Stream = CustomStream.Stream;
    module.exports.default = module.exports;
  }
});

// node_modules/bl/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/bl/BufferList.js"(exports, module) {
    "use strict";
    var { Buffer: Buffer2 } = require_buffer();
    var symbol = Symbol.for("BufferList");
    function BufferList(buf) {
      if (!(this instanceof BufferList)) {
        return new BufferList(buf);
      }
      BufferList._init.call(this, buf);
    }
    BufferList._init = function _init2(buf) {
      Object.defineProperty(this, symbol, { value: true });
      this._bufs = [];
      this.length = 0;
      if (buf) {
        this.append(buf);
      }
    };
    BufferList.prototype._new = function _new(buf) {
      return new BufferList(buf);
    };
    BufferList.prototype._offset = function _offset(offset) {
      if (offset === 0) {
        return [0, 0];
      }
      let tot = 0;
      for (let i = 0; i < this._bufs.length; i++) {
        const _t = tot + this._bufs[i].length;
        if (offset < _t || i === this._bufs.length - 1) {
          return [i, offset - tot];
        }
        tot = _t;
      }
    };
    BufferList.prototype._reverseOffset = function(blOffset) {
      const bufferId = blOffset[0];
      let offset = blOffset[1];
      for (let i = 0; i < bufferId; i++) {
        offset += this._bufs[i].length;
      }
      return offset;
    };
    BufferList.prototype.getBuffers = function getBuffers() {
      return this._bufs;
    };
    BufferList.prototype.get = function get(index) {
      if (index > this.length || index < 0) {
        return void 0;
      }
      const offset = this._offset(index);
      return this._bufs[offset[0]][offset[1]];
    };
    BufferList.prototype.slice = function slice(start, end) {
      if (typeof start === "number" && start < 0) {
        start += this.length;
      }
      if (typeof end === "number" && end < 0) {
        end += this.length;
      }
      return this.copy(null, 0, start, end);
    };
    BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart !== "number" || srcStart < 0) {
        srcStart = 0;
      }
      if (typeof srcEnd !== "number" || srcEnd > this.length) {
        srcEnd = this.length;
      }
      if (srcStart >= this.length) {
        return dst || Buffer2.alloc(0);
      }
      if (srcEnd <= 0) {
        return dst || Buffer2.alloc(0);
      }
      const copy2 = !!dst;
      const off = this._offset(srcStart);
      const len = srcEnd - srcStart;
      let bytes = len;
      let bufoff = copy2 && dstStart || 0;
      let start = off[1];
      if (srcStart === 0 && srcEnd === this.length) {
        if (!copy2) {
          return this._bufs.length === 1 ? this._bufs[0] : Buffer2.concat(this._bufs, this.length);
        }
        for (let i = 0; i < this._bufs.length; i++) {
          this._bufs[i].copy(dst, bufoff);
          bufoff += this._bufs[i].length;
        }
        return dst;
      }
      if (bytes <= this._bufs[off[0]].length - start) {
        return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
      }
      if (!copy2) {
        dst = Buffer2.allocUnsafe(len);
      }
      for (let i = off[0]; i < this._bufs.length; i++) {
        const l = this._bufs[i].length - start;
        if (bytes > l) {
          this._bufs[i].copy(dst, bufoff, start);
          bufoff += l;
        } else {
          this._bufs[i].copy(dst, bufoff, start, start + bytes);
          bufoff += l;
          break;
        }
        bytes -= l;
        if (start) {
          start = 0;
        }
      }
      if (dst.length > bufoff) return dst.slice(0, bufoff);
      return dst;
    };
    BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
      start = start || 0;
      end = typeof end !== "number" ? this.length : end;
      if (start < 0) {
        start += this.length;
      }
      if (end < 0) {
        end += this.length;
      }
      if (start === end) {
        return this._new();
      }
      const startOffset = this._offset(start);
      const endOffset = this._offset(end);
      const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
      if (endOffset[1] === 0) {
        buffers.pop();
      } else {
        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
      }
      if (startOffset[1] !== 0) {
        buffers[0] = buffers[0].slice(startOffset[1]);
      }
      return this._new(buffers);
    };
    BufferList.prototype.toString = function toString(encoding, start, end) {
      return this.slice(start, end).toString(encoding);
    };
    BufferList.prototype.consume = function consume(bytes) {
      bytes = Math.trunc(bytes);
      if (Number.isNaN(bytes) || bytes <= 0) return this;
      while (this._bufs.length) {
        if (bytes >= this._bufs[0].length) {
          bytes -= this._bufs[0].length;
          this.length -= this._bufs[0].length;
          this._bufs.shift();
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes);
          this.length -= bytes;
          break;
        }
      }
      return this;
    };
    BufferList.prototype.duplicate = function duplicate() {
      const copy = this._new();
      for (let i = 0; i < this._bufs.length; i++) {
        copy.append(this._bufs[i]);
      }
      return copy;
    };
    BufferList.prototype.append = function append(buf) {
      return this._attach(buf, BufferList.prototype._appendBuffer);
    };
    BufferList.prototype.prepend = function prepend(buf) {
      return this._attach(buf, BufferList.prototype._prependBuffer, true);
    };
    BufferList.prototype._attach = function _attach(buf, attacher, prepend) {
      if (buf == null) {
        return this;
      }
      if (buf.buffer) {
        attacher.call(this, Buffer2.from(buf.buffer, buf.byteOffset, buf.byteLength));
      } else if (Array.isArray(buf)) {
        const [starting, modifier] = prepend ? [buf.length - 1, -1] : [0, 1];
        for (let i = starting; i >= 0 && i < buf.length; i += modifier) {
          this._attach(buf[i], attacher, prepend);
        }
      } else if (this._isBufferList(buf)) {
        const [starting, modifier] = prepend ? [buf._bufs.length - 1, -1] : [0, 1];
        for (let i = starting; i >= 0 && i < buf._bufs.length; i += modifier) {
          this._attach(buf._bufs[i], attacher, prepend);
        }
      } else {
        if (typeof buf === "number") {
          buf = buf.toString();
        }
        attacher.call(this, Buffer2.from(buf));
      }
      return this;
    };
    BufferList.prototype._appendBuffer = function appendBuffer(buf) {
      this._bufs.push(buf);
      this.length += buf.length;
    };
    BufferList.prototype._prependBuffer = function prependBuffer(buf) {
      this._bufs.unshift(buf);
      this.length += buf.length;
    };
    BufferList.prototype.indexOf = function(search, offset, encoding) {
      if (encoding === void 0 && typeof offset === "string") {
        encoding = offset;
        offset = void 0;
      }
      if (typeof search === "function" || Array.isArray(search)) {
        throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
      } else if (typeof search === "number") {
        search = Buffer2.from([search]);
      } else if (typeof search === "string") {
        search = Buffer2.from(search, encoding);
      } else if (this._isBufferList(search)) {
        search = search.slice();
      } else if (Array.isArray(search.buffer)) {
        search = Buffer2.from(search.buffer, search.byteOffset, search.byteLength);
      } else if (!Buffer2.isBuffer(search)) {
        search = Buffer2.from(search);
      }
      offset = Number(offset || 0);
      if (isNaN(offset)) {
        offset = 0;
      }
      if (offset < 0) {
        offset = this.length + offset;
      }
      if (offset < 0) {
        offset = 0;
      }
      if (search.length === 0) {
        return offset > this.length ? this.length : offset;
      }
      const blOffset = this._offset(offset);
      let blIndex = blOffset[0];
      let buffOffset = blOffset[1];
      for (; blIndex < this._bufs.length; blIndex++) {
        const buff = this._bufs[blIndex];
        while (buffOffset < buff.length) {
          const availableWindow = buff.length - buffOffset;
          if (availableWindow >= search.length) {
            const nativeSearchResult = buff.indexOf(search, buffOffset);
            if (nativeSearchResult !== -1) {
              return this._reverseOffset([blIndex, nativeSearchResult]);
            }
            buffOffset = buff.length - search.length + 1;
          } else {
            const revOffset = this._reverseOffset([blIndex, buffOffset]);
            if (this._match(revOffset, search)) {
              return revOffset;
            }
            buffOffset++;
          }
        }
        buffOffset = 0;
      }
      return -1;
    };
    BufferList.prototype._match = function(offset, search) {
      if (this.length - offset < search.length) {
        return false;
      }
      for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
        if (this.get(offset + searchOffset) !== search[searchOffset]) {
          return false;
        }
      }
      return true;
    };
    (function() {
      const methods = {
        readDoubleBE: 8,
        readDoubleLE: 8,
        readFloatBE: 4,
        readFloatLE: 4,
        readBigInt64BE: 8,
        readBigInt64LE: 8,
        readBigUInt64BE: 8,
        readBigUInt64LE: 8,
        readInt32BE: 4,
        readInt32LE: 4,
        readUInt32BE: 4,
        readUInt32LE: 4,
        readInt16BE: 2,
        readInt16LE: 2,
        readUInt16BE: 2,
        readUInt16LE: 2,
        readInt8: 1,
        readUInt8: 1,
        readIntBE: null,
        readIntLE: null,
        readUIntBE: null,
        readUIntLE: null
      };
      for (const m in methods) {
        (function(m2) {
          if (methods[m2] === null) {
            BufferList.prototype[m2] = function(offset, byteLength) {
              return this.slice(offset, offset + byteLength)[m2](0, byteLength);
            };
          } else {
            BufferList.prototype[m2] = function(offset = 0) {
              return this.slice(offset, offset + methods[m2])[m2](0);
            };
          }
        })(m);
      }
    })();
    BufferList.prototype._isBufferList = function _isBufferList(b) {
      return b instanceof BufferList || BufferList.isBufferList(b);
    };
    BufferList.isBufferList = function isBufferList(b) {
      return b != null && b[symbol];
    };
    module.exports = BufferList;
  }
});

// node_modules/bl/bl.js
var require_bl = __commonJS({
  "node_modules/bl/bl.js"(exports, module) {
    "use strict";
    var DuplexStream = require_browser4().Duplex;
    var inherits = require_inherits_browser();
    var BufferList = require_BufferList();
    function BufferListStream(callback) {
      if (!(this instanceof BufferListStream)) {
        return new BufferListStream(callback);
      }
      if (typeof callback === "function") {
        this._callback = callback;
        const piper = (function piper2(err) {
          if (this._callback) {
            this._callback(err);
            this._callback = null;
          }
        }).bind(this);
        this.on("pipe", function onPipe(src) {
          src.on("error", piper);
        });
        this.on("unpipe", function onUnpipe(src) {
          src.removeListener("error", piper);
        });
        callback = null;
      }
      BufferList._init.call(this, callback);
      DuplexStream.call(this);
    }
    inherits(BufferListStream, DuplexStream);
    Object.assign(BufferListStream.prototype, BufferList.prototype);
    BufferListStream.prototype._new = function _new(callback) {
      return new BufferListStream(callback);
    };
    BufferListStream.prototype._write = function _write(buf, encoding, callback) {
      this._appendBuffer(buf);
      if (typeof callback === "function") {
        callback();
      }
    };
    BufferListStream.prototype._read = function _read(size) {
      if (!this.length) {
        return this.push(null);
      }
      size = Math.min(size, this.length);
      this.push(this.slice(0, size));
      this.consume(size);
    };
    BufferListStream.prototype.end = function end(chunk) {
      DuplexStream.prototype.end.call(this, chunk);
      if (this._callback) {
        this._callback(null, this.slice());
        this._callback = null;
      }
    };
    BufferListStream.prototype._destroy = function _destroy(err, cb) {
      this._bufs.length = 0;
      this.length = 0;
      cb(err);
    };
    BufferListStream.prototype._isBufferList = function _isBufferList(b) {
      return b instanceof BufferListStream || b instanceof BufferList || BufferListStream.isBufferList(b);
    };
    BufferListStream.isBufferList = BufferList.isBufferList;
    module.exports = BufferListStream;
    module.exports.BufferListStream = BufferListStream;
    module.exports.BufferList = BufferList;
  }
});

// node_modules/tedious/lib/incoming-message-stream.js
var require_incoming_message_stream = __commonJS({
  "node_modules/tedious/lib/incoming-message-stream.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _bl = _interopRequireDefault(require_bl());
    var _stream = require_stream();
    var _message = _interopRequireDefault(require_message());
    var _packet = require_packet();
    var _errors = require_errors();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var IncomingMessageStream = class extends _stream.Transform {
      constructor(debug) {
        super({
          readableObjectMode: true
        });
        this.debug = debug;
        this.currentMessage = void 0;
        this.bl = new _bl.default();
      }
      pause() {
        super.pause();
        if (this.currentMessage) {
          this.currentMessage.pause();
        }
        return this;
      }
      resume() {
        super.resume();
        if (this.currentMessage) {
          this.currentMessage.resume();
        }
        return this;
      }
      processBufferedData(callback) {
        while (this.bl.length >= _packet.HEADER_LENGTH) {
          const length = this.bl.readUInt16BE(2);
          if (length < _packet.HEADER_LENGTH) {
            return callback(new _errors.ConnectionError("Unable to process incoming packet"));
          }
          if (this.bl.length >= length) {
            const data = this.bl.slice(0, length);
            this.bl.consume(length);
            const packet = new _packet.Packet(data);
            this.debug.packet("Received", packet);
            this.debug.data(packet);
            let message = this.currentMessage;
            if (message === void 0) {
              this.currentMessage = message = new _message.default({
                type: packet.type(),
                resetConnection: false
              });
              this.push(message);
            }
            if (packet.isLast()) {
              message.once("end", () => {
                this.currentMessage = void 0;
                this.processBufferedData(callback);
              });
              message.end(packet.data());
              return;
            } else if (!message.write(packet.data())) {
              message.once("drain", () => {
                this.processBufferedData(callback);
              });
              return;
            }
          } else {
            break;
          }
        }
        callback();
      }
      _transform(chunk, _encoding, callback) {
        this.bl.append(chunk);
        this.processBufferedData(callback);
      }
    };
    var _default = exports.default = IncomingMessageStream;
    module.exports = IncomingMessageStream;
  }
});

// node_modules/tedious/lib/outgoing-message-stream.js
var require_outgoing_message_stream = __commonJS({
  "node_modules/tedious/lib/outgoing-message-stream.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _bl = _interopRequireDefault(require_bl());
    var _stream = require_stream();
    var _packet = require_packet();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var OutgoingMessageStream = class extends _stream.Duplex {
      constructor(debug, {
        packetSize
      }) {
        super({
          writableObjectMode: true
        });
        this.packetSize = packetSize;
        this.debug = debug;
        this.bl = new _bl.default();
        this.on("finish", () => {
          this.push(null);
        });
      }
      _write(message, _encoding, callback) {
        const length = this.packetSize - _packet.HEADER_LENGTH;
        let packetNumber = 0;
        this.currentMessage = message;
        this.currentMessage.on("data", (data) => {
          if (message.ignore) {
            return;
          }
          this.bl.append(data);
          while (this.bl.length > length) {
            const data2 = this.bl.slice(0, length);
            this.bl.consume(length);
            const packet = new _packet.Packet(message.type);
            packet.packetId(packetNumber += 1);
            packet.resetConnection(message.resetConnection);
            packet.addData(data2);
            this.debug.packet("Sent", packet);
            this.debug.data(packet);
            if (this.push(packet.buffer) === false) {
              message.pause();
            }
          }
        });
        this.currentMessage.on("end", () => {
          const data = this.bl.slice();
          this.bl.consume(data.length);
          const packet = new _packet.Packet(message.type);
          packet.packetId(packetNumber += 1);
          packet.resetConnection(message.resetConnection);
          packet.last(true);
          packet.ignore(message.ignore);
          packet.addData(data);
          this.debug.packet("Sent", packet);
          this.debug.data(packet);
          this.push(packet.buffer);
          this.currentMessage = void 0;
          callback();
        });
      }
      _read(_size) {
        if (this.currentMessage) {
          this.currentMessage.resume();
        }
      }
    };
    var _default = exports.default = OutgoingMessageStream;
    module.exports = OutgoingMessageStream;
  }
});

// node_modules/tedious/lib/message-io.js
var require_message_io = __commonJS({
  "node_modules/tedious/lib/message-io.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _nativeDuplexpair = _interopRequireDefault(require_native_duplexpair());
    var tls = _interopRequireWildcard(require_tls());
    var _events = require_events();
    var _message = _interopRequireDefault(require_message());
    var _packet = require_packet();
    var _incomingMessageStream = _interopRequireDefault(require_incoming_message_stream());
    var _outgoingMessageStream = _interopRequireDefault(require_outgoing_message_stream());
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
      return n.default = e, t && t.set(e, n), n;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var MessageIO = class extends _events.EventEmitter {
      constructor(socket, packetSize, debug) {
        super();
        this.socket = socket;
        this.debug = debug;
        this.tlsNegotiationComplete = false;
        this.incomingMessageStream = new _incomingMessageStream.default(this.debug);
        this.incomingMessageIterator = this.incomingMessageStream[Symbol.asyncIterator]();
        this.outgoingMessageStream = new _outgoingMessageStream.default(this.debug, {
          packetSize
        });
        this.socket.pipe(this.incomingMessageStream);
        this.outgoingMessageStream.pipe(this.socket);
      }
      packetSize(...args) {
        if (args.length > 0) {
          const packetSize = args[0];
          this.debug.log("Packet size changed from " + this.outgoingMessageStream.packetSize + " to " + packetSize);
          this.outgoingMessageStream.packetSize = packetSize;
        }
        if (this.securePair) {
          this.securePair.cleartext.setMaxSendFragment(this.outgoingMessageStream.packetSize);
        }
        return this.outgoingMessageStream.packetSize;
      }
      // Negotiate TLS encryption.
      startTls(credentialsDetails, hostname, trustServerCertificate) {
        if (!credentialsDetails.maxVersion || !["TLSv1.2", "TLSv1.1", "TLSv1"].includes(credentialsDetails.maxVersion)) {
          credentialsDetails.maxVersion = "TLSv1.2";
        }
        const secureContext = tls.createSecureContext(credentialsDetails);
        return new Promise((resolve, reject) => {
          const duplexpair = new _nativeDuplexpair.default();
          const securePair = this.securePair = {
            cleartext: tls.connect({
              socket: duplexpair.socket1,
              servername: hostname,
              secureContext,
              rejectUnauthorized: !trustServerCertificate
            }),
            encrypted: duplexpair.socket2
          };
          const onSecureConnect = () => {
            securePair.encrypted.removeListener("readable", onReadable);
            securePair.cleartext.removeListener("error", onError);
            securePair.cleartext.removeListener("secureConnect", onSecureConnect);
            securePair.cleartext.once("error", (err) => {
              this.socket.destroy(err);
            });
            const cipher = securePair.cleartext.getCipher();
            if (cipher) {
              this.debug.log("TLS negotiated (" + cipher.name + ", " + cipher.version + ")");
            }
            this.emit("secure", securePair.cleartext);
            securePair.cleartext.setMaxSendFragment(this.outgoingMessageStream.packetSize);
            this.outgoingMessageStream.unpipe(this.socket);
            this.socket.unpipe(this.incomingMessageStream);
            this.socket.pipe(securePair.encrypted);
            securePair.encrypted.pipe(this.socket);
            securePair.cleartext.pipe(this.incomingMessageStream);
            this.outgoingMessageStream.pipe(securePair.cleartext);
            this.tlsNegotiationComplete = true;
            resolve();
          };
          const onError = (err) => {
            securePair.encrypted.removeListener("readable", onReadable);
            securePair.cleartext.removeListener("error", onError);
            securePair.cleartext.removeListener("secureConnect", onSecureConnect);
            securePair.cleartext.destroy();
            securePair.encrypted.destroy();
            reject(err);
          };
          const onReadable = () => {
            const message = new _message.default({
              type: _packet.TYPE.PRELOGIN,
              resetConnection: false
            });
            let chunk;
            while (chunk = securePair.encrypted.read()) {
              message.write(chunk);
            }
            this.outgoingMessageStream.write(message);
            message.end();
            this.readMessage().then(async (response) => {
              securePair.encrypted.once("readable", onReadable);
              for await (const data of response) {
                securePair.encrypted.write(data);
              }
            }).catch(onError);
          };
          securePair.cleartext.once("error", onError);
          securePair.cleartext.once("secureConnect", onSecureConnect);
          securePair.encrypted.once("readable", onReadable);
        });
      }
      // TODO listen for 'drain' event when socket.write returns false.
      // TODO implement incomplete request cancelation (2.2.1.6)
      sendMessage(packetType, data, resetConnection) {
        const message = new _message.default({
          type: packetType,
          resetConnection
        });
        message.end(data);
        this.outgoingMessageStream.write(message);
        return message;
      }
      /**
       * Read the next incoming message from the socket.
       */
      async readMessage() {
        const result = await this.incomingMessageIterator.next();
        if (result.done) {
          throw new Error("unexpected end of message stream");
        }
        return result.value;
      }
    };
    var _default = exports.default = MessageIO;
    module.exports = MessageIO;
  }
});

// node_modules/tedious/lib/collation.js
var require_collation = __commonJS({
  "node_modules/tedious/lib/collation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.codepageBySortId = exports.codepageByLanguageId = exports.Flags = exports.Collation = void 0;
    var codepageByLanguageId = exports.codepageByLanguageId = {
      // Arabic_*
      [1025]: "CP1256",
      // Chinese_Taiwan_Stroke_*
      // Chinese_Traditional_Stroke_Count_*
      // Chinese_Taiwan_Bopomofo_*
      // Chinese_Traditional_Bopomofo_*
      [1028]: "CP950",
      // Czech_*
      [1029]: "CP1250",
      // Danish_Greenlandic_*
      // Danish_Norwegian_*
      [1030]: "CP1252",
      // Greek_*
      [1032]: "CP1253",
      // Latin1_General_*
      [1033]: "CP1252",
      // Traditional_Spanish_*
      [1034]: "CP1252",
      // Finnish_Swedish_*
      [1035]: "CP1252",
      // French_*
      [1036]: "CP1252",
      // Hebrew_*
      [1037]: "CP1255",
      // Hungarian_*
      // Hungarian_Technical_*
      [1038]: "CP1250",
      // Icelandic_*
      [1039]: "CP1252",
      // Japanese_*
      // Japanese_XJIS_*
      // Japanese_Unicode_*
      // Japanese_Bushu_Kakusu_*
      [1041]: "CP932",
      // Korean_*
      // Korean_Wansung_*
      [1042]: "CP949",
      // Norwegian_*
      [1044]: "CP1252",
      // Polish_*
      [1045]: "CP1250",
      // Romansh_*
      [1047]: "CP1252",
      // Romanian_*
      [1048]: "CP1250",
      // Cyrillic_*
      [1049]: "CP1251",
      // Croatian_*
      [1050]: "CP1250",
      // Slovak_*
      [1051]: "CP1250",
      // Albanian_*
      [1052]: "CP1250",
      // Thai_*
      [1054]: "CP874",
      // Turkish_*
      [1055]: "CP1254",
      // Urdu_*
      [1056]: "CP1256",
      // Ukrainian_*
      [1058]: "CP1251",
      // Slovenian_*
      [1060]: "CP1250",
      // Estonian_*
      [1061]: "CP1257",
      // Latvian_*
      [1062]: "CP1257",
      // Lithuanian_*
      [1063]: "CP1257",
      // Persian_*
      [1065]: "CP1256",
      // Vietnamese_*
      [1066]: "CP1258",
      // Azeri_Latin_*
      [1068]: "CP1254",
      // Upper_Sorbian_*
      [1070]: "CP1252",
      // Macedonian_FYROM_*
      [1071]: "CP1251",
      // Sami_Norway_*
      [1083]: "CP1252",
      // Kazakh_*
      [1087]: "CP1251",
      // Turkmen_*
      [1090]: "CP1250",
      // Uzbek_Latin_*
      [1091]: "CP1254",
      // Tatar_*
      [1092]: "CP1251",
      // Welsh_*
      [1106]: "CP1252",
      // Frisian_*
      [1122]: "CP1252",
      // Bashkir_*
      [1133]: "CP1251",
      // Mapudungan_*
      [1146]: "CP1252",
      // Mohawk_*
      [1148]: "CP1252",
      // Breton_*
      [1150]: "CP1252",
      // Uighur_*
      [1152]: "CP1256",
      // Corsican_*
      [1155]: "CP1252",
      // Yakut_*
      [1157]: "CP1251",
      // Dari_*
      [1164]: "CP1256",
      // Chinese_PRC_*
      // Chinese_Simplified_Pinyin_*
      // Chinese_PRC_Stroke_*
      // Chinese_Simplified_Stroke_Order_*
      [2052]: "CP936",
      // Serbian_Latin_*
      [2074]: "CP1250",
      // Azeri_Cyrillic_*
      [2092]: "CP1251",
      // Sami_Sweden_Finland_*
      [2107]: "CP1252",
      // Tamazight_*
      [2143]: "CP1252",
      // Chinese_Hong_Kong_Stroke_*
      [3076]: "CP950",
      // Modern_Spanish_*
      [3082]: "CP1252",
      // Serbian_Cyrillic_*
      [3098]: "CP1251",
      // Chinese_Traditional_Pinyin_*
      // Chinese_Traditional_Stroke_Order_*
      [5124]: "CP950",
      // Bosnian_Latin_*
      [5146]: "CP1250",
      // Bosnian_Cyrillic_*
      [8218]: "CP1251",
      // German
      // German_PhoneBook_*
      [1031]: "CP1252",
      // Georgian_Modern_Sort_*
      [1079]: "CP1252"
    };
    var codepageBySortId = exports.codepageBySortId = {
      [30]: "CP437",
      // SQL_Latin1_General_CP437_BIN
      [31]: "CP437",
      // SQL_Latin1_General_CP437_CS_AS
      [32]: "CP437",
      // SQL_Latin1_General_CP437_CI_AS
      [33]: "CP437",
      // SQL_Latin1_General_Pref_CP437_CI_AS
      [34]: "CP437",
      // SQL_Latin1_General_CP437_CI_AI
      [40]: "CP850",
      // SQL_Latin1_General_CP850_BIN
      [41]: "CP850",
      // SQL_Latin1_General_CP850_CS_AS
      [42]: "CP850",
      // SQL_Latin1_General_CP850_CI_AS
      [43]: "CP850",
      // SQL_Latin1_General_Pref_CP850_CI_AS
      [44]: "CP850",
      // SQL_Latin1_General_CP850_CI_AI
      [49]: "CP850",
      // SQL_1xCompat_CP850_CI_AS
      [51]: "CP1252",
      // SQL_Latin1_General_Cp1_CS_AS_KI_WI
      [52]: "CP1252",
      // SQL_Latin1_General_Cp1_CI_AS_KI_WI
      [53]: "CP1252",
      // SQL_Latin1_General_Pref_Cp1_CI_AS_KI_WI
      [54]: "CP1252",
      // SQL_Latin1_General_Cp1_CI_AI_KI_WI
      [55]: "CP850",
      // SQL_AltDiction_CP850_CS_AS
      [56]: "CP850",
      // SQL_AltDiction_Pref_CP850_CI_AS
      [57]: "CP850",
      // SQL_AltDiction_CP850_CI_AI
      [58]: "CP850",
      // SQL_Scandinavian_Pref_CP850_CI_AS
      [59]: "CP850",
      // SQL_Scandinavian_CP850_CS_AS
      [60]: "CP850",
      // SQL_Scandinavian_CP850_CI_AS
      [61]: "CP850",
      // SQL_AltDiction_CP850_CI_AS
      [80]: "CP1250",
      // SQL_Latin1_General_1250_BIN
      [81]: "CP1250",
      // SQL_Latin1_General_CP1250_CS_AS
      [82]: "CP1250",
      // SQL_Latin1_General_Cp1250_CI_AS_KI_WI
      [83]: "CP1250",
      // SQL_Czech_Cp1250_CS_AS_KI_WI
      [84]: "CP1250",
      // SQL_Czech_Cp1250_CI_AS_KI_WI
      [85]: "CP1250",
      // SQL_Hungarian_Cp1250_CS_AS_KI_WI
      [86]: "CP1250",
      // SQL_Hungarian_Cp1250_CI_AS_KI_WI
      [87]: "CP1250",
      // SQL_Polish_Cp1250_CS_AS_KI_WI
      [88]: "CP1250",
      // SQL_Polish_Cp1250_CI_AS_KI_WI
      [89]: "CP1250",
      // SQL_Romanian_Cp1250_CS_AS_KI_WI
      [90]: "CP1250",
      // SQL_Romanian_Cp1250_CI_AS_KI_WI
      [91]: "CP1250",
      // SQL_Croatian_Cp1250_CS_AS_KI_WI
      [92]: "CP1250",
      // SQL_Croatian_Cp1250_CI_AS_KI_WI
      [93]: "CP1250",
      // SQL_Slovak_Cp1250_CS_AS_KI_WI
      [94]: "CP1250",
      // SQL_Slovak_Cp1250_CI_AS_KI_WI
      [95]: "CP1250",
      // SQL_Slovenian_Cp1250_CS_AS_KI_WI
      [96]: "CP1250",
      // SQL_Slovenian_Cp1250_CI_AS_KI_WI
      [104]: "CP1251",
      // SQL_Latin1_General_1251_BIN
      [105]: "CP1251",
      // SQL_Latin1_General_CP1251_CS_AS
      [106]: "CP1251",
      // SQL_Latin1_General_CP1251_CI_AS
      [107]: "CP1251",
      // SQL_Ukrainian_Cp1251_CS_AS_KI_WI
      [108]: "CP1251",
      // SQL_Ukrainian_Cp1251_CI_AS_KI_WI
      [112]: "CP1253",
      // SQL_Latin1_General_1253_BIN
      [113]: "CP1253",
      // SQL_Latin1_General_CP1253_CS_AS
      [114]: "CP1253",
      // SQL_Latin1_General_CP1253_CI_AS
      [120]: "CP1253",
      // SQL_MixDiction_CP1253_CS_AS
      [121]: "CP1253",
      // SQL_AltDiction_CP1253_CS_AS
      [122]: "CP1253",
      // SQL_AltDiction2_CP1253_CS_AS
      [124]: "CP1253",
      // SQL_Latin1_General_CP1253_CI_AI
      [128]: "CP1254",
      // SQL_Latin1_General_1254_BIN
      [129]: "CP1254",
      // SQL_Latin1_General_Cp1254_CS_AS_KI_WI
      [130]: "CP1254",
      // SQL_Latin1_General_Cp1254_CI_AS_KI_WI
      [136]: "CP1255",
      // SQL_Latin1_General_1255_BIN
      [137]: "CP1255",
      // SQL_Latin1_General_CP1255_CS_AS
      [138]: "CP1255",
      // SQL_Latin1_General_CP1255_CI_AS
      [144]: "CP1256",
      // SQL_Latin1_General_1256_BIN
      [145]: "CP1256",
      // SQL_Latin1_General_CP1256_CS_AS
      [146]: "CP1256",
      // SQL_Latin1_General_CP1256_CI_AS
      [152]: "CP1257",
      // SQL_Latin1_General_1257_BIN
      [153]: "CP1257",
      // SQL_Latin1_General_CP1257_CS_AS
      [154]: "CP1257",
      // SQL_Latin1_General_CP1257_CI_AS
      [155]: "CP1257",
      // SQL_Estonian_Cp1257_CS_AS_KI_WI
      [156]: "CP1257",
      // SQL_Estonian_Cp1257_CI_AS_KI_WI
      [157]: "CP1257",
      // SQL_Latvian_Cp1257_CS_AS_KI_WI
      [158]: "CP1257",
      // SQL_Latvian_Cp1257_CI_AS_KI_WI
      [159]: "CP1257",
      // SQL_Lithuanian_Cp1257_CS_AS_KI_WI
      [160]: "CP1257",
      // SQL_Lithuanian_Cp1257_CI_AS_KI_WI
      [183]: "CP1252",
      // SQL_Danish_Pref_Cp1_CI_AS_KI_WI
      [184]: "CP1252",
      // SQL_SwedishPhone_Pref_Cp1_CI_AS_KI_WI
      [185]: "CP1252",
      // SQL_SwedishStd_Pref_Cp1_CI_AS_KI_WI
      [186]: "CP1252"
      // SQL_Icelandic_Pref_Cp1_CI_AS_KI_WI
    };
    var Flags = exports.Flags = {
      IGNORE_CASE: 1 << 0,
      IGNORE_ACCENT: 1 << 1,
      IGNORE_KANA: 1 << 2,
      IGNORE_WIDTH: 1 << 3,
      BINARY: 1 << 4,
      BINARY2: 1 << 5,
      UTF8: 1 << 6
    };
    var Collation = class {
      static fromBuffer(buffer, offset = 0) {
        let lcid = (buffer[offset + 2] & 15) << 16;
        lcid |= buffer[offset + 1] << 8;
        lcid |= buffer[offset + 0];
        let flags = (buffer[offset + 3] & 15) << 4;
        flags |= (buffer[offset + 2] & 240) >>> 4;
        const version3 = (buffer[offset + 3] & 240) >>> 4;
        const sortId = buffer[offset + 4];
        return new this(lcid, flags, version3, sortId);
      }
      constructor(lcid, flags, version3, sortId) {
        this.buffer = void 0;
        this.lcid = lcid;
        this.flags = flags;
        this.version = version3;
        this.sortId = sortId;
        if (this.flags & Flags.UTF8) {
          this.codepage = "utf-8";
        } else if (this.sortId) {
          this.codepage = codepageBySortId[this.sortId];
        } else {
          const languageId = this.lcid & 65535;
          this.codepage = codepageByLanguageId[languageId];
        }
      }
      toBuffer() {
        if (this.buffer) {
          return this.buffer;
        }
        this.buffer = Buffer.alloc(5);
        this.buffer[0] = this.lcid & 255;
        this.buffer[1] = this.lcid >>> 8 & 255;
        this.buffer[2] = this.lcid >>> 16 & 15 | (this.flags & 15) << 4;
        this.buffer[3] = (this.flags & 240) >>> 4 | (this.version & 15) << 4;
        this.buffer[4] = this.sortId & 255;
        return this.buffer;
      }
    };
    exports.Collation = Collation;
  }
});

// node_modules/tedious/lib/data-types/null.js
var require_null = __commonJS({
  "node_modules/tedious/lib/data-types/null.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var Null = {
      id: 31,
      type: "NULL",
      name: "Null",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports.default = Null;
    module.exports = Null;
  }
});

// node_modules/tedious/lib/data-types/intn.js
var require_intn = __commonJS({
  "node_modules/tedious/lib/data-types/intn.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var IntN = {
      id: 38,
      type: "INTN",
      name: "IntN",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports.default = IntN;
    module.exports = IntN;
  }
});

// node_modules/tedious/lib/data-types/tinyint.js
var require_tinyint = __commonJS({
  "node_modules/tedious/lib/data-types/tinyint.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _intn = _interopRequireDefault(require_intn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var DATA_LENGTH = Buffer.from([1]);
    var NULL_LENGTH = Buffer.from([0]);
    var TinyInt = {
      id: 48,
      type: "INT1",
      name: "TinyInt",
      declaration: function() {
        return "tinyint";
      },
      generateTypeInfo() {
        return Buffer.from([_intn.default.id, 1]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = Buffer.alloc(1);
        buffer.writeUInt8(Number(parameter.value), 0);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "number") {
          value = Number(value);
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        if (value < 0 || value > 255) {
          throw new TypeError("Value must be between 0 and 255, inclusive.");
        }
        return value | 0;
      }
    };
    var _default = exports.default = TinyInt;
    module.exports = TinyInt;
  }
});

// node_modules/tedious/lib/data-types/bitn.js
var require_bitn = __commonJS({
  "node_modules/tedious/lib/data-types/bitn.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var BitN = {
      id: 104,
      type: "BITN",
      name: "BitN",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      *generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports.default = BitN;
    module.exports = BitN;
  }
});

// node_modules/tedious/lib/data-types/bit.js
var require_bit = __commonJS({
  "node_modules/tedious/lib/data-types/bit.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _bitn = _interopRequireDefault(require_bitn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var DATA_LENGTH = Buffer.from([1]);
    var NULL_LENGTH = Buffer.from([0]);
    var Bit = {
      id: 50,
      type: "BIT",
      name: "Bit",
      declaration: function() {
        return "bit";
      },
      generateTypeInfo() {
        return Buffer.from([_bitn.default.id, 1]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        yield parameter.value ? Buffer.from([1]) : Buffer.from([0]);
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (value) {
          return true;
        } else {
          return false;
        }
      }
    };
    var _default = exports.default = Bit;
    module.exports = Bit;
  }
});

// node_modules/tedious/lib/data-types/smallint.js
var require_smallint = __commonJS({
  "node_modules/tedious/lib/data-types/smallint.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _intn = _interopRequireDefault(require_intn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var DATA_LENGTH = Buffer.from([2]);
    var NULL_LENGTH = Buffer.from([0]);
    var SmallInt = {
      id: 52,
      type: "INT2",
      name: "SmallInt",
      declaration: function() {
        return "smallint";
      },
      generateTypeInfo() {
        return Buffer.from([_intn.default.id, 2]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = Buffer.alloc(2);
        buffer.writeInt16LE(Number(parameter.value), 0);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "number") {
          value = Number(value);
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        if (value < -32768 || value > 32767) {
          throw new TypeError("Value must be between -32768 and 32767, inclusive.");
        }
        return value | 0;
      }
    };
    var _default = exports.default = SmallInt;
    module.exports = SmallInt;
  }
});

// node_modules/tedious/lib/data-types/int.js
var require_int = __commonJS({
  "node_modules/tedious/lib/data-types/int.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _intn = _interopRequireDefault(require_intn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([0]);
    var DATA_LENGTH = Buffer.from([4]);
    var Int = {
      id: 56,
      type: "INT4",
      name: "Int",
      declaration: function() {
        return "int";
      },
      generateTypeInfo() {
        return Buffer.from([_intn.default.id, 4]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = Buffer.alloc(4);
        buffer.writeInt32LE(Number(parameter.value), 0);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "number") {
          value = Number(value);
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        if (value < -2147483648 || value > 2147483647) {
          throw new TypeError("Value must be between -2147483648 and 2147483647, inclusive.");
        }
        return value | 0;
      }
    };
    var _default = exports.default = Int;
    module.exports = Int;
  }
});

// node_modules/tedious/lib/data-types/datetimen.js
var require_datetimen = __commonJS({
  "node_modules/tedious/lib/data-types/datetimen.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DateTimeN = {
      id: 111,
      type: "DATETIMN",
      name: "DateTimeN",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports.default = DateTimeN;
    module.exports = DateTimeN;
  }
});

// node_modules/tedious/lib/data-types/smalldatetime.js
var require_smalldatetime = __commonJS({
  "node_modules/tedious/lib/data-types/smalldatetime.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _datetimen = _interopRequireDefault(require_datetimen());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var EPOCH_DATE = new Date(1900, 0, 1);
    var UTC_EPOCH_DATE = new Date(Date.UTC(1900, 0, 1));
    var DATA_LENGTH = Buffer.from([4]);
    var NULL_LENGTH = Buffer.from([0]);
    var SmallDateTime = {
      id: 58,
      type: "DATETIM4",
      name: "SmallDateTime",
      declaration: function() {
        return "smalldatetime";
      },
      generateTypeInfo() {
        return Buffer.from([_datetimen.default.id, 4]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      generateParameterData: function* (parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = Buffer.alloc(4);
        let days, dstDiff, minutes;
        if (options.useUTC) {
          days = Math.floor((parameter.value.getTime() - UTC_EPOCH_DATE.getTime()) / (1e3 * 60 * 60 * 24));
          minutes = parameter.value.getUTCHours() * 60 + parameter.value.getUTCMinutes();
        } else {
          dstDiff = -(parameter.value.getTimezoneOffset() - EPOCH_DATE.getTimezoneOffset()) * 60 * 1e3;
          days = Math.floor((parameter.value.getTime() - EPOCH_DATE.getTime() + dstDiff) / (1e3 * 60 * 60 * 24));
          minutes = parameter.value.getHours() * 60 + parameter.value.getMinutes();
        }
        buffer.writeUInt16LE(days, 0);
        buffer.writeUInt16LE(minutes, 2);
        yield buffer;
      },
      validate: function(value, collation, options) {
        if (value == null) {
          return null;
        }
        if (!(value instanceof Date)) {
          value = new Date(Date.parse(value));
        }
        value = value;
        let year, month, date;
        if (options && options.useUTC) {
          year = value.getUTCFullYear();
          month = value.getUTCMonth();
          date = value.getUTCDate();
        } else {
          year = value.getFullYear();
          month = value.getMonth();
          date = value.getDate();
        }
        if (year < 1900 || year > 2079) {
          throw new TypeError("Out of range.");
        }
        if (year === 2079) {
          if (month > 5 || month === 5 && date > 6) {
            throw new TypeError("Out of range.");
          }
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid date.");
        }
        return value;
      }
    };
    var _default = exports.default = SmallDateTime;
    module.exports = SmallDateTime;
  }
});

// node_modules/tedious/lib/data-types/floatn.js
var require_floatn = __commonJS({
  "node_modules/tedious/lib/data-types/floatn.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var FloatN = {
      id: 109,
      type: "FLTN",
      name: "FloatN",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports.default = FloatN;
    module.exports = FloatN;
  }
});

// node_modules/tedious/lib/data-types/real.js
var require_real = __commonJS({
  "node_modules/tedious/lib/data-types/real.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _floatn = _interopRequireDefault(require_floatn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([0]);
    var DATA_LENGTH = Buffer.from([4]);
    var Real = {
      id: 59,
      type: "FLT4",
      name: "Real",
      declaration: function() {
        return "real";
      },
      generateTypeInfo() {
        return Buffer.from([_floatn.default.id, 4]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = Buffer.alloc(4);
        buffer.writeFloatLE(parseFloat(parameter.value), 0);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        value = parseFloat(value);
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        return value;
      }
    };
    var _default = exports.default = Real;
    module.exports = Real;
  }
});

// node_modules/tedious/lib/data-types/moneyn.js
var require_moneyn = __commonJS({
  "node_modules/tedious/lib/data-types/moneyn.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MoneyN = {
      id: 110,
      type: "MONEYN",
      name: "MoneyN",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports.default = MoneyN;
    module.exports = MoneyN;
  }
});

// node_modules/tedious/lib/data-types/money.js
var require_money = __commonJS({
  "node_modules/tedious/lib/data-types/money.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _moneyn = _interopRequireDefault(require_moneyn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
    var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
    var NULL_LENGTH = Buffer.from([0]);
    var DATA_LENGTH = Buffer.from([8]);
    var Money = {
      id: 60,
      type: "MONEY",
      name: "Money",
      declaration: function() {
        return "money";
      },
      generateTypeInfo: function() {
        return Buffer.from([_moneyn.default.id, 8]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const value = parameter.value * 1e4;
        const buffer = Buffer.alloc(8);
        buffer.writeInt32LE(Math.floor(value * SHIFT_RIGHT_32), 0);
        buffer.writeInt32LE(value & -1, 4);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        value = parseFloat(value);
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        if (value < -9223372036854776e-1 || value > 9223372036854776e-1) {
          throw new TypeError("Value must be between -922337203685477.5808 and 922337203685477.5807, inclusive.");
        }
        return value;
      }
    };
    var _default = exports.default = Money;
    module.exports = Money;
  }
});

// node_modules/@js-joda/core/dist/js-joda.esm.js
var js_joda_esm_exports = {};
__export(js_joda_esm_exports, {
  ArithmeticException: () => ArithmeticException,
  ChronoField: () => ChronoField,
  ChronoLocalDate: () => ChronoLocalDate,
  ChronoLocalDateTime: () => ChronoLocalDateTime,
  ChronoUnit: () => ChronoUnit,
  ChronoZonedDateTime: () => ChronoZonedDateTime,
  Clock: () => Clock,
  DateTimeException: () => DateTimeException,
  DateTimeFormatter: () => DateTimeFormatter,
  DateTimeFormatterBuilder: () => DateTimeFormatterBuilder,
  DateTimeParseException: () => DateTimeParseException,
  DayOfWeek: () => DayOfWeek,
  DecimalStyle: () => DecimalStyle,
  Duration: () => Duration,
  IllegalArgumentException: () => IllegalArgumentException,
  IllegalStateException: () => IllegalStateException,
  Instant: () => Instant,
  IsoChronology: () => IsoChronology,
  IsoFields: () => IsoFields,
  LocalDate: () => LocalDate,
  LocalDateTime: () => LocalDateTime,
  LocalTime: () => LocalTime,
  Month: () => Month,
  MonthDay: () => MonthDay,
  NullPointerException: () => NullPointerException,
  OffsetDateTime: () => OffsetDateTime,
  OffsetTime: () => OffsetTime,
  ParsePosition: () => ParsePosition,
  Period: () => Period,
  ResolverStyle: () => ResolverStyle,
  SignStyle: () => SignStyle,
  Temporal: () => Temporal,
  TemporalAccessor: () => TemporalAccessor,
  TemporalAdjuster: () => TemporalAdjuster,
  TemporalAdjusters: () => TemporalAdjusters,
  TemporalAmount: () => TemporalAmount,
  TemporalField: () => TemporalField,
  TemporalQueries: () => TemporalQueries,
  TemporalQuery: () => TemporalQuery,
  TemporalUnit: () => TemporalUnit,
  TextStyle: () => TextStyle,
  UnsupportedTemporalTypeException: () => UnsupportedTemporalTypeException,
  ValueRange: () => ValueRange,
  Year: () => Year,
  YearConstants: () => YearConstants,
  YearMonth: () => YearMonth,
  ZoneId: () => ZoneId,
  ZoneOffset: () => ZoneOffset,
  ZoneOffsetTransition: () => ZoneOffsetTransition,
  ZoneRegion: () => ZoneRegion,
  ZoneRules: () => ZoneRules,
  ZoneRulesProvider: () => ZoneRulesProvider,
  ZonedDateTime: () => ZonedDateTime,
  _: () => _,
  convert: () => convert,
  nativeJs: () => nativeJs,
  use: () => use
});
function createErrorType(name3, init2, superErrorClass) {
  if (superErrorClass === void 0) {
    superErrorClass = Error;
  }
  function JsJodaException(message) {
    if (!Error.captureStackTrace) {
      this.stack = new Error().stack;
    } else {
      Error.captureStackTrace(this, this.constructor);
    }
    this.message = message;
    init2 && init2.apply(this, arguments);
    this.toString = function() {
      return this.name + ": " + this.message;
    };
  }
  JsJodaException.prototype = Object.create(superErrorClass.prototype);
  JsJodaException.prototype.name = name3;
  JsJodaException.prototype.constructor = JsJodaException;
  return JsJodaException;
}
function messageWithCause(message, cause) {
  if (cause === void 0) {
    cause = null;
  }
  var msg = message || this.name;
  if (cause !== null && cause instanceof Error) {
    msg += "\n-------\nCaused by: " + cause.stack + "\n-------\n";
  }
  this.message = msg;
}
function messageForDateTimeParseException(message, text, index, cause) {
  if (text === void 0) {
    text = "";
  }
  if (index === void 0) {
    index = 0;
  }
  if (cause === void 0) {
    cause = null;
  }
  var msg = message || this.name;
  msg += ": " + text + ", at index: " + index;
  if (cause !== null && cause instanceof Error) {
    msg += "\n-------\nCaused by: " + cause.stack + "\n-------\n";
  }
  this.message = msg;
  this.parsedString = function() {
    return text;
  };
  this.errorIndex = function() {
    return index;
  };
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function assert(assertion, msg, error) {
  if (!assertion) {
    if (error) {
      throw new error(msg);
    } else {
      throw new Error(msg);
    }
  }
}
function requireNonNull(value, parameterName) {
  if (value == null) {
    throw new NullPointerException(parameterName + " must not be null");
  }
  return value;
}
function requireInstance(value, _class, parameterName) {
  if (!(value instanceof _class)) {
    throw new IllegalArgumentException(parameterName + " must be an instance of " + (_class.name ? _class.name : _class) + (value && value.constructor && value.constructor.name ? ", but is " + value.constructor.name : ""));
  }
  return value;
}
function abstractMethodFail(methodName) {
  throw new TypeError('abstract method "' + methodName + '" is not implemented');
}
function _init$n() {
  Duration.ZERO = new Duration(0, 0);
}
function _init$m() {
  YearConstants.MIN_VALUE = -999999;
  YearConstants.MAX_VALUE = 999999;
}
function _init$l() {
  ChronoUnit.NANOS = new ChronoUnit("Nanos", Duration.ofNanos(1));
  ChronoUnit.MICROS = new ChronoUnit("Micros", Duration.ofNanos(1e3));
  ChronoUnit.MILLIS = new ChronoUnit("Millis", Duration.ofNanos(1e6));
  ChronoUnit.SECONDS = new ChronoUnit("Seconds", Duration.ofSeconds(1));
  ChronoUnit.MINUTES = new ChronoUnit("Minutes", Duration.ofSeconds(60));
  ChronoUnit.HOURS = new ChronoUnit("Hours", Duration.ofSeconds(3600));
  ChronoUnit.HALF_DAYS = new ChronoUnit("HalfDays", Duration.ofSeconds(43200));
  ChronoUnit.DAYS = new ChronoUnit("Days", Duration.ofSeconds(86400));
  ChronoUnit.WEEKS = new ChronoUnit("Weeks", Duration.ofSeconds(7 * 86400));
  ChronoUnit.MONTHS = new ChronoUnit("Months", Duration.ofSeconds(31556952 / 12));
  ChronoUnit.YEARS = new ChronoUnit("Years", Duration.ofSeconds(31556952));
  ChronoUnit.DECADES = new ChronoUnit("Decades", Duration.ofSeconds(31556952 * 10));
  ChronoUnit.CENTURIES = new ChronoUnit("Centuries", Duration.ofSeconds(31556952 * 100));
  ChronoUnit.MILLENNIA = new ChronoUnit("Millennia", Duration.ofSeconds(31556952 * 1e3));
  ChronoUnit.ERAS = new ChronoUnit("Eras", Duration.ofSeconds(31556952 * (YearConstants.MAX_VALUE + 1)));
  ChronoUnit.FOREVER = new ChronoUnit("Forever", Duration.ofSeconds(MathUtil.MAX_SAFE_INTEGER, 999999999));
}
function _init$k() {
  ChronoField.NANO_OF_SECOND = new ChronoField("NanoOfSecond", ChronoUnit.NANOS, ChronoUnit.SECONDS, ValueRange.of(0, 999999999));
  ChronoField.NANO_OF_DAY = new ChronoField("NanoOfDay", ChronoUnit.NANOS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1e9 - 1));
  ChronoField.MICRO_OF_SECOND = new ChronoField("MicroOfSecond", ChronoUnit.MICROS, ChronoUnit.SECONDS, ValueRange.of(0, 999999));
  ChronoField.MICRO_OF_DAY = new ChronoField("MicroOfDay", ChronoUnit.MICROS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1e6 - 1));
  ChronoField.MILLI_OF_SECOND = new ChronoField("MilliOfSecond", ChronoUnit.MILLIS, ChronoUnit.SECONDS, ValueRange.of(0, 999));
  ChronoField.MILLI_OF_DAY = new ChronoField("MilliOfDay", ChronoUnit.MILLIS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1e3 - 1));
  ChronoField.SECOND_OF_MINUTE = new ChronoField("SecondOfMinute", ChronoUnit.SECONDS, ChronoUnit.MINUTES, ValueRange.of(0, 59));
  ChronoField.SECOND_OF_DAY = new ChronoField("SecondOfDay", ChronoUnit.SECONDS, ChronoUnit.DAYS, ValueRange.of(0, 86400 - 1));
  ChronoField.MINUTE_OF_HOUR = new ChronoField("MinuteOfHour", ChronoUnit.MINUTES, ChronoUnit.HOURS, ValueRange.of(0, 59));
  ChronoField.MINUTE_OF_DAY = new ChronoField("MinuteOfDay", ChronoUnit.MINUTES, ChronoUnit.DAYS, ValueRange.of(0, 24 * 60 - 1));
  ChronoField.HOUR_OF_AMPM = new ChronoField("HourOfAmPm", ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(0, 11));
  ChronoField.CLOCK_HOUR_OF_AMPM = new ChronoField("ClockHourOfAmPm", ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(1, 12));
  ChronoField.HOUR_OF_DAY = new ChronoField("HourOfDay", ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(0, 23));
  ChronoField.CLOCK_HOUR_OF_DAY = new ChronoField("ClockHourOfDay", ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(1, 24));
  ChronoField.AMPM_OF_DAY = new ChronoField("AmPmOfDay", ChronoUnit.HALF_DAYS, ChronoUnit.DAYS, ValueRange.of(0, 1));
  ChronoField.DAY_OF_WEEK = new ChronoField("DayOfWeek", ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));
  ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH = new ChronoField("AlignedDayOfWeekInMonth", ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));
  ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR = new ChronoField("AlignedDayOfWeekInYear", ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));
  ChronoField.DAY_OF_MONTH = new ChronoField("DayOfMonth", ChronoUnit.DAYS, ChronoUnit.MONTHS, ValueRange.of(1, 28, 31), "day");
  ChronoField.DAY_OF_YEAR = new ChronoField("DayOfYear", ChronoUnit.DAYS, ChronoUnit.YEARS, ValueRange.of(1, 365, 366));
  ChronoField.EPOCH_DAY = new ChronoField("EpochDay", ChronoUnit.DAYS, ChronoUnit.FOREVER, ValueRange.of(-365961662, 364522971));
  ChronoField.ALIGNED_WEEK_OF_MONTH = new ChronoField("AlignedWeekOfMonth", ChronoUnit.WEEKS, ChronoUnit.MONTHS, ValueRange.of(1, 4, 5));
  ChronoField.ALIGNED_WEEK_OF_YEAR = new ChronoField("AlignedWeekOfYear", ChronoUnit.WEEKS, ChronoUnit.YEARS, ValueRange.of(1, 53));
  ChronoField.MONTH_OF_YEAR = new ChronoField("MonthOfYear", ChronoUnit.MONTHS, ChronoUnit.YEARS, ValueRange.of(1, 12), "month");
  ChronoField.PROLEPTIC_MONTH = new ChronoField("ProlepticMonth", ChronoUnit.MONTHS, ChronoUnit.FOREVER, ValueRange.of(YearConstants.MIN_VALUE * 12, YearConstants.MAX_VALUE * 12 + 11));
  ChronoField.YEAR_OF_ERA = new ChronoField("YearOfEra", ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(1, YearConstants.MAX_VALUE, YearConstants.MAX_VALUE + 1));
  ChronoField.YEAR = new ChronoField("Year", ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(YearConstants.MIN_VALUE, YearConstants.MAX_VALUE), "year");
  ChronoField.ERA = new ChronoField("Era", ChronoUnit.ERAS, ChronoUnit.FOREVER, ValueRange.of(0, 1));
  ChronoField.INSTANT_SECONDS = new ChronoField("InstantSeconds", ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(MIN_SAFE_INTEGER, MAX_SAFE_INTEGER));
  ChronoField.OFFSET_SECONDS = new ChronoField("OffsetSeconds", ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(-18 * 3600, 18 * 3600));
}
function createTemporalQuery(name3, queryFromFunction) {
  var ExtendedTemporalQuery = function(_TemporalQuery) {
    _inheritsLoose(ExtendedTemporalQuery2, _TemporalQuery);
    function ExtendedTemporalQuery2() {
      return _TemporalQuery.apply(this, arguments) || this;
    }
    return ExtendedTemporalQuery2;
  }(TemporalQuery);
  ExtendedTemporalQuery.prototype.queryFrom = queryFromFunction;
  return new ExtendedTemporalQuery(name3);
}
function _init$j() {
  DayOfWeek.MONDAY = new DayOfWeek(0, "MONDAY");
  DayOfWeek.TUESDAY = new DayOfWeek(1, "TUESDAY");
  DayOfWeek.WEDNESDAY = new DayOfWeek(2, "WEDNESDAY");
  DayOfWeek.THURSDAY = new DayOfWeek(3, "THURSDAY");
  DayOfWeek.FRIDAY = new DayOfWeek(4, "FRIDAY");
  DayOfWeek.SATURDAY = new DayOfWeek(5, "SATURDAY");
  DayOfWeek.SUNDAY = new DayOfWeek(6, "SUNDAY");
  DayOfWeek.FROM = createTemporalQuery("DayOfWeek.FROM", function(temporal) {
    return DayOfWeek.from(temporal);
  });
  ENUMS = [DayOfWeek.MONDAY, DayOfWeek.TUESDAY, DayOfWeek.WEDNESDAY, DayOfWeek.THURSDAY, DayOfWeek.FRIDAY, DayOfWeek.SATURDAY, DayOfWeek.SUNDAY];
}
function _init$i() {
  Month.JANUARY = new Month(1, "JANUARY");
  Month.FEBRUARY = new Month(2, "FEBRUARY");
  Month.MARCH = new Month(3, "MARCH");
  Month.APRIL = new Month(4, "APRIL");
  Month.MAY = new Month(5, "MAY");
  Month.JUNE = new Month(6, "JUNE");
  Month.JULY = new Month(7, "JULY");
  Month.AUGUST = new Month(8, "AUGUST");
  Month.SEPTEMBER = new Month(9, "SEPTEMBER");
  Month.OCTOBER = new Month(10, "OCTOBER");
  Month.NOVEMBER = new Month(11, "NOVEMBER");
  Month.DECEMBER = new Month(12, "DECEMBER");
  MONTHS = [Month.JANUARY, Month.FEBRUARY, Month.MARCH, Month.APRIL, Month.MAY, Month.JUNE, Month.JULY, Month.AUGUST, Month.SEPTEMBER, Month.OCTOBER, Month.NOVEMBER, Month.DECEMBER];
}
function _init$h() {
  Period.ofDays(0);
}
function _init$g() {
  ZoneOffset.MAX_SECONDS = 18 * LocalTime.SECONDS_PER_HOUR;
  ZoneOffset.UTC = ZoneOffset.ofTotalSeconds(0);
  ZoneOffset.MIN = ZoneOffset.ofTotalSeconds(-ZoneOffset.MAX_SECONDS);
  ZoneOffset.MAX = ZoneOffset.ofTotalSeconds(ZoneOffset.MAX_SECONDS);
}
function _init$f() {
  DAY_OF_QUARTER = new DAY_OF_QUARTER_FIELD();
  QUARTER_OF_YEAR = new QUARTER_OF_YEAR_FIELD();
  WEEK_OF_WEEK_BASED_YEAR = new WEEK_OF_WEEK_BASED_YEAR_FIELD();
  WEEK_BASED_YEAR = new WEEK_BASED_YEAR_FIELD();
  WEEK_BASED_YEARS = new Unit("WeekBasedYears", Duration.ofSeconds(31556952));
  QUARTER_YEARS = new Unit("QuarterYears", Duration.ofSeconds(31556952 / 4));
  IsoFields.DAY_OF_QUARTER = DAY_OF_QUARTER;
  IsoFields.QUARTER_OF_YEAR = QUARTER_OF_YEAR;
  IsoFields.WEEK_OF_WEEK_BASED_YEAR = WEEK_OF_WEEK_BASED_YEAR;
  IsoFields.WEEK_BASED_YEAR = WEEK_BASED_YEAR;
  IsoFields.WEEK_BASED_YEARS = WEEK_BASED_YEARS;
  IsoFields.QUARTER_YEARS = QUARTER_YEARS;
  LocalDate.prototype.isoWeekOfWeekyear = function() {
    return this.get(IsoFields.WEEK_OF_WEEK_BASED_YEAR);
  };
  LocalDate.prototype.isoWeekyear = function() {
    return this.get(IsoFields.WEEK_BASED_YEAR);
  };
}
function _init$e() {
  ReducedPrinterParser.BASE_DATE = LocalDate.of(2e3, 1, 1);
  DateTimeFormatterBuilder.CompositePrinterParser = CompositePrinterParser;
  DateTimeFormatterBuilder.PadPrinterParserDecorator = PadPrinterParserDecorator;
  DateTimeFormatterBuilder.SettingsParser = SettingsParser;
  DateTimeFormatterBuilder.CharLiteralPrinterParser = StringLiteralPrinterParser;
  DateTimeFormatterBuilder.StringLiteralPrinterParser = StringLiteralPrinterParser;
  DateTimeFormatterBuilder.CharLiteralPrinterParser = CharLiteralPrinterParser;
  DateTimeFormatterBuilder.NumberPrinterParser = NumberPrinterParser;
  DateTimeFormatterBuilder.ReducedPrinterParser = ReducedPrinterParser;
  DateTimeFormatterBuilder.FractionPrinterParser = FractionPrinterParser;
  DateTimeFormatterBuilder.OffsetIdPrinterParser = OffsetIdPrinterParser;
  DateTimeFormatterBuilder.ZoneIdPrinterParser = ZoneIdPrinterParser;
}
function _init$d() {
  DateTimeFormatter.ISO_LOCAL_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral("-").appendValue(ChronoField.MONTH_OF_YEAR, 2).appendLiteral("-").appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_LOCAL_TIME = new DateTimeFormatterBuilder().appendValue(ChronoField.HOUR_OF_DAY, 2).appendLiteral(":").appendValue(ChronoField.MINUTE_OF_HOUR, 2).optionalStart().appendLiteral(":").appendValue(ChronoField.SECOND_OF_MINUTE, 2).optionalStart().appendFraction(ChronoField.NANO_OF_SECOND, 0, 9, true).toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_LOCAL_DATE_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral("T").append(DateTimeFormatter.ISO_LOCAL_TIME).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_INSTANT = new DateTimeFormatterBuilder().parseCaseInsensitive().appendInstant().toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_OFFSET_DATE_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE_TIME).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_ZONED_DATE_TIME = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_OFFSET_DATE_TIME).optionalStart().appendLiteral("[").parseCaseSensitive().appendZoneId().appendLiteral("]").toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.BASIC_ISO_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendValue(ChronoField.MONTH_OF_YEAR, 2).appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_OFFSET_DATE = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_OFFSET_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_TIME).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_ORDINAL_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral("-").appendValue(ChronoField.DAY_OF_YEAR).toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_WEEK_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral("-W").appendValue(ChronoField.ALIGNED_WEEK_OF_YEAR).appendLiteral("-").appendValue(ChronoField.DAY_OF_WEEK).toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_DATE = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).optionalStart().appendOffsetId().optionalEnd().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_TIME).optionalStart().appendOffsetId().optionalEnd().toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_DATE_TIME = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_LOCAL_DATE_TIME).optionalStart().appendOffsetId().optionalEnd().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.PARSED_EXCESS_DAYS = createTemporalQuery("PARSED_EXCESS_DAYS", function(temporal) {
    if (temporal instanceof DateTimeBuilder) {
      return temporal.excessDays;
    } else {
      return Period.ZERO;
    }
  });
  DateTimeFormatter.PARSED_LEAP_SECOND = createTemporalQuery("PARSED_LEAP_SECOND", function(temporal) {
    if (temporal instanceof DateTimeBuilder) {
      return temporal.leapSecond;
    } else {
      return false;
    }
  });
}
function _init$c() {
  PARSER$2 = new DateTimeFormatterBuilder().appendLiteral("--").appendValue(ChronoField.MONTH_OF_YEAR, 2).appendLiteral("-").appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter();
  MonthDay.FROM = createTemporalQuery("MonthDay.FROM", function(temporal) {
    return MonthDay.from(temporal);
  });
}
function _init$b() {
  PARSER$1 = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral("-").appendValue(ChronoField.MONTH_OF_YEAR, 2).toFormatter();
  YearMonth.FROM = createTemporalQuery("YearMonth.FROM", function(temporal) {
    return YearMonth.from(temporal);
  });
}
function _init$a() {
  Year.MIN_VALUE = YearConstants.MIN_VALUE;
  Year.MAX_VALUE = YearConstants.MAX_VALUE;
  PARSER = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).toFormatter();
  Year.FROM = createTemporalQuery("Year.FROM", function(temporal) {
    return Year.from(temporal);
  });
}
function _init$9() {
  IsoChronology.INSTANCE = new IsoChronology("IsoChronology");
}
function _init$8() {
  OffsetTime.MIN = OffsetTime.ofNumbers(0, 0, 0, 0, ZoneOffset.MAX);
  OffsetTime.MAX = OffsetTime.ofNumbers(23, 59, 59, 999999999, ZoneOffset.MIN);
  OffsetTime.FROM = createTemporalQuery("OffsetTime.FROM", function(temporal) {
    return OffsetTime.from(temporal);
  });
}
function strcmp(a, b) {
  if (a < b) {
    return -1;
  }
  if (a > b) {
    return 1;
  }
  return 0;
}
function _init$7() {
  ZonedDateTime.FROM = createTemporalQuery("ZonedDateTime.FROM", function(temporal) {
    return ZonedDateTime.from(temporal);
  });
}
function _init$6() {
  OffsetDateTime.MIN = LocalDateTime.MIN.atOffset(ZoneOffset.MAX);
  OffsetDateTime.MAX = LocalDateTime.MAX.atOffset(ZoneOffset.MIN);
  OffsetDateTime.FROM = createTemporalQuery("OffsetDateTime.FROM", function(temporal) {
    return OffsetDateTime.from(temporal);
  });
}
function _init$5() {
  LocalDate.MIN = LocalDate.of(YearConstants.MIN_VALUE, 1, 1);
  LocalDate.MAX = LocalDate.of(YearConstants.MAX_VALUE, 12, 31);
  LocalDate.EPOCH_0 = LocalDate.ofEpochDay(0);
  LocalDate.FROM = createTemporalQuery("LocalDate.FROM", function(temporal) {
    return LocalDate.from(temporal);
  });
}
function _init$4() {
  LocalDateTime.MIN = LocalDateTime.of(LocalDate.MIN, LocalTime.MIN);
  LocalDateTime.MAX = LocalDateTime.of(LocalDate.MAX, LocalTime.MAX);
  LocalDateTime.FROM = createTemporalQuery("LocalDateTime.FROM", function(temporal) {
    return LocalDateTime.from(temporal);
  });
}
function _init$3() {
  LocalTime.HOURS = [];
  for (var hour = 0; hour < 24; hour++) {
    LocalTime.of(hour, 0, 0, 0);
  }
  LocalTime.MIN = LocalTime.HOURS[0];
  LocalTime.MAX = new LocalTime(23, 59, 59, 999999999);
  LocalTime.MIDNIGHT = LocalTime.HOURS[0];
  LocalTime.NOON = LocalTime.HOURS[12];
  LocalTime.FROM = createTemporalQuery("LocalTime.FROM", function(temporal) {
    return LocalTime.from(temporal);
  });
}
function _init$2() {
  Instant.MIN_SECONDS = -31619119219200;
  Instant.MAX_SECONDS = 31494816403199;
  Instant.EPOCH = new Instant(0, 0);
  Instant.MIN = Instant.ofEpochSecond(Instant.MIN_SECONDS, 0);
  Instant.MAX = Instant.ofEpochSecond(Instant.MAX_SECONDS, 999999999);
  Instant.FROM = createTemporalQuery("Instant.FROM", function(temporal) {
    return Instant.from(temporal);
  });
}
function _init$1() {
  TemporalQueries.ZONE_ID = createTemporalQuery("ZONE_ID", function(temporal) {
    return temporal.query(TemporalQueries.ZONE_ID);
  });
  TemporalQueries.CHRONO = createTemporalQuery("CHRONO", function(temporal) {
    return temporal.query(TemporalQueries.CHRONO);
  });
  TemporalQueries.PRECISION = createTemporalQuery("PRECISION", function(temporal) {
    return temporal.query(TemporalQueries.PRECISION);
  });
  TemporalQueries.OFFSET = createTemporalQuery("OFFSET", function(temporal) {
    if (temporal.isSupported(ChronoField.OFFSET_SECONDS)) {
      return ZoneOffset.ofTotalSeconds(temporal.get(ChronoField.OFFSET_SECONDS));
    }
    return null;
  });
  TemporalQueries.ZONE = createTemporalQuery("ZONE", function(temporal) {
    var zone = temporal.query(TemporalQueries.ZONE_ID);
    return zone != null ? zone : temporal.query(TemporalQueries.OFFSET);
  });
  TemporalQueries.LOCAL_DATE = createTemporalQuery("LOCAL_DATE", function(temporal) {
    if (temporal.isSupported(ChronoField.EPOCH_DAY)) {
      return LocalDate.ofEpochDay(temporal.getLong(ChronoField.EPOCH_DAY));
    }
    return null;
  });
  TemporalQueries.LOCAL_TIME = createTemporalQuery("LOCAL_TIME", function(temporal) {
    if (temporal.isSupported(ChronoField.NANO_OF_DAY)) {
      return LocalTime.ofNanoOfDay(temporal.getLong(ChronoField.NANO_OF_DAY));
    }
    return null;
  });
}
function _init() {
  SYSTEM_DEFAULT_ZONE_ID_INSTANCE = new SystemDefaultZoneId();
  ZoneId.systemDefault = ZoneIdFactory.systemDefault;
  ZoneId.getAvailableZoneIds = ZoneIdFactory.getAvailableZoneIds;
  ZoneId.of = ZoneIdFactory.of;
  ZoneId.ofOffset = ZoneIdFactory.ofOffset;
  ZoneId.from = ZoneIdFactory.from;
  ZoneOffset.from = ZoneIdFactory.from;
  ZoneId.SYSTEM = SYSTEM_DEFAULT_ZONE_ID_INSTANCE;
  ZoneId.UTC = ZoneOffset.ofTotalSeconds(0);
}
function init() {
  if (isInit) {
    return;
  }
  isInit = true;
  _init$m();
  _init$n();
  _init$l();
  _init$k();
  _init$3();
  _init$f();
  _init$1();
  _init$j();
  _init$2();
  _init$5();
  _init$4();
  _init$a();
  _init$i();
  _init$b();
  _init$c();
  _init$h();
  _init$g();
  _init$7();
  _init();
  _init$9();
  _init$d();
  _init$e();
  _init$6();
  _init$8();
}
function convert(temporal, zone) {
  return new ToNativeJsConverter(temporal, zone);
}
function nativeJs(date, zone) {
  if (zone === void 0) {
    zone = ZoneId.systemDefault();
  }
  requireNonNull(date, "date");
  requireNonNull(zone, "zone");
  if (date instanceof Date) {
    return Instant.ofEpochMilli(date.getTime()).atZone(zone);
  } else if (typeof date.toDate === "function" && date.toDate() instanceof Date) {
    return Instant.ofEpochMilli(date.toDate().getTime()).atZone(zone);
  }
  throw new IllegalArgumentException("date must be a javascript Date or a moment instance");
}
function bindUse(jsJoda) {
  var used = [];
  return function use2(fn) {
    if (!~used.indexOf(fn)) {
      fn(jsJoda);
      used.push(fn);
    }
    return jsJoda;
  };
}
var DateTimeException, DateTimeParseException, UnsupportedTemporalTypeException, ArithmeticException, IllegalArgumentException, IllegalStateException, NullPointerException, assert$1, MAX_SAFE_INTEGER, MIN_SAFE_INTEGER, MathUtil, Enum, TemporalAmount, TemporalUnit, Duration, YearConstants, ChronoUnit, TemporalField, ValueRange, ChronoField, TemporalQueries, TemporalAccessor, TemporalQuery, DayOfWeek, ENUMS, Month, MONTHS, PATTERN, Period, ParsePosition, EnumMap, ResolverStyle, Temporal, ChronoLocalDate, StringUtil, ZoneId, ZoneRules, Fixed, SECONDS_CACHE, ID_CACHE, ZoneOffset, DateTimeBuilder, DateTimeParseContext, Parsed, DateTimePrintContext, IsoFields, QUARTER_DAYS, Field, DAY_OF_QUARTER_FIELD, QUARTER_OF_YEAR_FIELD, WEEK_OF_WEEK_BASED_YEAR_FIELD, WEEK_BASED_YEAR_FIELD, Unit, DAY_OF_QUARTER, QUARTER_OF_YEAR, WEEK_OF_WEEK_BASED_YEAR, WEEK_BASED_YEAR, WEEK_BASED_YEARS, QUARTER_YEARS, DecimalStyle, SignStyle, TextStyle, CharLiteralPrinterParser, CompositePrinterParser, FractionPrinterParser, MAX_WIDTH$1, EXCEED_POINTS, NumberPrinterParser, ReducedPrinterParser, PATTERNS, OffsetIdPrinterParser, PadPrinterParserDecorator, SettingsParser, StringLiteralPrinterParser, ZoneRulesProvider, ZoneRegion, ZoneIdPrinterParser, ZoneIdTree, ZoneIdTreeMap, zoneIdTree, MAX_WIDTH, DateTimeFormatterBuilder, SECONDS_PER_10000_YEARS, SECONDS_0000_TO_1970, InstantPrinterParser, DefaultingParser, StringBuilder, DateTimeFormatter, MonthDay, PARSER$2, YearMonth, PARSER$1, Year, PARSER, TemporalAdjuster, TemporalAdjusters, Impl, DayOfWeekInMonth, RelativeDayOfWeek, IsoChronology, OffsetTime, ChronoZonedDateTime, ZonedDateTime, OffsetDateTime, DAYS_PER_CYCLE, DAYS_0000_TO_1970, LocalDate, ChronoLocalDateTime, LocalDateTime, LocalTime, NANOS_PER_MILLI, Instant, Clock, SystemClock, FixedClock, OffsetClock, ZoneOffsetTransition, SystemDefaultZoneRules, SystemDefaultZoneId, ZoneIdFactory, SYSTEM_DEFAULT_ZONE_ID_INSTANCE, isInit, ToNativeJsConverter, _, jsJodaExports, use;
var init_js_joda_esm = __esm({
  "node_modules/@js-joda/core/dist/js-joda.esm.js"() {
    DateTimeException = createErrorType("DateTimeException", messageWithCause);
    DateTimeParseException = createErrorType("DateTimeParseException", messageForDateTimeParseException);
    UnsupportedTemporalTypeException = createErrorType("UnsupportedTemporalTypeException", null, DateTimeException);
    ArithmeticException = createErrorType("ArithmeticException");
    IllegalArgumentException = createErrorType("IllegalArgumentException");
    IllegalStateException = createErrorType("IllegalStateException");
    NullPointerException = createErrorType("NullPointerException");
    assert$1 = Object.freeze({
      __proto__: null,
      abstractMethodFail,
      assert,
      requireInstance,
      requireNonNull
    });
    MAX_SAFE_INTEGER = 9007199254740991;
    MIN_SAFE_INTEGER = -9007199254740991;
    MathUtil = function() {
      function MathUtil2() {
      }
      MathUtil2.intDiv = function intDiv(x, y) {
        var r = x / y;
        r = MathUtil2.roundDown(r);
        return MathUtil2.safeZero(r);
      };
      MathUtil2.intMod = function intMod(x, y) {
        var r = x - MathUtil2.intDiv(x, y) * y;
        r = MathUtil2.roundDown(r);
        return MathUtil2.safeZero(r);
      };
      MathUtil2.roundDown = function roundDown(r) {
        if (r < 0) {
          return Math.ceil(r);
        } else {
          return Math.floor(r);
        }
      };
      MathUtil2.floorDiv = function floorDiv(x, y) {
        var r = Math.floor(x / y);
        return MathUtil2.safeZero(r);
      };
      MathUtil2.floorMod = function floorMod(x, y) {
        var r = x - MathUtil2.floorDiv(x, y) * y;
        return MathUtil2.safeZero(r);
      };
      MathUtil2.safeAdd = function safeAdd(x, y) {
        MathUtil2.verifyInt(x);
        MathUtil2.verifyInt(y);
        if (x === 0) {
          return MathUtil2.safeZero(y);
        }
        if (y === 0) {
          return MathUtil2.safeZero(x);
        }
        var r = MathUtil2.safeToInt(x + y);
        if (r === x || r === y) {
          throw new ArithmeticException("Invalid addition beyond MAX_SAFE_INTEGER!");
        }
        return r;
      };
      MathUtil2.safeSubtract = function safeSubtract(x, y) {
        MathUtil2.verifyInt(x);
        MathUtil2.verifyInt(y);
        if (x === 0 && y === 0) {
          return 0;
        } else if (x === 0) {
          return MathUtil2.safeZero(-1 * y);
        } else if (y === 0) {
          return MathUtil2.safeZero(x);
        }
        return MathUtil2.safeToInt(x - y);
      };
      MathUtil2.safeMultiply = function safeMultiply(x, y) {
        MathUtil2.verifyInt(x);
        MathUtil2.verifyInt(y);
        if (x === 1) {
          return MathUtil2.safeZero(y);
        }
        if (y === 1) {
          return MathUtil2.safeZero(x);
        }
        if (x === 0 || y === 0) {
          return 0;
        }
        var r = MathUtil2.safeToInt(x * y);
        if (r / y !== x || x === MIN_SAFE_INTEGER && y === -1 || y === MIN_SAFE_INTEGER && x === -1) {
          throw new ArithmeticException("Multiplication overflows: " + x + " * " + y);
        }
        return r;
      };
      MathUtil2.parseInt = function(_parseInt) {
        function parseInt2(_x) {
          return _parseInt.apply(this, arguments);
        }
        parseInt2.toString = function() {
          return _parseInt.toString();
        };
        return parseInt2;
      }(function(value) {
        var r = parseInt(value);
        return MathUtil2.safeToInt(r);
      });
      MathUtil2.safeToInt = function safeToInt(value) {
        MathUtil2.verifyInt(value);
        return MathUtil2.safeZero(value);
      };
      MathUtil2.verifyInt = function verifyInt(value) {
        if (value == null) {
          throw new ArithmeticException("Invalid value: '" + value + "', using null or undefined as argument");
        }
        if (isNaN(value)) {
          throw new ArithmeticException("Invalid int value, using NaN as argument");
        }
        if (Number.isInteger) {
          if (!Number.isInteger(Number(value))) {
            throw new ArithmeticException("Invalid value: '" + value + "' is a float");
          }
        } else if (value % 1 !== 0) {
          throw new ArithmeticException("Invalid value: '" + value + "' is a float");
        }
        if (value > MAX_SAFE_INTEGER || value < MIN_SAFE_INTEGER) {
          throw new ArithmeticException("Calculation overflows an int: " + value);
        }
      };
      MathUtil2.safeZero = function safeZero(value) {
        return value === 0 ? 0 : +value;
      };
      MathUtil2.compareNumbers = function compareNumbers(a, b) {
        if (a < b) {
          return -1;
        }
        if (a > b) {
          return 1;
        }
        return 0;
      };
      MathUtil2.smi = function smi(int) {
        return int >>> 1 & 1073741824 | int & 3221225471;
      };
      MathUtil2.hash = function hash(number) {
        if (number !== number || number === Infinity) {
          return 0;
        }
        var result = number;
        while (number > 4294967295) {
          number /= 4294967295;
          result ^= number;
        }
        return MathUtil2.smi(result);
      };
      MathUtil2.hashCode = function hashCode() {
        var result = 17;
        for (var _len = arguments.length, numbers = new Array(_len), _key = 0; _key < _len; _key++) {
          numbers[_key] = arguments[_key];
        }
        for (var _i = 0, _numbers = numbers; _i < _numbers.length; _i++) {
          var n = _numbers[_i];
          result = (result << 5) - result + MathUtil2.hash(n);
        }
        return MathUtil2.hash(result);
      };
      return MathUtil2;
    }();
    MathUtil.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;
    MathUtil.MIN_SAFE_INTEGER = MIN_SAFE_INTEGER;
    Enum = function() {
      function Enum2(name3) {
        this._name = name3;
      }
      var _proto = Enum2.prototype;
      _proto.equals = function equals(other) {
        return this === other;
      };
      _proto.toString = function toString() {
        return this._name;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      return Enum2;
    }();
    TemporalAmount = function() {
      function TemporalAmount2() {
      }
      var _proto = TemporalAmount2.prototype;
      _proto.get = function get(unit) {
        abstractMethodFail("get");
      };
      _proto.units = function units() {
        abstractMethodFail("units");
      };
      _proto.addTo = function addTo(temporal) {
        abstractMethodFail("addTo");
      };
      _proto.subtractFrom = function subtractFrom(temporal) {
        abstractMethodFail("subtractFrom");
      };
      return TemporalAmount2;
    }();
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive) {
      TemporalAmount.prototype[Symbol.toPrimitive] = function(hint) {
        if (hint !== "number") {
          return this.toString();
        }
        throw new TypeError("A conversion from TemporalAmount to a number is not allowed. To compare use the methods .equals(), .compareTo(), .isBefore() or one that is more suitable to your use case.");
      };
    }
    TemporalUnit = function() {
      function TemporalUnit2() {
      }
      var _proto = TemporalUnit2.prototype;
      _proto.duration = function duration() {
        abstractMethodFail("duration");
      };
      _proto.isDurationEstimated = function isDurationEstimated() {
        abstractMethodFail("isDurationEstimated");
      };
      _proto.isDateBased = function isDateBased() {
        abstractMethodFail("isDateBased");
      };
      _proto.isTimeBased = function isTimeBased() {
        abstractMethodFail("isTimeBased");
      };
      _proto.isSupportedBy = function isSupportedBy(temporal) {
        abstractMethodFail("isSupportedBy");
      };
      _proto.addTo = function addTo(dateTime, periodToAdd) {
        abstractMethodFail("addTo");
      };
      _proto.between = function between(temporal1, temporal2) {
        abstractMethodFail("between");
      };
      return TemporalUnit2;
    }();
    Duration = function(_TemporalAmount) {
      _inheritsLoose(Duration2, _TemporalAmount);
      function Duration2(seconds, nanos) {
        var _this;
        _this = _TemporalAmount.call(this) || this;
        _this._seconds = MathUtil.safeToInt(seconds);
        _this._nanos = MathUtil.safeToInt(nanos);
        return _this;
      }
      Duration2.ofDays = function ofDays(days) {
        return Duration2._create(MathUtil.safeMultiply(days, LocalTime.SECONDS_PER_DAY), 0);
      };
      Duration2.ofHours = function ofHours(hours) {
        return Duration2._create(MathUtil.safeMultiply(hours, LocalTime.SECONDS_PER_HOUR), 0);
      };
      Duration2.ofMinutes = function ofMinutes(minutes) {
        return Duration2._create(MathUtil.safeMultiply(minutes, LocalTime.SECONDS_PER_MINUTE), 0);
      };
      Duration2.ofSeconds = function ofSeconds(seconds, nanoAdjustment) {
        if (nanoAdjustment === void 0) {
          nanoAdjustment = 0;
        }
        var secs = MathUtil.safeAdd(seconds, MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND));
        var nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);
        return Duration2._create(secs, nos);
      };
      Duration2.ofMillis = function ofMillis(millis) {
        var secs = MathUtil.intDiv(millis, 1e3);
        var mos = MathUtil.intMod(millis, 1e3);
        if (mos < 0) {
          mos += 1e3;
          secs--;
        }
        return Duration2._create(secs, mos * 1e6);
      };
      Duration2.ofNanos = function ofNanos(nanos) {
        var secs = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_SECOND);
        var nos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_SECOND);
        if (nos < 0) {
          nos += LocalTime.NANOS_PER_SECOND;
          secs--;
        }
        return this._create(secs, nos);
      };
      Duration2.of = function of(amount, unit) {
        return Duration2.ZERO.plus(amount, unit);
      };
      Duration2.from = function from(amount) {
        requireNonNull(amount, "amount");
        requireInstance(amount, TemporalAmount);
        var duration = Duration2.ZERO;
        amount.units().forEach(function(unit) {
          duration = duration.plus(amount.get(unit), unit);
        });
        return duration;
      };
      Duration2.between = function between(startInclusive, endExclusive) {
        requireNonNull(startInclusive, "startInclusive");
        requireNonNull(endExclusive, "endExclusive");
        var secs = startInclusive.until(endExclusive, ChronoUnit.SECONDS);
        var nanos = 0;
        if (startInclusive.isSupported(ChronoField.NANO_OF_SECOND) && endExclusive.isSupported(ChronoField.NANO_OF_SECOND)) {
          try {
            var startNos = startInclusive.getLong(ChronoField.NANO_OF_SECOND);
            nanos = endExclusive.getLong(ChronoField.NANO_OF_SECOND) - startNos;
            if (secs > 0 && nanos < 0) {
              nanos += LocalTime.NANOS_PER_SECOND;
            } else if (secs < 0 && nanos > 0) {
              nanos -= LocalTime.NANOS_PER_SECOND;
            } else if (secs === 0 && nanos !== 0) {
              var adjustedEnd = endExclusive.with(ChronoField.NANO_OF_SECOND, startNos);
              secs = startInclusive.until(adjustedEnd, ChronoUnit.SECONDS);
            }
          } catch (e) {
          }
        }
        return this.ofSeconds(secs, nanos);
      };
      Duration2.parse = function parse2(text) {
        requireNonNull(text, "text");
        var PATTERN2 = new RegExp("([-+]?)P(?:([-+]?[0-9]+)D)?(T(?:([-+]?[0-9]+)H)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)(?:[.,]([0-9]{0,9}))?S)?)?", "i");
        var matches = PATTERN2.exec(text);
        if (matches !== null) {
          if ("T" === matches[3] === false) {
            var negate = "-" === matches[1];
            var dayMatch = matches[2];
            var hourMatch = matches[4];
            var minuteMatch = matches[5];
            var secondMatch = matches[6];
            var fractionMatch = matches[7];
            if (dayMatch != null || hourMatch != null || minuteMatch != null || secondMatch != null) {
              var daysAsSecs = Duration2._parseNumber(text, dayMatch, LocalTime.SECONDS_PER_DAY, "days");
              var hoursAsSecs = Duration2._parseNumber(text, hourMatch, LocalTime.SECONDS_PER_HOUR, "hours");
              var minsAsSecs = Duration2._parseNumber(text, minuteMatch, LocalTime.SECONDS_PER_MINUTE, "minutes");
              var seconds = Duration2._parseNumber(text, secondMatch, 1, "seconds");
              var negativeSecs = secondMatch != null && secondMatch.charAt(0) === "-";
              var nanos = Duration2._parseFraction(text, fractionMatch, negativeSecs ? -1 : 1);
              try {
                return Duration2._create(negate, daysAsSecs, hoursAsSecs, minsAsSecs, seconds, nanos);
              } catch (ex) {
                throw new DateTimeParseException("Text cannot be parsed to a Duration: overflow", text, 0, ex);
              }
            }
          }
        }
        throw new DateTimeParseException("Text cannot be parsed to a Duration", text, 0);
      };
      Duration2._parseNumber = function _parseNumber(text, parsed, multiplier, errorText) {
        if (parsed == null) {
          return 0;
        }
        try {
          if (parsed[0] === "+") {
            parsed = parsed.substring(1);
          }
          return MathUtil.safeMultiply(parseFloat(parsed), multiplier);
        } catch (ex) {
          throw new DateTimeParseException("Text cannot be parsed to a Duration: " + errorText, text, 0, ex);
        }
      };
      Duration2._parseFraction = function _parseFraction(text, parsed, negate) {
        if (parsed == null || parsed.length === 0) {
          return 0;
        }
        parsed = (parsed + "000000000").substring(0, 9);
        return parseFloat(parsed) * negate;
      };
      Duration2._create = function _create() {
        if (arguments.length <= 2) {
          return Duration2._createSecondsNanos(arguments[0], arguments[1]);
        } else {
          return Duration2._createNegateDaysHoursMinutesSecondsNanos(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
        }
      };
      Duration2._createNegateDaysHoursMinutesSecondsNanos = function _createNegateDaysHoursMinutesSecondsNanos(negate, daysAsSecs, hoursAsSecs, minsAsSecs, secs, nanos) {
        var seconds = MathUtil.safeAdd(daysAsSecs, MathUtil.safeAdd(hoursAsSecs, MathUtil.safeAdd(minsAsSecs, secs)));
        if (negate) {
          return Duration2.ofSeconds(seconds, nanos).negated();
        }
        return Duration2.ofSeconds(seconds, nanos);
      };
      Duration2._createSecondsNanos = function _createSecondsNanos(seconds, nanoAdjustment) {
        if (seconds === void 0) {
          seconds = 0;
        }
        if (nanoAdjustment === void 0) {
          nanoAdjustment = 0;
        }
        if (seconds === 0 && nanoAdjustment === 0) {
          return Duration2.ZERO;
        }
        return new Duration2(seconds, nanoAdjustment);
      };
      var _proto = Duration2.prototype;
      _proto.get = function get(unit) {
        if (unit === ChronoUnit.SECONDS) {
          return this._seconds;
        } else if (unit === ChronoUnit.NANOS) {
          return this._nanos;
        } else {
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
      };
      _proto.units = function units() {
        return [ChronoUnit.SECONDS, ChronoUnit.NANOS];
      };
      _proto.isZero = function isZero() {
        return this._seconds === 0 && this._nanos === 0;
      };
      _proto.isNegative = function isNegative() {
        return this._seconds < 0;
      };
      _proto.seconds = function seconds() {
        return this._seconds;
      };
      _proto.nano = function nano() {
        return this._nanos;
      };
      _proto.withSeconds = function withSeconds(seconds) {
        return Duration2._create(seconds, this._nanos);
      };
      _proto.withNanos = function withNanos(nanoOfSecond) {
        ChronoField.NANO_OF_SECOND.checkValidIntValue(nanoOfSecond);
        return Duration2._create(this._seconds, nanoOfSecond);
      };
      _proto.plusDuration = function plusDuration(duration) {
        requireNonNull(duration, "duration");
        return this.plus(duration.seconds(), duration.nano());
      };
      _proto.plus = function plus(durationOrNumber, unitOrNumber) {
        if (arguments.length === 1) {
          return this.plusDuration(durationOrNumber);
        } else if (arguments.length === 2 && unitOrNumber instanceof TemporalUnit) {
          return this.plusAmountUnit(durationOrNumber, unitOrNumber);
        } else {
          return this.plusSecondsNanos(durationOrNumber, unitOrNumber);
        }
      };
      _proto.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {
        requireNonNull(amountToAdd, "amountToAdd");
        requireNonNull(unit, "unit");
        if (unit === ChronoUnit.DAYS) {
          return this.plusSecondsNanos(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY), 0);
        }
        if (unit.isDurationEstimated()) {
          throw new UnsupportedTemporalTypeException("Unit must not have an estimated duration");
        }
        if (amountToAdd === 0) {
          return this;
        }
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.NANOS:
              return this.plusNanos(amountToAdd);
            case ChronoUnit.MICROS:
              return this.plusSecondsNanos(MathUtil.intDiv(amountToAdd, 1e6 * 1e3) * 1e3, MathUtil.intMod(amountToAdd, 1e6 * 1e3) * 1e3);
            case ChronoUnit.MILLIS:
              return this.plusMillis(amountToAdd);
            case ChronoUnit.SECONDS:
              return this.plusSeconds(amountToAdd);
          }
          return this.plusSecondsNanos(MathUtil.safeMultiply(unit.duration().seconds(), amountToAdd), 0);
        }
        var duration = unit.duration().multipliedBy(amountToAdd);
        return this.plusSecondsNanos(duration.seconds(), duration.nano());
      };
      _proto.plusDays = function plusDays(daysToAdd) {
        return this.plusSecondsNanos(MathUtil.safeMultiply(daysToAdd, LocalTime.SECONDS_PER_DAY), 0);
      };
      _proto.plusHours = function plusHours(hoursToAdd) {
        return this.plusSecondsNanos(MathUtil.safeMultiply(hoursToAdd, LocalTime.SECONDS_PER_HOUR), 0);
      };
      _proto.plusMinutes = function plusMinutes(minutesToAdd) {
        return this.plusSecondsNanos(MathUtil.safeMultiply(minutesToAdd, LocalTime.SECONDS_PER_MINUTE), 0);
      };
      _proto.plusSeconds = function plusSeconds(secondsToAdd) {
        return this.plusSecondsNanos(secondsToAdd, 0);
      };
      _proto.plusMillis = function plusMillis(millisToAdd) {
        return this.plusSecondsNanos(MathUtil.intDiv(millisToAdd, 1e3), MathUtil.intMod(millisToAdd, 1e3) * 1e6);
      };
      _proto.plusNanos = function plusNanos(nanosToAdd) {
        return this.plusSecondsNanos(0, nanosToAdd);
      };
      _proto.plusSecondsNanos = function plusSecondsNanos(secondsToAdd, nanosToAdd) {
        requireNonNull(secondsToAdd, "secondsToAdd");
        requireNonNull(nanosToAdd, "nanosToAdd");
        if (secondsToAdd === 0 && nanosToAdd === 0) {
          return this;
        }
        var epochSec = MathUtil.safeAdd(this._seconds, secondsToAdd);
        epochSec = MathUtil.safeAdd(epochSec, MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND));
        nanosToAdd = MathUtil.intMod(nanosToAdd, LocalTime.NANOS_PER_SECOND);
        var nanoAdjustment = MathUtil.safeAdd(this._nanos, nanosToAdd);
        return Duration2.ofSeconds(epochSec, nanoAdjustment);
      };
      _proto.minus = function minus(durationOrNumber, unit) {
        if (arguments.length === 1) {
          return this.minusDuration(durationOrNumber);
        } else {
          return this.minusAmountUnit(durationOrNumber, unit);
        }
      };
      _proto.minusDuration = function minusDuration(duration) {
        requireNonNull(duration, "duration");
        var secsToSubtract = duration.seconds();
        var nanosToSubtract = duration.nano();
        if (secsToSubtract === MIN_SAFE_INTEGER) {
          return this.plus(MAX_SAFE_INTEGER, -nanosToSubtract);
        }
        return this.plus(-secsToSubtract, -nanosToSubtract);
      };
      _proto.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {
        requireNonNull(amountToSubtract, "amountToSubtract");
        requireNonNull(unit, "unit");
        return amountToSubtract === MIN_SAFE_INTEGER ? this.plusAmountUnit(MAX_SAFE_INTEGER, unit) : this.plusAmountUnit(-amountToSubtract, unit);
      };
      _proto.minusDays = function minusDays(daysToSubtract) {
        return daysToSubtract === MIN_SAFE_INTEGER ? this.plusDays(MAX_SAFE_INTEGER) : this.plusDays(-daysToSubtract);
      };
      _proto.minusHours = function minusHours(hoursToSubtract) {
        return hoursToSubtract === MIN_SAFE_INTEGER ? this.plusHours(MAX_SAFE_INTEGER) : this.plusHours(-hoursToSubtract);
      };
      _proto.minusMinutes = function minusMinutes(minutesToSubtract) {
        return minutesToSubtract === MIN_SAFE_INTEGER ? this.plusMinutes(MAX_SAFE_INTEGER) : this.plusMinutes(-minutesToSubtract);
      };
      _proto.minusSeconds = function minusSeconds(secondsToSubtract) {
        return secondsToSubtract === MIN_SAFE_INTEGER ? this.plusSeconds(MAX_SAFE_INTEGER) : this.plusSeconds(-secondsToSubtract);
      };
      _proto.minusMillis = function minusMillis(millisToSubtract) {
        return millisToSubtract === MIN_SAFE_INTEGER ? this.plusMillis(MAX_SAFE_INTEGER) : this.plusMillis(-millisToSubtract);
      };
      _proto.minusNanos = function minusNanos(nanosToSubtract) {
        return nanosToSubtract === MIN_SAFE_INTEGER ? this.plusNanos(MAX_SAFE_INTEGER) : this.plusNanos(-nanosToSubtract);
      };
      _proto.multipliedBy = function multipliedBy(multiplicand) {
        if (multiplicand === 0) {
          return Duration2.ZERO;
        }
        if (multiplicand === 1) {
          return this;
        }
        var secs = MathUtil.safeMultiply(this._seconds, multiplicand);
        var nos = MathUtil.safeMultiply(this._nanos, multiplicand);
        secs = secs + MathUtil.intDiv(nos, LocalTime.NANOS_PER_SECOND);
        nos = MathUtil.intMod(nos, LocalTime.NANOS_PER_SECOND);
        return Duration2.ofSeconds(secs, nos);
      };
      _proto.dividedBy = function dividedBy(divisor) {
        if (divisor === 0) {
          throw new ArithmeticException("Cannot divide by zero");
        }
        if (divisor === 1) {
          return this;
        }
        var secs = MathUtil.intDiv(this._seconds, divisor);
        var secsMod = MathUtil.roundDown((this._seconds / divisor - secs) * LocalTime.NANOS_PER_SECOND);
        var nos = MathUtil.intDiv(this._nanos, divisor);
        nos = secsMod + nos;
        return Duration2.ofSeconds(secs, nos);
      };
      _proto.negated = function negated() {
        return this.multipliedBy(-1);
      };
      _proto.abs = function abs() {
        return this.isNegative() ? this.negated() : this;
      };
      _proto.addTo = function addTo(temporal) {
        requireNonNull(temporal, "temporal");
        if (this._seconds !== 0) {
          temporal = temporal.plus(this._seconds, ChronoUnit.SECONDS);
        }
        if (this._nanos !== 0) {
          temporal = temporal.plus(this._nanos, ChronoUnit.NANOS);
        }
        return temporal;
      };
      _proto.subtractFrom = function subtractFrom(temporal) {
        requireNonNull(temporal, "temporal");
        if (this._seconds !== 0) {
          temporal = temporal.minus(this._seconds, ChronoUnit.SECONDS);
        }
        if (this._nanos !== 0) {
          temporal = temporal.minus(this._nanos, ChronoUnit.NANOS);
        }
        return temporal;
      };
      _proto.toDays = function toDays() {
        return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_DAY);
      };
      _proto.toHours = function toHours() {
        return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);
      };
      _proto.toMinutes = function toMinutes() {
        return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_MINUTE);
      };
      _proto.toMillis = function toMillis() {
        var millis = Math.round(MathUtil.safeMultiply(this._seconds, 1e3));
        millis = MathUtil.safeAdd(millis, MathUtil.intDiv(this._nanos, 1e6));
        return millis;
      };
      _proto.toNanos = function toNanos() {
        var totalNanos = MathUtil.safeMultiply(this._seconds, LocalTime.NANOS_PER_SECOND);
        totalNanos = MathUtil.safeAdd(totalNanos, this._nanos);
        return totalNanos;
      };
      _proto.compareTo = function compareTo(otherDuration) {
        requireNonNull(otherDuration, "otherDuration");
        requireInstance(otherDuration, Duration2, "otherDuration");
        var cmp = MathUtil.compareNumbers(this._seconds, otherDuration.seconds());
        if (cmp !== 0) {
          return cmp;
        }
        return this._nanos - otherDuration.nano();
      };
      _proto.equals = function equals(otherDuration) {
        if (this === otherDuration) {
          return true;
        }
        if (otherDuration instanceof Duration2) {
          return this.seconds() === otherDuration.seconds() && this.nano() === otherDuration.nano();
        }
        return false;
      };
      _proto.toString = function toString() {
        if (this === Duration2.ZERO) {
          return "PT0S";
        }
        var hours = MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);
        var minutes = MathUtil.intDiv(MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_HOUR), LocalTime.SECONDS_PER_MINUTE);
        var secs = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_MINUTE);
        var rval = "PT";
        if (hours !== 0) {
          rval += hours + "H";
        }
        if (minutes !== 0) {
          rval += minutes + "M";
        }
        if (secs === 0 && this._nanos === 0 && rval.length > 2) {
          return rval;
        }
        if (secs < 0 && this._nanos > 0) {
          if (secs === -1) {
            rval += "-0";
          } else {
            rval += secs + 1;
          }
        } else {
          rval += secs;
        }
        if (this._nanos > 0) {
          rval += ".";
          var nanoString;
          if (secs < 0) {
            nanoString = "" + (2 * LocalTime.NANOS_PER_SECOND - this._nanos);
          } else {
            nanoString = "" + (LocalTime.NANOS_PER_SECOND + this._nanos);
          }
          nanoString = nanoString.slice(1, nanoString.length);
          rval += nanoString;
          while (rval.charAt(rval.length - 1) === "0") {
            rval = rval.slice(0, rval.length - 1);
          }
        }
        rval += "S";
        return rval;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      return Duration2;
    }(TemporalAmount);
    YearConstants = function YearConstants2() {
    };
    ChronoUnit = function(_TemporalUnit) {
      _inheritsLoose(ChronoUnit2, _TemporalUnit);
      function ChronoUnit2(name3, estimatedDuration) {
        var _this;
        _this = _TemporalUnit.call(this) || this;
        _this._name = name3;
        _this._duration = estimatedDuration;
        return _this;
      }
      var _proto = ChronoUnit2.prototype;
      _proto.duration = function duration() {
        return this._duration;
      };
      _proto.isDurationEstimated = function isDurationEstimated() {
        return this.isDateBased() || this === ChronoUnit2.FOREVER;
      };
      _proto.isDateBased = function isDateBased() {
        return this.compareTo(ChronoUnit2.DAYS) >= 0 && this !== ChronoUnit2.FOREVER;
      };
      _proto.isTimeBased = function isTimeBased() {
        return this.compareTo(ChronoUnit2.DAYS) < 0;
      };
      _proto.isSupportedBy = function isSupportedBy(temporal) {
        if (this === ChronoUnit2.FOREVER) {
          return false;
        }
        try {
          temporal.plus(1, this);
          return true;
        } catch (e) {
          try {
            temporal.plus(-1, this);
            return true;
          } catch (e2) {
            return false;
          }
        }
      };
      _proto.addTo = function addTo(temporal, amount) {
        return temporal.plus(amount, this);
      };
      _proto.between = function between(temporal1, temporal2) {
        return temporal1.until(temporal2, this);
      };
      _proto.toString = function toString() {
        return this._name;
      };
      _proto.compareTo = function compareTo(other) {
        return this.duration().compareTo(other.duration());
      };
      return ChronoUnit2;
    }(TemporalUnit);
    TemporalField = function() {
      function TemporalField2() {
      }
      var _proto = TemporalField2.prototype;
      _proto.isDateBased = function isDateBased() {
        abstractMethodFail("isDateBased");
      };
      _proto.isTimeBased = function isTimeBased() {
        abstractMethodFail("isTimeBased");
      };
      _proto.baseUnit = function baseUnit() {
        abstractMethodFail("baseUnit");
      };
      _proto.rangeUnit = function rangeUnit() {
        abstractMethodFail("rangeUnit");
      };
      _proto.range = function range() {
        abstractMethodFail("range");
      };
      _proto.rangeRefinedBy = function rangeRefinedBy(temporal) {
        abstractMethodFail("rangeRefinedBy");
      };
      _proto.getFrom = function getFrom(temporal) {
        abstractMethodFail("getFrom");
      };
      _proto.adjustInto = function adjustInto(temporal, newValue) {
        abstractMethodFail("adjustInto");
      };
      _proto.isSupportedBy = function isSupportedBy(temporal) {
        abstractMethodFail("isSupportedBy");
      };
      _proto.displayName = function displayName() {
        abstractMethodFail("displayName");
      };
      _proto.equals = function equals(other) {
        abstractMethodFail("equals");
      };
      _proto.name = function name3() {
        abstractMethodFail("name");
      };
      return TemporalField2;
    }();
    ValueRange = function() {
      function ValueRange2(minSmallest, minLargest, maxSmallest, maxLargest) {
        assert(!(minSmallest > minLargest), "Smallest minimum value '" + minSmallest + "' must be less than largest minimum value '" + minLargest + "'", IllegalArgumentException);
        assert(!(maxSmallest > maxLargest), "Smallest maximum value '" + maxSmallest + "' must be less than largest maximum value '" + maxLargest + "'", IllegalArgumentException);
        assert(!(minLargest > maxLargest), "Minimum value '" + minLargest + "' must be less than maximum value '" + maxLargest + "'", IllegalArgumentException);
        this._minSmallest = minSmallest;
        this._minLargest = minLargest;
        this._maxLargest = maxLargest;
        this._maxSmallest = maxSmallest;
      }
      var _proto = ValueRange2.prototype;
      _proto.isFixed = function isFixed() {
        return this._minSmallest === this._minLargest && this._maxSmallest === this._maxLargest;
      };
      _proto.minimum = function minimum() {
        return this._minSmallest;
      };
      _proto.largestMinimum = function largestMinimum() {
        return this._minLargest;
      };
      _proto.maximum = function maximum() {
        return this._maxLargest;
      };
      _proto.smallestMaximum = function smallestMaximum() {
        return this._maxSmallest;
      };
      _proto.isValidValue = function isValidValue(value) {
        return this.minimum() <= value && value <= this.maximum();
      };
      _proto.checkValidValue = function checkValidValue(value, field) {
        var msg;
        if (!this.isValidValue(value)) {
          if (field != null) {
            msg = "Invalid value for " + field + " (valid values " + this.toString() + "): " + value;
          } else {
            msg = "Invalid value (valid values " + this.toString() + "): " + value;
          }
          return assert(false, msg, DateTimeException);
        }
        return value;
      };
      _proto.checkValidIntValue = function checkValidIntValue(value, field) {
        if (this.isValidIntValue(value) === false) {
          throw new DateTimeException("Invalid int value for " + field + ": " + value);
        }
        return value;
      };
      _proto.isValidIntValue = function isValidIntValue(value) {
        return this.isIntValue() && this.isValidValue(value);
      };
      _proto.isIntValue = function isIntValue() {
        return this.minimum() >= MathUtil.MIN_SAFE_INTEGER && this.maximum() <= MathUtil.MAX_SAFE_INTEGER;
      };
      _proto.equals = function equals(other) {
        if (other === this) {
          return true;
        }
        if (other instanceof ValueRange2) {
          return this._minSmallest === other._minSmallest && this._minLargest === other._minLargest && this._maxSmallest === other._maxSmallest && this._maxLargest === other._maxLargest;
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return MathUtil.hashCode(this._minSmallest, this._minLargest, this._maxSmallest, this._maxLargest);
      };
      _proto.toString = function toString() {
        var str = this.minimum() + (this.minimum() !== this.largestMinimum() ? "/" + this.largestMinimum() : "");
        str += " - ";
        str += this.smallestMaximum() + (this.smallestMaximum() !== this.maximum() ? "/" + this.maximum() : "");
        return str;
      };
      ValueRange2.of = function of() {
        if (arguments.length === 2) {
          return new ValueRange2(arguments[0], arguments[0], arguments[1], arguments[1]);
        } else if (arguments.length === 3) {
          return new ValueRange2(arguments[0], arguments[0], arguments[1], arguments[2]);
        } else if (arguments.length === 4) {
          return new ValueRange2(arguments[0], arguments[1], arguments[2], arguments[3]);
        } else {
          return assert(false, "Invalid number of arguments " + arguments.length, IllegalArgumentException);
        }
      };
      return ValueRange2;
    }();
    ChronoField = function(_TemporalField) {
      _inheritsLoose(ChronoField2, _TemporalField);
      ChronoField2.byName = function byName(fieldName) {
        for (var prop in ChronoField2) {
          if (ChronoField2[prop]) {
            if (ChronoField2[prop] instanceof ChronoField2 && ChronoField2[prop].name() === fieldName) {
              return ChronoField2[prop];
            }
          }
        }
      };
      function ChronoField2(name3, baseUnit, rangeUnit, range) {
        var _this;
        _this = _TemporalField.call(this) || this;
        _this._name = name3;
        _this._baseUnit = baseUnit;
        _this._rangeUnit = rangeUnit;
        _this._range = range;
        return _this;
      }
      var _proto = ChronoField2.prototype;
      _proto.name = function name3() {
        return this._name;
      };
      _proto.baseUnit = function baseUnit() {
        return this._baseUnit;
      };
      _proto.rangeUnit = function rangeUnit() {
        return this._rangeUnit;
      };
      _proto.range = function range() {
        return this._range;
      };
      _proto.displayName = function displayName() {
        return this.toString();
      };
      _proto.checkValidValue = function checkValidValue(value) {
        return this.range().checkValidValue(value, this);
      };
      _proto.checkValidIntValue = function checkValidIntValue(value) {
        return this.range().checkValidIntValue(value, this);
      };
      _proto.isDateBased = function isDateBased() {
        var dateBased = this === ChronoField2.DAY_OF_WEEK || this === ChronoField2.ALIGNED_DAY_OF_WEEK_IN_MONTH || this === ChronoField2.ALIGNED_DAY_OF_WEEK_IN_YEAR || this === ChronoField2.DAY_OF_MONTH || this === ChronoField2.DAY_OF_YEAR || this === ChronoField2.EPOCH_DAY || this === ChronoField2.ALIGNED_WEEK_OF_MONTH || this === ChronoField2.ALIGNED_WEEK_OF_YEAR || this === ChronoField2.MONTH_OF_YEAR || this === ChronoField2.PROLEPTIC_MONTH || this === ChronoField2.YEAR_OF_ERA || this === ChronoField2.YEAR || this === ChronoField2.ERA;
        return dateBased;
      };
      _proto.isTimeBased = function isTimeBased() {
        var timeBased = this === ChronoField2.NANO_OF_SECOND || this === ChronoField2.NANO_OF_DAY || this === ChronoField2.MICRO_OF_SECOND || this === ChronoField2.MICRO_OF_DAY || this === ChronoField2.MILLI_OF_SECOND || this === ChronoField2.MILLI_OF_DAY || this === ChronoField2.SECOND_OF_MINUTE || this === ChronoField2.SECOND_OF_DAY || this === ChronoField2.MINUTE_OF_HOUR || this === ChronoField2.MINUTE_OF_DAY || this === ChronoField2.HOUR_OF_AMPM || this === ChronoField2.CLOCK_HOUR_OF_AMPM || this === ChronoField2.HOUR_OF_DAY || this === ChronoField2.CLOCK_HOUR_OF_DAY || this === ChronoField2.AMPM_OF_DAY;
        return timeBased;
      };
      _proto.rangeRefinedBy = function rangeRefinedBy(temporal) {
        return temporal.range(this);
      };
      _proto.getFrom = function getFrom(temporal) {
        return temporal.getLong(this);
      };
      _proto.toString = function toString() {
        return this.name();
      };
      _proto.equals = function equals(other) {
        return this === other;
      };
      _proto.adjustInto = function adjustInto(temporal, newValue) {
        return temporal.with(this, newValue);
      };
      _proto.isSupportedBy = function isSupportedBy(temporal) {
        return temporal.isSupported(this);
      };
      return ChronoField2;
    }(TemporalField);
    TemporalQueries = function() {
      function TemporalQueries2() {
      }
      TemporalQueries2.zoneId = function zoneId() {
        return TemporalQueries2.ZONE_ID;
      };
      TemporalQueries2.chronology = function chronology() {
        return TemporalQueries2.CHRONO;
      };
      TemporalQueries2.precision = function precision() {
        return TemporalQueries2.PRECISION;
      };
      TemporalQueries2.zone = function zone() {
        return TemporalQueries2.ZONE;
      };
      TemporalQueries2.offset = function offset() {
        return TemporalQueries2.OFFSET;
      };
      TemporalQueries2.localDate = function localDate() {
        return TemporalQueries2.LOCAL_DATE;
      };
      TemporalQueries2.localTime = function localTime() {
        return TemporalQueries2.LOCAL_TIME;
      };
      return TemporalQueries2;
    }();
    TemporalAccessor = function() {
      function TemporalAccessor2() {
      }
      var _proto = TemporalAccessor2.prototype;
      _proto.query = function query(_query) {
        if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.chronology() || _query === TemporalQueries.precision()) {
          return null;
        }
        return _query.queryFrom(this);
      };
      _proto.get = function get(field) {
        return this.range(field).checkValidIntValue(this.getLong(field), field);
      };
      _proto.getLong = function getLong(field) {
        abstractMethodFail("getLong");
      };
      _proto.range = function range(field) {
        if (field instanceof ChronoField) {
          if (this.isSupported(field)) {
            return field.range();
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.rangeRefinedBy(this);
      };
      _proto.isSupported = function isSupported(field) {
        abstractMethodFail("isSupported");
      };
      return TemporalAccessor2;
    }();
    TemporalQuery = function(_Enum) {
      _inheritsLoose(TemporalQuery2, _Enum);
      function TemporalQuery2() {
        return _Enum.apply(this, arguments) || this;
      }
      var _proto = TemporalQuery2.prototype;
      _proto.queryFrom = function queryFrom(temporal) {
        abstractMethodFail("queryFrom");
      };
      return TemporalQuery2;
    }(Enum);
    DayOfWeek = function(_TemporalAccessor) {
      _inheritsLoose(DayOfWeek2, _TemporalAccessor);
      function DayOfWeek2(ordinal, name3) {
        var _this;
        _this = _TemporalAccessor.call(this) || this;
        _this._ordinal = ordinal;
        _this._name = name3;
        return _this;
      }
      var _proto = DayOfWeek2.prototype;
      _proto.ordinal = function ordinal() {
        return this._ordinal;
      };
      _proto.name = function name3() {
        return this._name;
      };
      DayOfWeek2.values = function values() {
        return ENUMS.slice();
      };
      DayOfWeek2.valueOf = function valueOf(name3) {
        var ordinal = 0;
        for (ordinal; ordinal < ENUMS.length; ordinal++) {
          if (ENUMS[ordinal].name() === name3) {
            break;
          }
        }
        return DayOfWeek2.of(ordinal + 1);
      };
      DayOfWeek2.of = function of(dayOfWeek) {
        if (dayOfWeek < 1 || dayOfWeek > 7) {
          throw new DateTimeException("Invalid value for DayOfWeek: " + dayOfWeek);
        }
        return ENUMS[dayOfWeek - 1];
      };
      DayOfWeek2.from = function from(temporal) {
        assert(temporal != null, "temporal", NullPointerException);
        if (temporal instanceof DayOfWeek2) {
          return temporal;
        }
        try {
          return DayOfWeek2.of(temporal.get(ChronoField.DAY_OF_WEEK));
        } catch (ex) {
          if (ex instanceof DateTimeException) {
            throw new DateTimeException("Unable to obtain DayOfWeek from TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""), ex);
          } else {
            throw ex;
          }
        }
      };
      _proto.value = function value() {
        return this._ordinal + 1;
      };
      _proto.displayName = function displayName(style, locale) {
        throw new IllegalArgumentException("Pattern using (localized) text not implemented yet!");
      };
      _proto.isSupported = function isSupported(field) {
        if (field instanceof ChronoField) {
          return field === ChronoField.DAY_OF_WEEK;
        }
        return field != null && field.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        if (field === ChronoField.DAY_OF_WEEK) {
          return field.range();
        } else if (field instanceof ChronoField) {
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.rangeRefinedBy(this);
      };
      _proto.get = function get(field) {
        if (field === ChronoField.DAY_OF_WEEK) {
          return this.value();
        }
        return this.range(field).checkValidIntValue(this.getLong(field), field);
      };
      _proto.getLong = function getLong(field) {
        if (field === ChronoField.DAY_OF_WEEK) {
          return this.value();
        } else if (field instanceof ChronoField) {
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.getFrom(this);
      };
      _proto.plus = function plus(days) {
        var amount = MathUtil.floorMod(days, 7);
        return ENUMS[MathUtil.floorMod(this._ordinal + (amount + 7), 7)];
      };
      _proto.minus = function minus(days) {
        return this.plus(-1 * MathUtil.floorMod(days, 7));
      };
      _proto.query = function query(_query) {
        if (_query === TemporalQueries.precision()) {
          return ChronoUnit.DAYS;
        } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
          return null;
        }
        assert(_query != null, "query", NullPointerException);
        return _query.queryFrom(this);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        requireNonNull(temporal, "temporal");
        return temporal.with(ChronoField.DAY_OF_WEEK, this.value());
      };
      _proto.equals = function equals(other) {
        return this === other;
      };
      _proto.toString = function toString() {
        return this._name;
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, DayOfWeek2, "other");
        return this._ordinal - other._ordinal;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      return DayOfWeek2;
    }(TemporalAccessor);
    Month = function(_TemporalAccessor) {
      _inheritsLoose(Month2, _TemporalAccessor);
      function Month2(value, name3) {
        var _this;
        _this = _TemporalAccessor.call(this) || this;
        _this._value = MathUtil.safeToInt(value);
        _this._name = name3;
        return _this;
      }
      var _proto = Month2.prototype;
      _proto.value = function value() {
        return this._value;
      };
      _proto.ordinal = function ordinal() {
        return this._value - 1;
      };
      _proto.name = function name3() {
        return this._name;
      };
      _proto.displayName = function displayName(style, locale) {
        throw new IllegalArgumentException("Pattern using (localized) text not implemented yet!");
      };
      _proto.isSupported = function isSupported(field) {
        if (null === field) {
          return false;
        }
        if (field instanceof ChronoField) {
          return field === ChronoField.MONTH_OF_YEAR;
        }
        return field != null && field.isSupportedBy(this);
      };
      _proto.get = function get(field) {
        if (field === ChronoField.MONTH_OF_YEAR) {
          return this.value();
        }
        return this.range(field).checkValidIntValue(this.getLong(field), field);
      };
      _proto.getLong = function getLong(field) {
        if (field === ChronoField.MONTH_OF_YEAR) {
          return this.value();
        } else if (field instanceof ChronoField) {
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.getFrom(this);
      };
      _proto.plus = function plus(months) {
        var amount = MathUtil.intMod(months, 12) + 12;
        var newMonthVal = MathUtil.intMod(this.value() + amount, 12);
        newMonthVal = newMonthVal === 0 ? 12 : newMonthVal;
        return Month2.of(newMonthVal);
      };
      _proto.minus = function minus(months) {
        return this.plus(-1 * MathUtil.intMod(months, 12));
      };
      _proto.length = function length(leapYear) {
        switch (this) {
          case Month2.FEBRUARY:
            return leapYear ? 29 : 28;
          case Month2.APRIL:
          case Month2.JUNE:
          case Month2.SEPTEMBER:
          case Month2.NOVEMBER:
            return 30;
          default:
            return 31;
        }
      };
      _proto.minLength = function minLength() {
        switch (this) {
          case Month2.FEBRUARY:
            return 28;
          case Month2.APRIL:
          case Month2.JUNE:
          case Month2.SEPTEMBER:
          case Month2.NOVEMBER:
            return 30;
          default:
            return 31;
        }
      };
      _proto.maxLength = function maxLength() {
        switch (this) {
          case Month2.FEBRUARY:
            return 29;
          case Month2.APRIL:
          case Month2.JUNE:
          case Month2.SEPTEMBER:
          case Month2.NOVEMBER:
            return 30;
          default:
            return 31;
        }
      };
      _proto.firstDayOfYear = function firstDayOfYear(leapYear) {
        var leap = leapYear ? 1 : 0;
        switch (this) {
          case Month2.JANUARY:
            return 1;
          case Month2.FEBRUARY:
            return 32;
          case Month2.MARCH:
            return 60 + leap;
          case Month2.APRIL:
            return 91 + leap;
          case Month2.MAY:
            return 121 + leap;
          case Month2.JUNE:
            return 152 + leap;
          case Month2.JULY:
            return 182 + leap;
          case Month2.AUGUST:
            return 213 + leap;
          case Month2.SEPTEMBER:
            return 244 + leap;
          case Month2.OCTOBER:
            return 274 + leap;
          case Month2.NOVEMBER:
            return 305 + leap;
          case Month2.DECEMBER:
          default:
            return 335 + leap;
        }
      };
      _proto.firstMonthOfQuarter = function firstMonthOfQuarter() {
        switch (this) {
          case Month2.JANUARY:
          case Month2.FEBRUARY:
          case Month2.MARCH:
            return Month2.JANUARY;
          case Month2.APRIL:
          case Month2.MAY:
          case Month2.JUNE:
            return Month2.APRIL;
          case Month2.JULY:
          case Month2.AUGUST:
          case Month2.SEPTEMBER:
            return Month2.JULY;
          case Month2.OCTOBER:
          case Month2.NOVEMBER:
          case Month2.DECEMBER:
          default:
            return Month2.OCTOBER;
        }
      };
      _proto.query = function query(_query) {
        assert(_query != null, "query() parameter must not be null", DateTimeException);
        if (_query === TemporalQueries.chronology()) {
          return IsoChronology.INSTANCE;
        } else if (_query === TemporalQueries.precision()) {
          return ChronoUnit.MONTHS;
        }
        return _TemporalAccessor.prototype.query.call(this, _query);
      };
      _proto.toString = function toString() {
        switch (this) {
          case Month2.JANUARY:
            return "JANUARY";
          case Month2.FEBRUARY:
            return "FEBRUARY";
          case Month2.MARCH:
            return "MARCH";
          case Month2.APRIL:
            return "APRIL";
          case Month2.MAY:
            return "MAY";
          case Month2.JUNE:
            return "JUNE";
          case Month2.JULY:
            return "JULY";
          case Month2.AUGUST:
            return "AUGUST";
          case Month2.SEPTEMBER:
            return "SEPTEMBER";
          case Month2.OCTOBER:
            return "OCTOBER";
          case Month2.NOVEMBER:
            return "NOVEMBER";
          case Month2.DECEMBER:
            return "DECEMBER";
          default:
            return "unknown Month, value: " + this.value();
        }
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.adjustInto = function adjustInto(temporal) {
        return temporal.with(ChronoField.MONTH_OF_YEAR, this.value());
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, Month2, "other");
        return this._value - other._value;
      };
      _proto.equals = function equals(other) {
        return this === other;
      };
      Month2.valueOf = function valueOf(name3) {
        var ordinal = 0;
        for (ordinal; ordinal < MONTHS.length; ordinal++) {
          if (MONTHS[ordinal].name() === name3) {
            break;
          }
        }
        return Month2.of(ordinal + 1);
      };
      Month2.values = function values() {
        return MONTHS.slice();
      };
      Month2.of = function of(month) {
        if (month < 1 || month > 12) {
          assert(false, "Invalid value for MonthOfYear: " + month, DateTimeException);
        }
        return MONTHS[month - 1];
      };
      Month2.from = function from(temporal) {
        if (temporal instanceof Month2) {
          return temporal;
        }
        try {
          return Month2.of(temporal.get(ChronoField.MONTH_OF_YEAR));
        } catch (ex) {
          throw new DateTimeException("Unable to obtain Month from TemporalAccessor: " + temporal + " of type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ""), ex);
        }
      };
      return Month2;
    }(TemporalAccessor);
    PATTERN = /([-+]?)P(?:([-+]?[0-9]+)Y)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)W)?(?:([-+]?[0-9]+)D)?/;
    Period = function(_TemporalAmount) {
      _inheritsLoose(Period2, _TemporalAmount);
      function Period2(years, months, days) {
        var _this;
        _this = _TemporalAmount.call(this) || this;
        var _years = MathUtil.safeToInt(years);
        var _months = MathUtil.safeToInt(months);
        var _days = MathUtil.safeToInt(days);
        if (_years === 0 && _months === 0 && _days === 0) {
          if (!Period2.ZERO) {
            _this._years = _years;
            _this._months = _months;
            _this._days = _days;
            Period2.ZERO = _assertThisInitialized(_this);
          }
          return Period2.ZERO || _assertThisInitialized(_this);
        }
        _this._years = _years;
        _this._months = _months;
        _this._days = _days;
        return _this;
      }
      Period2.ofYears = function ofYears(years) {
        return Period2.create(years, 0, 0);
      };
      Period2.ofMonths = function ofMonths(months) {
        return Period2.create(0, months, 0);
      };
      Period2.ofWeeks = function ofWeeks(weeks) {
        return Period2.create(0, 0, MathUtil.safeMultiply(weeks, 7));
      };
      Period2.ofDays = function ofDays(days) {
        return Period2.create(0, 0, days);
      };
      Period2.of = function of(years, months, days) {
        return Period2.create(years, months, days);
      };
      Period2.from = function from(amount) {
        if (amount instanceof Period2) {
          return amount;
        }
        requireNonNull(amount, "amount");
        var years = 0;
        var months = 0;
        var days = 0;
        var units = amount.units();
        for (var i = 0; i < units.length; i++) {
          var unit = units[i];
          var unitAmount = amount.get(unit);
          if (unit === ChronoUnit.YEARS) {
            years = MathUtil.safeToInt(unitAmount);
          } else if (unit === ChronoUnit.MONTHS) {
            months = MathUtil.safeToInt(unitAmount);
          } else if (unit === ChronoUnit.DAYS) {
            days = MathUtil.safeToInt(unitAmount);
          } else {
            throw new DateTimeException("Unit must be Years, Months or Days, but was " + unit);
          }
        }
        return Period2.create(years, months, days);
      };
      Period2.between = function between(startDate, endDate) {
        requireNonNull(startDate, "startDate");
        requireNonNull(endDate, "endDate");
        requireInstance(startDate, LocalDate, "startDate");
        requireInstance(endDate, LocalDate, "endDate");
        return startDate.until(endDate);
      };
      Period2.parse = function parse2(text) {
        requireNonNull(text, "text");
        try {
          return Period2._parse(text);
        } catch (ex) {
          if (ex instanceof ArithmeticException) {
            throw new DateTimeParseException("Text cannot be parsed to a Period", text, 0, ex);
          } else {
            throw ex;
          }
        }
      };
      Period2._parse = function _parse(text) {
        var matches = PATTERN.exec(text);
        if (matches != null) {
          var negate = "-" === matches[1] ? -1 : 1;
          var yearMatch = matches[2];
          var monthMatch = matches[3];
          var weekMatch = matches[4];
          var dayMatch = matches[5];
          if (yearMatch != null || monthMatch != null || weekMatch != null || dayMatch != null) {
            var years = Period2._parseNumber(text, yearMatch, negate);
            var months = Period2._parseNumber(text, monthMatch, negate);
            var weeks = Period2._parseNumber(text, weekMatch, negate);
            var days = Period2._parseNumber(text, dayMatch, negate);
            days = MathUtil.safeAdd(days, MathUtil.safeMultiply(weeks, 7));
            return Period2.create(years, months, days);
          }
        }
        throw new DateTimeParseException("Text cannot be parsed to a Period", text, 0);
      };
      Period2._parseNumber = function _parseNumber(text, str, negate) {
        if (str == null) {
          return 0;
        }
        var val = MathUtil.parseInt(str);
        return MathUtil.safeMultiply(val, negate);
      };
      Period2.create = function create(years, months, days) {
        return new Period2(years, months, days);
      };
      var _proto = Period2.prototype;
      _proto.units = function units() {
        return [ChronoUnit.YEARS, ChronoUnit.MONTHS, ChronoUnit.DAYS];
      };
      _proto.chronology = function chronology() {
        return IsoChronology.INSTANCE;
      };
      _proto.get = function get(unit) {
        if (unit === ChronoUnit.YEARS) {
          return this._years;
        }
        if (unit === ChronoUnit.MONTHS) {
          return this._months;
        }
        if (unit === ChronoUnit.DAYS) {
          return this._days;
        }
        throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
      };
      _proto.isZero = function isZero() {
        return this === Period2.ZERO;
      };
      _proto.isNegative = function isNegative() {
        return this._years < 0 || this._months < 0 || this._days < 0;
      };
      _proto.years = function years() {
        return this._years;
      };
      _proto.months = function months() {
        return this._months;
      };
      _proto.days = function days() {
        return this._days;
      };
      _proto.withYears = function withYears(years) {
        if (years === this._years) {
          return this;
        }
        return Period2.create(years, this._months, this._days);
      };
      _proto.withMonths = function withMonths(months) {
        if (months === this._months) {
          return this;
        }
        return Period2.create(this._years, months, this._days);
      };
      _proto.withDays = function withDays(days) {
        if (days === this._days) {
          return this;
        }
        return Period2.create(this._years, this._months, days);
      };
      _proto.plus = function plus(amountToAdd) {
        var amount = Period2.from(amountToAdd);
        return Period2.create(MathUtil.safeAdd(this._years, amount._years), MathUtil.safeAdd(this._months, amount._months), MathUtil.safeAdd(this._days, amount._days));
      };
      _proto.plusYears = function plusYears(yearsToAdd) {
        if (yearsToAdd === 0) {
          return this;
        }
        return Period2.create(MathUtil.safeToInt(MathUtil.safeAdd(this._years, yearsToAdd)), this._months, this._days);
      };
      _proto.plusMonths = function plusMonths(monthsToAdd) {
        if (monthsToAdd === 0) {
          return this;
        }
        return Period2.create(this._years, MathUtil.safeToInt(MathUtil.safeAdd(this._months, monthsToAdd)), this._days);
      };
      _proto.plusDays = function plusDays(daysToAdd) {
        if (daysToAdd === 0) {
          return this;
        }
        return Period2.create(this._years, this._months, MathUtil.safeToInt(MathUtil.safeAdd(this._days, daysToAdd)));
      };
      _proto.minus = function minus(amountToSubtract) {
        var amount = Period2.from(amountToSubtract);
        return Period2.create(MathUtil.safeSubtract(this._years, amount._years), MathUtil.safeSubtract(this._months, amount._months), MathUtil.safeSubtract(this._days, amount._days));
      };
      _proto.minusYears = function minusYears(yearsToSubtract) {
        return this.plusYears(-1 * yearsToSubtract);
      };
      _proto.minusMonths = function minusMonths(monthsToSubtract) {
        return this.plusMonths(-1 * monthsToSubtract);
      };
      _proto.minusDays = function minusDays(daysToSubtract) {
        return this.plusDays(-1 * daysToSubtract);
      };
      _proto.multipliedBy = function multipliedBy(scalar) {
        if (this === Period2.ZERO || scalar === 1) {
          return this;
        }
        return Period2.create(MathUtil.safeMultiply(this._years, scalar), MathUtil.safeMultiply(this._months, scalar), MathUtil.safeMultiply(this._days, scalar));
      };
      _proto.negated = function negated() {
        return this.multipliedBy(-1);
      };
      _proto.normalized = function normalized() {
        var totalMonths = this.toTotalMonths();
        var splitYears = MathUtil.intDiv(totalMonths, 12);
        var splitMonths = MathUtil.intMod(totalMonths, 12);
        if (splitYears === this._years && splitMonths === this._months) {
          return this;
        }
        return Period2.create(MathUtil.safeToInt(splitYears), splitMonths, this._days);
      };
      _proto.toTotalMonths = function toTotalMonths() {
        return this._years * 12 + this._months;
      };
      _proto.addTo = function addTo(temporal) {
        requireNonNull(temporal, "temporal");
        if (this._years !== 0) {
          if (this._months !== 0) {
            temporal = temporal.plus(this.toTotalMonths(), ChronoUnit.MONTHS);
          } else {
            temporal = temporal.plus(this._years, ChronoUnit.YEARS);
          }
        } else if (this._months !== 0) {
          temporal = temporal.plus(this._months, ChronoUnit.MONTHS);
        }
        if (this._days !== 0) {
          temporal = temporal.plus(this._days, ChronoUnit.DAYS);
        }
        return temporal;
      };
      _proto.subtractFrom = function subtractFrom(temporal) {
        requireNonNull(temporal, "temporal");
        if (this._years !== 0) {
          if (this._months !== 0) {
            temporal = temporal.minus(this.toTotalMonths(), ChronoUnit.MONTHS);
          } else {
            temporal = temporal.minus(this._years, ChronoUnit.YEARS);
          }
        } else if (this._months !== 0) {
          temporal = temporal.minus(this._months, ChronoUnit.MONTHS);
        }
        if (this._days !== 0) {
          temporal = temporal.minus(this._days, ChronoUnit.DAYS);
        }
        return temporal;
      };
      _proto.equals = function equals(obj) {
        if (this === obj) {
          return true;
        }
        if (obj instanceof Period2) {
          var other = obj;
          return this._years === other._years && this._months === other._months && this._days === other._days;
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return MathUtil.hashCode(this._years, this._months, this._days);
      };
      _proto.toString = function toString() {
        if (this === Period2.ZERO) {
          return "P0D";
        } else {
          var buf = "P";
          if (this._years !== 0) {
            buf += this._years + "Y";
          }
          if (this._months !== 0) {
            buf += this._months + "M";
          }
          if (this._days !== 0) {
            buf += this._days + "D";
          }
          return buf;
        }
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      return Period2;
    }(TemporalAmount);
    ParsePosition = function() {
      function ParsePosition2(index) {
        this._index = index;
        this._errorIndex = -1;
      }
      var _proto = ParsePosition2.prototype;
      _proto.getIndex = function getIndex() {
        return this._index;
      };
      _proto.setIndex = function setIndex(index) {
        this._index = index;
      };
      _proto.getErrorIndex = function getErrorIndex() {
        return this._errorIndex;
      };
      _proto.setErrorIndex = function setErrorIndex(errorIndex) {
        this._errorIndex = errorIndex;
      };
      return ParsePosition2;
    }();
    EnumMap = function() {
      function EnumMap2() {
        this._map = {};
      }
      var _proto = EnumMap2.prototype;
      _proto.putAll = function putAll(otherMap) {
        for (var key in otherMap._map) {
          this._map[key] = otherMap._map[key];
        }
        return this;
      };
      _proto.containsKey = function containsKey(key) {
        return this._map.hasOwnProperty(key.name()) && this.get(key) !== void 0;
      };
      _proto.get = function get(key) {
        return this._map[key.name()];
      };
      _proto.put = function put(key, val) {
        return this.set(key, val);
      };
      _proto.set = function set(key, val) {
        this._map[key.name()] = val;
        return this;
      };
      _proto.retainAll = function retainAll(keyList) {
        var map = {};
        for (var i = 0; i < keyList.length; i++) {
          var key = keyList[i].name();
          map[key] = this._map[key];
        }
        this._map = map;
        return this;
      };
      _proto.remove = function remove(key) {
        var keyName = key.name();
        var val = this._map[keyName];
        this._map[keyName] = void 0;
        return val;
      };
      _proto.keySet = function keySet() {
        return this._map;
      };
      _proto.clear = function clear() {
        this._map = {};
      };
      return EnumMap2;
    }();
    ResolverStyle = function(_Enum) {
      _inheritsLoose(ResolverStyle2, _Enum);
      function ResolverStyle2() {
        return _Enum.apply(this, arguments) || this;
      }
      return ResolverStyle2;
    }(Enum);
    ResolverStyle.STRICT = new ResolverStyle("STRICT");
    ResolverStyle.SMART = new ResolverStyle("SMART");
    ResolverStyle.LENIENT = new ResolverStyle("LENIENT");
    Temporal = function(_TemporalAccessor) {
      _inheritsLoose(Temporal2, _TemporalAccessor);
      function Temporal2() {
        return _TemporalAccessor.apply(this, arguments) || this;
      }
      var _proto = Temporal2.prototype;
      _proto.isSupported = function isSupported(fieldOrUnit) {
        abstractMethodFail("isSupported");
      };
      _proto.minus = function minus(amount, unit) {
        if (arguments.length < 2) {
          return this._minusAmount(amount);
        } else {
          return this._minusUnit(amount, unit);
        }
      };
      _proto._minusAmount = function _minusAmount(amount) {
        requireNonNull(amount, "amount");
        requireInstance(amount, TemporalAmount, "amount");
        return amount.subtractFrom(this);
      };
      _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
        requireNonNull(amountToSubtract, "amountToSubtract");
        requireNonNull(unit, "unit");
        requireInstance(unit, TemporalUnit, "unit");
        return this._plusUnit(-amountToSubtract, unit);
      };
      _proto.plus = function plus(amount, unit) {
        if (arguments.length < 2) {
          return this._plusAmount(amount);
        } else {
          return this._plusUnit(amount, unit);
        }
      };
      _proto._plusAmount = function _plusAmount(amount) {
        requireNonNull(amount, "amount");
        requireInstance(amount, TemporalAmount, "amount");
        return amount.addTo(this);
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        abstractMethodFail("_plusUnit");
      };
      _proto.until = function until(endTemporal, unit) {
        abstractMethodFail("until");
      };
      _proto.with = function _with(adjusterOrField, newValue) {
        if (arguments.length < 2) {
          return this._withAdjuster(adjusterOrField);
        } else {
          return this._withField(adjusterOrField, newValue);
        }
      };
      _proto._withAdjuster = function _withAdjuster(adjuster) {
        requireNonNull(adjuster, "adjuster");
        assert(typeof adjuster.adjustInto === "function", "adjuster must be a TemporalAdjuster", IllegalArgumentException);
        return adjuster.adjustInto(this);
      };
      _proto._withField = function _withField(field, newValue) {
        abstractMethodFail("_withField");
      };
      return Temporal2;
    }(TemporalAccessor);
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive) {
      Temporal.prototype[Symbol.toPrimitive] = function(hint) {
        if (hint !== "number") {
          return this.toString();
        }
        throw new TypeError("A conversion from Temporal to a number is not allowed. To compare use the methods .equals(), .compareTo(), .isBefore() or one that is more suitable to your use case.");
      };
    }
    ChronoLocalDate = function(_Temporal) {
      _inheritsLoose(ChronoLocalDate2, _Temporal);
      function ChronoLocalDate2() {
        return _Temporal.apply(this, arguments) || this;
      }
      var _proto = ChronoLocalDate2.prototype;
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (fieldOrUnit instanceof ChronoField) {
          return fieldOrUnit.isDateBased();
        } else if (fieldOrUnit instanceof ChronoUnit) {
          return fieldOrUnit.isDateBased();
        }
        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
      };
      _proto.query = function query(_query) {
        if (_query === TemporalQueries.chronology()) {
          return this.chronology();
        } else if (_query === TemporalQueries.precision()) {
          return ChronoUnit.DAYS;
        } else if (_query === TemporalQueries.localDate()) {
          return LocalDate.ofEpochDay(this.toEpochDay());
        } else if (_query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
          return null;
        }
        return _Temporal.prototype.query.call(this, _query);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        return temporal.with(ChronoField.EPOCH_DAY, this.toEpochDay());
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        requireInstance(formatter, DateTimeFormatter, "formatter");
        return formatter.format(this);
      };
      return ChronoLocalDate2;
    }(Temporal);
    StringUtil = function() {
      function StringUtil2() {
      }
      StringUtil2.startsWith = function startsWith(text, pattern) {
        return text.indexOf(pattern) === 0;
      };
      StringUtil2.hashCode = function hashCode(text) {
        var len = text.length;
        if (len === 0) {
          return 0;
        }
        var hash = 0;
        for (var i = 0; i < len; i++) {
          var chr = text.charCodeAt(i);
          hash = (hash << 5) - hash + chr;
          hash |= 0;
        }
        return MathUtil.smi(hash);
      };
      return StringUtil2;
    }();
    ZoneId = function() {
      function ZoneId2() {
      }
      ZoneId2.systemDefault = function systemDefault() {
        throw new DateTimeException("not supported operation");
      };
      ZoneId2.getAvailableZoneIds = function getAvailableZoneIds() {
        throw new DateTimeException("not supported operation");
      };
      ZoneId2.of = function of(zoneId) {
        throw new DateTimeException("not supported operation" + zoneId);
      };
      ZoneId2.ofOffset = function ofOffset(prefix, offset) {
        throw new DateTimeException("not supported operation" + prefix + offset);
      };
      ZoneId2.from = function from(temporal) {
        throw new DateTimeException("not supported operation" + temporal);
      };
      var _proto = ZoneId2.prototype;
      _proto.id = function id() {
        abstractMethodFail("ZoneId.id");
      };
      _proto.rules = function rules() {
        abstractMethodFail("ZoneId.rules");
      };
      _proto.normalized = function normalized() {
        var rules = this.rules();
        if (rules.isFixedOffset()) {
          return rules.offset(Instant.EPOCH);
        }
        return this;
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof ZoneId2) {
          return this.id() === other.id();
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return StringUtil.hashCode(this.id());
      };
      _proto.toString = function toString() {
        return this.id();
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      return ZoneId2;
    }();
    ZoneRules = function() {
      function ZoneRules2() {
      }
      ZoneRules2.of = function of(offset) {
        requireNonNull(offset, "offset");
        return new Fixed(offset);
      };
      var _proto = ZoneRules2.prototype;
      _proto.isFixedOffset = function isFixedOffset() {
        abstractMethodFail("ZoneRules.isFixedOffset");
      };
      _proto.offset = function offset(instantOrLocalDateTime) {
        if (instantOrLocalDateTime instanceof Instant) {
          return this.offsetOfInstant(instantOrLocalDateTime);
        } else {
          return this.offsetOfLocalDateTime(instantOrLocalDateTime);
        }
      };
      _proto.offsetOfInstant = function offsetOfInstant(instant) {
        abstractMethodFail("ZoneRules.offsetInstant");
      };
      _proto.offsetOfEpochMilli = function offsetOfEpochMilli(epochMilli) {
        abstractMethodFail("ZoneRules.offsetOfEpochMilli");
      };
      _proto.offsetOfLocalDateTime = function offsetOfLocalDateTime(localDateTime) {
        abstractMethodFail("ZoneRules.offsetLocalDateTime");
      };
      _proto.validOffsets = function validOffsets(localDateTime) {
        abstractMethodFail("ZoneRules.validOffsets");
      };
      _proto.transition = function transition(localDateTime) {
        abstractMethodFail("ZoneRules.transition");
      };
      _proto.standardOffset = function standardOffset(instant) {
        abstractMethodFail("ZoneRules.standardOffset");
      };
      _proto.daylightSavings = function daylightSavings(instant) {
        abstractMethodFail("ZoneRules.daylightSavings");
      };
      _proto.isDaylightSavings = function isDaylightSavings(instant) {
        abstractMethodFail("ZoneRules.isDaylightSavings");
      };
      _proto.isValidOffset = function isValidOffset(localDateTime, offset) {
        abstractMethodFail("ZoneRules.isValidOffset");
      };
      _proto.nextTransition = function nextTransition(instant) {
        abstractMethodFail("ZoneRules.nextTransition");
      };
      _proto.previousTransition = function previousTransition(instant) {
        abstractMethodFail("ZoneRules.previousTransition");
      };
      _proto.transitions = function transitions() {
        abstractMethodFail("ZoneRules.transitions");
      };
      _proto.transitionRules = function transitionRules() {
        abstractMethodFail("ZoneRules.transitionRules");
      };
      _proto.toString = function toString() {
        abstractMethodFail("ZoneRules.toString");
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      return ZoneRules2;
    }();
    Fixed = function(_ZoneRules) {
      _inheritsLoose(Fixed2, _ZoneRules);
      function Fixed2(offset) {
        var _this;
        _this = _ZoneRules.call(this) || this;
        _this._offset = offset;
        return _this;
      }
      var _proto2 = Fixed2.prototype;
      _proto2.isFixedOffset = function isFixedOffset() {
        return true;
      };
      _proto2.offsetOfInstant = function offsetOfInstant() {
        return this._offset;
      };
      _proto2.offsetOfEpochMilli = function offsetOfEpochMilli() {
        return this._offset;
      };
      _proto2.offsetOfLocalDateTime = function offsetOfLocalDateTime() {
        return this._offset;
      };
      _proto2.validOffsets = function validOffsets() {
        return [this._offset];
      };
      _proto2.transition = function transition() {
        return null;
      };
      _proto2.standardOffset = function standardOffset() {
        return this._offset;
      };
      _proto2.daylightSavings = function daylightSavings() {
        return Duration.ZERO;
      };
      _proto2.isDaylightSavings = function isDaylightSavings() {
        return false;
      };
      _proto2.isValidOffset = function isValidOffset(localDateTime, offset) {
        return this._offset.equals(offset);
      };
      _proto2.nextTransition = function nextTransition() {
        return null;
      };
      _proto2.previousTransition = function previousTransition() {
        return null;
      };
      _proto2.transitions = function transitions() {
        return [];
      };
      _proto2.transitionRules = function transitionRules() {
        return [];
      };
      _proto2.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof Fixed2) {
          return this._offset.equals(other._offset);
        }
        return false;
      };
      _proto2.toString = function toString() {
        return "FixedRules:" + this._offset.toString();
      };
      return Fixed2;
    }(ZoneRules);
    SECONDS_CACHE = {};
    ID_CACHE = {};
    ZoneOffset = function(_ZoneId) {
      _inheritsLoose(ZoneOffset2, _ZoneId);
      function ZoneOffset2(totalSeconds) {
        var _this;
        _this = _ZoneId.call(this) || this;
        ZoneOffset2._validateTotalSeconds(totalSeconds);
        _this._totalSeconds = MathUtil.safeToInt(totalSeconds);
        _this._rules = ZoneRules.of(_assertThisInitialized(_this));
        _this._id = ZoneOffset2._buildId(totalSeconds);
        return _this;
      }
      var _proto = ZoneOffset2.prototype;
      _proto.totalSeconds = function totalSeconds() {
        return this._totalSeconds;
      };
      _proto.id = function id() {
        return this._id;
      };
      ZoneOffset2._buildId = function _buildId(totalSeconds) {
        if (totalSeconds === 0) {
          return "Z";
        } else {
          var absTotalSeconds = Math.abs(totalSeconds);
          var absHours = MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_HOUR);
          var absMinutes = MathUtil.intMod(MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);
          var buf = (totalSeconds < 0 ? "-" : "+") + (absHours < 10 ? "0" : "") + absHours + (absMinutes < 10 ? ":0" : ":") + absMinutes;
          var absSeconds = MathUtil.intMod(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE);
          if (absSeconds !== 0) {
            buf += (absSeconds < 10 ? ":0" : ":") + absSeconds;
          }
          return buf;
        }
      };
      ZoneOffset2._validateTotalSeconds = function _validateTotalSeconds(totalSeconds) {
        if (Math.abs(totalSeconds) > ZoneOffset2.MAX_SECONDS) {
          throw new DateTimeException("Zone offset not in valid range: -18:00 to +18:00");
        }
      };
      ZoneOffset2._validate = function _validate(hours, minutes, seconds) {
        if (hours < -18 || hours > 18) {
          throw new DateTimeException("Zone offset hours not in valid range: value " + hours + " is not in the range -18 to 18");
        }
        if (hours > 0) {
          if (minutes < 0 || seconds < 0) {
            throw new DateTimeException("Zone offset minutes and seconds must be positive because hours is positive");
          }
        } else if (hours < 0) {
          if (minutes > 0 || seconds > 0) {
            throw new DateTimeException("Zone offset minutes and seconds must be negative because hours is negative");
          }
        } else if (minutes > 0 && seconds < 0 || minutes < 0 && seconds > 0) {
          throw new DateTimeException("Zone offset minutes and seconds must have the same sign");
        }
        if (Math.abs(minutes) > 59) {
          throw new DateTimeException("Zone offset minutes not in valid range: abs(value) " + Math.abs(minutes) + " is not in the range 0 to 59");
        }
        if (Math.abs(seconds) > 59) {
          throw new DateTimeException("Zone offset seconds not in valid range: abs(value) " + Math.abs(seconds) + " is not in the range 0 to 59");
        }
        if (Math.abs(hours) === 18 && (Math.abs(minutes) > 0 || Math.abs(seconds) > 0)) {
          throw new DateTimeException("Zone offset not in valid range: -18:00 to +18:00");
        }
      };
      ZoneOffset2.of = function of(offsetId) {
        requireNonNull(offsetId, "offsetId");
        var offset = ID_CACHE[offsetId];
        if (offset != null) {
          return offset;
        }
        var hours, minutes, seconds;
        switch (offsetId.length) {
          case 2:
            offsetId = offsetId[0] + "0" + offsetId[1];
          case 3:
            hours = ZoneOffset2._parseNumber(offsetId, 1, false);
            minutes = 0;
            seconds = 0;
            break;
          case 5:
            hours = ZoneOffset2._parseNumber(offsetId, 1, false);
            minutes = ZoneOffset2._parseNumber(offsetId, 3, false);
            seconds = 0;
            break;
          case 6:
            hours = ZoneOffset2._parseNumber(offsetId, 1, false);
            minutes = ZoneOffset2._parseNumber(offsetId, 4, true);
            seconds = 0;
            break;
          case 7:
            hours = ZoneOffset2._parseNumber(offsetId, 1, false);
            minutes = ZoneOffset2._parseNumber(offsetId, 3, false);
            seconds = ZoneOffset2._parseNumber(offsetId, 5, false);
            break;
          case 9:
            hours = ZoneOffset2._parseNumber(offsetId, 1, false);
            minutes = ZoneOffset2._parseNumber(offsetId, 4, true);
            seconds = ZoneOffset2._parseNumber(offsetId, 7, true);
            break;
          default:
            throw new DateTimeException("Invalid ID for ZoneOffset, invalid format: " + offsetId);
        }
        var first = offsetId[0];
        if (first !== "+" && first !== "-") {
          throw new DateTimeException("Invalid ID for ZoneOffset, plus/minus not found when expected: " + offsetId);
        }
        if (first === "-") {
          return ZoneOffset2.ofHoursMinutesSeconds(-hours, -minutes, -seconds);
        } else {
          return ZoneOffset2.ofHoursMinutesSeconds(hours, minutes, seconds);
        }
      };
      ZoneOffset2._parseNumber = function _parseNumber(offsetId, pos, precededByColon) {
        if (precededByColon && offsetId[pos - 1] !== ":") {
          throw new DateTimeException("Invalid ID for ZoneOffset, colon not found when expected: " + offsetId);
        }
        var ch1 = offsetId[pos];
        var ch2 = offsetId[pos + 1];
        if (ch1 < "0" || ch1 > "9" || ch2 < "0" || ch2 > "9") {
          throw new DateTimeException("Invalid ID for ZoneOffset, non numeric characters found: " + offsetId);
        }
        return (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);
      };
      ZoneOffset2.ofHours = function ofHours(hours) {
        return ZoneOffset2.ofHoursMinutesSeconds(hours, 0, 0);
      };
      ZoneOffset2.ofHoursMinutes = function ofHoursMinutes(hours, minutes) {
        return ZoneOffset2.ofHoursMinutesSeconds(hours, minutes, 0);
      };
      ZoneOffset2.ofHoursMinutesSeconds = function ofHoursMinutesSeconds(hours, minutes, seconds) {
        ZoneOffset2._validate(hours, minutes, seconds);
        var totalSeconds = hours * LocalTime.SECONDS_PER_HOUR + minutes * LocalTime.SECONDS_PER_MINUTE + seconds;
        return ZoneOffset2.ofTotalSeconds(totalSeconds);
      };
      ZoneOffset2.ofTotalMinutes = function ofTotalMinutes(totalMinutes) {
        var totalSeconds = totalMinutes * LocalTime.SECONDS_PER_MINUTE;
        return ZoneOffset2.ofTotalSeconds(totalSeconds);
      };
      ZoneOffset2.ofTotalSeconds = function ofTotalSeconds(totalSeconds) {
        if (totalSeconds % (15 * LocalTime.SECONDS_PER_MINUTE) === 0) {
          var totalSecs = totalSeconds;
          var result = SECONDS_CACHE[totalSecs];
          if (result == null) {
            result = new ZoneOffset2(totalSeconds);
            SECONDS_CACHE[totalSecs] = result;
            ID_CACHE[result.id()] = result;
          }
          return result;
        } else {
          return new ZoneOffset2(totalSeconds);
        }
      };
      _proto.rules = function rules() {
        return this._rules;
      };
      _proto.get = function get(field) {
        return this.getLong(field);
      };
      _proto.getLong = function getLong(field) {
        if (field === ChronoField.OFFSET_SECONDS) {
          return this._totalSeconds;
        } else if (field instanceof ChronoField) {
          throw new DateTimeException("Unsupported field: " + field);
        }
        return field.getFrom(this);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {
          return this;
        } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.precision() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId()) {
          return null;
        }
        return _query.queryFrom(this);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        return temporal.with(ChronoField.OFFSET_SECONDS, this._totalSeconds);
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        return other._totalSeconds - this._totalSeconds;
      };
      _proto.equals = function equals(obj) {
        if (this === obj) {
          return true;
        }
        if (obj instanceof ZoneOffset2) {
          return this._totalSeconds === obj._totalSeconds;
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return this._totalSeconds;
      };
      _proto.toString = function toString() {
        return this._id;
      };
      return ZoneOffset2;
    }(ZoneId);
    DateTimeBuilder = function(_TemporalAccessor) {
      _inheritsLoose(DateTimeBuilder2, _TemporalAccessor);
      DateTimeBuilder2.create = function create(field, value) {
        var dtb = new DateTimeBuilder2();
        dtb._addFieldValue(field, value);
        return dtb;
      };
      function DateTimeBuilder2() {
        var _this;
        _this = _TemporalAccessor.call(this) || this;
        _this.fieldValues = new EnumMap();
        _this.chrono = null;
        _this.zone = null;
        _this.date = null;
        _this.time = null;
        _this.leapSecond = false;
        _this.excessDays = null;
        return _this;
      }
      var _proto = DateTimeBuilder2.prototype;
      _proto.getFieldValue0 = function getFieldValue0(field) {
        return this.fieldValues.get(field);
      };
      _proto._addFieldValue = function _addFieldValue(field, value) {
        requireNonNull(field, "field");
        var old = this.getFieldValue0(field);
        if (old != null && old !== value) {
          throw new DateTimeException("Conflict found: " + field + " " + old + " differs from " + field + " " + value + ": " + this);
        }
        return this._putFieldValue0(field, value);
      };
      _proto._putFieldValue0 = function _putFieldValue0(field, value) {
        this.fieldValues.put(field, value);
        return this;
      };
      _proto.resolve = function resolve(resolverStyle, resolverFields) {
        if (resolverFields != null) {
          this.fieldValues.retainAll(resolverFields);
        }
        this._mergeDate(resolverStyle);
        this._mergeTime(resolverStyle);
        this._resolveTimeInferZeroes(resolverStyle);
        if (this.excessDays != null && this.excessDays.isZero() === false && this.date != null && this.time != null) {
          this.date = this.date.plus(this.excessDays);
          this.excessDays = Period.ZERO;
        }
        this._resolveInstant();
        return this;
      };
      _proto._mergeDate = function _mergeDate(resolverStyle) {
        this._checkDate(IsoChronology.INSTANCE.resolveDate(this.fieldValues, resolverStyle));
      };
      _proto._checkDate = function _checkDate(date) {
        if (date != null) {
          this._addObject(date);
          for (var fieldName in this.fieldValues.keySet()) {
            var field = ChronoField.byName(fieldName);
            if (field) {
              if (this.fieldValues.get(field) !== void 0) {
                if (field.isDateBased()) {
                  var val1 = void 0;
                  try {
                    val1 = date.getLong(field);
                  } catch (ex) {
                    if (ex instanceof DateTimeException) {
                      continue;
                    } else {
                      throw ex;
                    }
                  }
                  var val2 = this.fieldValues.get(field);
                  if (val1 !== val2) {
                    throw new DateTimeException("Conflict found: Field " + field + " " + val1 + " differs from " + field + " " + val2 + " derived from " + date);
                  }
                }
              }
            }
          }
        }
      };
      _proto._mergeTime = function _mergeTime(resolverStyle) {
        if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_DAY)) {
          var ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_DAY);
          if (resolverStyle !== ResolverStyle.LENIENT) {
            if (resolverStyle === ResolverStyle.SMART && ch === 0) ;
            else {
              ChronoField.CLOCK_HOUR_OF_DAY.checkValidValue(ch);
            }
          }
          this._addFieldValue(ChronoField.HOUR_OF_DAY, ch === 24 ? 0 : ch);
        }
        if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_AMPM)) {
          var _ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_AMPM);
          if (resolverStyle !== ResolverStyle.LENIENT) {
            if (resolverStyle === ResolverStyle.SMART && _ch === 0) ;
            else {
              ChronoField.CLOCK_HOUR_OF_AMPM.checkValidValue(_ch);
            }
          }
          this._addFieldValue(ChronoField.HOUR_OF_AMPM, _ch === 12 ? 0 : _ch);
        }
        if (resolverStyle !== ResolverStyle.LENIENT) {
          if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY)) {
            ChronoField.AMPM_OF_DAY.checkValidValue(this.fieldValues.get(ChronoField.AMPM_OF_DAY));
          }
          if (this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {
            ChronoField.HOUR_OF_AMPM.checkValidValue(this.fieldValues.get(ChronoField.HOUR_OF_AMPM));
          }
        }
        if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY) && this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {
          var ap = this.fieldValues.remove(ChronoField.AMPM_OF_DAY);
          var hap = this.fieldValues.remove(ChronoField.HOUR_OF_AMPM);
          this._addFieldValue(ChronoField.HOUR_OF_DAY, ap * 12 + hap);
        }
        if (this.fieldValues.containsKey(ChronoField.NANO_OF_DAY)) {
          var nod = this.fieldValues.remove(ChronoField.NANO_OF_DAY);
          if (resolverStyle !== ResolverStyle.LENIENT) {
            ChronoField.NANO_OF_DAY.checkValidValue(nod);
          }
          this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(nod, 1e9));
          this._addFieldValue(ChronoField.NANO_OF_SECOND, MathUtil.intMod(nod, 1e9));
        }
        if (this.fieldValues.containsKey(ChronoField.MICRO_OF_DAY)) {
          var cod = this.fieldValues.remove(ChronoField.MICRO_OF_DAY);
          if (resolverStyle !== ResolverStyle.LENIENT) {
            ChronoField.MICRO_OF_DAY.checkValidValue(cod);
          }
          this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(cod, 1e6));
          this._addFieldValue(ChronoField.MICRO_OF_SECOND, MathUtil.intMod(cod, 1e6));
        }
        if (this.fieldValues.containsKey(ChronoField.MILLI_OF_DAY)) {
          var lod = this.fieldValues.remove(ChronoField.MILLI_OF_DAY);
          if (resolverStyle !== ResolverStyle.LENIENT) {
            ChronoField.MILLI_OF_DAY.checkValidValue(lod);
          }
          this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(lod, 1e3));
          this._addFieldValue(ChronoField.MILLI_OF_SECOND, MathUtil.intMod(lod, 1e3));
        }
        if (this.fieldValues.containsKey(ChronoField.SECOND_OF_DAY)) {
          var sod = this.fieldValues.remove(ChronoField.SECOND_OF_DAY);
          if (resolverStyle !== ResolverStyle.LENIENT) {
            ChronoField.SECOND_OF_DAY.checkValidValue(sod);
          }
          this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(sod, 3600));
          this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(MathUtil.intDiv(sod, 60), 60));
          this._addFieldValue(ChronoField.SECOND_OF_MINUTE, MathUtil.intMod(sod, 60));
        }
        if (this.fieldValues.containsKey(ChronoField.MINUTE_OF_DAY)) {
          var mod = this.fieldValues.remove(ChronoField.MINUTE_OF_DAY);
          if (resolverStyle !== ResolverStyle.LENIENT) {
            ChronoField.MINUTE_OF_DAY.checkValidValue(mod);
          }
          this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(mod, 60));
          this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(mod, 60));
        }
        if (resolverStyle !== ResolverStyle.LENIENT) {
          if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {
            ChronoField.MILLI_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MILLI_OF_SECOND));
          }
          if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {
            ChronoField.MICRO_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MICRO_OF_SECOND));
          }
        }
        if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {
          var los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);
          var cos = this.fieldValues.get(ChronoField.MICRO_OF_SECOND);
          this._putFieldValue0(ChronoField.MICRO_OF_SECOND, los * 1e3 + MathUtil.intMod(cos, 1e3));
        }
        if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {
          var nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);
          this._putFieldValue0(ChronoField.MICRO_OF_SECOND, MathUtil.intDiv(nos, 1e3));
          this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);
        }
        if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {
          var _nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);
          this._putFieldValue0(ChronoField.MILLI_OF_SECOND, MathUtil.intDiv(_nos, 1e6));
          this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);
        }
        if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {
          var _cos = this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);
          this._putFieldValue0(ChronoField.NANO_OF_SECOND, _cos * 1e3);
        } else if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {
          var _los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);
          this._putFieldValue0(ChronoField.NANO_OF_SECOND, _los * 1e6);
        }
      };
      _proto._resolveTimeInferZeroes = function _resolveTimeInferZeroes(resolverStyle) {
        var hod = this.fieldValues.get(ChronoField.HOUR_OF_DAY);
        var moh = this.fieldValues.get(ChronoField.MINUTE_OF_HOUR);
        var som = this.fieldValues.get(ChronoField.SECOND_OF_MINUTE);
        var nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);
        if (hod == null) {
          return;
        }
        if (moh == null && (som != null || nos != null)) {
          return;
        }
        if (moh != null && som == null && nos != null) {
          return;
        }
        if (resolverStyle !== ResolverStyle.LENIENT) {
          if (hod != null) {
            if (resolverStyle === ResolverStyle.SMART && hod === 24 && (moh == null || moh === 0) && (som == null || som === 0) && (nos == null || nos === 0)) {
              hod = 0;
              this.excessDays = Period.ofDays(1);
            }
            var hodVal = ChronoField.HOUR_OF_DAY.checkValidIntValue(hod);
            if (moh != null) {
              var mohVal = ChronoField.MINUTE_OF_HOUR.checkValidIntValue(moh);
              if (som != null) {
                var somVal = ChronoField.SECOND_OF_MINUTE.checkValidIntValue(som);
                if (nos != null) {
                  var nosVal = ChronoField.NANO_OF_SECOND.checkValidIntValue(nos);
                  this._addObject(LocalTime.of(hodVal, mohVal, somVal, nosVal));
                } else {
                  this._addObject(LocalTime.of(hodVal, mohVal, somVal));
                }
              } else {
                if (nos == null) {
                  this._addObject(LocalTime.of(hodVal, mohVal));
                }
              }
            } else {
              if (som == null && nos == null) {
                this._addObject(LocalTime.of(hodVal, 0));
              }
            }
          }
        } else {
          if (hod != null) {
            var _hodVal = hod;
            if (moh != null) {
              if (som != null) {
                if (nos == null) {
                  nos = 0;
                }
                var totalNanos = MathUtil.safeMultiply(_hodVal, 36e11);
                totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(moh, 6e10));
                totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(som, 1e9));
                totalNanos = MathUtil.safeAdd(totalNanos, nos);
                var excessDays = MathUtil.floorDiv(totalNanos, 864e11);
                var nod = MathUtil.floorMod(totalNanos, 864e11);
                this._addObject(LocalTime.ofNanoOfDay(nod));
                this.excessDays = Period.ofDays(excessDays);
              } else {
                var totalSecs = MathUtil.safeMultiply(_hodVal, 3600);
                totalSecs = MathUtil.safeAdd(totalSecs, MathUtil.safeMultiply(moh, 60));
                var _excessDays = MathUtil.floorDiv(totalSecs, 86400);
                var sod = MathUtil.floorMod(totalSecs, 86400);
                this._addObject(LocalTime.ofSecondOfDay(sod));
                this.excessDays = Period.ofDays(_excessDays);
              }
            } else {
              var _excessDays2 = MathUtil.safeToInt(MathUtil.floorDiv(_hodVal, 24));
              _hodVal = MathUtil.floorMod(_hodVal, 24);
              this._addObject(LocalTime.of(_hodVal, 0));
              this.excessDays = Period.ofDays(_excessDays2);
            }
          }
        }
        this.fieldValues.remove(ChronoField.HOUR_OF_DAY);
        this.fieldValues.remove(ChronoField.MINUTE_OF_HOUR);
        this.fieldValues.remove(ChronoField.SECOND_OF_MINUTE);
        this.fieldValues.remove(ChronoField.NANO_OF_SECOND);
      };
      _proto._addObject = function _addObject(dateOrTime) {
        if (dateOrTime instanceof ChronoLocalDate) {
          this.date = dateOrTime;
        } else if (dateOrTime instanceof LocalTime) {
          this.time = dateOrTime;
        }
      };
      _proto._resolveInstant = function _resolveInstant() {
        if (this.date != null && this.time != null) {
          var offsetSecs = this.fieldValues.get(ChronoField.OFFSET_SECONDS);
          if (offsetSecs != null) {
            var offset = ZoneOffset.ofTotalSeconds(offsetSecs);
            var instant = this.date.atTime(this.time).atZone(offset).getLong(ChronoField.INSTANT_SECONDS);
            this.fieldValues.put(ChronoField.INSTANT_SECONDS, instant);
          } else if (this.zone != null) {
            var _instant = this.date.atTime(this.time).atZone(this.zone).getLong(ChronoField.INSTANT_SECONDS);
            this.fieldValues.put(ChronoField.INSTANT_SECONDS, _instant);
          }
        }
      };
      _proto.build = function build(type) {
        return type.queryFrom(this);
      };
      _proto.isSupported = function isSupported(field) {
        if (field == null) {
          return false;
        }
        return this.fieldValues.containsKey(field) && this.fieldValues.get(field) !== void 0 || this.date != null && this.date.isSupported(field) || this.time != null && this.time.isSupported(field);
      };
      _proto.getLong = function getLong(field) {
        requireNonNull(field, "field");
        var value = this.getFieldValue0(field);
        if (value == null) {
          if (this.date != null && this.date.isSupported(field)) {
            return this.date.getLong(field);
          }
          if (this.time != null && this.time.isSupported(field)) {
            return this.time.getLong(field);
          }
          throw new DateTimeException("Field not found: " + field);
        }
        return value;
      };
      _proto.query = function query(_query) {
        if (_query === TemporalQueries.zoneId()) {
          return this.zone;
        } else if (_query === TemporalQueries.chronology()) {
          return this.chrono;
        } else if (_query === TemporalQueries.localDate()) {
          return this.date != null ? LocalDate.from(this.date) : null;
        } else if (_query === TemporalQueries.localTime()) {
          return this.time;
        } else if (_query === TemporalQueries.zone() || _query === TemporalQueries.offset()) {
          return _query.queryFrom(this);
        } else if (_query === TemporalQueries.precision()) {
          return null;
        }
        return _query.queryFrom(this);
      };
      return DateTimeBuilder2;
    }(TemporalAccessor);
    DateTimeParseContext = function() {
      function DateTimeParseContext2() {
        if (arguments.length === 1) {
          if (arguments[0] instanceof DateTimeParseContext2) {
            this._constructorSelf.apply(this, arguments);
            return;
          } else {
            this._constructorFormatter.apply(this, arguments);
          }
        } else {
          this._constructorParam.apply(this, arguments);
        }
        this._caseSensitive = true;
        this._strict = true;
        this._parsed = [new Parsed(this)];
      }
      var _proto = DateTimeParseContext2.prototype;
      _proto._constructorParam = function _constructorParam(locale, symbols, chronology) {
        this._locale = locale;
        this._symbols = symbols;
        this._overrideChronology = chronology;
      };
      _proto._constructorFormatter = function _constructorFormatter(formatter) {
        this._locale = formatter.locale();
        this._symbols = formatter.decimalStyle();
        this._overrideChronology = formatter.chronology();
      };
      _proto._constructorSelf = function _constructorSelf(other) {
        this._locale = other._locale;
        this._symbols = other._symbols;
        this._overrideChronology = other._overrideChronology;
        this._overrideZone = other._overrideZone;
        this._caseSensitive = other._caseSensitive;
        this._strict = other._strict;
        this._parsed = [new Parsed(this)];
      };
      _proto.copy = function copy() {
        return new DateTimeParseContext2(this);
      };
      _proto.symbols = function symbols() {
        return this._symbols;
      };
      _proto.isStrict = function isStrict() {
        return this._strict;
      };
      _proto.setStrict = function setStrict(strict) {
        this._strict = strict;
      };
      _proto.locale = function locale() {
        return this._locale;
      };
      _proto.setLocale = function setLocale(locale) {
        this._locale = locale;
      };
      _proto.startOptional = function startOptional() {
        this._parsed.push(this.currentParsed().copy());
      };
      _proto.endOptional = function endOptional(successful) {
        if (successful) {
          this._parsed.splice(this._parsed.length - 2, 1);
        } else {
          this._parsed.splice(this._parsed.length - 1, 1);
        }
      };
      _proto.isCaseSensitive = function isCaseSensitive() {
        return this._caseSensitive;
      };
      _proto.setCaseSensitive = function setCaseSensitive(caseSensitive) {
        this._caseSensitive = caseSensitive;
      };
      _proto.subSequenceEquals = function subSequenceEquals(cs1, offset1, cs2, offset2, length) {
        if (offset1 + length > cs1.length || offset2 + length > cs2.length) {
          return false;
        }
        if (!this.isCaseSensitive()) {
          cs1 = cs1.toLowerCase();
          cs2 = cs2.toLowerCase();
        }
        for (var i = 0; i < length; i++) {
          var ch1 = cs1[offset1 + i];
          var ch2 = cs2[offset2 + i];
          if (ch1 !== ch2) {
            return false;
          }
        }
        return true;
      };
      _proto.charEquals = function charEquals(ch1, ch2) {
        if (this.isCaseSensitive()) {
          return ch1 === ch2;
        }
        return this.charEqualsIgnoreCase(ch1, ch2);
      };
      _proto.charEqualsIgnoreCase = function charEqualsIgnoreCase(c1, c2) {
        return c1 === c2 || c1.toLowerCase() === c2.toLowerCase();
      };
      _proto.setParsedField = function setParsedField(field, value, errorPos, successPos) {
        var currentParsedFieldValues = this.currentParsed().fieldValues;
        var old = currentParsedFieldValues.get(field);
        currentParsedFieldValues.set(field, value);
        return old != null && old !== value ? ~errorPos : successPos;
      };
      _proto.setParsedZone = function setParsedZone(zone) {
        requireNonNull(zone, "zone");
        this.currentParsed().zone = zone;
      };
      _proto.getParsed = function getParsed(field) {
        return this.currentParsed().fieldValues.get(field);
      };
      _proto.toParsed = function toParsed() {
        return this.currentParsed();
      };
      _proto.currentParsed = function currentParsed() {
        return this._parsed[this._parsed.length - 1];
      };
      _proto.setParsedLeapSecond = function setParsedLeapSecond() {
        this.currentParsed().leapSecond = true;
      };
      _proto.getEffectiveChronology = function getEffectiveChronology() {
        var chrono = this.currentParsed().chrono;
        if (chrono == null) {
          chrono = this._overrideChronology;
          if (chrono == null) {
            chrono = IsoChronology.INSTANCE;
          }
        }
        return chrono;
      };
      return DateTimeParseContext2;
    }();
    Parsed = function(_Temporal) {
      _inheritsLoose(Parsed2, _Temporal);
      function Parsed2(dateTimeParseContext) {
        var _this;
        _this = _Temporal.call(this) || this;
        _this.chrono = null;
        _this.zone = null;
        _this.fieldValues = new EnumMap();
        _this.leapSecond = false;
        _this.dateTimeParseContext = dateTimeParseContext;
        return _this;
      }
      var _proto2 = Parsed2.prototype;
      _proto2.copy = function copy() {
        var cloned = new Parsed2();
        cloned.chrono = this.chrono;
        cloned.zone = this.zone;
        cloned.fieldValues.putAll(this.fieldValues);
        cloned.leapSecond = this.leapSecond;
        cloned.dateTimeParseContext = this.dateTimeParseContext;
        return cloned;
      };
      _proto2.toString = function toString() {
        return this.fieldValues + ", " + this.chrono + ", " + this.zone;
      };
      _proto2.isSupported = function isSupported(field) {
        return this.fieldValues.containsKey(field);
      };
      _proto2.get = function get(field) {
        var val = this.fieldValues.get(field);
        assert(val != null);
        return val;
      };
      _proto2.query = function query(_query) {
        if (_query === TemporalQueries.chronology()) {
          return this.chrono;
        }
        if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.zone()) {
          return this.zone;
        }
        return _Temporal.prototype.query.call(this, _query);
      };
      _proto2.toBuilder = function toBuilder() {
        var builder = new DateTimeBuilder();
        builder.fieldValues.putAll(this.fieldValues);
        builder.chrono = this.dateTimeParseContext.getEffectiveChronology();
        if (this.zone != null) {
          builder.zone = this.zone;
        } else {
          builder.zone = this.overrideZone;
        }
        builder.leapSecond = this.leapSecond;
        builder.excessDays = this.excessDays;
        return builder;
      };
      return Parsed2;
    }(Temporal);
    DateTimePrintContext = function() {
      function DateTimePrintContext2(temporal, localeOrFormatter, symbols) {
        if (arguments.length === 2 && arguments[1] instanceof DateTimeFormatter) {
          this._temporal = DateTimePrintContext2.adjust(temporal, localeOrFormatter);
          this._locale = localeOrFormatter.locale();
          this._symbols = localeOrFormatter.decimalStyle();
        } else {
          this._temporal = temporal;
          this._locale = localeOrFormatter;
          this._symbols = symbols;
        }
        this._optional = 0;
      }
      DateTimePrintContext2.adjust = function adjust(temporal, formatter) {
        return temporal;
      };
      var _proto = DateTimePrintContext2.prototype;
      _proto.symbols = function symbols() {
        return this._symbols;
      };
      _proto.startOptional = function startOptional() {
        this._optional++;
      };
      _proto.endOptional = function endOptional() {
        this._optional--;
      };
      _proto.getValueQuery = function getValueQuery(query) {
        var result = this._temporal.query(query);
        if (result == null && this._optional === 0) {
          throw new DateTimeException("Unable to extract value: " + this._temporal);
        }
        return result;
      };
      _proto.getValue = function getValue(field) {
        try {
          return this._temporal.getLong(field);
        } catch (ex) {
          if (ex instanceof DateTimeException && this._optional > 0) {
            return null;
          }
          throw ex;
        }
      };
      _proto.temporal = function temporal() {
        return this._temporal;
      };
      _proto.locale = function locale() {
        return this._locale;
      };
      _proto.setDateTime = function setDateTime(temporal) {
        this._temporal = temporal;
      };
      _proto.setLocale = function setLocale(locale) {
        this._locale = locale;
      };
      return DateTimePrintContext2;
    }();
    IsoFields = {};
    QUARTER_DAYS = [0, 90, 181, 273, 0, 91, 182, 274];
    Field = function(_TemporalField) {
      _inheritsLoose(Field2, _TemporalField);
      function Field2() {
        return _TemporalField.apply(this, arguments) || this;
      }
      var _proto = Field2.prototype;
      _proto.isDateBased = function isDateBased() {
        return true;
      };
      _proto.isTimeBased = function isTimeBased() {
        return false;
      };
      _proto._isIso = function _isIso() {
        return true;
      };
      Field2._getWeekRangeByLocalDate = function _getWeekRangeByLocalDate(date) {
        var wby = Field2._getWeekBasedYear(date);
        return ValueRange.of(1, Field2._getWeekRangeByYear(wby));
      };
      Field2._getWeekRangeByYear = function _getWeekRangeByYear(wby) {
        var date = LocalDate.of(wby, 1, 1);
        if (date.dayOfWeek() === DayOfWeek.THURSDAY || date.dayOfWeek() === DayOfWeek.WEDNESDAY && date.isLeapYear()) {
          return 53;
        }
        return 52;
      };
      Field2._getWeek = function _getWeek(date) {
        var dow0 = date.dayOfWeek().ordinal();
        var doy0 = date.dayOfYear() - 1;
        var doyThu0 = doy0 + (3 - dow0);
        var alignedWeek = MathUtil.intDiv(doyThu0, 7);
        var firstThuDoy0 = doyThu0 - alignedWeek * 7;
        var firstMonDoy0 = firstThuDoy0 - 3;
        if (firstMonDoy0 < -3) {
          firstMonDoy0 += 7;
        }
        if (doy0 < firstMonDoy0) {
          return Field2._getWeekRangeByLocalDate(date.withDayOfYear(180).minusYears(1)).maximum();
        }
        var week = MathUtil.intDiv(doy0 - firstMonDoy0, 7) + 1;
        if (week === 53) {
          if ((firstMonDoy0 === -3 || firstMonDoy0 === -2 && date.isLeapYear()) === false) {
            week = 1;
          }
        }
        return week;
      };
      Field2._getWeekBasedYear = function _getWeekBasedYear(date) {
        var year = date.year();
        var doy = date.dayOfYear();
        if (doy <= 3) {
          var dow = date.dayOfWeek().ordinal();
          if (doy - dow < -2) {
            year--;
          }
        } else if (doy >= 363) {
          var _dow = date.dayOfWeek().ordinal();
          doy = doy - 363 - (date.isLeapYear() ? 1 : 0);
          if (doy - _dow >= 0) {
            year++;
          }
        }
        return year;
      };
      _proto.displayName = function displayName() {
        return this.toString();
      };
      _proto.resolve = function resolve() {
        return null;
      };
      _proto.name = function name3() {
        return this.toString();
      };
      return Field2;
    }(TemporalField);
    DAY_OF_QUARTER_FIELD = function(_Field) {
      _inheritsLoose(DAY_OF_QUARTER_FIELD2, _Field);
      function DAY_OF_QUARTER_FIELD2() {
        return _Field.apply(this, arguments) || this;
      }
      var _proto2 = DAY_OF_QUARTER_FIELD2.prototype;
      _proto2.toString = function toString() {
        return "DayOfQuarter";
      };
      _proto2.baseUnit = function baseUnit() {
        return ChronoUnit.DAYS;
      };
      _proto2.rangeUnit = function rangeUnit() {
        return QUARTER_YEARS;
      };
      _proto2.range = function range() {
        return ValueRange.of(1, 90, 92);
      };
      _proto2.isSupportedBy = function isSupportedBy(temporal) {
        return temporal.isSupported(ChronoField.DAY_OF_YEAR) && temporal.isSupported(ChronoField.MONTH_OF_YEAR) && temporal.isSupported(ChronoField.YEAR) && this._isIso(temporal);
      };
      _proto2.rangeRefinedBy = function rangeRefinedBy(temporal) {
        if (temporal.isSupported(this) === false) {
          throw new UnsupportedTemporalTypeException("Unsupported field: DayOfQuarter");
        }
        var qoy = temporal.getLong(QUARTER_OF_YEAR);
        if (qoy === 1) {
          var year = temporal.getLong(ChronoField.YEAR);
          return IsoChronology.isLeapYear(year) ? ValueRange.of(1, 91) : ValueRange.of(1, 90);
        } else if (qoy === 2) {
          return ValueRange.of(1, 91);
        } else if (qoy === 3 || qoy === 4) {
          return ValueRange.of(1, 92);
        }
        return this.range();
      };
      _proto2.getFrom = function getFrom(temporal) {
        if (temporal.isSupported(this) === false) {
          throw new UnsupportedTemporalTypeException("Unsupported field: DayOfQuarter");
        }
        var doy = temporal.get(ChronoField.DAY_OF_YEAR);
        var moy = temporal.get(ChronoField.MONTH_OF_YEAR);
        var year = temporal.getLong(ChronoField.YEAR);
        return doy - QUARTER_DAYS[MathUtil.intDiv(moy - 1, 3) + (IsoChronology.isLeapYear(year) ? 4 : 0)];
      };
      _proto2.adjustInto = function adjustInto(temporal, newValue) {
        var curValue = this.getFrom(temporal);
        this.range().checkValidValue(newValue, this);
        return temporal.with(ChronoField.DAY_OF_YEAR, temporal.getLong(ChronoField.DAY_OF_YEAR) + (newValue - curValue));
      };
      _proto2.resolve = function resolve(fieldValues, partialTemporal, resolverStyle) {
        var yearLong = fieldValues.get(ChronoField.YEAR);
        var qoyLong = fieldValues.get(QUARTER_OF_YEAR);
        if (yearLong == null || qoyLong == null) {
          return null;
        }
        var y = ChronoField.YEAR.checkValidIntValue(yearLong);
        var doq = fieldValues.get(DAY_OF_QUARTER);
        var date;
        if (resolverStyle === ResolverStyle.LENIENT) {
          var qoy = qoyLong;
          date = LocalDate.of(y, 1, 1);
          date = date.plusMonths(MathUtil.safeMultiply(MathUtil.safeSubtract(qoy, 1), 3));
          date = date.plusDays(MathUtil.safeSubtract(doq, 1));
        } else {
          var _qoy = QUARTER_OF_YEAR.range().checkValidIntValue(qoyLong, QUARTER_OF_YEAR);
          if (resolverStyle === ResolverStyle.STRICT) {
            var max = 92;
            if (_qoy === 1) {
              max = IsoChronology.isLeapYear(y) ? 91 : 90;
            } else if (_qoy === 2) {
              max = 91;
            }
            ValueRange.of(1, max).checkValidValue(doq, this);
          } else {
            this.range().checkValidValue(doq, this);
          }
          date = LocalDate.of(y, (_qoy - 1) * 3 + 1, 1).plusDays(doq - 1);
        }
        fieldValues.remove(this);
        fieldValues.remove(ChronoField.YEAR);
        fieldValues.remove(QUARTER_OF_YEAR);
        return date;
      };
      return DAY_OF_QUARTER_FIELD2;
    }(Field);
    QUARTER_OF_YEAR_FIELD = function(_Field2) {
      _inheritsLoose(QUARTER_OF_YEAR_FIELD2, _Field2);
      function QUARTER_OF_YEAR_FIELD2() {
        return _Field2.apply(this, arguments) || this;
      }
      var _proto3 = QUARTER_OF_YEAR_FIELD2.prototype;
      _proto3.toString = function toString() {
        return "QuarterOfYear";
      };
      _proto3.baseUnit = function baseUnit() {
        return QUARTER_YEARS;
      };
      _proto3.rangeUnit = function rangeUnit() {
        return ChronoUnit.YEARS;
      };
      _proto3.range = function range() {
        return ValueRange.of(1, 4);
      };
      _proto3.isSupportedBy = function isSupportedBy(temporal) {
        return temporal.isSupported(ChronoField.MONTH_OF_YEAR) && this._isIso(temporal);
      };
      _proto3.rangeRefinedBy = function rangeRefinedBy(temporal) {
        return this.range();
      };
      _proto3.getFrom = function getFrom(temporal) {
        if (temporal.isSupported(this) === false) {
          throw new UnsupportedTemporalTypeException("Unsupported field: QuarterOfYear");
        }
        var moy = temporal.getLong(ChronoField.MONTH_OF_YEAR);
        return MathUtil.intDiv(moy + 2, 3);
      };
      _proto3.adjustInto = function adjustInto(temporal, newValue) {
        var curValue = this.getFrom(temporal);
        this.range().checkValidValue(newValue, this);
        return temporal.with(ChronoField.MONTH_OF_YEAR, temporal.getLong(ChronoField.MONTH_OF_YEAR) + (newValue - curValue) * 3);
      };
      return QUARTER_OF_YEAR_FIELD2;
    }(Field);
    WEEK_OF_WEEK_BASED_YEAR_FIELD = function(_Field3) {
      _inheritsLoose(WEEK_OF_WEEK_BASED_YEAR_FIELD2, _Field3);
      function WEEK_OF_WEEK_BASED_YEAR_FIELD2() {
        return _Field3.apply(this, arguments) || this;
      }
      var _proto4 = WEEK_OF_WEEK_BASED_YEAR_FIELD2.prototype;
      _proto4.toString = function toString() {
        return "WeekOfWeekBasedYear";
      };
      _proto4.baseUnit = function baseUnit() {
        return ChronoUnit.WEEKS;
      };
      _proto4.rangeUnit = function rangeUnit() {
        return WEEK_BASED_YEARS;
      };
      _proto4.range = function range() {
        return ValueRange.of(1, 52, 53);
      };
      _proto4.isSupportedBy = function isSupportedBy(temporal) {
        return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);
      };
      _proto4.rangeRefinedBy = function rangeRefinedBy(temporal) {
        if (temporal.isSupported(this) === false) {
          throw new UnsupportedTemporalTypeException("Unsupported field: WeekOfWeekBasedYear");
        }
        return Field._getWeekRangeByLocalDate(LocalDate.from(temporal));
      };
      _proto4.getFrom = function getFrom(temporal) {
        if (temporal.isSupported(this) === false) {
          throw new UnsupportedTemporalTypeException("Unsupported field: WeekOfWeekBasedYear");
        }
        return Field._getWeek(LocalDate.from(temporal));
      };
      _proto4.adjustInto = function adjustInto(temporal, newValue) {
        this.range().checkValidValue(newValue, this);
        return temporal.plus(MathUtil.safeSubtract(newValue, this.getFrom(temporal)), ChronoUnit.WEEKS);
      };
      _proto4.resolve = function resolve(fieldValues, partialTemporal, resolverStyle) {
        var wbyLong = fieldValues.get(WEEK_BASED_YEAR);
        var dowLong = fieldValues.get(ChronoField.DAY_OF_WEEK);
        if (wbyLong == null || dowLong == null) {
          return null;
        }
        var wby = WEEK_BASED_YEAR.range().checkValidIntValue(wbyLong, WEEK_BASED_YEAR);
        var wowby = fieldValues.get(WEEK_OF_WEEK_BASED_YEAR);
        var date;
        if (resolverStyle === ResolverStyle.LENIENT) {
          var dow = dowLong;
          var weeks = 0;
          if (dow > 7) {
            weeks = MathUtil.intDiv(dow - 1, 7);
            dow = MathUtil.intMod(dow - 1, 7) + 1;
          } else if (dow < 1) {
            weeks = MathUtil.intDiv(dow, 7) - 1;
            dow = MathUtil.intMod(dow, 7) + 7;
          }
          date = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).plusWeeks(weeks).with(ChronoField.DAY_OF_WEEK, dow);
        } else {
          var _dow2 = ChronoField.DAY_OF_WEEK.checkValidIntValue(dowLong);
          if (resolverStyle === ResolverStyle.STRICT) {
            var temp = LocalDate.of(wby, 1, 4);
            var range = Field._getWeekRangeByLocalDate(temp);
            range.checkValidValue(wowby, this);
          } else {
            this.range().checkValidValue(wowby, this);
          }
          date = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).with(ChronoField.DAY_OF_WEEK, _dow2);
        }
        fieldValues.remove(this);
        fieldValues.remove(WEEK_BASED_YEAR);
        fieldValues.remove(ChronoField.DAY_OF_WEEK);
        return date;
      };
      _proto4.displayName = function displayName() {
        return "Week";
      };
      return WEEK_OF_WEEK_BASED_YEAR_FIELD2;
    }(Field);
    WEEK_BASED_YEAR_FIELD = function(_Field4) {
      _inheritsLoose(WEEK_BASED_YEAR_FIELD2, _Field4);
      function WEEK_BASED_YEAR_FIELD2() {
        return _Field4.apply(this, arguments) || this;
      }
      var _proto5 = WEEK_BASED_YEAR_FIELD2.prototype;
      _proto5.toString = function toString() {
        return "WeekBasedYear";
      };
      _proto5.baseUnit = function baseUnit() {
        return WEEK_BASED_YEARS;
      };
      _proto5.rangeUnit = function rangeUnit() {
        return ChronoUnit.FOREVER;
      };
      _proto5.range = function range() {
        return ChronoField.YEAR.range();
      };
      _proto5.isSupportedBy = function isSupportedBy(temporal) {
        return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);
      };
      _proto5.rangeRefinedBy = function rangeRefinedBy(temporal) {
        return ChronoField.YEAR.range();
      };
      _proto5.getFrom = function getFrom(temporal) {
        if (temporal.isSupported(this) === false) {
          throw new UnsupportedTemporalTypeException("Unsupported field: WeekBasedYear");
        }
        return Field._getWeekBasedYear(LocalDate.from(temporal));
      };
      _proto5.adjustInto = function adjustInto(temporal, newValue) {
        if (this.isSupportedBy(temporal) === false) {
          throw new UnsupportedTemporalTypeException("Unsupported field: WeekBasedYear");
        }
        var newWby = this.range().checkValidIntValue(newValue, WEEK_BASED_YEAR);
        var date = LocalDate.from(temporal);
        var dow = date.get(ChronoField.DAY_OF_WEEK);
        var week = Field._getWeek(date);
        if (week === 53 && Field._getWeekRangeByYear(newWby) === 52) {
          week = 52;
        }
        var resolved = LocalDate.of(newWby, 1, 4);
        var days = dow - resolved.get(ChronoField.DAY_OF_WEEK) + (week - 1) * 7;
        resolved = resolved.plusDays(days);
        return temporal.with(resolved);
      };
      return WEEK_BASED_YEAR_FIELD2;
    }(Field);
    Unit = function(_TemporalUnit) {
      _inheritsLoose(Unit2, _TemporalUnit);
      function Unit2(name3, estimatedDuration) {
        var _this;
        _this = _TemporalUnit.call(this) || this;
        _this._name = name3;
        _this._duration = estimatedDuration;
        return _this;
      }
      var _proto6 = Unit2.prototype;
      _proto6.duration = function duration() {
        return this._duration;
      };
      _proto6.isDurationEstimated = function isDurationEstimated() {
        return true;
      };
      _proto6.isDateBased = function isDateBased() {
        return true;
      };
      _proto6.isTimeBased = function isTimeBased() {
        return false;
      };
      _proto6.isSupportedBy = function isSupportedBy(temporal) {
        return temporal.isSupported(ChronoField.EPOCH_DAY);
      };
      _proto6.addTo = function addTo(temporal, periodToAdd) {
        switch (this) {
          case WEEK_BASED_YEARS: {
            var added = MathUtil.safeAdd(temporal.get(WEEK_BASED_YEAR), periodToAdd);
            return temporal.with(WEEK_BASED_YEAR, added);
          }
          case QUARTER_YEARS:
            return temporal.plus(MathUtil.intDiv(periodToAdd, 256), ChronoUnit.YEARS).plus(MathUtil.intMod(periodToAdd, 256) * 3, ChronoUnit.MONTHS);
          default:
            throw new IllegalStateException("Unreachable");
        }
      };
      _proto6.between = function between(temporal1, temporal2) {
        switch (this) {
          case WEEK_BASED_YEARS:
            return MathUtil.safeSubtract(temporal2.getLong(WEEK_BASED_YEAR), temporal1.getLong(WEEK_BASED_YEAR));
          case QUARTER_YEARS:
            return MathUtil.intDiv(temporal1.until(temporal2, ChronoUnit.MONTHS), 3);
          default:
            throw new IllegalStateException("Unreachable");
        }
      };
      _proto6.toString = function toString() {
        return this._name;
      };
      return Unit2;
    }(TemporalUnit);
    DAY_OF_QUARTER = null;
    QUARTER_OF_YEAR = null;
    WEEK_OF_WEEK_BASED_YEAR = null;
    WEEK_BASED_YEAR = null;
    WEEK_BASED_YEARS = null;
    QUARTER_YEARS = null;
    DecimalStyle = function() {
      function DecimalStyle2(zeroChar, positiveSignChar, negativeSignChar, decimalPointChar) {
        this._zeroDigit = zeroChar;
        this._zeroDigitCharCode = zeroChar.charCodeAt(0);
        this._positiveSign = positiveSignChar;
        this._negativeSign = negativeSignChar;
        this._decimalSeparator = decimalPointChar;
      }
      var _proto = DecimalStyle2.prototype;
      _proto.positiveSign = function positiveSign() {
        return this._positiveSign;
      };
      _proto.withPositiveSign = function withPositiveSign(positiveSign) {
        if (positiveSign === this._positiveSign) {
          return this;
        }
        return new DecimalStyle2(this._zeroDigit, positiveSign, this._negativeSign, this._decimalSeparator);
      };
      _proto.negativeSign = function negativeSign() {
        return this._negativeSign;
      };
      _proto.withNegativeSign = function withNegativeSign(negativeSign) {
        if (negativeSign === this._negativeSign) {
          return this;
        }
        return new DecimalStyle2(this._zeroDigit, this._positiveSign, negativeSign, this._decimalSeparator);
      };
      _proto.zeroDigit = function zeroDigit() {
        return this._zeroDigit;
      };
      _proto.withZeroDigit = function withZeroDigit(zeroDigit) {
        if (zeroDigit === this._zeroDigit) {
          return this;
        }
        return new DecimalStyle2(zeroDigit, this._positiveSign, this._negativeSign, this._decimalSeparator);
      };
      _proto.decimalSeparator = function decimalSeparator() {
        return this._decimalSeparator;
      };
      _proto.withDecimalSeparator = function withDecimalSeparator(decimalSeparator) {
        if (decimalSeparator === this._decimalSeparator) {
          return this;
        }
        return new DecimalStyle2(this._zeroDigit, this._positiveSign, this._negativeSign, decimalSeparator);
      };
      _proto.convertToDigit = function convertToDigit(char) {
        var val = char.charCodeAt(0) - this._zeroDigitCharCode;
        return val >= 0 && val <= 9 ? val : -1;
      };
      _proto.convertNumberToI18N = function convertNumberToI18N(numericText) {
        if (this._zeroDigit === "0") {
          return numericText;
        }
        var diff = this._zeroDigitCharCode - "0".charCodeAt(0);
        var convertedText = "";
        for (var i = 0; i < numericText.length; i++) {
          convertedText += String.fromCharCode(numericText.charCodeAt(i) + diff);
        }
        return convertedText;
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof DecimalStyle2) {
          return this._zeroDigit === other._zeroDigit && this._positiveSign === other._positiveSign && this._negativeSign === other._negativeSign && this._decimalSeparator === other._decimalSeparator;
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return this._zeroDigit + this._positiveSign + this._negativeSign + this._decimalSeparator;
      };
      _proto.toString = function toString() {
        return "DecimalStyle[" + this._zeroDigit + this._positiveSign + this._negativeSign + this._decimalSeparator + "]";
      };
      DecimalStyle2.of = function of() {
        throw new Error("not yet supported");
      };
      DecimalStyle2.availableLocales = function availableLocales() {
        throw new Error("not yet supported");
      };
      return DecimalStyle2;
    }();
    DecimalStyle.STANDARD = new DecimalStyle("0", "+", "-", ".");
    SignStyle = function(_Enum) {
      _inheritsLoose(SignStyle2, _Enum);
      function SignStyle2() {
        return _Enum.apply(this, arguments) || this;
      }
      var _proto = SignStyle2.prototype;
      _proto.parse = function parse2(positive, strict, fixedWidth) {
        switch (this) {
          case SignStyle2.NORMAL:
            return !positive || !strict;
          case SignStyle2.ALWAYS:
          case SignStyle2.EXCEEDS_PAD:
            return true;
          default:
            return !strict && !fixedWidth;
        }
      };
      return SignStyle2;
    }(Enum);
    SignStyle.NORMAL = new SignStyle("NORMAL");
    SignStyle.NEVER = new SignStyle("NEVER");
    SignStyle.ALWAYS = new SignStyle("ALWAYS");
    SignStyle.EXCEEDS_PAD = new SignStyle("EXCEEDS_PAD");
    SignStyle.NOT_NEGATIVE = new SignStyle("NOT_NEGATIVE");
    TextStyle = function(_Enum) {
      _inheritsLoose(TextStyle2, _Enum);
      function TextStyle2() {
        return _Enum.apply(this, arguments) || this;
      }
      var _proto = TextStyle2.prototype;
      _proto.isStandalone = function isStandalone() {
        switch (this) {
          case TextStyle2.FULL_STANDALONE:
          case TextStyle2.SHORT_STANDALONE:
          case TextStyle2.NARROW_STANDALONE:
            return true;
          default:
            return false;
        }
      };
      _proto.asStandalone = function asStandalone() {
        switch (this) {
          case TextStyle2.FULL:
            return TextStyle2.FULL_STANDALONE;
          case TextStyle2.SHORT:
            return TextStyle2.SHORT_STANDALONE;
          case TextStyle2.NARROW:
            return TextStyle2.NARROW_STANDALONE;
          default:
            return this;
        }
      };
      _proto.asNormal = function asNormal() {
        switch (this) {
          case TextStyle2.FULL_STANDALONE:
            return TextStyle2.FULL;
          case TextStyle2.SHORT_STANDALONE:
            return TextStyle2.SHORT;
          case TextStyle2.NARROW_STANDALONE:
            return TextStyle2.NARROW;
          default:
            return this;
        }
      };
      return TextStyle2;
    }(Enum);
    TextStyle.FULL = new TextStyle("FULL");
    TextStyle.FULL_STANDALONE = new TextStyle("FULL_STANDALONE");
    TextStyle.SHORT = new TextStyle("SHORT");
    TextStyle.SHORT_STANDALONE = new TextStyle("SHORT_STANDALONE");
    TextStyle.NARROW = new TextStyle("NARROW");
    TextStyle.NARROW_STANDALONE = new TextStyle("NARROW_STANDALONE");
    CharLiteralPrinterParser = function() {
      function CharLiteralPrinterParser2(literal) {
        if (literal.length > 1) {
          throw new IllegalArgumentException('invalid literal, too long: "' + literal + '"');
        }
        this._literal = literal;
      }
      var _proto = CharLiteralPrinterParser2.prototype;
      _proto.print = function print(context3, buf) {
        buf.append(this._literal);
        return true;
      };
      _proto.parse = function parse2(context3, text, position) {
        var length = text.length;
        if (position === length) {
          return ~position;
        }
        var ch = text.charAt(position);
        if (context3.charEquals(this._literal, ch) === false) {
          return ~position;
        }
        return position + this._literal.length;
      };
      _proto.toString = function toString() {
        if (this._literal === "'") {
          return "''";
        }
        return "'" + this._literal + "'";
      };
      return CharLiteralPrinterParser2;
    }();
    CompositePrinterParser = function() {
      function CompositePrinterParser2(printerParsers, optional) {
        this._printerParsers = printerParsers;
        this._optional = optional;
      }
      var _proto = CompositePrinterParser2.prototype;
      _proto.withOptional = function withOptional(optional) {
        if (optional === this._optional) {
          return this;
        }
        return new CompositePrinterParser2(this._printerParsers, optional);
      };
      _proto.print = function print(context3, buf) {
        var length = buf.length();
        if (this._optional) {
          context3.startOptional();
        }
        try {
          for (var i = 0; i < this._printerParsers.length; i++) {
            var pp = this._printerParsers[i];
            if (pp.print(context3, buf) === false) {
              buf.setLength(length);
              return true;
            }
          }
        } finally {
          if (this._optional) {
            context3.endOptional();
          }
        }
        return true;
      };
      _proto.parse = function parse2(context3, text, position) {
        if (this._optional) {
          context3.startOptional();
          var pos = position;
          for (var i = 0; i < this._printerParsers.length; i++) {
            var pp = this._printerParsers[i];
            pos = pp.parse(context3, text, pos);
            if (pos < 0) {
              context3.endOptional(false);
              return position;
            }
          }
          context3.endOptional(true);
          return pos;
        } else {
          for (var _i = 0; _i < this._printerParsers.length; _i++) {
            var _pp = this._printerParsers[_i];
            position = _pp.parse(context3, text, position);
            if (position < 0) {
              break;
            }
          }
          return position;
        }
      };
      _proto.toString = function toString() {
        var buf = "";
        if (this._printerParsers != null) {
          buf += this._optional ? "[" : "(";
          for (var i = 0; i < this._printerParsers.length; i++) {
            var pp = this._printerParsers[i];
            buf += pp.toString();
          }
          buf += this._optional ? "]" : ")";
        }
        return buf;
      };
      return CompositePrinterParser2;
    }();
    FractionPrinterParser = function() {
      function FractionPrinterParser2(field, minWidth, maxWidth, decimalPoint) {
        requireNonNull(field, "field");
        if (field.range().isFixed() === false) {
          throw new IllegalArgumentException("Field must have a fixed set of values: " + field);
        }
        if (minWidth < 0 || minWidth > 9) {
          throw new IllegalArgumentException("Minimum width must be from 0 to 9 inclusive but was " + minWidth);
        }
        if (maxWidth < 1 || maxWidth > 9) {
          throw new IllegalArgumentException("Maximum width must be from 1 to 9 inclusive but was " + maxWidth);
        }
        if (maxWidth < minWidth) {
          throw new IllegalArgumentException("Maximum width must exceed or equal the minimum width but " + maxWidth + " < " + minWidth);
        }
        this.field = field;
        this.minWidth = minWidth;
        this.maxWidth = maxWidth;
        this.decimalPoint = decimalPoint;
      }
      var _proto = FractionPrinterParser2.prototype;
      _proto.print = function print(context3, buf) {
        var value = context3.getValue(this.field);
        if (value === null) {
          return false;
        }
        var symbols = context3.symbols();
        if (value === 0) {
          if (this.minWidth > 0) {
            if (this.decimalPoint) {
              buf.append(symbols.decimalSeparator());
            }
            for (var i = 0; i < this.minWidth; i++) {
              buf.append(symbols.zeroDigit());
            }
          }
        } else {
          var fraction = this.convertToFraction(value, symbols.zeroDigit());
          var outputScale = Math.min(Math.max(fraction.length, this.minWidth), this.maxWidth);
          fraction = fraction.substr(0, outputScale);
          if (fraction * 1 > 0) {
            while (fraction.length > this.minWidth && fraction[fraction.length - 1] === "0") {
              fraction = fraction.substr(0, fraction.length - 1);
            }
          }
          var str = fraction;
          str = symbols.convertNumberToI18N(str);
          if (this.decimalPoint) {
            buf.append(symbols.decimalSeparator());
          }
          buf.append(str);
        }
        return true;
      };
      _proto.parse = function parse2(context3, text, position) {
        var effectiveMin = context3.isStrict() ? this.minWidth : 0;
        var effectiveMax = context3.isStrict() ? this.maxWidth : 9;
        var length = text.length;
        if (position === length) {
          return effectiveMin > 0 ? ~position : position;
        }
        if (this.decimalPoint) {
          if (text[position] !== context3.symbols().decimalSeparator()) {
            return effectiveMin > 0 ? ~position : position;
          }
          position++;
        }
        var minEndPos = position + effectiveMin;
        if (minEndPos > length) {
          return ~position;
        }
        var maxEndPos = Math.min(position + effectiveMax, length);
        var total = 0;
        var pos = position;
        while (pos < maxEndPos) {
          var ch = text.charAt(pos++);
          var digit = context3.symbols().convertToDigit(ch);
          if (digit < 0) {
            if (pos < minEndPos) {
              return ~position;
            }
            pos--;
            break;
          }
          total = total * 10 + digit;
        }
        var moveLeft = pos - position;
        var scale = Math.pow(10, moveLeft);
        var value = this.convertFromFraction(total, scale);
        return context3.setParsedField(this.field, value, position, pos);
      };
      _proto.convertToFraction = function convertToFraction(value, zeroDigit) {
        var range = this.field.range();
        range.checkValidValue(value, this.field);
        var _min = range.minimum();
        var _range = range.maximum() - _min + 1;
        var _value = value - _min;
        var _scaled = MathUtil.intDiv(_value * 1e9, _range);
        var fraction = "" + _scaled;
        while (fraction.length < 9) {
          fraction = zeroDigit + fraction;
        }
        return fraction;
      };
      _proto.convertFromFraction = function convertFromFraction(total, scale) {
        var range = this.field.range();
        var _min = range.minimum();
        var _range = range.maximum() - _min + 1;
        var _value = MathUtil.intDiv(total * _range, scale);
        return _value;
      };
      _proto.toString = function toString() {
        var decimal = this.decimalPoint ? ",DecimalPoint" : "";
        return "Fraction(" + this.field + "," + this.minWidth + "," + this.maxWidth + decimal + ")";
      };
      return FractionPrinterParser2;
    }();
    MAX_WIDTH$1 = 15;
    EXCEED_POINTS = [0, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9];
    NumberPrinterParser = function() {
      function NumberPrinterParser2(field, minWidth, maxWidth, signStyle, subsequentWidth) {
        if (subsequentWidth === void 0) {
          subsequentWidth = 0;
        }
        this._field = field;
        this._minWidth = minWidth;
        this._maxWidth = maxWidth;
        this._signStyle = signStyle;
        this._subsequentWidth = subsequentWidth;
      }
      var _proto = NumberPrinterParser2.prototype;
      _proto.field = function field() {
        return this._field;
      };
      _proto.minWidth = function minWidth() {
        return this._minWidth;
      };
      _proto.maxWidth = function maxWidth() {
        return this._maxWidth;
      };
      _proto.signStyle = function signStyle() {
        return this._signStyle;
      };
      _proto.withFixedWidth = function withFixedWidth() {
        if (this._subsequentWidth === -1) {
          return this;
        }
        return new NumberPrinterParser2(this._field, this._minWidth, this._maxWidth, this._signStyle, -1);
      };
      _proto.withSubsequentWidth = function withSubsequentWidth(subsequentWidth) {
        return new NumberPrinterParser2(this._field, this._minWidth, this._maxWidth, this._signStyle, this._subsequentWidth + subsequentWidth);
      };
      _proto._isFixedWidth = function _isFixedWidth() {
        return this._subsequentWidth === -1 || this._subsequentWidth > 0 && this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE;
      };
      _proto.print = function print(context3, buf) {
        var contextValue = context3.getValue(this._field);
        if (contextValue == null) {
          return false;
        }
        var value = this._getValue(context3, contextValue);
        var symbols = context3.symbols();
        var str = "" + Math.abs(value);
        if (str.length > this._maxWidth) {
          throw new DateTimeException("Field " + this._field + " cannot be printed as the value " + value + " exceeds the maximum print width of " + this._maxWidth);
        }
        str = symbols.convertNumberToI18N(str);
        if (value >= 0) {
          switch (this._signStyle) {
            case SignStyle.EXCEEDS_PAD:
              if (this._minWidth < MAX_WIDTH$1 && value >= EXCEED_POINTS[this._minWidth]) {
                buf.append(symbols.positiveSign());
              }
              break;
            case SignStyle.ALWAYS:
              buf.append(symbols.positiveSign());
              break;
          }
        } else {
          switch (this._signStyle) {
            case SignStyle.NORMAL:
            case SignStyle.EXCEEDS_PAD:
            case SignStyle.ALWAYS:
              buf.append(symbols.negativeSign());
              break;
            case SignStyle.NOT_NEGATIVE:
              throw new DateTimeException("Field " + this._field + " cannot be printed as the value " + value + " cannot be negative according to the SignStyle");
          }
        }
        for (var i = 0; i < this._minWidth - str.length; i++) {
          buf.append(symbols.zeroDigit());
        }
        buf.append(str);
        return true;
      };
      _proto.parse = function parse2(context3, text, position) {
        var length = text.length;
        if (position === length) {
          return ~position;
        }
        assert(position >= 0 && position < length);
        var sign2 = text.charAt(position);
        var negative = false;
        var positive = false;
        if (sign2 === context3.symbols().positiveSign()) {
          if (this._signStyle.parse(true, context3.isStrict(), this._minWidth === this._maxWidth) === false) {
            return ~position;
          }
          positive = true;
          position++;
        } else if (sign2 === context3.symbols().negativeSign()) {
          if (this._signStyle.parse(false, context3.isStrict(), this._minWidth === this._maxWidth) === false) {
            return ~position;
          }
          negative = true;
          position++;
        } else {
          if (this._signStyle === SignStyle.ALWAYS && context3.isStrict()) {
            return ~position;
          }
        }
        var effMinWidth = context3.isStrict() || this._isFixedWidth() ? this._minWidth : 1;
        var minEndPos = position + effMinWidth;
        if (minEndPos > length) {
          return ~position;
        }
        var effMaxWidth = (context3.isStrict() || this._isFixedWidth() ? this._maxWidth : 9) + Math.max(this._subsequentWidth, 0);
        var total = 0;
        var pos = position;
        for (var pass = 0; pass < 2; pass++) {
          var maxEndPos = Math.min(pos + effMaxWidth, length);
          while (pos < maxEndPos) {
            var ch = text.charAt(pos++);
            var digit = context3.symbols().convertToDigit(ch);
            if (digit < 0) {
              pos--;
              if (pos < minEndPos) {
                return ~position;
              }
              break;
            }
            if (pos - position > MAX_WIDTH$1) {
              throw new ArithmeticException("number text exceeds length");
            } else {
              total = total * 10 + digit;
            }
          }
          if (this._subsequentWidth > 0 && pass === 0) {
            var parseLen = pos - position;
            effMaxWidth = Math.max(effMinWidth, parseLen - this._subsequentWidth);
            pos = position;
            total = 0;
          } else {
            break;
          }
        }
        if (negative) {
          if (total === 0 && context3.isStrict()) {
            return ~(position - 1);
          }
          if (total !== 0) {
            total = -total;
          }
        } else if (this._signStyle === SignStyle.EXCEEDS_PAD && context3.isStrict()) {
          var _parseLen = pos - position;
          if (positive) {
            if (_parseLen <= this._minWidth) {
              return ~(position - 1);
            }
          } else {
            if (_parseLen > this._minWidth) {
              return ~position;
            }
          }
        }
        return this._setValue(context3, total, position, pos);
      };
      _proto._getValue = function _getValue(context3, value) {
        return value;
      };
      _proto._setValue = function _setValue(context3, value, errorPos, successPos) {
        return context3.setParsedField(this._field, value, errorPos, successPos);
      };
      _proto.toString = function toString() {
        if (this._minWidth === 1 && this._maxWidth === MAX_WIDTH$1 && this._signStyle === SignStyle.NORMAL) {
          return "Value(" + this._field + ")";
        }
        if (this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE) {
          return "Value(" + this._field + "," + this._minWidth + ")";
        }
        return "Value(" + this._field + "," + this._minWidth + "," + this._maxWidth + "," + this._signStyle + ")";
      };
      return NumberPrinterParser2;
    }();
    ReducedPrinterParser = function(_NumberPrinterParser) {
      _inheritsLoose(ReducedPrinterParser2, _NumberPrinterParser);
      function ReducedPrinterParser2(field, width, maxWidth, baseValue, baseDate) {
        var _this;
        _this = _NumberPrinterParser.call(this, field, width, maxWidth, SignStyle.NOT_NEGATIVE) || this;
        if (width < 1 || width > 10) {
          throw new IllegalArgumentException("The width must be from 1 to 10 inclusive but was " + width);
        }
        if (maxWidth < 1 || maxWidth > 10) {
          throw new IllegalArgumentException("The maxWidth must be from 1 to 10 inclusive but was " + maxWidth);
        }
        if (maxWidth < width) {
          throw new IllegalArgumentException("The maxWidth must be greater than the width");
        }
        if (baseDate === null) {
          if (field.range().isValidValue(baseValue) === false) {
            throw new IllegalArgumentException("The base value must be within the range of the field");
          }
          if (baseValue + EXCEED_POINTS[width] > MathUtil.MAX_SAFE_INTEGER) {
            throw new DateTimeException("Unable to add printer-parser as the range exceeds the capacity of an int");
          }
        }
        _this._baseValue = baseValue;
        _this._baseDate = baseDate;
        return _this;
      }
      var _proto2 = ReducedPrinterParser2.prototype;
      _proto2._getValue = function _getValue(context3, value) {
        var absValue = Math.abs(value);
        var baseValue = this._baseValue;
        if (this._baseDate !== null) {
          context3.temporal();
          var chrono = IsoChronology.INSTANCE;
          baseValue = chrono.date(this._baseDate).get(this._field);
        }
        if (value >= baseValue && value < baseValue + EXCEED_POINTS[this._minWidth]) {
          return absValue % EXCEED_POINTS[this._minWidth];
        }
        return absValue % EXCEED_POINTS[this._maxWidth];
      };
      _proto2._setValue = function _setValue(context3, value, errorPos, successPos) {
        var baseValue = this._baseValue;
        if (this._baseDate != null) {
          var chrono = context3.getEffectiveChronology();
          baseValue = chrono.date(this._baseDate).get(this._field);
        }
        var parseLen = successPos - errorPos;
        if (parseLen === this._minWidth && value >= 0) {
          var range = EXCEED_POINTS[this._minWidth];
          var lastPart = baseValue % range;
          var basePart = baseValue - lastPart;
          if (baseValue > 0) {
            value = basePart + value;
          } else {
            value = basePart - value;
          }
          if (value < baseValue) {
            value += range;
          }
        }
        return context3.setParsedField(this._field, value, errorPos, successPos);
      };
      _proto2.withFixedWidth = function withFixedWidth() {
        if (this._subsequentWidth === -1) {
          return this;
        }
        return new ReducedPrinterParser2(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate);
      };
      _proto2.withSubsequentWidth = function withSubsequentWidth(subsequentWidth) {
        return new ReducedPrinterParser2(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate, this._subsequentWidth + subsequentWidth);
      };
      _proto2.isFixedWidth = function isFixedWidth(context3) {
        if (context3.isStrict() === false) {
          return false;
        }
        return _NumberPrinterParser.prototype.isFixedWidth.call(this, context3);
      };
      _proto2.toString = function toString() {
        return "ReducedValue(" + this._field + "," + this._minWidth + "," + this._maxWidth + "," + (this._baseDate != null ? this._baseDate : this._baseValue) + ")";
      };
      return ReducedPrinterParser2;
    }(NumberPrinterParser);
    PATTERNS = ["+HH", "+HHmm", "+HH:mm", "+HHMM", "+HH:MM", "+HHMMss", "+HH:MM:ss", "+HHMMSS", "+HH:MM:SS"];
    OffsetIdPrinterParser = function() {
      function OffsetIdPrinterParser2(noOffsetText, pattern) {
        requireNonNull(noOffsetText, "noOffsetText");
        requireNonNull(pattern, "pattern");
        this.noOffsetText = noOffsetText;
        this.type = this._checkPattern(pattern);
      }
      var _proto = OffsetIdPrinterParser2.prototype;
      _proto._checkPattern = function _checkPattern(pattern) {
        for (var i = 0; i < PATTERNS.length; i++) {
          if (PATTERNS[i] === pattern) {
            return i;
          }
        }
        throw new IllegalArgumentException("Invalid zone offset pattern: " + pattern);
      };
      _proto.print = function print(context3, buf) {
        var offsetSecs = context3.getValue(ChronoField.OFFSET_SECONDS);
        if (offsetSecs == null) {
          return false;
        }
        var totalSecs = MathUtil.safeToInt(offsetSecs);
        if (totalSecs === 0) {
          buf.append(this.noOffsetText);
        } else {
          var absHours = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 3600), 100));
          var absMinutes = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 60), 60));
          var absSeconds = Math.abs(MathUtil.intMod(totalSecs, 60));
          var bufPos = buf.length();
          var output = absHours;
          buf.append(totalSecs < 0 ? "-" : "+").appendChar(MathUtil.intDiv(absHours, 10) + "0").appendChar(MathUtil.intMod(absHours, 10) + "0");
          if (this.type >= 3 || this.type >= 1 && absMinutes > 0) {
            buf.append(this.type % 2 === 0 ? ":" : "").appendChar(MathUtil.intDiv(absMinutes, 10) + "0").appendChar(absMinutes % 10 + "0");
            output += absMinutes;
            if (this.type >= 7 || this.type >= 5 && absSeconds > 0) {
              buf.append(this.type % 2 === 0 ? ":" : "").appendChar(MathUtil.intDiv(absSeconds, 10) + "0").appendChar(absSeconds % 10 + "0");
              output += absSeconds;
            }
          }
          if (output === 0) {
            buf.setLength(bufPos);
            buf.append(this.noOffsetText);
          }
        }
        return true;
      };
      _proto.parse = function parse2(context3, text, position) {
        var length = text.length;
        var noOffsetLen = this.noOffsetText.length;
        if (noOffsetLen === 0) {
          if (position === length) {
            return context3.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position);
          }
        } else {
          if (position === length) {
            return ~position;
          }
          if (context3.subSequenceEquals(text, position, this.noOffsetText, 0, noOffsetLen)) {
            return context3.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);
          }
        }
        var sign2 = text[position];
        if (sign2 === "+" || sign2 === "-") {
          var negative = sign2 === "-" ? -1 : 1;
          var array = [0, 0, 0, 0];
          array[0] = position + 1;
          if ((this._parseNumber(array, 1, text, true) || this._parseNumber(array, 2, text, this.type >= 3) || this._parseNumber(array, 3, text, false)) === false) {
            var offsetSecs = MathUtil.safeZero(negative * (array[1] * 3600 + array[2] * 60 + array[3]));
            return context3.setParsedField(ChronoField.OFFSET_SECONDS, offsetSecs, position, array[0]);
          }
        }
        if (noOffsetLen === 0) {
          return context3.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);
        }
        return ~position;
      };
      _proto._parseNumber = function _parseNumber(array, arrayIndex, parseText, required) {
        if ((this.type + 3) / 2 < arrayIndex) {
          return false;
        }
        var pos = array[0];
        if (this.type % 2 === 0 && arrayIndex > 1) {
          if (pos + 1 > parseText.length || parseText[pos] !== ":") {
            return required;
          }
          pos++;
        }
        if (pos + 2 > parseText.length) {
          return required;
        }
        var ch1 = parseText[pos++];
        var ch2 = parseText[pos++];
        if (ch1 < "0" || ch1 > "9" || ch2 < "0" || ch2 > "9") {
          return required;
        }
        var value = (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);
        if (value < 0 || value > 59) {
          return required;
        }
        array[arrayIndex] = value;
        array[0] = pos;
        return false;
      };
      _proto.toString = function toString() {
        var converted = this.noOffsetText.replace("'", "''");
        return "Offset(" + PATTERNS[this.type] + ",'" + converted + "')";
      };
      return OffsetIdPrinterParser2;
    }();
    OffsetIdPrinterParser.INSTANCE_ID = new OffsetIdPrinterParser("Z", "+HH:MM:ss");
    OffsetIdPrinterParser.PATTERNS = PATTERNS;
    PadPrinterParserDecorator = function() {
      function PadPrinterParserDecorator2(printerParser, padWidth, padChar) {
        this._printerParser = printerParser;
        this._padWidth = padWidth;
        this._padChar = padChar;
      }
      var _proto = PadPrinterParserDecorator2.prototype;
      _proto.print = function print(context3, buf) {
        var preLen = buf.length();
        if (this._printerParser.print(context3, buf) === false) {
          return false;
        }
        var len = buf.length() - preLen;
        if (len > this._padWidth) {
          throw new DateTimeException("Cannot print as output of " + len + " characters exceeds pad width of " + this._padWidth);
        }
        for (var i = 0; i < this._padWidth - len; i++) {
          buf.insert(preLen, this._padChar);
        }
        return true;
      };
      _proto.parse = function parse2(context3, text, position) {
        var strict = context3.isStrict();
        var caseSensitive = context3.isCaseSensitive();
        assert(!(position > text.length));
        assert(position >= 0);
        if (position === text.length) {
          return ~position;
        }
        var endPos = position + this._padWidth;
        if (endPos > text.length) {
          if (strict) {
            return ~position;
          }
          endPos = text.length;
        }
        var pos = position;
        while (pos < endPos && (caseSensitive ? text[pos] === this._padChar : context3.charEquals(text[pos], this._padChar))) {
          pos++;
        }
        text = text.substring(0, endPos);
        var resultPos = this._printerParser.parse(context3, text, pos);
        if (resultPos !== endPos && strict) {
          return ~(position + pos);
        }
        return resultPos;
      };
      _proto.toString = function toString() {
        return "Pad(" + this._printerParser + "," + this._padWidth + (this._padChar === " " ? ")" : ",'" + this._padChar + "')");
      };
      return PadPrinterParserDecorator2;
    }();
    SettingsParser = function(_Enum) {
      _inheritsLoose(SettingsParser2, _Enum);
      function SettingsParser2() {
        return _Enum.apply(this, arguments) || this;
      }
      var _proto = SettingsParser2.prototype;
      _proto.print = function print() {
        return true;
      };
      _proto.parse = function parse2(context3, text, position) {
        switch (this) {
          case SettingsParser2.SENSITIVE:
            context3.setCaseSensitive(true);
            break;
          case SettingsParser2.INSENSITIVE:
            context3.setCaseSensitive(false);
            break;
          case SettingsParser2.STRICT:
            context3.setStrict(true);
            break;
          case SettingsParser2.LENIENT:
            context3.setStrict(false);
            break;
        }
        return position;
      };
      _proto.toString = function toString() {
        switch (this) {
          case SettingsParser2.SENSITIVE:
            return "ParseCaseSensitive(true)";
          case SettingsParser2.INSENSITIVE:
            return "ParseCaseSensitive(false)";
          case SettingsParser2.STRICT:
            return "ParseStrict(true)";
          case SettingsParser2.LENIENT:
            return "ParseStrict(false)";
        }
      };
      return SettingsParser2;
    }(Enum);
    SettingsParser.SENSITIVE = new SettingsParser("SENSITIVE");
    SettingsParser.INSENSITIVE = new SettingsParser("INSENSITIVE");
    SettingsParser.STRICT = new SettingsParser("STRICT");
    SettingsParser.LENIENT = new SettingsParser("LENIENT");
    StringLiteralPrinterParser = function() {
      function StringLiteralPrinterParser2(literal) {
        this._literal = literal;
      }
      var _proto = StringLiteralPrinterParser2.prototype;
      _proto.print = function print(context3, buf) {
        buf.append(this._literal);
        return true;
      };
      _proto.parse = function parse2(context3, text, position) {
        var length = text.length;
        assert(!(position > length || position < 0));
        if (context3.subSequenceEquals(text, position, this._literal, 0, this._literal.length) === false) {
          return ~position;
        }
        return position + this._literal.length;
      };
      _proto.toString = function toString() {
        var converted = this._literal.replace("'", "''");
        return "'" + converted + "'";
      };
      return StringLiteralPrinterParser2;
    }();
    ZoneRulesProvider = function() {
      function ZoneRulesProvider2() {
      }
      ZoneRulesProvider2.getRules = function getRules(zoneId) {
        throw new DateTimeException("unsupported ZoneId:" + zoneId);
      };
      ZoneRulesProvider2.getAvailableZoneIds = function getAvailableZoneIds() {
        return [];
      };
      return ZoneRulesProvider2;
    }();
    ZoneRegion = function(_ZoneId) {
      _inheritsLoose(ZoneRegion2, _ZoneId);
      ZoneRegion2.ofId = function ofId(zoneId) {
        var rules = ZoneRulesProvider.getRules(zoneId);
        return new ZoneRegion2(zoneId, rules);
      };
      function ZoneRegion2(id, rules) {
        var _this;
        _this = _ZoneId.call(this) || this;
        _this._id = id;
        _this._rules = rules;
        return _this;
      }
      var _proto = ZoneRegion2.prototype;
      _proto.id = function id() {
        return this._id;
      };
      _proto.rules = function rules() {
        return this._rules;
      };
      return ZoneRegion2;
    }(ZoneId);
    ZoneIdPrinterParser = function() {
      function ZoneIdPrinterParser2(query, description) {
        this.query = query;
        this.description = description;
      }
      var _proto = ZoneIdPrinterParser2.prototype;
      _proto.print = function print(context3, buf) {
        var zone = context3.getValueQuery(this.query);
        if (zone == null) {
          return false;
        }
        buf.append(zone.id());
        return true;
      };
      _proto.parse = function parse2(context3, text, position) {
        var length = text.length;
        if (position > length) {
          return ~position;
        }
        if (position === length) {
          return ~position;
        }
        var nextChar = text.charAt(position);
        if (nextChar === "+" || nextChar === "-") {
          var newContext = context3.copy();
          var endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);
          if (endPos < 0) {
            return endPos;
          }
          var offset = newContext.getParsed(ChronoField.OFFSET_SECONDS);
          var zone = ZoneOffset.ofTotalSeconds(offset);
          context3.setParsedZone(zone);
          return endPos;
        } else if (length >= position + 2) {
          var nextNextChar = text.charAt(position + 1);
          if (context3.charEquals(nextChar, "U") && context3.charEquals(nextNextChar, "T")) {
            if (length >= position + 3 && context3.charEquals(text.charAt(position + 2), "C")) {
              return this._parsePrefixedOffset(context3, text, position, position + 3);
            }
            return this._parsePrefixedOffset(context3, text, position, position + 2);
          } else if (context3.charEquals(nextChar, "G") && length >= position + 3 && context3.charEquals(nextNextChar, "M") && context3.charEquals(text.charAt(position + 2), "T")) {
            return this._parsePrefixedOffset(context3, text, position, position + 3);
          }
        }
        if (text.substr(position, 6) === "SYSTEM") {
          context3.setParsedZone(ZoneId.systemDefault());
          return position + 6;
        }
        if (context3.charEquals(nextChar, "Z")) {
          context3.setParsedZone(ZoneOffset.UTC);
          return position + 1;
        }
        var availableZoneIds = ZoneRulesProvider.getAvailableZoneIds();
        if (zoneIdTree.size !== availableZoneIds.length) {
          zoneIdTree = ZoneIdTree.createTreeMap(availableZoneIds);
        }
        var maxParseLength = length - position;
        var treeMap = zoneIdTree.treeMap;
        var parsedZoneId = null;
        var parseLength = 0;
        while (treeMap != null) {
          var parsedSubZoneId = text.substr(position, Math.min(treeMap.length, maxParseLength));
          treeMap = treeMap.get(parsedSubZoneId);
          if (treeMap != null && treeMap.isLeaf) {
            parsedZoneId = parsedSubZoneId;
            parseLength = treeMap.length;
          }
        }
        if (parsedZoneId != null) {
          context3.setParsedZone(ZoneRegion.ofId(parsedZoneId));
          return position + parseLength;
        }
        return ~position;
      };
      _proto._parsePrefixedOffset = function _parsePrefixedOffset(context3, text, prefixPos, position) {
        var prefix = text.substring(prefixPos, position).toUpperCase();
        var newContext = context3.copy();
        if (position < text.length && context3.charEquals(text.charAt(position), "Z")) {
          context3.setParsedZone(ZoneId.ofOffset(prefix, ZoneOffset.UTC));
          return position;
        }
        var endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);
        if (endPos < 0) {
          context3.setParsedZone(ZoneId.ofOffset(prefix, ZoneOffset.UTC));
          return position;
        }
        var offsetSecs = newContext.getParsed(ChronoField.OFFSET_SECONDS);
        var offset = ZoneOffset.ofTotalSeconds(offsetSecs);
        context3.setParsedZone(ZoneId.ofOffset(prefix, offset));
        return endPos;
      };
      _proto.toString = function toString() {
        return this.description;
      };
      return ZoneIdPrinterParser2;
    }();
    ZoneIdTree = function() {
      ZoneIdTree2.createTreeMap = function createTreeMap(availableZoneIds) {
        var sortedZoneIds = availableZoneIds.sort(function(a, b) {
          return a.length - b.length;
        });
        var treeMap = new ZoneIdTreeMap(sortedZoneIds[0].length, false);
        for (var i = 0; i < sortedZoneIds.length; i++) {
          treeMap.add(sortedZoneIds[i]);
        }
        return new ZoneIdTree2(sortedZoneIds.length, treeMap);
      };
      function ZoneIdTree2(size, treeMap) {
        this.size = size;
        this.treeMap = treeMap;
      }
      return ZoneIdTree2;
    }();
    ZoneIdTreeMap = function() {
      function ZoneIdTreeMap2(length, isLeaf) {
        if (length === void 0) {
          length = 0;
        }
        if (isLeaf === void 0) {
          isLeaf = false;
        }
        this.length = length;
        this.isLeaf = isLeaf;
        this._treeMap = {};
      }
      var _proto2 = ZoneIdTreeMap2.prototype;
      _proto2.add = function add(zoneId) {
        var idLength = zoneId.length;
        if (idLength === this.length) {
          this._treeMap[zoneId] = new ZoneIdTreeMap2(idLength, true);
        } else if (idLength > this.length) {
          var subZoneId = zoneId.substr(0, this.length);
          var subTreeMap = this._treeMap[subZoneId];
          if (subTreeMap == null) {
            subTreeMap = new ZoneIdTreeMap2(idLength, false);
            this._treeMap[subZoneId] = subTreeMap;
          }
          subTreeMap.add(zoneId);
        }
      };
      _proto2.get = function get(zoneId) {
        return this._treeMap[zoneId];
      };
      return ZoneIdTreeMap2;
    }();
    zoneIdTree = new ZoneIdTree([]);
    MAX_WIDTH = 15;
    DateTimeFormatterBuilder = function() {
      function DateTimeFormatterBuilder2() {
        this._active = this;
        this._parent = null;
        this._printerParsers = [];
        this._optional = false;
        this._padNextWidth = 0;
        this._padNextChar = null;
        this._valueParserIndex = -1;
      }
      DateTimeFormatterBuilder2._of = function _of(parent, optional) {
        requireNonNull(parent, "parent");
        requireNonNull(optional, "optional");
        var dtFormatterBuilder = new DateTimeFormatterBuilder2();
        dtFormatterBuilder._parent = parent;
        dtFormatterBuilder._optional = optional;
        return dtFormatterBuilder;
      };
      var _proto = DateTimeFormatterBuilder2.prototype;
      _proto.parseCaseSensitive = function parseCaseSensitive() {
        this._appendInternalPrinterParser(SettingsParser.SENSITIVE);
        return this;
      };
      _proto.parseCaseInsensitive = function parseCaseInsensitive() {
        this._appendInternalPrinterParser(SettingsParser.INSENSITIVE);
        return this;
      };
      _proto.parseStrict = function parseStrict() {
        this._appendInternalPrinterParser(SettingsParser.STRICT);
        return this;
      };
      _proto.parseLenient = function parseLenient() {
        this._appendInternalPrinterParser(SettingsParser.LENIENT);
        return this;
      };
      _proto.parseDefaulting = function parseDefaulting(field, value) {
        requireNonNull(field);
        this._appendInternal(new DefaultingParser(field, value));
        return this;
      };
      _proto.appendValue = function appendValue() {
        if (arguments.length === 1) {
          return this._appendValue1.apply(this, arguments);
        } else if (arguments.length === 2) {
          return this._appendValue2.apply(this, arguments);
        } else {
          return this._appendValue4.apply(this, arguments);
        }
      };
      _proto._appendValue1 = function _appendValue1(field) {
        requireNonNull(field);
        this._appendValuePrinterParser(new NumberPrinterParser(field, 1, MAX_WIDTH, SignStyle.NORMAL));
        return this;
      };
      _proto._appendValue2 = function _appendValue2(field, width) {
        requireNonNull(field);
        if (width < 1 || width > MAX_WIDTH) {
          throw new IllegalArgumentException("The width must be from 1 to " + MAX_WIDTH + " inclusive but was " + width);
        }
        var pp = new NumberPrinterParser(field, width, width, SignStyle.NOT_NEGATIVE);
        this._appendValuePrinterParser(pp);
        return this;
      };
      _proto._appendValue4 = function _appendValue4(field, minWidth, maxWidth, signStyle) {
        requireNonNull(field);
        requireNonNull(signStyle);
        if (minWidth === maxWidth && signStyle === SignStyle.NOT_NEGATIVE) {
          return this._appendValue2(field, maxWidth);
        }
        if (minWidth < 1 || minWidth > MAX_WIDTH) {
          throw new IllegalArgumentException("The minimum width must be from 1 to " + MAX_WIDTH + " inclusive but was " + minWidth);
        }
        if (maxWidth < 1 || maxWidth > MAX_WIDTH) {
          throw new IllegalArgumentException("The minimum width must be from 1 to " + MAX_WIDTH + " inclusive but was " + maxWidth);
        }
        if (maxWidth < minWidth) {
          throw new IllegalArgumentException("The maximum width must exceed or equal the minimum width but " + maxWidth + " < " + minWidth);
        }
        var pp = new NumberPrinterParser(field, minWidth, maxWidth, signStyle);
        this._appendValuePrinterParser(pp);
        return this;
      };
      _proto.appendValueReduced = function appendValueReduced() {
        if (arguments.length === 4 && arguments[3] instanceof ChronoLocalDate) {
          return this._appendValueReducedFieldWidthMaxWidthBaseDate.apply(this, arguments);
        } else {
          return this._appendValueReducedFieldWidthMaxWidthBaseValue.apply(this, arguments);
        }
      };
      _proto._appendValueReducedFieldWidthMaxWidthBaseValue = function _appendValueReducedFieldWidthMaxWidthBaseValue(field, width, maxWidth, baseValue) {
        requireNonNull(field, "field");
        var pp = new ReducedPrinterParser(field, width, maxWidth, baseValue, null);
        this._appendValuePrinterParser(pp);
        return this;
      };
      _proto._appendValueReducedFieldWidthMaxWidthBaseDate = function _appendValueReducedFieldWidthMaxWidthBaseDate(field, width, maxWidth, baseDate) {
        requireNonNull(field, "field");
        requireNonNull(baseDate, "baseDate");
        requireInstance(baseDate, ChronoLocalDate, "baseDate");
        var pp = new ReducedPrinterParser(field, width, maxWidth, 0, baseDate);
        this._appendValuePrinterParser(pp);
        return this;
      };
      _proto._appendValuePrinterParser = function _appendValuePrinterParser(pp) {
        assert(pp != null);
        if (this._active._valueParserIndex >= 0 && this._active._printerParsers[this._active._valueParserIndex] instanceof NumberPrinterParser) {
          var activeValueParser = this._active._valueParserIndex;
          var basePP = this._active._printerParsers[activeValueParser];
          if (pp.minWidth() === pp.maxWidth() && pp.signStyle() === SignStyle.NOT_NEGATIVE) {
            basePP = basePP.withSubsequentWidth(pp.maxWidth());
            this._appendInternal(pp.withFixedWidth());
            this._active._valueParserIndex = activeValueParser;
          } else {
            basePP = basePP.withFixedWidth();
            this._active._valueParserIndex = this._appendInternal(pp);
          }
          this._active._printerParsers[activeValueParser] = basePP;
        } else {
          this._active._valueParserIndex = this._appendInternal(pp);
        }
        return this;
      };
      _proto.appendFraction = function appendFraction(field, minWidth, maxWidth, decimalPoint) {
        this._appendInternal(new FractionPrinterParser(field, minWidth, maxWidth, decimalPoint));
        return this;
      };
      _proto.appendInstant = function appendInstant(fractionalDigits) {
        if (fractionalDigits === void 0) {
          fractionalDigits = -2;
        }
        if (fractionalDigits < -2 || fractionalDigits > 9) {
          throw new IllegalArgumentException("Invalid fractional digits: " + fractionalDigits);
        }
        this._appendInternal(new InstantPrinterParser(fractionalDigits));
        return this;
      };
      _proto.appendOffsetId = function appendOffsetId() {
        this._appendInternal(OffsetIdPrinterParser.INSTANCE_ID);
        return this;
      };
      _proto.appendOffset = function appendOffset(pattern, noOffsetText) {
        this._appendInternalPrinterParser(new OffsetIdPrinterParser(noOffsetText, pattern));
        return this;
      };
      _proto.appendZoneId = function appendZoneId() {
        this._appendInternal(new ZoneIdPrinterParser(TemporalQueries.zoneId(), "ZoneId()"));
        return this;
      };
      _proto.appendPattern = function appendPattern(pattern) {
        requireNonNull(pattern, "pattern");
        this._parsePattern(pattern);
        return this;
      };
      _proto.appendZoneText = function appendZoneText() {
        throw new IllegalArgumentException("Pattern using (localized) text not implemented, use @js-joda/locale plugin!");
      };
      _proto.appendText = function appendText() {
        throw new IllegalArgumentException("Pattern using (localized) text not implemented, use @js-joda/locale plugin!");
      };
      _proto.appendLocalizedOffset = function appendLocalizedOffset() {
        throw new IllegalArgumentException("Pattern using (localized) text not implemented, use @js-joda/locale plugin!");
      };
      _proto.appendWeekField = function appendWeekField() {
        throw new IllegalArgumentException("Pattern using (localized) text not implemented, use @js-joda/locale plugin!");
      };
      _proto._parsePattern = function _parsePattern(pattern) {
        var FIELD_MAP = {
          "G": ChronoField.ERA,
          "y": ChronoField.YEAR_OF_ERA,
          "u": ChronoField.YEAR,
          "Q": IsoFields.QUARTER_OF_YEAR,
          "q": IsoFields.QUARTER_OF_YEAR,
          "M": ChronoField.MONTH_OF_YEAR,
          "L": ChronoField.MONTH_OF_YEAR,
          "D": ChronoField.DAY_OF_YEAR,
          "d": ChronoField.DAY_OF_MONTH,
          "F": ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH,
          "E": ChronoField.DAY_OF_WEEK,
          "c": ChronoField.DAY_OF_WEEK,
          "e": ChronoField.DAY_OF_WEEK,
          "a": ChronoField.AMPM_OF_DAY,
          "H": ChronoField.HOUR_OF_DAY,
          "k": ChronoField.CLOCK_HOUR_OF_DAY,
          "K": ChronoField.HOUR_OF_AMPM,
          "h": ChronoField.CLOCK_HOUR_OF_AMPM,
          "m": ChronoField.MINUTE_OF_HOUR,
          "s": ChronoField.SECOND_OF_MINUTE,
          "S": ChronoField.NANO_OF_SECOND,
          "A": ChronoField.MILLI_OF_DAY,
          "n": ChronoField.NANO_OF_SECOND,
          "N": ChronoField.NANO_OF_DAY
        };
        for (var pos = 0; pos < pattern.length; pos++) {
          var cur = pattern.charAt(pos);
          if (cur >= "A" && cur <= "Z" || cur >= "a" && cur <= "z") {
            var start = pos++;
            for (; pos < pattern.length && pattern.charAt(pos) === cur; pos++) ;
            var count = pos - start;
            if (cur === "p") {
              var pad = 0;
              if (pos < pattern.length) {
                cur = pattern.charAt(pos);
                if (cur >= "A" && cur <= "Z" || cur >= "a" && cur <= "z") {
                  pad = count;
                  start = pos++;
                  for (; pos < pattern.length && pattern.charAt(pos) === cur; pos++) ;
                  count = pos - start;
                }
              }
              if (pad === 0) {
                throw new IllegalArgumentException("Pad letter 'p' must be followed by valid pad pattern: " + pattern);
              }
              this.padNext(pad);
            }
            var field = FIELD_MAP[cur];
            if (field != null) {
              this._parseField(cur, count, field);
            } else if (cur === "z") {
              if (count > 4) {
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
              } else if (count === 4) {
                this.appendZoneText(TextStyle.FULL);
              } else {
                this.appendZoneText(TextStyle.SHORT);
              }
            } else if (cur === "V") {
              if (count !== 2) {
                throw new IllegalArgumentException("Pattern letter count must be 2: " + cur);
              }
              this.appendZoneId();
            } else if (cur === "Z") {
              if (count < 4) {
                this.appendOffset("+HHMM", "+0000");
              } else if (count === 4) {
                this.appendLocalizedOffset(TextStyle.FULL);
              } else if (count === 5) {
                this.appendOffset("+HH:MM:ss", "Z");
              } else {
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
              }
            } else if (cur === "O") {
              if (count === 1) {
                this.appendLocalizedOffset(TextStyle.SHORT);
              } else if (count === 4) {
                this.appendLocalizedOffset(TextStyle.FULL);
              } else {
                throw new IllegalArgumentException("Pattern letter count must be 1 or 4: " + cur);
              }
            } else if (cur === "X") {
              if (count > 5) {
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
              }
              this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], "Z");
            } else if (cur === "x") {
              if (count > 5) {
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
              }
              var zero = count === 1 ? "+00" : count % 2 === 0 ? "+0000" : "+00:00";
              this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], zero);
            } else if (cur === "W") {
              if (count > 1) {
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
              }
              this.appendWeekField("W", count);
            } else if (cur === "w") {
              if (count > 2) {
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
              }
              this.appendWeekField("w", count);
            } else if (cur === "Y") {
              this.appendWeekField("Y", count);
            } else {
              throw new IllegalArgumentException("Unknown pattern letter: " + cur);
            }
            pos--;
          } else if (cur === "'") {
            var _start = pos++;
            for (; pos < pattern.length; pos++) {
              if (pattern.charAt(pos) === "'") {
                if (pos + 1 < pattern.length && pattern.charAt(pos + 1) === "'") {
                  pos++;
                } else {
                  break;
                }
              }
            }
            if (pos >= pattern.length) {
              throw new IllegalArgumentException("Pattern ends with an incomplete string literal: " + pattern);
            }
            var str = pattern.substring(_start + 1, pos);
            if (str.length === 0) {
              this.appendLiteral("'");
            } else {
              this.appendLiteral(str.replace("''", "'"));
            }
          } else if (cur === "[") {
            this.optionalStart();
          } else if (cur === "]") {
            if (this._active._parent === null) {
              throw new IllegalArgumentException("Pattern invalid as it contains ] without previous [");
            }
            this.optionalEnd();
          } else if (cur === "{" || cur === "}" || cur === "#") {
            throw new IllegalArgumentException("Pattern includes reserved character: '" + cur + "'");
          } else {
            this.appendLiteral(cur);
          }
        }
      };
      _proto._parseField = function _parseField(cur, count, field) {
        switch (cur) {
          case "u":
          case "y":
            if (count === 2) {
              this.appendValueReduced(field, 2, 2, ReducedPrinterParser.BASE_DATE);
            } else if (count < 4) {
              this.appendValue(field, count, MAX_WIDTH, SignStyle.NORMAL);
            } else {
              this.appendValue(field, count, MAX_WIDTH, SignStyle.EXCEEDS_PAD);
            }
            break;
          case "M":
          case "Q":
            switch (count) {
              case 1:
                this.appendValue(field);
                break;
              case 2:
                this.appendValue(field, 2);
                break;
              case 3:
                this.appendText(field, TextStyle.SHORT);
                break;
              case 4:
                this.appendText(field, TextStyle.FULL);
                break;
              case 5:
                this.appendText(field, TextStyle.NARROW);
                break;
              default:
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          case "L":
          case "q":
            switch (count) {
              case 1:
                this.appendValue(field);
                break;
              case 2:
                this.appendValue(field, 2);
                break;
              case 3:
                this.appendText(field, TextStyle.SHORT_STANDALONE);
                break;
              case 4:
                this.appendText(field, TextStyle.FULL_STANDALONE);
                break;
              case 5:
                this.appendText(field, TextStyle.NARROW_STANDALONE);
                break;
              default:
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          case "e":
            switch (count) {
              case 1:
              case 2:
                this.appendWeekField("e", count);
                break;
              case 3:
                this.appendText(field, TextStyle.SHORT);
                break;
              case 4:
                this.appendText(field, TextStyle.FULL);
                break;
              case 5:
                this.appendText(field, TextStyle.NARROW);
                break;
              default:
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          case "c":
            switch (count) {
              case 1:
                this.appendWeekField("c", count);
                break;
              case 2:
                throw new IllegalArgumentException("Invalid number of pattern letters: " + cur);
              case 3:
                this.appendText(field, TextStyle.SHORT_STANDALONE);
                break;
              case 4:
                this.appendText(field, TextStyle.FULL_STANDALONE);
                break;
              case 5:
                this.appendText(field, TextStyle.NARROW_STANDALONE);
                break;
              default:
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          case "a":
            if (count === 1) {
              this.appendText(field, TextStyle.SHORT);
            } else {
              throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          case "E":
          case "G":
            switch (count) {
              case 1:
              case 2:
              case 3:
                this.appendText(field, TextStyle.SHORT);
                break;
              case 4:
                this.appendText(field, TextStyle.FULL);
                break;
              case 5:
                this.appendText(field, TextStyle.NARROW);
                break;
              default:
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          case "S":
            this.appendFraction(ChronoField.NANO_OF_SECOND, count, count, false);
            break;
          case "F":
            if (count === 1) {
              this.appendValue(field);
            } else {
              throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          case "d":
          case "h":
          case "H":
          case "k":
          case "K":
          case "m":
          case "s":
            if (count === 1) {
              this.appendValue(field);
            } else if (count === 2) {
              this.appendValue(field, count);
            } else {
              throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          case "D":
            if (count === 1) {
              this.appendValue(field);
            } else if (count <= 3) {
              this.appendValue(field, count);
            } else {
              throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          default:
            if (count === 1) {
              this.appendValue(field);
            } else {
              this.appendValue(field, count);
            }
            break;
        }
      };
      _proto.padNext = function padNext() {
        if (arguments.length === 1) {
          return this._padNext1.apply(this, arguments);
        } else {
          return this._padNext2.apply(this, arguments);
        }
      };
      _proto._padNext1 = function _padNext1(padWidth) {
        return this._padNext2(padWidth, " ");
      };
      _proto._padNext2 = function _padNext2(padWidth, padChar) {
        if (padWidth < 1) {
          throw new IllegalArgumentException("The pad width must be at least one but was " + padWidth);
        }
        this._active._padNextWidth = padWidth;
        this._active._padNextChar = padChar;
        this._active._valueParserIndex = -1;
        return this;
      };
      _proto.optionalStart = function optionalStart() {
        this._active._valueParserIndex = -1;
        this._active = DateTimeFormatterBuilder2._of(this._active, true);
        return this;
      };
      _proto.optionalEnd = function optionalEnd() {
        if (this._active._parent == null) {
          throw new IllegalStateException("Cannot call optionalEnd() as there was no previous call to optionalStart()");
        }
        if (this._active._printerParsers.length > 0) {
          var cpp = new CompositePrinterParser(this._active._printerParsers, this._active._optional);
          this._active = this._active._parent;
          this._appendInternal(cpp);
        } else {
          this._active = this._active._parent;
        }
        return this;
      };
      _proto._appendInternal = function _appendInternal(pp) {
        assert(pp != null);
        if (this._active._padNextWidth > 0) {
          if (pp != null) {
            pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);
          }
          this._active._padNextWidth = 0;
          this._active._padNextChar = 0;
        }
        this._active._printerParsers.push(pp);
        this._active._valueParserIndex = -1;
        return this._active._printerParsers.length - 1;
      };
      _proto.appendLiteral = function appendLiteral(literal) {
        assert(literal != null);
        if (literal.length > 0) {
          if (literal.length === 1) {
            this._appendInternalPrinterParser(new CharLiteralPrinterParser(literal.charAt(0)));
          } else {
            this._appendInternalPrinterParser(new StringLiteralPrinterParser(literal));
          }
        }
        return this;
      };
      _proto._appendInternalPrinterParser = function _appendInternalPrinterParser(pp) {
        assert(pp != null);
        if (this._active._padNextWidth > 0) {
          if (pp != null) {
            pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);
          }
          this._active._padNextWidth = 0;
          this._active._padNextChar = 0;
        }
        this._active._printerParsers.push(pp);
        this._active._valueParserIndex = -1;
        return this._active._printerParsers.length - 1;
      };
      _proto.append = function append(formatter) {
        requireNonNull(formatter, "formatter");
        this._appendInternal(formatter._toPrinterParser(false));
        return this;
      };
      _proto.toFormatter = function toFormatter(resolverStyle) {
        if (resolverStyle === void 0) {
          resolverStyle = ResolverStyle.SMART;
        }
        while (this._active._parent != null) {
          this.optionalEnd();
        }
        var pp = new CompositePrinterParser(this._printerParsers, false);
        return new DateTimeFormatter(pp, null, DecimalStyle.STANDARD, resolverStyle, null, null, null);
      };
      return DateTimeFormatterBuilder2;
    }();
    SECONDS_PER_10000_YEARS = 146097 * 25 * 86400;
    SECONDS_0000_TO_1970 = (146097 * 5 - (30 * 365 + 7)) * 86400;
    InstantPrinterParser = function() {
      function InstantPrinterParser2(fractionalDigits) {
        this.fractionalDigits = fractionalDigits;
      }
      var _proto2 = InstantPrinterParser2.prototype;
      _proto2.print = function print(context3, buf) {
        var inSecs = context3.getValue(ChronoField.INSTANT_SECONDS);
        var inNanos = 0;
        if (context3.temporal().isSupported(ChronoField.NANO_OF_SECOND)) {
          inNanos = context3.temporal().getLong(ChronoField.NANO_OF_SECOND);
        }
        if (inSecs == null) {
          return false;
        }
        var inSec = inSecs;
        var inNano = ChronoField.NANO_OF_SECOND.checkValidIntValue(inNanos);
        if (inSec >= -SECONDS_0000_TO_1970) {
          var zeroSecs = inSec - SECONDS_PER_10000_YEARS + SECONDS_0000_TO_1970;
          var hi = MathUtil.floorDiv(zeroSecs, SECONDS_PER_10000_YEARS) + 1;
          var lo = MathUtil.floorMod(zeroSecs, SECONDS_PER_10000_YEARS);
          var ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);
          if (hi > 0) {
            buf.append("+").append(hi);
          }
          buf.append(ldt.toString());
          if (ldt.second() === 0) {
            buf.append(":00");
          }
        } else {
          var _zeroSecs = inSec + SECONDS_0000_TO_1970;
          var _hi = MathUtil.intDiv(_zeroSecs, SECONDS_PER_10000_YEARS);
          var _lo = MathUtil.intMod(_zeroSecs, SECONDS_PER_10000_YEARS);
          var _ldt = LocalDateTime.ofEpochSecond(_lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);
          var pos = buf.length();
          buf.append(_ldt.toString());
          if (_ldt.second() === 0) {
            buf.append(":00");
          }
          if (_hi < 0) {
            if (_ldt.year() === -1e4) {
              buf.replace(pos, pos + 2, "" + (_hi - 1));
            } else if (_lo === 0) {
              buf.insert(pos, _hi);
            } else {
              buf.insert(pos + 1, Math.abs(_hi));
            }
          }
        }
        if (this.fractionalDigits === -2) {
          if (inNano !== 0) {
            buf.append(".");
            if (MathUtil.intMod(inNano, 1e6) === 0) {
              buf.append(("" + (MathUtil.intDiv(inNano, 1e6) + 1e3)).substring(1));
            } else if (MathUtil.intMod(inNano, 1e3) === 0) {
              buf.append(("" + (MathUtil.intDiv(inNano, 1e3) + 1e6)).substring(1));
            } else {
              buf.append(("" + (inNano + 1e9)).substring(1));
            }
          }
        } else if (this.fractionalDigits > 0 || this.fractionalDigits === -1 && inNano > 0) {
          buf.append(".");
          var div = 1e8;
          for (var i = 0; this.fractionalDigits === -1 && inNano > 0 || i < this.fractionalDigits; i++) {
            var digit = MathUtil.intDiv(inNano, div);
            buf.append(digit);
            inNano = inNano - digit * div;
            div = MathUtil.intDiv(div, 10);
          }
        }
        buf.append("Z");
        return true;
      };
      _proto2.parse = function parse2(context3, text, position) {
        var newContext = context3.copy();
        var minDigits = this.fractionalDigits < 0 ? 0 : this.fractionalDigits;
        var maxDigits = this.fractionalDigits < 0 ? 9 : this.fractionalDigits;
        var parser = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral("T").appendValue(ChronoField.HOUR_OF_DAY, 2).appendLiteral(":").appendValue(ChronoField.MINUTE_OF_HOUR, 2).appendLiteral(":").appendValue(ChronoField.SECOND_OF_MINUTE, 2).appendFraction(ChronoField.NANO_OF_SECOND, minDigits, maxDigits, true).appendLiteral("Z").toFormatter()._toPrinterParser(false);
        var pos = parser.parse(newContext, text, position);
        if (pos < 0) {
          return pos;
        }
        var yearParsed = newContext.getParsed(ChronoField.YEAR);
        var month = newContext.getParsed(ChronoField.MONTH_OF_YEAR);
        var day = newContext.getParsed(ChronoField.DAY_OF_MONTH);
        var hour = newContext.getParsed(ChronoField.HOUR_OF_DAY);
        var min = newContext.getParsed(ChronoField.MINUTE_OF_HOUR);
        var secVal = newContext.getParsed(ChronoField.SECOND_OF_MINUTE);
        var nanoVal = newContext.getParsed(ChronoField.NANO_OF_SECOND);
        var sec = secVal != null ? secVal : 0;
        var nano = nanoVal != null ? nanoVal : 0;
        var year = MathUtil.intMod(yearParsed, 1e4);
        var days = 0;
        if (hour === 24 && min === 0 && sec === 0 && nano === 0) {
          hour = 0;
          days = 1;
        } else if (hour === 23 && min === 59 && sec === 60) {
          context3.setParsedLeapSecond();
          sec = 59;
        }
        var instantSecs;
        try {
          var ldt = LocalDateTime.of(year, month, day, hour, min, sec, 0).plusDays(days);
          instantSecs = ldt.toEpochSecond(ZoneOffset.UTC);
          instantSecs += MathUtil.safeMultiply(MathUtil.intDiv(yearParsed, 1e4), SECONDS_PER_10000_YEARS);
        } catch (ex) {
          return ~position;
        }
        var successPos = pos;
        successPos = context3.setParsedField(ChronoField.INSTANT_SECONDS, instantSecs, position, successPos);
        return context3.setParsedField(ChronoField.NANO_OF_SECOND, nano, position, successPos);
      };
      _proto2.toString = function toString() {
        return "Instant()";
      };
      return InstantPrinterParser2;
    }();
    DefaultingParser = function() {
      function DefaultingParser2(field, value) {
        this._field = field;
        this._value = value;
      }
      var _proto3 = DefaultingParser2.prototype;
      _proto3.print = function print() {
        return true;
      };
      _proto3.parse = function parse2(context3, text, position) {
        if (context3.getParsed(this._field) == null) {
          context3.setParsedField(this._field, this._value, position, position);
        }
        return position;
      };
      return DefaultingParser2;
    }();
    StringBuilder = function() {
      function StringBuilder2() {
        this._str = "";
      }
      var _proto = StringBuilder2.prototype;
      _proto.append = function append(str) {
        this._str += str;
        return this;
      };
      _proto.appendChar = function appendChar(str) {
        this._str += str[0];
        return this;
      };
      _proto.insert = function insert(offset, str) {
        this._str = this._str.slice(0, offset) + str + this._str.slice(offset);
        return this;
      };
      _proto.replace = function replace(start, end, str) {
        this._str = this._str.slice(0, start) + str + this._str.slice(end);
        return this;
      };
      _proto.length = function length() {
        return this._str.length;
      };
      _proto.setLength = function setLength(length) {
        this._str = this._str.slice(0, length);
        return this;
      };
      _proto.toString = function toString() {
        return this._str;
      };
      return StringBuilder2;
    }();
    DateTimeFormatter = function() {
      DateTimeFormatter2.parsedExcessDays = function parsedExcessDays() {
        return DateTimeFormatter2.PARSED_EXCESS_DAYS;
      };
      DateTimeFormatter2.parsedLeapSecond = function parsedLeapSecond() {
        return DateTimeFormatter2.PARSED_LEAP_SECOND;
      };
      DateTimeFormatter2.ofPattern = function ofPattern(pattern) {
        return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter();
      };
      function DateTimeFormatter2(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone) {
        if (chrono === void 0) {
          chrono = IsoChronology.INSTANCE;
        }
        assert(printerParser != null);
        assert(decimalStyle != null);
        assert(resolverStyle != null);
        this._printerParser = printerParser;
        this._locale = locale;
        this._decimalStyle = decimalStyle;
        this._resolverStyle = resolverStyle;
        this._resolverFields = resolverFields;
        this._chrono = chrono;
        this._zone = zone;
      }
      var _proto = DateTimeFormatter2.prototype;
      _proto.locale = function locale() {
        return this._locale;
      };
      _proto.decimalStyle = function decimalStyle() {
        return this._decimalStyle;
      };
      _proto.chronology = function chronology() {
        return this._chrono;
      };
      _proto.withChronology = function withChronology(chrono) {
        if (this._chrono != null && this._chrono.equals(chrono)) {
          return this;
        }
        return new DateTimeFormatter2(this._printerParser, this._locale, this._decimalStyle, this._resolverStyle, this._resolverFields, chrono, this._zone);
      };
      _proto.withLocale = function withLocale() {
        return this;
      };
      _proto.withResolverStyle = function withResolverStyle(resolverStyle) {
        requireNonNull(resolverStyle, "resolverStyle");
        if (resolverStyle.equals(this._resolverStyle)) {
          return this;
        }
        return new DateTimeFormatter2(this._printerParser, this._locale, this._decimalStyle, resolverStyle, this._resolverFields, this._chrono, this._zone);
      };
      _proto.format = function format(temporal) {
        var buf = new StringBuilder(32);
        this._formatTo(temporal, buf);
        return buf.toString();
      };
      _proto._formatTo = function _formatTo(temporal, appendable) {
        requireNonNull(temporal, "temporal");
        requireNonNull(appendable, "appendable");
        var context3 = new DateTimePrintContext(temporal, this);
        this._printerParser.print(context3, appendable);
      };
      _proto.parse = function parse2(text, type) {
        if (arguments.length === 1) {
          return this.parse1(text);
        } else {
          return this.parse2(text, type);
        }
      };
      _proto.parse1 = function parse1(text) {
        requireNonNull(text, "text");
        try {
          return this._parseToBuilder(text, null).resolve(this._resolverStyle, this._resolverFields);
        } catch (ex) {
          if (ex instanceof DateTimeParseException) {
            throw ex;
          } else {
            throw this._createError(text, ex);
          }
        }
      };
      _proto.parse2 = function parse2(text, type) {
        requireNonNull(text, "text");
        requireNonNull(type, "type");
        try {
          var builder = this._parseToBuilder(text, null).resolve(this._resolverStyle, this._resolverFields);
          return builder.build(type);
        } catch (ex) {
          if (ex instanceof DateTimeParseException) {
            throw ex;
          } else {
            throw this._createError(text, ex);
          }
        }
      };
      _proto._createError = function _createError(text, ex) {
        var abbr = "";
        if (text.length > 64) {
          abbr = text.substring(0, 64) + "...";
        } else {
          abbr = text;
        }
        return new DateTimeParseException("Text '" + abbr + "' could not be parsed: " + ex.message, text, 0, ex);
      };
      _proto._parseToBuilder = function _parseToBuilder(text, position) {
        var pos = position != null ? position : new ParsePosition(0);
        var result = this._parseUnresolved0(text, pos);
        if (result == null || pos.getErrorIndex() >= 0 || position == null && pos.getIndex() < text.length) {
          var abbr = "";
          if (text.length > 64) {
            abbr = text.substr(0, 64).toString() + "...";
          } else {
            abbr = text;
          }
          if (pos.getErrorIndex() >= 0) {
            throw new DateTimeParseException("Text '" + abbr + "' could not be parsed at index " + pos.getErrorIndex(), text, pos.getErrorIndex());
          } else {
            throw new DateTimeParseException("Text '" + abbr + "' could not be parsed, unparsed text found at index " + pos.getIndex(), text, pos.getIndex());
          }
        }
        return result.toBuilder();
      };
      _proto.parseUnresolved = function parseUnresolved(text, position) {
        return this._parseUnresolved0(text, position);
      };
      _proto._parseUnresolved0 = function _parseUnresolved0(text, position) {
        assert(text != null, "text", NullPointerException);
        assert(position != null, "position", NullPointerException);
        var context3 = new DateTimeParseContext(this);
        var pos = position.getIndex();
        pos = this._printerParser.parse(context3, text, pos);
        if (pos < 0) {
          position.setErrorIndex(~pos);
          return null;
        }
        position.setIndex(pos);
        return context3.toParsed();
      };
      _proto._toPrinterParser = function _toPrinterParser(optional) {
        return this._printerParser.withOptional(optional);
      };
      _proto.toString = function toString() {
        var pattern = this._printerParser.toString();
        return pattern.indexOf("[") === 0 ? pattern : pattern.substring(1, pattern.length - 1);
      };
      return DateTimeFormatter2;
    }();
    MonthDay = function(_TemporalAccessor) {
      _inheritsLoose(MonthDay2, _TemporalAccessor);
      MonthDay2.now = function now(zoneIdOrClock) {
        if (arguments.length === 0) {
          return MonthDay2.now0();
        } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {
          return MonthDay2.nowZoneId(zoneIdOrClock);
        } else {
          return MonthDay2.nowClock(zoneIdOrClock);
        }
      };
      MonthDay2.now0 = function now0() {
        return this.nowClock(Clock.systemDefaultZone());
      };
      MonthDay2.nowZoneId = function nowZoneId(zone) {
        requireNonNull(zone, "zone");
        return this.nowClock(Clock.system(zone));
      };
      MonthDay2.nowClock = function nowClock(clock) {
        requireNonNull(clock, "clock");
        var now = LocalDate.now(clock);
        return MonthDay2.of(now.month(), now.dayOfMonth());
      };
      MonthDay2.of = function of(monthOrNumber, number) {
        if (arguments.length === 2 && monthOrNumber instanceof Month) {
          return MonthDay2.ofMonthNumber(monthOrNumber, number);
        } else {
          return MonthDay2.ofNumberNumber(monthOrNumber, number);
        }
      };
      MonthDay2.ofMonthNumber = function ofMonthNumber(month, dayOfMonth) {
        requireNonNull(month, "month");
        ChronoField.DAY_OF_MONTH.checkValidValue(dayOfMonth);
        if (dayOfMonth > month.maxLength()) {
          throw new DateTimeException("Illegal value for DayOfMonth field, value " + dayOfMonth + " is not valid for month " + month.toString());
        }
        return new MonthDay2(month.value(), dayOfMonth);
      };
      MonthDay2.ofNumberNumber = function ofNumberNumber(month, dayOfMonth) {
        requireNonNull(month, "month");
        requireNonNull(dayOfMonth, "dayOfMonth");
        return MonthDay2.of(Month.of(month), dayOfMonth);
      };
      MonthDay2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        requireInstance(temporal, TemporalAccessor, "temporal");
        if (temporal instanceof MonthDay2) {
          return temporal;
        }
        try {
          return MonthDay2.of(temporal.get(ChronoField.MONTH_OF_YEAR), temporal.get(ChronoField.DAY_OF_MONTH));
        } catch (ex) {
          throw new DateTimeException("Unable to obtain MonthDay from TemporalAccessor: " + temporal + ", type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ""));
        }
      };
      MonthDay2.parse = function parse2(text, formatter) {
        if (arguments.length === 1) {
          return MonthDay2.parseString(text);
        } else {
          return MonthDay2.parseStringFormatter(text, formatter);
        }
      };
      MonthDay2.parseString = function parseString(text) {
        return MonthDay2.parseStringFormatter(text, PARSER$2);
      };
      MonthDay2.parseStringFormatter = function parseStringFormatter(text, formatter) {
        requireNonNull(text, "text");
        requireNonNull(formatter, "formatter");
        requireInstance(formatter, DateTimeFormatter, "formatter");
        return formatter.parse(text, MonthDay2.FROM);
      };
      function MonthDay2(month, dayOfMonth) {
        var _this;
        _this = _TemporalAccessor.call(this) || this;
        _this._month = MathUtil.safeToInt(month);
        _this._day = MathUtil.safeToInt(dayOfMonth);
        return _this;
      }
      var _proto = MonthDay2.prototype;
      _proto.monthValue = function monthValue() {
        return this._month;
      };
      _proto.month = function month() {
        return Month.of(this._month);
      };
      _proto.dayOfMonth = function dayOfMonth() {
        return this._day;
      };
      _proto.isSupported = function isSupported(field) {
        if (field instanceof ChronoField) {
          return field === ChronoField.MONTH_OF_YEAR || field === ChronoField.DAY_OF_MONTH;
        }
        return field != null && field.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        if (field === ChronoField.MONTH_OF_YEAR) {
          return field.range();
        } else if (field === ChronoField.DAY_OF_MONTH) {
          return ValueRange.of(1, this.month().minLength(), this.month().maxLength());
        }
        return _TemporalAccessor.prototype.range.call(this, field);
      };
      _proto.get = function get(field) {
        return this.range(field).checkValidIntValue(this.getLong(field), field);
      };
      _proto.getLong = function getLong(field) {
        requireNonNull(field, "field");
        if (field instanceof ChronoField) {
          switch (field) {
            case ChronoField.DAY_OF_MONTH:
              return this._day;
            case ChronoField.MONTH_OF_YEAR:
              return this._month;
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.getFrom(this);
      };
      _proto.isValidYear = function isValidYear(year) {
        return (this._day === 29 && this._month === 2 && Year.isLeap(year) === false) === false;
      };
      _proto.withMonth = function withMonth(month) {
        return this.with(Month.of(month));
      };
      _proto.with = function _with(month) {
        requireNonNull(month, "month");
        if (month.value() === this._month) {
          return this;
        }
        var day = Math.min(this._day, month.maxLength());
        return new MonthDay2(month.value(), day);
      };
      _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
        if (dayOfMonth === this._day) {
          return this;
        }
        return MonthDay2.of(this._month, dayOfMonth);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        requireInstance(_query, TemporalQuery, "query");
        if (_query === TemporalQueries.chronology()) {
          return IsoChronology.INSTANCE;
        }
        return _TemporalAccessor.prototype.query.call(this, _query);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        requireNonNull(temporal, "temporal");
        temporal = temporal.with(ChronoField.MONTH_OF_YEAR, this._month);
        return temporal.with(ChronoField.DAY_OF_MONTH, Math.min(temporal.range(ChronoField.DAY_OF_MONTH).maximum(), this._day));
      };
      _proto.atYear = function atYear(year) {
        return LocalDate.of(year, this._month, this.isValidYear(year) ? this._day : 28);
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, MonthDay2, "other");
        var cmp = this._month - other.monthValue();
        if (cmp === 0) {
          cmp = this._day - other.dayOfMonth();
        }
        return cmp;
      };
      _proto.isAfter = function isAfter(other) {
        requireNonNull(other, "other");
        requireInstance(other, MonthDay2, "other");
        return this.compareTo(other) > 0;
      };
      _proto.isBefore = function isBefore(other) {
        requireNonNull(other, "other");
        requireInstance(other, MonthDay2, "other");
        return this.compareTo(other) < 0;
      };
      _proto.equals = function equals(obj) {
        if (this === obj) {
          return true;
        }
        if (obj instanceof MonthDay2) {
          var other = obj;
          return this.monthValue() === other.monthValue() && this.dayOfMonth() === other.dayOfMonth();
        }
        return false;
      };
      _proto.toString = function toString() {
        return "--" + (this._month < 10 ? "0" : "") + this._month + (this._day < 10 ? "-0" : "-") + this._day;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        requireInstance(formatter, DateTimeFormatter, "formatter");
        return formatter.format(this);
      };
      return MonthDay2;
    }(TemporalAccessor);
    YearMonth = function(_Temporal) {
      _inheritsLoose(YearMonth2, _Temporal);
      YearMonth2.now = function now(zoneIdOrClock) {
        if (arguments.length === 0) {
          return YearMonth2.now0();
        } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {
          return YearMonth2.nowZoneId(zoneIdOrClock);
        } else {
          return YearMonth2.nowClock(zoneIdOrClock);
        }
      };
      YearMonth2.now0 = function now0() {
        return YearMonth2.nowClock(Clock.systemDefaultZone());
      };
      YearMonth2.nowZoneId = function nowZoneId(zone) {
        return YearMonth2.nowClock(Clock.system(zone));
      };
      YearMonth2.nowClock = function nowClock(clock) {
        var now = LocalDate.now(clock);
        return YearMonth2.of(now.year(), now.month());
      };
      YearMonth2.of = function of(year, monthOrNumber) {
        if (arguments.length === 2 && monthOrNumber instanceof Month) {
          return YearMonth2.ofNumberMonth(year, monthOrNumber);
        } else {
          return YearMonth2.ofNumberNumber(year, monthOrNumber);
        }
      };
      YearMonth2.ofNumberMonth = function ofNumberMonth(year, month) {
        requireNonNull(month, "month");
        requireInstance(month, Month, "month");
        return YearMonth2.ofNumberNumber(year, month.value());
      };
      YearMonth2.ofNumberNumber = function ofNumberNumber(year, month) {
        requireNonNull(year, "year");
        requireNonNull(month, "month");
        ChronoField.YEAR.checkValidValue(year);
        ChronoField.MONTH_OF_YEAR.checkValidValue(month);
        return new YearMonth2(year, month);
      };
      YearMonth2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        if (temporal instanceof YearMonth2) {
          return temporal;
        }
        try {
          return YearMonth2.of(temporal.get(ChronoField.YEAR), temporal.get(ChronoField.MONTH_OF_YEAR));
        } catch (ex) {
          throw new DateTimeException("Unable to obtain YearMonth from TemporalAccessor: " + temporal + ", type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ""));
        }
      };
      YearMonth2.parse = function parse2(text, formatter) {
        if (arguments.length === 1) {
          return YearMonth2.parseString(text);
        } else {
          return YearMonth2.parseStringFormatter(text, formatter);
        }
      };
      YearMonth2.parseString = function parseString(text) {
        return YearMonth2.parseStringFormatter(text, PARSER$1);
      };
      YearMonth2.parseStringFormatter = function parseStringFormatter(text, formatter) {
        requireNonNull(formatter, "formatter");
        return formatter.parse(text, YearMonth2.FROM);
      };
      function YearMonth2(year, month) {
        var _this;
        _this = _Temporal.call(this) || this;
        _this._year = MathUtil.safeToInt(year);
        _this._month = MathUtil.safeToInt(month);
        return _this;
      }
      var _proto = YearMonth2.prototype;
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (arguments.length === 1 && fieldOrUnit instanceof TemporalField) {
          return this.isSupportedField(fieldOrUnit);
        } else {
          return this.isSupportedUnit(fieldOrUnit);
        }
      };
      _proto.isSupportedField = function isSupportedField(field) {
        if (field instanceof ChronoField) {
          return field === ChronoField.YEAR || field === ChronoField.MONTH_OF_YEAR || field === ChronoField.PROLEPTIC_MONTH || field === ChronoField.YEAR_OF_ERA || field === ChronoField.ERA;
        }
        return field != null && field.isSupportedBy(this);
      };
      _proto.isSupportedUnit = function isSupportedUnit(unit) {
        if (unit instanceof ChronoUnit) {
          return unit === ChronoUnit.MONTHS || unit === ChronoUnit.YEARS || unit === ChronoUnit.DECADES || unit === ChronoUnit.CENTURIES || unit === ChronoUnit.MILLENNIA || unit === ChronoUnit.ERAS;
        }
        return unit != null && unit.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        if (field === ChronoField.YEAR_OF_ERA) {
          return this.year() <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE);
        }
        return _Temporal.prototype.range.call(this, field);
      };
      _proto.get = function get(field) {
        requireNonNull(field, "field");
        requireInstance(field, TemporalField, "field");
        return this.range(field).checkValidIntValue(this.getLong(field), field);
      };
      _proto.getLong = function getLong(field) {
        requireNonNull(field, "field");
        requireInstance(field, TemporalField, "field");
        if (field instanceof ChronoField) {
          switch (field) {
            case ChronoField.MONTH_OF_YEAR:
              return this._month;
            case ChronoField.PROLEPTIC_MONTH:
              return this._getProlepticMonth();
            case ChronoField.YEAR_OF_ERA:
              return this._year < 1 ? 1 - this._year : this._year;
            case ChronoField.YEAR:
              return this._year;
            case ChronoField.ERA:
              return this._year < 1 ? 0 : 1;
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.getFrom(this);
      };
      _proto._getProlepticMonth = function _getProlepticMonth() {
        return MathUtil.safeAdd(MathUtil.safeMultiply(this._year, 12), this._month - 1);
      };
      _proto.year = function year() {
        return this._year;
      };
      _proto.monthValue = function monthValue() {
        return this._month;
      };
      _proto.month = function month() {
        return Month.of(this._month);
      };
      _proto.isLeapYear = function isLeapYear() {
        return IsoChronology.isLeapYear(this._year);
      };
      _proto.isValidDay = function isValidDay(dayOfMonth) {
        return dayOfMonth >= 1 && dayOfMonth <= this.lengthOfMonth();
      };
      _proto.lengthOfMonth = function lengthOfMonth() {
        return this.month().length(this.isLeapYear());
      };
      _proto.lengthOfYear = function lengthOfYear() {
        return this.isLeapYear() ? 366 : 365;
      };
      _proto.with = function _with(adjusterOrField, value) {
        if (arguments.length === 1) {
          return this._withAdjuster(adjusterOrField);
        } else {
          return this._withField(adjusterOrField, value);
        }
      };
      _proto._withField = function _withField(field, newValue) {
        requireNonNull(field, "field");
        requireInstance(field, TemporalField, "field");
        if (field instanceof ChronoField) {
          var f = field;
          f.checkValidValue(newValue);
          switch (f) {
            case ChronoField.MONTH_OF_YEAR:
              return this.withMonth(newValue);
            case ChronoField.PROLEPTIC_MONTH:
              return this.plusMonths(newValue - this.getLong(ChronoField.PROLEPTIC_MONTH));
            case ChronoField.YEAR_OF_ERA:
              return this.withYear(this._year < 1 ? 1 - newValue : newValue);
            case ChronoField.YEAR:
              return this.withYear(newValue);
            case ChronoField.ERA:
              return this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year);
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.adjustInto(this, newValue);
      };
      _proto.withYear = function withYear(year) {
        ChronoField.YEAR.checkValidValue(year);
        return new YearMonth2(year, this._month);
      };
      _proto.withMonth = function withMonth(month) {
        ChronoField.MONTH_OF_YEAR.checkValidValue(month);
        return new YearMonth2(this._year, month);
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        requireNonNull(unit, "unit");
        requireInstance(unit, TemporalUnit, "unit");
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.MONTHS:
              return this.plusMonths(amountToAdd);
            case ChronoUnit.YEARS:
              return this.plusYears(amountToAdd);
            case ChronoUnit.DECADES:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));
            case ChronoUnit.CENTURIES:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));
            case ChronoUnit.MILLENNIA:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1e3));
            case ChronoUnit.ERAS:
              return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusYears = function plusYears(yearsToAdd) {
        if (yearsToAdd === 0) {
          return this;
        }
        var newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);
        return this.withYear(newYear);
      };
      _proto.plusMonths = function plusMonths(monthsToAdd) {
        if (monthsToAdd === 0) {
          return this;
        }
        var monthCount = this._year * 12 + (this._month - 1);
        var calcMonths = monthCount + monthsToAdd;
        var newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.floorDiv(calcMonths, 12));
        var newMonth = MathUtil.floorMod(calcMonths, 12) + 1;
        return new YearMonth2(newYear, newMonth);
      };
      _proto.minusYears = function minusYears(yearsToSubtract) {
        return yearsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusYears(MathUtil.MIN_SAFE_INTEGER).plusYears(1) : this.plusYears(-yearsToSubtract);
      };
      _proto.minusMonths = function minusMonths(monthsToSubtract) {
        return monthsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusMonths(Math.MAX_SAFE_INTEGER).plusMonths(1) : this.plusMonths(-monthsToSubtract);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        requireInstance(_query, TemporalQuery, "query");
        if (_query === TemporalQueries.chronology()) {
          return IsoChronology.INSTANCE;
        } else if (_query === TemporalQueries.precision()) {
          return ChronoUnit.MONTHS;
        } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
          return null;
        }
        return _Temporal.prototype.query.call(this, _query);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        requireNonNull(temporal, "temporal");
        requireInstance(temporal, Temporal, "temporal");
        return temporal.with(ChronoField.PROLEPTIC_MONTH, this._getProlepticMonth());
      };
      _proto.until = function until(endExclusive, unit) {
        requireNonNull(endExclusive, "endExclusive");
        requireNonNull(unit, "unit");
        requireInstance(endExclusive, Temporal, "endExclusive");
        requireInstance(unit, TemporalUnit, "unit");
        var end = YearMonth2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          var monthsUntil = end._getProlepticMonth() - this._getProlepticMonth();
          switch (unit) {
            case ChronoUnit.MONTHS:
              return monthsUntil;
            case ChronoUnit.YEARS:
              return MathUtil.intDiv(monthsUntil, 12);
            case ChronoUnit.DECADES:
              return MathUtil.intDiv(monthsUntil, 120);
            case ChronoUnit.CENTURIES:
              return MathUtil.intDiv(monthsUntil, 1200);
            case ChronoUnit.MILLENNIA:
              return MathUtil.intDiv(monthsUntil, 12e3);
            case ChronoUnit.ERAS:
              return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.between(this, end);
      };
      _proto.atDay = function atDay(dayOfMonth) {
        requireNonNull(dayOfMonth, "dayOfMonth");
        return LocalDate.of(this._year, this._month, dayOfMonth);
      };
      _proto.atEndOfMonth = function atEndOfMonth() {
        return LocalDate.of(this._year, this._month, this.lengthOfMonth());
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, YearMonth2, "other");
        var cmp = this._year - other.year();
        if (cmp === 0) {
          cmp = this._month - other.monthValue();
        }
        return cmp;
      };
      _proto.isAfter = function isAfter(other) {
        return this.compareTo(other) > 0;
      };
      _proto.isBefore = function isBefore(other) {
        return this.compareTo(other) < 0;
      };
      _proto.equals = function equals(obj) {
        if (this === obj) {
          return true;
        }
        if (obj instanceof YearMonth2) {
          var other = obj;
          return this.year() === other.year() && this.monthValue() === other.monthValue();
        }
        return false;
      };
      _proto.toString = function toString() {
        return PARSER$1.format(this);
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        return formatter.format(this);
      };
      return YearMonth2;
    }(Temporal);
    Year = function(_Temporal) {
      _inheritsLoose(Year2, _Temporal);
      function Year2(value) {
        var _this;
        _this = _Temporal.call(this) || this;
        _this._year = MathUtil.safeToInt(value);
        return _this;
      }
      var _proto = Year2.prototype;
      _proto.value = function value() {
        return this._year;
      };
      Year2.now = function now(zoneIdOrClock) {
        if (zoneIdOrClock === void 0) {
          zoneIdOrClock = void 0;
        }
        if (zoneIdOrClock === void 0) {
          return Year2.now0();
        } else if (zoneIdOrClock instanceof ZoneId) {
          return Year2.nowZoneId(zoneIdOrClock);
        } else {
          return Year2.nowClock(zoneIdOrClock);
        }
      };
      Year2.now0 = function now0() {
        return Year2.nowClock(Clock.systemDefaultZone());
      };
      Year2.nowZoneId = function nowZoneId(zone) {
        requireNonNull(zone, "zone");
        requireInstance(zone, ZoneId, "zone");
        return Year2.nowClock(Clock.system(zone));
      };
      Year2.nowClock = function nowClock(clock) {
        requireNonNull(clock, "clock");
        requireInstance(clock, Clock, "clock");
        var now = LocalDate.now(clock);
        return Year2.of(now.year());
      };
      Year2.of = function of(isoYear) {
        requireNonNull(isoYear, "isoYear");
        ChronoField.YEAR.checkValidValue(isoYear);
        return new Year2(isoYear);
      };
      Year2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        requireInstance(temporal, TemporalAccessor, "temporal");
        if (temporal instanceof Year2) {
          return temporal;
        }
        try {
          return Year2.of(temporal.get(ChronoField.YEAR));
        } catch (ex) {
          throw new DateTimeException("Unable to obtain Year from TemporalAccessor: " + temporal + ", type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ""));
        }
      };
      Year2.parse = function parse2(text, formatter) {
        if (arguments.length <= 1) {
          return Year2.parseText(text);
        } else {
          return Year2.parseTextFormatter(text, formatter);
        }
      };
      Year2.parseText = function parseText(text) {
        requireNonNull(text, "text");
        return Year2.parse(text, PARSER);
      };
      Year2.parseTextFormatter = function parseTextFormatter(text, formatter) {
        if (formatter === void 0) {
          formatter = PARSER;
        }
        requireNonNull(text, "text");
        requireNonNull(formatter, "formatter");
        requireInstance(formatter, DateTimeFormatter, "formatter");
        return formatter.parse(text, Year2.FROM);
      };
      Year2.isLeap = function isLeap(year) {
        return MathUtil.intMod(year, 4) === 0 && (MathUtil.intMod(year, 100) !== 0 || MathUtil.intMod(year, 400) === 0);
      };
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (arguments.length === 1 && fieldOrUnit instanceof TemporalField) {
          return this.isSupportedField(fieldOrUnit);
        } else {
          return this.isSupportedUnit(fieldOrUnit);
        }
      };
      _proto.isSupportedField = function isSupportedField(field) {
        if (field instanceof ChronoField) {
          return field === ChronoField.YEAR || field === ChronoField.YEAR_OF_ERA || field === ChronoField.ERA;
        }
        return field != null && field.isSupportedBy(this);
      };
      _proto.isSupportedUnit = function isSupportedUnit(unit) {
        if (unit instanceof ChronoUnit) {
          return unit === ChronoUnit.YEARS || unit === ChronoUnit.DECADES || unit === ChronoUnit.CENTURIES || unit === ChronoUnit.MILLENNIA || unit === ChronoUnit.ERAS;
        }
        return unit != null && unit.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        if (this.isSupported(field)) {
          return field.range();
        } else if (field instanceof ChronoField) {
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return _Temporal.prototype.range.call(this, field);
      };
      _proto.get = function get(field) {
        return this.range(field).checkValidIntValue(this.getLong(field), field);
      };
      _proto.getLong = function getLong(field) {
        requireNonNull(field, "field");
        if (field instanceof ChronoField) {
          switch (field) {
            case ChronoField.YEAR_OF_ERA:
              return this._year < 1 ? 1 - this._year : this._year;
            case ChronoField.YEAR:
              return this._year;
            case ChronoField.ERA:
              return this._year < 1 ? 0 : 1;
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.getFrom(this);
      };
      _proto.isLeap = function isLeap() {
        return Year2.isLeap(this._year);
      };
      _proto._withField = function _withField(field, newValue) {
        requireNonNull(field, "field");
        requireInstance(field, TemporalField, "field");
        if (field instanceof ChronoField) {
          field.checkValidValue(newValue);
          switch (field) {
            case ChronoField.YEAR_OF_ERA:
              return Year2.of(this._year < 1 ? 1 - newValue : newValue);
            case ChronoField.YEAR:
              return Year2.of(newValue);
            case ChronoField.ERA:
              return this.getLong(ChronoField.ERA) === newValue ? this : Year2.of(1 - this._year);
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.adjustInto(this, newValue);
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        requireNonNull(amountToAdd, "amountToAdd");
        requireNonNull(unit, "unit");
        requireInstance(unit, TemporalUnit, "unit");
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.YEARS:
              return this.plusYears(amountToAdd);
            case ChronoUnit.DECADES:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));
            case ChronoUnit.CENTURIES:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));
            case ChronoUnit.MILLENNIA:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1e3));
            case ChronoUnit.ERAS:
              return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusYears = function plusYears(yearsToAdd) {
        if (yearsToAdd === 0) {
          return this;
        }
        return Year2.of(ChronoField.YEAR.checkValidIntValue(MathUtil.safeAdd(this._year, yearsToAdd)));
      };
      _proto.minusYears = function minusYears(yearsToSubtract) {
        return yearsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusYears(MathUtil.MAX_SAFE_INTEGER).plusYears(1) : this.plusYears(-yearsToSubtract);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        requireNonNull(temporal, "temporal");
        return temporal.with(ChronoField.YEAR, this._year);
      };
      _proto.isValidMonthDay = function isValidMonthDay(monthDay) {
        return monthDay != null && monthDay.isValidYear(this._year);
      };
      _proto.length = function length() {
        return this.isLeap() ? 366 : 365;
      };
      _proto.atDay = function atDay(dayOfYear) {
        return LocalDate.ofYearDay(this._year, dayOfYear);
      };
      _proto.atMonth = function atMonth(monthOrNumber) {
        if (arguments.length === 1 && monthOrNumber instanceof Month) {
          return this.atMonthMonth(monthOrNumber);
        } else {
          return this.atMonthNumber(monthOrNumber);
        }
      };
      _proto.atMonthMonth = function atMonthMonth(month) {
        requireNonNull(month, "month");
        requireInstance(month, Month, "month");
        return YearMonth.of(this._year, month);
      };
      _proto.atMonthNumber = function atMonthNumber(month) {
        requireNonNull(month, "month");
        return YearMonth.of(this._year, month);
      };
      _proto.atMonthDay = function atMonthDay(monthDay) {
        requireNonNull(monthDay, "monthDay");
        requireInstance(monthDay, MonthDay, "monthDay");
        return monthDay.atYear(this._year);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query()");
        requireInstance(_query, TemporalQuery, "query()");
        if (_query === TemporalQueries.chronology()) {
          return IsoChronology.INSTANCE;
        } else if (_query === TemporalQueries.precision()) {
          return ChronoUnit.YEARS;
        } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
          return null;
        }
        return _Temporal.prototype.query.call(this, _query);
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, Year2, "other");
        return this._year - other._year;
      };
      _proto.isAfter = function isAfter(other) {
        requireNonNull(other, "other");
        requireInstance(other, Year2, "other");
        return this._year > other._year;
      };
      _proto.isBefore = function isBefore(other) {
        requireNonNull(other, "other");
        requireInstance(other, Year2, "other");
        return this._year < other._year;
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        requireInstance(formatter, DateTimeFormatter, "formatter");
        return formatter.format(this);
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof Year2) {
          return this.value() === other.value();
        }
        return false;
      };
      _proto.toString = function toString() {
        return "" + this._year;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.until = function until(endExclusive, unit) {
        var end = Year2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          var yearsUntil = end.value() - this.value();
          switch (unit) {
            case ChronoUnit.YEARS:
              return yearsUntil;
            case ChronoUnit.DECADES:
              return MathUtil.intDiv(yearsUntil, 10);
            case ChronoUnit.CENTURIES:
              return MathUtil.intDiv(yearsUntil, 100);
            case ChronoUnit.MILLENNIA:
              return MathUtil.intDiv(yearsUntil, 1e3);
            case ChronoUnit.ERAS:
              return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.between(this, end);
      };
      return Year2;
    }(Temporal);
    TemporalAdjuster = function() {
      function TemporalAdjuster2() {
      }
      var _proto = TemporalAdjuster2.prototype;
      _proto.adjustInto = function adjustInto(temporal) {
        abstractMethodFail("adjustInto");
      };
      return TemporalAdjuster2;
    }();
    TemporalAdjusters = function() {
      function TemporalAdjusters2() {
      }
      TemporalAdjusters2.firstDayOfMonth = function firstDayOfMonth() {
        return Impl.FIRST_DAY_OF_MONTH;
      };
      TemporalAdjusters2.lastDayOfMonth = function lastDayOfMonth() {
        return Impl.LAST_DAY_OF_MONTH;
      };
      TemporalAdjusters2.firstDayOfNextMonth = function firstDayOfNextMonth() {
        return Impl.FIRST_DAY_OF_NEXT_MONTH;
      };
      TemporalAdjusters2.firstDayOfYear = function firstDayOfYear() {
        return Impl.FIRST_DAY_OF_YEAR;
      };
      TemporalAdjusters2.lastDayOfYear = function lastDayOfYear() {
        return Impl.LAST_DAY_OF_YEAR;
      };
      TemporalAdjusters2.firstDayOfNextYear = function firstDayOfNextYear() {
        return Impl.FIRST_DAY_OF_NEXT_YEAR;
      };
      TemporalAdjusters2.firstInMonth = function firstInMonth(dayOfWeek) {
        requireNonNull(dayOfWeek, "dayOfWeek");
        return new DayOfWeekInMonth(1, dayOfWeek);
      };
      TemporalAdjusters2.lastInMonth = function lastInMonth(dayOfWeek) {
        requireNonNull(dayOfWeek, "dayOfWeek");
        return new DayOfWeekInMonth(-1, dayOfWeek);
      };
      TemporalAdjusters2.dayOfWeekInMonth = function dayOfWeekInMonth(ordinal, dayOfWeek) {
        requireNonNull(dayOfWeek, "dayOfWeek");
        return new DayOfWeekInMonth(ordinal, dayOfWeek);
      };
      TemporalAdjusters2.next = function next(dayOfWeek) {
        return new RelativeDayOfWeek(2, dayOfWeek);
      };
      TemporalAdjusters2.nextOrSame = function nextOrSame(dayOfWeek) {
        return new RelativeDayOfWeek(0, dayOfWeek);
      };
      TemporalAdjusters2.previous = function previous(dayOfWeek) {
        return new RelativeDayOfWeek(3, dayOfWeek);
      };
      TemporalAdjusters2.previousOrSame = function previousOrSame(dayOfWeek) {
        return new RelativeDayOfWeek(1, dayOfWeek);
      };
      return TemporalAdjusters2;
    }();
    Impl = function(_TemporalAdjuster) {
      _inheritsLoose(Impl2, _TemporalAdjuster);
      function Impl2(ordinal) {
        var _this;
        _this = _TemporalAdjuster.call(this) || this;
        _this._ordinal = ordinal;
        return _this;
      }
      var _proto = Impl2.prototype;
      _proto.adjustInto = function adjustInto(temporal) {
        switch (this._ordinal) {
          case 0:
            return temporal.with(ChronoField.DAY_OF_MONTH, 1);
          case 1:
            return temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());
          case 2:
            return temporal.with(ChronoField.DAY_OF_MONTH, 1).plus(1, ChronoUnit.MONTHS);
          case 3:
            return temporal.with(ChronoField.DAY_OF_YEAR, 1);
          case 4:
            return temporal.with(ChronoField.DAY_OF_YEAR, temporal.range(ChronoField.DAY_OF_YEAR).maximum());
          case 5:
            return temporal.with(ChronoField.DAY_OF_YEAR, 1).plus(1, ChronoUnit.YEARS);
        }
        throw new IllegalStateException("Unreachable");
      };
      return Impl2;
    }(TemporalAdjuster);
    Impl.FIRST_DAY_OF_MONTH = new Impl(0);
    Impl.LAST_DAY_OF_MONTH = new Impl(1);
    Impl.FIRST_DAY_OF_NEXT_MONTH = new Impl(2);
    Impl.FIRST_DAY_OF_YEAR = new Impl(3);
    Impl.LAST_DAY_OF_YEAR = new Impl(4);
    Impl.FIRST_DAY_OF_NEXT_YEAR = new Impl(5);
    DayOfWeekInMonth = function(_TemporalAdjuster2) {
      _inheritsLoose(DayOfWeekInMonth2, _TemporalAdjuster2);
      function DayOfWeekInMonth2(ordinal, dow) {
        var _this2;
        _this2 = _TemporalAdjuster2.call(this) || this;
        _this2._ordinal = ordinal;
        _this2._dowValue = dow.value();
        return _this2;
      }
      var _proto2 = DayOfWeekInMonth2.prototype;
      _proto2.adjustInto = function adjustInto(temporal) {
        if (this._ordinal >= 0) {
          var temp = temporal.with(ChronoField.DAY_OF_MONTH, 1);
          var curDow = temp.get(ChronoField.DAY_OF_WEEK);
          var dowDiff = MathUtil.intMod(this._dowValue - curDow + 7, 7);
          dowDiff += (this._ordinal - 1) * 7;
          return temp.plus(dowDiff, ChronoUnit.DAYS);
        } else {
          var _temp = temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());
          var _curDow = _temp.get(ChronoField.DAY_OF_WEEK);
          var daysDiff = this._dowValue - _curDow;
          daysDiff = daysDiff === 0 ? 0 : daysDiff > 0 ? daysDiff - 7 : daysDiff;
          daysDiff -= (-this._ordinal - 1) * 7;
          return _temp.plus(daysDiff, ChronoUnit.DAYS);
        }
      };
      return DayOfWeekInMonth2;
    }(TemporalAdjuster);
    RelativeDayOfWeek = function(_TemporalAdjuster3) {
      _inheritsLoose(RelativeDayOfWeek2, _TemporalAdjuster3);
      function RelativeDayOfWeek2(relative, dayOfWeek) {
        var _this3;
        _this3 = _TemporalAdjuster3.call(this) || this;
        requireNonNull(dayOfWeek, "dayOfWeek");
        _this3._relative = relative;
        _this3._dowValue = dayOfWeek.value();
        return _this3;
      }
      var _proto3 = RelativeDayOfWeek2.prototype;
      _proto3.adjustInto = function adjustInto(temporal) {
        var calDow = temporal.get(ChronoField.DAY_OF_WEEK);
        if (this._relative < 2 && calDow === this._dowValue) {
          return temporal;
        }
        if ((this._relative & 1) === 0) {
          var daysDiff = calDow - this._dowValue;
          return temporal.plus(daysDiff >= 0 ? 7 - daysDiff : -daysDiff, ChronoUnit.DAYS);
        } else {
          var _daysDiff = this._dowValue - calDow;
          return temporal.minus(_daysDiff >= 0 ? 7 - _daysDiff : -_daysDiff, ChronoUnit.DAYS);
        }
      };
      return RelativeDayOfWeek2;
    }(TemporalAdjuster);
    IsoChronology = function(_Enum) {
      _inheritsLoose(IsoChronology2, _Enum);
      function IsoChronology2() {
        return _Enum.apply(this, arguments) || this;
      }
      IsoChronology2.isLeapYear = function isLeapYear(prolepticYear) {
        return (prolepticYear & 3) === 0 && (prolepticYear % 100 !== 0 || prolepticYear % 400 === 0);
      };
      var _proto = IsoChronology2.prototype;
      _proto._updateResolveMap = function _updateResolveMap(fieldValues, field, value) {
        requireNonNull(fieldValues, "fieldValues");
        requireNonNull(field, "field");
        var current = fieldValues.get(field);
        if (current != null && current !== value) {
          throw new DateTimeException("Invalid state, field: " + field + " " + current + " conflicts with " + field + " " + value);
        }
        fieldValues.put(field, value);
      };
      _proto.resolveDate = function resolveDate(fieldValues, resolverStyle) {
        if (fieldValues.containsKey(ChronoField.EPOCH_DAY)) {
          return LocalDate.ofEpochDay(fieldValues.remove(ChronoField.EPOCH_DAY));
        }
        var prolepticMonth = fieldValues.remove(ChronoField.PROLEPTIC_MONTH);
        if (prolepticMonth != null) {
          if (resolverStyle !== ResolverStyle.LENIENT) {
            ChronoField.PROLEPTIC_MONTH.checkValidValue(prolepticMonth);
          }
          this._updateResolveMap(fieldValues, ChronoField.MONTH_OF_YEAR, MathUtil.floorMod(prolepticMonth, 12) + 1);
          this._updateResolveMap(fieldValues, ChronoField.YEAR, MathUtil.floorDiv(prolepticMonth, 12));
        }
        var yoeLong = fieldValues.remove(ChronoField.YEAR_OF_ERA);
        if (yoeLong != null) {
          if (resolverStyle !== ResolverStyle.LENIENT) {
            ChronoField.YEAR_OF_ERA.checkValidValue(yoeLong);
          }
          var era = fieldValues.remove(ChronoField.ERA);
          if (era == null) {
            var year = fieldValues.get(ChronoField.YEAR);
            if (resolverStyle === ResolverStyle.STRICT) {
              if (year != null) {
                this._updateResolveMap(fieldValues, ChronoField.YEAR, year > 0 ? yoeLong : MathUtil.safeSubtract(1, yoeLong));
              } else {
                fieldValues.put(ChronoField.YEAR_OF_ERA, yoeLong);
              }
            } else {
              this._updateResolveMap(fieldValues, ChronoField.YEAR, year == null || year > 0 ? yoeLong : MathUtil.safeSubtract(1, yoeLong));
            }
          } else if (era === 1) {
            this._updateResolveMap(fieldValues, ChronoField.YEAR, yoeLong);
          } else if (era === 0) {
            this._updateResolveMap(fieldValues, ChronoField.YEAR, MathUtil.safeSubtract(1, yoeLong));
          } else {
            throw new DateTimeException("Invalid value for era: " + era);
          }
        } else if (fieldValues.containsKey(ChronoField.ERA)) {
          ChronoField.ERA.checkValidValue(fieldValues.get(ChronoField.ERA));
        }
        if (fieldValues.containsKey(ChronoField.YEAR)) {
          if (fieldValues.containsKey(ChronoField.MONTH_OF_YEAR)) {
            if (fieldValues.containsKey(ChronoField.DAY_OF_MONTH)) {
              var y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
              var moy = fieldValues.remove(ChronoField.MONTH_OF_YEAR);
              var dom = fieldValues.remove(ChronoField.DAY_OF_MONTH);
              if (resolverStyle === ResolverStyle.LENIENT) {
                var months = moy - 1;
                var days = dom - 1;
                return LocalDate.of(y, 1, 1).plusMonths(months).plusDays(days);
              } else if (resolverStyle === ResolverStyle.SMART) {
                ChronoField.DAY_OF_MONTH.checkValidValue(dom);
                if (moy === 4 || moy === 6 || moy === 9 || moy === 11) {
                  dom = Math.min(dom, 30);
                } else if (moy === 2) {
                  dom = Math.min(dom, Month.FEBRUARY.length(Year.isLeap(y)));
                }
                return LocalDate.of(y, moy, dom);
              } else {
                return LocalDate.of(y, moy, dom);
              }
            }
          }
          if (fieldValues.containsKey(ChronoField.DAY_OF_YEAR)) {
            var _y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
            if (resolverStyle === ResolverStyle.LENIENT) {
              var _days = MathUtil.safeSubtract(fieldValues.remove(ChronoField.DAY_OF_YEAR), 1);
              return LocalDate.ofYearDay(_y, 1).plusDays(_days);
            }
            var doy = ChronoField.DAY_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.DAY_OF_YEAR));
            return LocalDate.ofYearDay(_y, doy);
          }
          if (fieldValues.containsKey(ChronoField.ALIGNED_WEEK_OF_YEAR)) {
            if (fieldValues.containsKey(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR)) {
              var _y2 = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
              if (resolverStyle === ResolverStyle.LENIENT) {
                var weeks = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR), 1);
                var _days2 = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR), 1);
                return LocalDate.of(_y2, 1, 1).plusWeeks(weeks).plusDays(_days2);
              }
              var aw = ChronoField.ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR));
              var ad = ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR));
              var date = LocalDate.of(_y2, 1, 1).plusDays((aw - 1) * 7 + (ad - 1));
              if (resolverStyle === ResolverStyle.STRICT && date.get(ChronoField.YEAR) !== _y2) {
                throw new DateTimeException("Strict mode rejected date parsed to a different year");
              }
              return date;
            }
            if (fieldValues.containsKey(ChronoField.DAY_OF_WEEK)) {
              var _y3 = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
              if (resolverStyle === ResolverStyle.LENIENT) {
                var _weeks = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR), 1);
                var _days3 = MathUtil.safeSubtract(fieldValues.remove(ChronoField.DAY_OF_WEEK), 1);
                return LocalDate.of(_y3, 1, 1).plusWeeks(_weeks).plusDays(_days3);
              }
              var _aw = ChronoField.ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR));
              var dow = ChronoField.DAY_OF_WEEK.checkValidIntValue(fieldValues.remove(ChronoField.DAY_OF_WEEK));
              var _date = LocalDate.of(_y3, 1, 1).plusWeeks(_aw - 1).with(TemporalAdjusters.nextOrSame(DayOfWeek.of(dow)));
              if (resolverStyle === ResolverStyle.STRICT && _date.get(ChronoField.YEAR) !== _y3) {
                throw new DateTimeException("Strict mode rejected date parsed to a different month");
              }
              return _date;
            }
          }
        }
        return null;
      };
      _proto.date = function date(temporal) {
        return LocalDate.from(temporal);
      };
      return IsoChronology2;
    }(Enum);
    OffsetTime = function(_Temporal) {
      _inheritsLoose(OffsetTime2, _Temporal);
      OffsetTime2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        if (temporal instanceof OffsetTime2) {
          return temporal;
        } else if (temporal instanceof OffsetDateTime) {
          return temporal.toOffsetTime();
        }
        try {
          var time = LocalTime.from(temporal);
          var offset = ZoneOffset.from(temporal);
          return new OffsetTime2(time, offset);
        } catch (ex) {
          throw new DateTimeException("Unable to obtain OffsetTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
        }
      };
      OffsetTime2.now = function now(clockOrZone) {
        if (arguments.length === 0) {
          return OffsetTime2._now(Clock.systemDefaultZone());
        } else if (clockOrZone instanceof Clock) {
          return OffsetTime2._now(clockOrZone);
        } else {
          return OffsetTime2._now(Clock.system(clockOrZone));
        }
      };
      OffsetTime2._now = function _now(clock) {
        requireNonNull(clock, "clock");
        var now = clock.instant();
        return OffsetTime2.ofInstant(now, clock.zone().rules().offset(now));
      };
      OffsetTime2.of = function of() {
        if (arguments.length <= 2) {
          return OffsetTime2.ofTimeAndOffset.apply(this, arguments);
        } else {
          return OffsetTime2.ofNumbers.apply(this, arguments);
        }
      };
      OffsetTime2.ofNumbers = function ofNumbers(hour, minute, second, nanoOfSecond, offset) {
        var time = LocalTime.of(hour, minute, second, nanoOfSecond);
        return new OffsetTime2(time, offset);
      };
      OffsetTime2.ofTimeAndOffset = function ofTimeAndOffset(time, offset) {
        return new OffsetTime2(time, offset);
      };
      OffsetTime2.ofInstant = function ofInstant(instant, zone) {
        requireNonNull(instant, "instant");
        requireInstance(instant, Instant, "instant");
        requireNonNull(zone, "zone");
        requireInstance(zone, ZoneId, "zone");
        var rules = zone.rules();
        var offset = rules.offset(instant);
        var secsOfDay = instant.epochSecond() % LocalTime.SECONDS_PER_DAY;
        secsOfDay = (secsOfDay + offset.totalSeconds()) % LocalTime.SECONDS_PER_DAY;
        if (secsOfDay < 0) {
          secsOfDay += LocalTime.SECONDS_PER_DAY;
        }
        var time = LocalTime.ofSecondOfDay(secsOfDay, instant.nano());
        return new OffsetTime2(time, offset);
      };
      OffsetTime2.parse = function parse2(text, formatter) {
        if (formatter === void 0) {
          formatter = DateTimeFormatter.ISO_OFFSET_TIME;
        }
        requireNonNull(formatter, "formatter");
        return formatter.parse(text, OffsetTime2.FROM);
      };
      function OffsetTime2(time, offset) {
        var _this;
        _this = _Temporal.call(this) || this;
        requireNonNull(time, "time");
        requireInstance(time, LocalTime, "time");
        requireNonNull(offset, "offset");
        requireInstance(offset, ZoneOffset, "offset");
        _this._time = time;
        _this._offset = offset;
        return _this;
      }
      var _proto = OffsetTime2.prototype;
      _proto.adjustInto = function adjustInto(temporal) {
        return temporal.with(ChronoField.NANO_OF_DAY, this._time.toNanoOfDay()).with(ChronoField.OFFSET_SECONDS, this.offset().totalSeconds());
      };
      _proto.atDate = function atDate(date) {
        return OffsetDateTime.of(date, this._time, this._offset);
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        return formatter.format(this, OffsetTime2.FROM);
      };
      _proto.get = function get(field) {
        return _Temporal.prototype.get.call(this, field);
      };
      _proto.getLong = function getLong(field) {
        if (field instanceof ChronoField) {
          if (field === ChronoField.OFFSET_SECONDS) {
            return this._offset.totalSeconds();
          }
          return this._time.getLong(field);
        }
        return field.getFrom(this);
      };
      _proto.hour = function hour() {
        return this._time.hour();
      };
      _proto.minute = function minute() {
        return this._time.minute();
      };
      _proto.second = function second() {
        return this._time.second();
      };
      _proto.nano = function nano() {
        return this._time.nano();
      };
      _proto.offset = function offset() {
        return this._offset;
      };
      _proto.isAfter = function isAfter(other) {
        requireNonNull(other, "other");
        return this._toEpochNano() > other._toEpochNano();
      };
      _proto.isBefore = function isBefore(other) {
        requireNonNull(other, "other");
        return this._toEpochNano() < other._toEpochNano();
      };
      _proto.isEqual = function isEqual(other) {
        requireNonNull(other, "other");
        return this._toEpochNano() === other._toEpochNano();
      };
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (fieldOrUnit instanceof ChronoField) {
          return fieldOrUnit.isTimeBased() || fieldOrUnit === ChronoField.OFFSET_SECONDS;
        } else if (fieldOrUnit instanceof ChronoUnit) {
          return fieldOrUnit.isTimeBased();
        }
        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
      };
      _proto.minusHours = function minusHours(hours) {
        return this._withLocalTimeOffset(this._time.minusHours(hours), this._offset);
      };
      _proto.minusMinutes = function minusMinutes(minutes) {
        return this._withLocalTimeOffset(this._time.minusMinutes(minutes), this._offset);
      };
      _proto.minusSeconds = function minusSeconds(seconds) {
        return this._withLocalTimeOffset(this._time.minusSeconds(seconds), this._offset);
      };
      _proto.minusNanos = function minusNanos(nanos) {
        return this._withLocalTimeOffset(this._time.minusNanos(nanos), this._offset);
      };
      _proto._minusAmount = function _minusAmount(amount) {
        requireNonNull(amount);
        return amount.subtractFrom(this);
      };
      _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
        return this.plus(-1 * amountToSubtract, unit);
      };
      _proto._plusAmount = function _plusAmount(amount) {
        requireNonNull(amount);
        return amount.addTo(this);
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        if (unit instanceof ChronoUnit) {
          return this._withLocalTimeOffset(this._time.plus(amountToAdd, unit), this._offset);
        }
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusHours = function plusHours(hours) {
        return this._withLocalTimeOffset(this._time.plusHours(hours), this._offset);
      };
      _proto.plusMinutes = function plusMinutes(minutes) {
        return this._withLocalTimeOffset(this._time.plusMinutes(minutes), this._offset);
      };
      _proto.plusSeconds = function plusSeconds(seconds) {
        return this._withLocalTimeOffset(this._time.plusSeconds(seconds), this._offset);
      };
      _proto.plusNanos = function plusNanos(nanos) {
        return this._withLocalTimeOffset(this._time.plusNanos(nanos), this._offset);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        if (_query === TemporalQueries.precision()) {
          return ChronoUnit.NANOS;
        } else if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {
          return this.offset();
        } else if (_query === TemporalQueries.localTime()) {
          return this._time;
        } else if (_query === TemporalQueries.chronology() || _query === TemporalQueries.localDate() || _query === TemporalQueries.zoneId()) {
          return null;
        }
        return _Temporal.prototype.query.call(this, _query);
      };
      _proto.range = function range(field) {
        if (field instanceof ChronoField) {
          if (field === ChronoField.OFFSET_SECONDS) {
            return field.range();
          }
          return this._time.range(field);
        }
        return field.rangeRefinedBy(this);
      };
      _proto.toLocalTime = function toLocalTime() {
        return this._time;
      };
      _proto.truncatedTo = function truncatedTo(unit) {
        return this._withLocalTimeOffset(this._time.truncatedTo(unit), this._offset);
      };
      _proto.until = function until(endExclusive, unit) {
        requireNonNull(endExclusive, "endExclusive");
        requireNonNull(unit, "unit");
        var end = OffsetTime2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          var nanosUntil = end._toEpochNano() - this._toEpochNano();
          switch (unit) {
            case ChronoUnit.NANOS:
              return nanosUntil;
            case ChronoUnit.MICROS:
              return MathUtil.intDiv(nanosUntil, 1e3);
            case ChronoUnit.MILLIS:
              return MathUtil.intDiv(nanosUntil, 1e6);
            case ChronoUnit.SECONDS:
              return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_SECOND);
            case ChronoUnit.MINUTES:
              return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_MINUTE);
            case ChronoUnit.HOURS:
              return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_HOUR);
            case ChronoUnit.HALF_DAYS:
              return MathUtil.intDiv(nanosUntil, 12 * LocalTime.NANOS_PER_HOUR);
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.between(this, end);
      };
      _proto.withHour = function withHour(hour) {
        return this._withLocalTimeOffset(this._time.withHour(hour), this._offset);
      };
      _proto.withMinute = function withMinute(minute) {
        return this._withLocalTimeOffset(this._time.withMinute(minute), this._offset);
      };
      _proto.withSecond = function withSecond(second) {
        return this._withLocalTimeOffset(this._time.withSecond(second), this._offset);
      };
      _proto.withNano = function withNano(nano) {
        return this._withLocalTimeOffset(this._time.withNano(nano), this._offset);
      };
      _proto.withOffsetSameInstant = function withOffsetSameInstant(offset) {
        requireNonNull(offset, "offset");
        if (offset.equals(this._offset)) {
          return this;
        }
        var difference = offset.totalSeconds() - this._offset.totalSeconds();
        var adjusted = this._time.plusSeconds(difference);
        return new OffsetTime2(adjusted, offset);
      };
      _proto.withOffsetSameLocal = function withOffsetSameLocal(offset) {
        return offset != null && offset.equals(this._offset) ? this : new OffsetTime2(this._time, offset);
      };
      _proto._toEpochNano = function _toEpochNano() {
        var nod = this._time.toNanoOfDay();
        var offsetNanos = this._offset.totalSeconds() * LocalTime.NANOS_PER_SECOND;
        return nod - offsetNanos;
      };
      _proto._withAdjuster = function _withAdjuster(adjuster) {
        requireNonNull(adjuster, "adjuster");
        if (adjuster instanceof LocalTime) {
          return this._withLocalTimeOffset(adjuster, this._offset);
        } else if (adjuster instanceof ZoneOffset) {
          return this._withLocalTimeOffset(this._time, adjuster);
        } else if (adjuster instanceof OffsetTime2) {
          return adjuster;
        }
        return adjuster.adjustInto(this);
      };
      _proto._withField = function _withField(field, newValue) {
        requireNonNull(field, "field");
        if (field instanceof ChronoField) {
          if (field === ChronoField.OFFSET_SECONDS) {
            return this._withLocalTimeOffset(this._time, ZoneOffset.ofTotalSeconds(field.checkValidIntValue(newValue)));
          }
          return this._withLocalTimeOffset(this._time.with(field, newValue), this._offset);
        }
        return field.adjustInto(this, newValue);
      };
      _proto._withLocalTimeOffset = function _withLocalTimeOffset(time, offset) {
        if (this._time === time && this._offset.equals(offset)) {
          return this;
        }
        return new OffsetTime2(time, offset);
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, OffsetTime2, "other");
        if (this._offset.equals(other._offset)) {
          return this._time.compareTo(other._time);
        }
        var compare = MathUtil.compareNumbers(this._toEpochNano(), other._toEpochNano());
        if (compare === 0) {
          return this._time.compareTo(other._time);
        }
        return compare;
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof OffsetTime2) {
          return this._time.equals(other._time) && this._offset.equals(other._offset);
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return this._time.hashCode() ^ this._offset.hashCode();
      };
      _proto.toString = function toString() {
        return this._time.toString() + this._offset.toString();
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      return OffsetTime2;
    }(Temporal);
    ChronoZonedDateTime = function(_Temporal) {
      _inheritsLoose(ChronoZonedDateTime2, _Temporal);
      function ChronoZonedDateTime2() {
        return _Temporal.apply(this, arguments) || this;
      }
      var _proto = ChronoZonedDateTime2.prototype;
      _proto.query = function query(_query) {
        if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.zone()) {
          return this.zone();
        } else if (_query === TemporalQueries.chronology()) {
          return this.toLocalDate().chronology();
        } else if (_query === TemporalQueries.precision()) {
          return ChronoUnit.NANOS;
        } else if (_query === TemporalQueries.offset()) {
          return this.offset();
        } else if (_query === TemporalQueries.localDate()) {
          return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());
        } else if (_query === TemporalQueries.localTime()) {
          return this.toLocalTime();
        }
        return _Temporal.prototype.query.call(this, _query);
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        return formatter.format(this);
      };
      _proto.toInstant = function toInstant() {
        return Instant.ofEpochSecond(this.toEpochSecond(), this.toLocalTime().nano());
      };
      _proto.toEpochSecond = function toEpochSecond() {
        var epochDay = this.toLocalDate().toEpochDay();
        var secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();
        secs -= this.offset().totalSeconds();
        return secs;
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        var cmp = MathUtil.compareNumbers(this.toEpochSecond(), other.toEpochSecond());
        if (cmp === 0) {
          cmp = this.toLocalTime().nano() - other.toLocalTime().nano();
          if (cmp === 0) {
            cmp = this.toLocalDateTime().compareTo(other.toLocalDateTime());
            if (cmp === 0) {
              cmp = strcmp(this.zone().id(), other.zone().id());
            }
          }
        }
        return cmp;
      };
      _proto.isAfter = function isAfter(other) {
        requireNonNull(other, "other");
        var thisEpochSec = this.toEpochSecond();
        var otherEpochSec = other.toEpochSecond();
        return thisEpochSec > otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() > other.toLocalTime().nano();
      };
      _proto.isBefore = function isBefore(other) {
        requireNonNull(other, "other");
        var thisEpochSec = this.toEpochSecond();
        var otherEpochSec = other.toEpochSecond();
        return thisEpochSec < otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() < other.toLocalTime().nano();
      };
      _proto.isEqual = function isEqual(other) {
        requireNonNull(other, "other");
        return this.toEpochSecond() === other.toEpochSecond() && this.toLocalTime().nano() === other.toLocalTime().nano();
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof ChronoZonedDateTime2) {
          return this.compareTo(other) === 0;
        }
        return false;
      };
      return ChronoZonedDateTime2;
    }(Temporal);
    ZonedDateTime = function(_ChronoZonedDateTime) {
      _inheritsLoose(ZonedDateTime2, _ChronoZonedDateTime);
      ZonedDateTime2.now = function now(clockOrZone) {
        var clock;
        if (clockOrZone instanceof ZoneId) {
          clock = Clock.system(clockOrZone);
        } else {
          clock = clockOrZone == null ? Clock.systemDefaultZone() : clockOrZone;
        }
        return ZonedDateTime2.ofInstant(clock.instant(), clock.zone());
      };
      ZonedDateTime2.of = function of() {
        if (arguments.length <= 2) {
          return ZonedDateTime2.of2.apply(this, arguments);
        } else if (arguments.length === 3 && arguments[0] instanceof LocalDate) {
          return ZonedDateTime2.of3.apply(this, arguments);
        } else {
          return ZonedDateTime2.of8.apply(this, arguments);
        }
      };
      ZonedDateTime2.of3 = function of3(date, time, zone) {
        return ZonedDateTime2.of2(LocalDateTime.of(date, time), zone);
      };
      ZonedDateTime2.of2 = function of2(localDateTime, zone) {
        return ZonedDateTime2.ofLocal(localDateTime, zone, null);
      };
      ZonedDateTime2.of8 = function of8(year, month, dayOfMonth, hour, minute, second, nanoOfSecond, zone) {
        var dt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);
        return ZonedDateTime2.ofLocal(dt, zone, null);
      };
      ZonedDateTime2.ofLocal = function ofLocal(localDateTime, zone, preferredOffset) {
        requireNonNull(localDateTime, "localDateTime");
        requireNonNull(zone, "zone");
        if (zone instanceof ZoneOffset) {
          return new ZonedDateTime2(localDateTime, zone, zone);
        }
        var offset = null;
        var rules = zone.rules();
        var validOffsets = rules.validOffsets(localDateTime);
        if (validOffsets.length === 1) {
          offset = validOffsets[0];
        } else if (validOffsets.length === 0) {
          var trans = rules.transition(localDateTime);
          localDateTime = localDateTime.plusSeconds(trans.duration().seconds());
          offset = trans.offsetAfter();
        } else {
          if (preferredOffset != null && validOffsets.some(function(validOffset) {
            return validOffset.equals(preferredOffset);
          })) {
            offset = preferredOffset;
          } else {
            offset = requireNonNull(validOffsets[0], "offset");
          }
        }
        return new ZonedDateTime2(localDateTime, offset, zone);
      };
      ZonedDateTime2.ofInstant = function ofInstant() {
        if (arguments.length === 2) {
          return ZonedDateTime2.ofInstant2.apply(this, arguments);
        } else {
          return ZonedDateTime2.ofInstant3.apply(this, arguments);
        }
      };
      ZonedDateTime2.ofInstant2 = function ofInstant2(instant, zone) {
        requireNonNull(instant, "instant");
        requireNonNull(zone, "zone");
        return ZonedDateTime2._create(instant.epochSecond(), instant.nano(), zone);
      };
      ZonedDateTime2.ofInstant3 = function ofInstant3(localDateTime, offset, zone) {
        requireNonNull(localDateTime, "localDateTime");
        requireNonNull(offset, "offset");
        requireNonNull(zone, "zone");
        return ZonedDateTime2._create(localDateTime.toEpochSecond(offset), localDateTime.nano(), zone);
      };
      ZonedDateTime2._create = function _create(epochSecond, nanoOfSecond, zone) {
        var rules = zone.rules();
        var instant = Instant.ofEpochSecond(epochSecond, nanoOfSecond);
        var offset = rules.offset(instant);
        var ldt = LocalDateTime.ofEpochSecond(epochSecond, nanoOfSecond, offset);
        return new ZonedDateTime2(ldt, offset, zone);
      };
      ZonedDateTime2.ofStrict = function ofStrict(localDateTime, offset, zone) {
        requireNonNull(localDateTime, "localDateTime");
        requireNonNull(offset, "offset");
        requireNonNull(zone, "zone");
        var rules = zone.rules();
        if (rules.isValidOffset(localDateTime, offset) === false) {
          var trans = rules.transition(localDateTime);
          if (trans != null && trans.isGap()) {
            throw new DateTimeException("LocalDateTime " + localDateTime + " does not exist in zone " + zone + " due to a gap in the local time-line, typically caused by daylight savings");
          }
          throw new DateTimeException('ZoneOffset "' + offset + '" is not valid for LocalDateTime "' + localDateTime + '" in zone "' + zone + '"');
        }
        return new ZonedDateTime2(localDateTime, offset, zone);
      };
      ZonedDateTime2.ofLenient = function ofLenient(localDateTime, offset, zone) {
        requireNonNull(localDateTime, "localDateTime");
        requireNonNull(offset, "offset");
        requireNonNull(zone, "zone");
        if (zone instanceof ZoneOffset && offset.equals(zone) === false) {
          throw new IllegalArgumentException("ZoneId must match ZoneOffset");
        }
        return new ZonedDateTime2(localDateTime, offset, zone);
      };
      ZonedDateTime2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        if (temporal instanceof ZonedDateTime2) {
          return temporal;
        }
        var zone = ZoneId.from(temporal);
        if (temporal.isSupported(ChronoField.INSTANT_SECONDS)) {
          var zdt = ZonedDateTime2._from(temporal, zone);
          if (zdt != null) return zdt;
        }
        var ldt = LocalDateTime.from(temporal);
        return ZonedDateTime2.of2(ldt, zone);
      };
      ZonedDateTime2._from = function _from(temporal, zone) {
        try {
          return ZonedDateTime2.__from(temporal, zone);
        } catch (ex) {
          if (!(ex instanceof DateTimeException)) throw ex;
        }
      };
      ZonedDateTime2.__from = function __from(temporal, zone) {
        var epochSecond = temporal.getLong(ChronoField.INSTANT_SECONDS);
        var nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);
        return ZonedDateTime2._create(epochSecond, nanoOfSecond, zone);
      };
      ZonedDateTime2.parse = function parse2(text, formatter) {
        if (formatter === void 0) {
          formatter = DateTimeFormatter.ISO_ZONED_DATE_TIME;
        }
        requireNonNull(formatter, "formatter");
        return formatter.parse(text, ZonedDateTime2.FROM);
      };
      function ZonedDateTime2(dateTime, offset, zone) {
        var _this;
        requireNonNull(dateTime, "dateTime");
        requireNonNull(offset, "offset");
        requireNonNull(zone, "zone");
        _this = _ChronoZonedDateTime.call(this) || this;
        _this._dateTime = dateTime;
        _this._offset = offset;
        _this._zone = zone;
        return _this;
      }
      var _proto = ZonedDateTime2.prototype;
      _proto._resolveLocal = function _resolveLocal(newDateTime) {
        requireNonNull(newDateTime, "newDateTime");
        return ZonedDateTime2.ofLocal(newDateTime, this._zone, this._offset);
      };
      _proto._resolveInstant = function _resolveInstant(newDateTime) {
        return ZonedDateTime2.ofInstant3(newDateTime, this._offset, this._zone);
      };
      _proto._resolveOffset = function _resolveOffset(offset) {
        if (offset.equals(this._offset) === false && this._zone.rules().isValidOffset(this._dateTime, offset)) {
          return new ZonedDateTime2(this._dateTime, offset, this._zone);
        }
        return this;
      };
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (fieldOrUnit instanceof ChronoField) {
          return true;
        } else if (fieldOrUnit instanceof ChronoUnit) {
          return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
        }
        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        if (field instanceof ChronoField) {
          if (field === ChronoField.INSTANT_SECONDS || field === ChronoField.OFFSET_SECONDS) {
            return field.range();
          }
          return this._dateTime.range(field);
        }
        return field.rangeRefinedBy(this);
      };
      _proto.get = function get(field) {
        return this.getLong(field);
      };
      _proto.getLong = function getLong(field) {
        if (field instanceof ChronoField) {
          switch (field) {
            case ChronoField.INSTANT_SECONDS:
              return this.toEpochSecond();
            case ChronoField.OFFSET_SECONDS:
              return this._offset.totalSeconds();
          }
          return this._dateTime.getLong(field);
        }
        requireNonNull(field, "field");
        return field.getFrom(this);
      };
      _proto.offset = function offset() {
        return this._offset;
      };
      _proto.withEarlierOffsetAtOverlap = function withEarlierOffsetAtOverlap() {
        var trans = this._zone.rules().transition(this._dateTime);
        if (trans != null && trans.isOverlap()) {
          var earlierOffset = trans.offsetBefore();
          if (earlierOffset.equals(this._offset) === false) {
            return new ZonedDateTime2(this._dateTime, earlierOffset, this._zone);
          }
        }
        return this;
      };
      _proto.withLaterOffsetAtOverlap = function withLaterOffsetAtOverlap() {
        var trans = this._zone.rules().transition(this.toLocalDateTime());
        if (trans != null) {
          var laterOffset = trans.offsetAfter();
          if (laterOffset.equals(this._offset) === false) {
            return new ZonedDateTime2(this._dateTime, laterOffset, this._zone);
          }
        }
        return this;
      };
      _proto.zone = function zone() {
        return this._zone;
      };
      _proto.withZoneSameLocal = function withZoneSameLocal(zone) {
        requireNonNull(zone, "zone");
        return this._zone.equals(zone) ? this : ZonedDateTime2.ofLocal(this._dateTime, zone, this._offset);
      };
      _proto.withZoneSameInstant = function withZoneSameInstant(zone) {
        requireNonNull(zone, "zone");
        return this._zone.equals(zone) ? this : ZonedDateTime2._create(this._dateTime.toEpochSecond(this._offset), this._dateTime.nano(), zone);
      };
      _proto.withFixedOffsetZone = function withFixedOffsetZone() {
        return this._zone.equals(this._offset) ? this : new ZonedDateTime2(this._dateTime, this._offset, this._offset);
      };
      _proto.year = function year() {
        return this._dateTime.year();
      };
      _proto.monthValue = function monthValue() {
        return this._dateTime.monthValue();
      };
      _proto.month = function month() {
        return this._dateTime.month();
      };
      _proto.dayOfMonth = function dayOfMonth() {
        return this._dateTime.dayOfMonth();
      };
      _proto.dayOfYear = function dayOfYear() {
        return this._dateTime.dayOfYear();
      };
      _proto.dayOfWeek = function dayOfWeek() {
        return this._dateTime.dayOfWeek();
      };
      _proto.hour = function hour() {
        return this._dateTime.hour();
      };
      _proto.minute = function minute() {
        return this._dateTime.minute();
      };
      _proto.second = function second() {
        return this._dateTime.second();
      };
      _proto.nano = function nano() {
        return this._dateTime.nano();
      };
      _proto._withAdjuster = function _withAdjuster(adjuster) {
        if (adjuster instanceof LocalDate) {
          return this._resolveLocal(LocalDateTime.of(adjuster, this._dateTime.toLocalTime()));
        } else if (adjuster instanceof LocalTime) {
          return this._resolveLocal(LocalDateTime.of(this._dateTime.toLocalDate(), adjuster));
        } else if (adjuster instanceof LocalDateTime) {
          return this._resolveLocal(adjuster);
        } else if (adjuster instanceof Instant) {
          var instant = adjuster;
          return ZonedDateTime2._create(instant.epochSecond(), instant.nano(), this._zone);
        } else if (adjuster instanceof ZoneOffset) {
          return this._resolveOffset(adjuster);
        }
        return _ChronoZonedDateTime.prototype._withAdjuster.call(this, adjuster);
      };
      _proto._withField = function _withField(field, newValue) {
        if (field instanceof ChronoField) {
          switch (field) {
            case ChronoField.INSTANT_SECONDS:
              return ZonedDateTime2._create(newValue, this.nano(), this._zone);
            case ChronoField.OFFSET_SECONDS: {
              var offset = ZoneOffset.ofTotalSeconds(field.checkValidIntValue(newValue));
              return this._resolveOffset(offset);
            }
          }
          return this._resolveLocal(this._dateTime.with(field, newValue));
        }
        return field.adjustInto(this, newValue);
      };
      _proto.withYear = function withYear(year) {
        return this._resolveLocal(this._dateTime.withYear(year));
      };
      _proto.withMonth = function withMonth(month) {
        return this._resolveLocal(this._dateTime.withMonth(month));
      };
      _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
        return this._resolveLocal(this._dateTime.withDayOfMonth(dayOfMonth));
      };
      _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
        return this._resolveLocal(this._dateTime.withDayOfYear(dayOfYear));
      };
      _proto.withHour = function withHour(hour) {
        return this._resolveLocal(this._dateTime.withHour(hour));
      };
      _proto.withMinute = function withMinute(minute) {
        return this._resolveLocal(this._dateTime.withMinute(minute));
      };
      _proto.withSecond = function withSecond(second) {
        return this._resolveLocal(this._dateTime.withSecond(second));
      };
      _proto.withNano = function withNano(nanoOfSecond) {
        return this._resolveLocal(this._dateTime.withNano(nanoOfSecond));
      };
      _proto.truncatedTo = function truncatedTo(unit) {
        return this._resolveLocal(this._dateTime.truncatedTo(unit));
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        if (unit instanceof ChronoUnit) {
          if (unit.isDateBased()) {
            return this._resolveLocal(this._dateTime.plus(amountToAdd, unit));
          } else {
            return this._resolveInstant(this._dateTime.plus(amountToAdd, unit));
          }
        }
        requireNonNull(unit, "unit");
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusYears = function plusYears(years) {
        return this._resolveLocal(this._dateTime.plusYears(years));
      };
      _proto.plusMonths = function plusMonths(months) {
        return this._resolveLocal(this._dateTime.plusMonths(months));
      };
      _proto.plusWeeks = function plusWeeks(weeks) {
        return this._resolveLocal(this._dateTime.plusWeeks(weeks));
      };
      _proto.plusDays = function plusDays(days) {
        return this._resolveLocal(this._dateTime.plusDays(days));
      };
      _proto.plusHours = function plusHours(hours) {
        return this._resolveInstant(this._dateTime.plusHours(hours));
      };
      _proto.plusMinutes = function plusMinutes(minutes) {
        return this._resolveInstant(this._dateTime.plusMinutes(minutes));
      };
      _proto.plusSeconds = function plusSeconds(seconds) {
        return this._resolveInstant(this._dateTime.plusSeconds(seconds));
      };
      _proto.plusNanos = function plusNanos(nanos) {
        return this._resolveInstant(this._dateTime.plusNanos(nanos));
      };
      _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
        return this._plusUnit(-1 * amountToSubtract, unit);
      };
      _proto.minusYears = function minusYears(years) {
        return this.plusYears(-1 * years);
      };
      _proto.minusMonths = function minusMonths(months) {
        return this.plusMonths(-1 * months);
      };
      _proto.minusWeeks = function minusWeeks(weeks) {
        return this.plusWeeks(-1 * weeks);
      };
      _proto.minusDays = function minusDays(days) {
        return this.plusDays(-1 * days);
      };
      _proto.minusHours = function minusHours(hours) {
        return this.plusHours(-1 * hours);
      };
      _proto.minusMinutes = function minusMinutes(minutes) {
        return this.plusMinutes(-1 * minutes);
      };
      _proto.minusSeconds = function minusSeconds(seconds) {
        return this.plusSeconds(-1 * seconds);
      };
      _proto.minusNanos = function minusNanos(nanos) {
        return this.plusNanos(-1 * nanos);
      };
      _proto.query = function query(_query) {
        if (_query === TemporalQueries.localDate()) {
          return this.toLocalDate();
        }
        requireNonNull(_query, "query");
        return _ChronoZonedDateTime.prototype.query.call(this, _query);
      };
      _proto.until = function until(endExclusive, unit) {
        var end = ZonedDateTime2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          end = end.withZoneSameInstant(this._zone);
          if (unit.isDateBased()) {
            return this._dateTime.until(end._dateTime, unit);
          } else {
            var difference = this._offset.totalSeconds() - end._offset.totalSeconds();
            var adjustedEnd = end._dateTime.plusSeconds(difference);
            return this._dateTime.until(adjustedEnd, unit);
          }
        }
        return unit.between(this, end);
      };
      _proto.toLocalDateTime = function toLocalDateTime() {
        return this._dateTime;
      };
      _proto.toLocalDate = function toLocalDate() {
        return this._dateTime.toLocalDate();
      };
      _proto.toLocalTime = function toLocalTime() {
        return this._dateTime.toLocalTime();
      };
      _proto.toOffsetDateTime = function toOffsetDateTime() {
        return OffsetDateTime.of(this._dateTime, this._offset);
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof ZonedDateTime2) {
          return this._dateTime.equals(other._dateTime) && this._offset.equals(other._offset) && this._zone.equals(other._zone);
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return MathUtil.hashCode(this._dateTime.hashCode(), this._offset.hashCode(), this._zone.hashCode());
      };
      _proto.toString = function toString() {
        var str = this._dateTime.toString() + this._offset.toString();
        if (this._offset !== this._zone) {
          str += "[" + this._zone.toString() + "]";
        }
        return str;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.format = function format(formatter) {
        return _ChronoZonedDateTime.prototype.format.call(this, formatter);
      };
      return ZonedDateTime2;
    }(ChronoZonedDateTime);
    OffsetDateTime = function(_Temporal) {
      _inheritsLoose(OffsetDateTime2, _Temporal);
      OffsetDateTime2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        if (temporal instanceof OffsetDateTime2) {
          return temporal;
        }
        try {
          var offset = ZoneOffset.from(temporal);
          try {
            var ldt = LocalDateTime.from(temporal);
            return OffsetDateTime2.of(ldt, offset);
          } catch (_2) {
            var instant = Instant.from(temporal);
            return OffsetDateTime2.ofInstant(instant, offset);
          }
        } catch (ex) {
          throw new DateTimeException("Unable to obtain OffsetDateTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
        }
      };
      OffsetDateTime2.now = function now(clockOrZone) {
        if (arguments.length === 0) {
          return OffsetDateTime2.now(Clock.systemDefaultZone());
        } else {
          requireNonNull(clockOrZone, "clockOrZone");
          if (clockOrZone instanceof ZoneId) {
            return OffsetDateTime2.now(Clock.system(clockOrZone));
          } else if (clockOrZone instanceof Clock) {
            var now2 = clockOrZone.instant();
            return OffsetDateTime2.ofInstant(now2, clockOrZone.zone().rules().offset(now2));
          } else {
            throw new IllegalArgumentException("clockOrZone must be an instance of ZoneId or Clock");
          }
        }
      };
      OffsetDateTime2.of = function of() {
        if (arguments.length <= 2) {
          return OffsetDateTime2.ofDateTime.apply(this, arguments);
        } else if (arguments.length === 3) {
          return OffsetDateTime2.ofDateAndTime.apply(this, arguments);
        } else {
          return OffsetDateTime2.ofNumbers.apply(this, arguments);
        }
      };
      OffsetDateTime2.ofDateTime = function ofDateTime(dateTime, offset) {
        return new OffsetDateTime2(dateTime, offset);
      };
      OffsetDateTime2.ofDateAndTime = function ofDateAndTime(date, time, offset) {
        var dt = LocalDateTime.of(date, time);
        return new OffsetDateTime2(dt, offset);
      };
      OffsetDateTime2.ofNumbers = function ofNumbers(year, month, dayOfMonth, hour, minute, second, nanoOfSecond, offset) {
        if (hour === void 0) {
          hour = 0;
        }
        if (minute === void 0) {
          minute = 0;
        }
        if (second === void 0) {
          second = 0;
        }
        if (nanoOfSecond === void 0) {
          nanoOfSecond = 0;
        }
        var dt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);
        return new OffsetDateTime2(dt, offset);
      };
      OffsetDateTime2.ofInstant = function ofInstant(instant, zone) {
        requireNonNull(instant, "instant");
        requireNonNull(zone, "zone");
        var rules = zone.rules();
        var offset = rules.offset(instant);
        var ldt = LocalDateTime.ofEpochSecond(instant.epochSecond(), instant.nano(), offset);
        return new OffsetDateTime2(ldt, offset);
      };
      OffsetDateTime2.parse = function parse2(text, formatter) {
        if (formatter === void 0) {
          formatter = DateTimeFormatter.ISO_OFFSET_DATE_TIME;
        }
        requireNonNull(formatter, "formatter");
        return formatter.parse(text, OffsetDateTime2.FROM);
      };
      function OffsetDateTime2(dateTime, offset) {
        var _this;
        _this = _Temporal.call(this) || this;
        requireNonNull(dateTime, "dateTime");
        requireInstance(dateTime, LocalDateTime, "dateTime");
        requireNonNull(offset, "offset");
        requireInstance(offset, ZoneOffset, "offset");
        _this._dateTime = dateTime;
        _this._offset = offset;
        return _this;
      }
      var _proto = OffsetDateTime2.prototype;
      _proto.adjustInto = function adjustInto(temporal) {
        return temporal.with(ChronoField.EPOCH_DAY, this.toLocalDate().toEpochDay()).with(ChronoField.NANO_OF_DAY, this.toLocalTime().toNanoOfDay()).with(ChronoField.OFFSET_SECONDS, this.offset().totalSeconds());
      };
      _proto.until = function until(endExclusive, unit) {
        var end = OffsetDateTime2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          end = end.withOffsetSameInstant(this._offset);
          return this._dateTime.until(end._dateTime, unit);
        }
        return unit.between(this, end);
      };
      _proto.atZoneSameInstant = function atZoneSameInstant(zone) {
        return ZonedDateTime.ofInstant(this._dateTime, this._offset, zone);
      };
      _proto.atZoneSimilarLocal = function atZoneSimilarLocal(zone) {
        return ZonedDateTime.ofLocal(this._dateTime, zone, this._offset);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        if (_query === TemporalQueries.chronology()) {
          return IsoChronology.INSTANCE;
        } else if (_query === TemporalQueries.precision()) {
          return ChronoUnit.NANOS;
        } else if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {
          return this.offset();
        } else if (_query === TemporalQueries.localDate()) {
          return this.toLocalDate();
        } else if (_query === TemporalQueries.localTime()) {
          return this.toLocalTime();
        } else if (_query === TemporalQueries.zoneId()) {
          return null;
        }
        return _Temporal.prototype.query.call(this, _query);
      };
      _proto.get = function get(field) {
        if (field instanceof ChronoField) {
          switch (field) {
            case ChronoField.INSTANT_SECONDS:
              throw new DateTimeException("Field too large for an int: " + field);
            case ChronoField.OFFSET_SECONDS:
              return this.offset().totalSeconds();
          }
          return this._dateTime.get(field);
        }
        return _Temporal.prototype.get.call(this, field);
      };
      _proto.getLong = function getLong(field) {
        if (field instanceof ChronoField) {
          switch (field) {
            case ChronoField.INSTANT_SECONDS:
              return this.toEpochSecond();
            case ChronoField.OFFSET_SECONDS:
              return this.offset().totalSeconds();
          }
          return this._dateTime.getLong(field);
        }
        return field.getFrom(this);
      };
      _proto.offset = function offset() {
        return this._offset;
      };
      _proto.year = function year() {
        return this._dateTime.year();
      };
      _proto.monthValue = function monthValue() {
        return this._dateTime.monthValue();
      };
      _proto.month = function month() {
        return this._dateTime.month();
      };
      _proto.dayOfMonth = function dayOfMonth() {
        return this._dateTime.dayOfMonth();
      };
      _proto.dayOfYear = function dayOfYear() {
        return this._dateTime.dayOfYear();
      };
      _proto.dayOfWeek = function dayOfWeek() {
        return this._dateTime.dayOfWeek();
      };
      _proto.hour = function hour() {
        return this._dateTime.hour();
      };
      _proto.minute = function minute() {
        return this._dateTime.minute();
      };
      _proto.second = function second() {
        return this._dateTime.second();
      };
      _proto.nano = function nano() {
        return this._dateTime.nano();
      };
      _proto.toLocalDateTime = function toLocalDateTime() {
        return this._dateTime;
      };
      _proto.toLocalDate = function toLocalDate() {
        return this._dateTime.toLocalDate();
      };
      _proto.toLocalTime = function toLocalTime() {
        return this._dateTime.toLocalTime();
      };
      _proto.toOffsetTime = function toOffsetTime() {
        return OffsetTime.of(this._dateTime.toLocalTime(), this._offset);
      };
      _proto.toZonedDateTime = function toZonedDateTime() {
        return ZonedDateTime.of(this._dateTime, this._offset);
      };
      _proto.toInstant = function toInstant() {
        return this._dateTime.toInstant(this._offset);
      };
      _proto.toEpochSecond = function toEpochSecond() {
        return this._dateTime.toEpochSecond(this._offset);
      };
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (fieldOrUnit instanceof ChronoField) {
          return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
        }
        if (fieldOrUnit instanceof ChronoUnit) {
          return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
        }
        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        if (field instanceof ChronoField) {
          if (field === ChronoField.INSTANT_SECONDS || field === ChronoField.OFFSET_SECONDS) {
            return field.range();
          }
          return this._dateTime.range(field);
        }
        return field.rangeRefinedBy(this);
      };
      _proto._withAdjuster = function _withAdjuster(adjuster) {
        requireNonNull(adjuster);
        if (adjuster instanceof LocalDate || adjuster instanceof LocalTime || adjuster instanceof LocalDateTime) {
          return this._withDateTimeOffset(this._dateTime.with(adjuster), this._offset);
        } else if (adjuster instanceof Instant) {
          return OffsetDateTime2.ofInstant(adjuster, this._offset);
        } else if (adjuster instanceof ZoneOffset) {
          return this._withDateTimeOffset(this._dateTime, adjuster);
        } else if (adjuster instanceof OffsetDateTime2) {
          return adjuster;
        }
        return adjuster.adjustInto(this);
      };
      _proto._withField = function _withField(field, newValue) {
        requireNonNull(field);
        if (field instanceof ChronoField) {
          var f = field;
          switch (f) {
            case ChronoField.INSTANT_SECONDS:
              return OffsetDateTime2.ofInstant(Instant.ofEpochSecond(newValue, this.nano()), this._offset);
            case ChronoField.OFFSET_SECONDS: {
              return this._withDateTimeOffset(this._dateTime, ZoneOffset.ofTotalSeconds(f.checkValidIntValue(newValue)));
            }
          }
          return this._withDateTimeOffset(this._dateTime.with(field, newValue), this._offset);
        }
        return field.adjustInto(this, newValue);
      };
      _proto._withDateTimeOffset = function _withDateTimeOffset(dateTime, offset) {
        if (this._dateTime === dateTime && this._offset.equals(offset)) {
          return this;
        }
        return new OffsetDateTime2(dateTime, offset);
      };
      _proto.withYear = function withYear(year) {
        return this._withDateTimeOffset(this._dateTime.withYear(year), this._offset);
      };
      _proto.withMonth = function withMonth(month) {
        return this._withDateTimeOffset(this._dateTime.withMonth(month), this._offset);
      };
      _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
        return this._withDateTimeOffset(this._dateTime.withDayOfMonth(dayOfMonth), this._offset);
      };
      _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
        return this._withDateTimeOffset(this._dateTime.withDayOfYear(dayOfYear), this._offset);
      };
      _proto.withHour = function withHour(hour) {
        return this._withDateTimeOffset(this._dateTime.withHour(hour), this._offset);
      };
      _proto.withMinute = function withMinute(minute) {
        return this._withDateTimeOffset(this._dateTime.withMinute(minute), this._offset);
      };
      _proto.withSecond = function withSecond(second) {
        return this._withDateTimeOffset(this._dateTime.withSecond(second), this._offset);
      };
      _proto.withNano = function withNano(nanoOfSecond) {
        return this._withDateTimeOffset(this._dateTime.withNano(nanoOfSecond), this._offset);
      };
      _proto.withOffsetSameLocal = function withOffsetSameLocal(offset) {
        requireNonNull(offset, "offset");
        return this._withDateTimeOffset(this._dateTime, offset);
      };
      _proto.withOffsetSameInstant = function withOffsetSameInstant(offset) {
        requireNonNull(offset, "offset");
        if (offset.equals(this._offset)) {
          return this;
        }
        var difference = offset.totalSeconds() - this._offset.totalSeconds();
        var adjusted = this._dateTime.plusSeconds(difference);
        return new OffsetDateTime2(adjusted, offset);
      };
      _proto.truncatedTo = function truncatedTo(unit) {
        return this._withDateTimeOffset(this._dateTime.truncatedTo(unit), this._offset);
      };
      _proto._plusAmount = function _plusAmount(amount) {
        requireNonNull(amount, "amount");
        return amount.addTo(this);
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        if (unit instanceof ChronoUnit) {
          return this._withDateTimeOffset(this._dateTime.plus(amountToAdd, unit), this._offset);
        }
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusYears = function plusYears(years) {
        return this._withDateTimeOffset(this._dateTime.plusYears(years), this._offset);
      };
      _proto.plusMonths = function plusMonths(months) {
        return this._withDateTimeOffset(this._dateTime.plusMonths(months), this._offset);
      };
      _proto.plusWeeks = function plusWeeks(weeks) {
        return this._withDateTimeOffset(this._dateTime.plusWeeks(weeks), this._offset);
      };
      _proto.plusDays = function plusDays(days) {
        return this._withDateTimeOffset(this._dateTime.plusDays(days), this._offset);
      };
      _proto.plusHours = function plusHours(hours) {
        return this._withDateTimeOffset(this._dateTime.plusHours(hours), this._offset);
      };
      _proto.plusMinutes = function plusMinutes(minutes) {
        return this._withDateTimeOffset(this._dateTime.plusMinutes(minutes), this._offset);
      };
      _proto.plusSeconds = function plusSeconds(seconds) {
        return this._withDateTimeOffset(this._dateTime.plusSeconds(seconds), this._offset);
      };
      _proto.plusNanos = function plusNanos(nanos) {
        return this._withDateTimeOffset(this._dateTime.plusNanos(nanos), this._offset);
      };
      _proto._minusAmount = function _minusAmount(amount) {
        requireNonNull(amount);
        return amount.subtractFrom(this);
      };
      _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
        return this.plus(-1 * amountToSubtract, unit);
      };
      _proto.minusYears = function minusYears(years) {
        return this._withDateTimeOffset(this._dateTime.minusYears(years), this._offset);
      };
      _proto.minusMonths = function minusMonths(months) {
        return this._withDateTimeOffset(this._dateTime.minusMonths(months), this._offset);
      };
      _proto.minusWeeks = function minusWeeks(weeks) {
        return this._withDateTimeOffset(this._dateTime.minusWeeks(weeks), this._offset);
      };
      _proto.minusDays = function minusDays(days) {
        return this._withDateTimeOffset(this._dateTime.minusDays(days), this._offset);
      };
      _proto.minusHours = function minusHours(hours) {
        return this._withDateTimeOffset(this._dateTime.minusHours(hours), this._offset);
      };
      _proto.minusMinutes = function minusMinutes(minutes) {
        return this._withDateTimeOffset(this._dateTime.minusMinutes(minutes), this._offset);
      };
      _proto.minusSeconds = function minusSeconds(seconds) {
        return this._withDateTimeOffset(this._dateTime.minusSeconds(seconds), this._offset);
      };
      _proto.minusNanos = function minusNanos(nanos) {
        return this._withDateTimeOffset(this._dateTime.minusNanos(nanos), this._offset);
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, OffsetDateTime2, "other");
        if (this.offset().equals(other.offset())) {
          return this.toLocalDateTime().compareTo(other.toLocalDateTime());
        }
        var cmp = MathUtil.compareNumbers(this.toEpochSecond(), other.toEpochSecond());
        if (cmp === 0) {
          cmp = this.toLocalTime().nano() - other.toLocalTime().nano();
          if (cmp === 0) {
            cmp = this.toLocalDateTime().compareTo(other.toLocalDateTime());
          }
        }
        return cmp;
      };
      _proto.isAfter = function isAfter(other) {
        requireNonNull(other, "other");
        var thisEpochSec = this.toEpochSecond();
        var otherEpochSec = other.toEpochSecond();
        return thisEpochSec > otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() > other.toLocalTime().nano();
      };
      _proto.isBefore = function isBefore(other) {
        requireNonNull(other, "other");
        var thisEpochSec = this.toEpochSecond();
        var otherEpochSec = other.toEpochSecond();
        return thisEpochSec < otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() < other.toLocalTime().nano();
      };
      _proto.isEqual = function isEqual(other) {
        requireNonNull(other, "other");
        return this.toEpochSecond() === other.toEpochSecond() && this.toLocalTime().nano() === other.toLocalTime().nano();
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof OffsetDateTime2) {
          return this._dateTime.equals(other._dateTime) && this._offset.equals(other._offset);
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return this._dateTime.hashCode() ^ this._offset.hashCode();
      };
      _proto.toString = function toString() {
        return this._dateTime.toString() + this._offset.toString();
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        return formatter.format(this);
      };
      return OffsetDateTime2;
    }(Temporal);
    DAYS_PER_CYCLE = 146097;
    DAYS_0000_TO_1970 = DAYS_PER_CYCLE * 5 - (30 * 365 + 7);
    LocalDate = function(_ChronoLocalDate) {
      _inheritsLoose(LocalDate2, _ChronoLocalDate);
      LocalDate2.now = function now(clockOrZone) {
        var clock;
        if (clockOrZone == null) {
          clock = Clock.systemDefaultZone();
        } else if (clockOrZone instanceof ZoneId) {
          clock = Clock.system(clockOrZone);
        } else {
          clock = clockOrZone;
        }
        return LocalDate2.ofInstant(clock.instant(), clock.zone());
      };
      LocalDate2.ofInstant = function ofInstant(instant, zone) {
        if (zone === void 0) {
          zone = ZoneId.systemDefault();
        }
        requireNonNull(instant, "instant");
        var offset = zone.rules().offset(instant);
        var epochSec = instant.epochSecond() + offset.totalSeconds();
        var epochDay = MathUtil.floorDiv(epochSec, LocalTime.SECONDS_PER_DAY);
        return LocalDate2.ofEpochDay(epochDay);
      };
      LocalDate2.of = function of(year, month, dayOfMonth) {
        return new LocalDate2(year, month, dayOfMonth);
      };
      LocalDate2.ofYearDay = function ofYearDay(year, dayOfYear) {
        ChronoField.YEAR.checkValidValue(year);
        var leap = IsoChronology.isLeapYear(year);
        if (dayOfYear === 366 && leap === false) {
          assert(false, "Invalid date 'DayOfYear 366' as '" + year + "' is not a leap year", DateTimeException);
        }
        var moy = Month.of(Math.floor((dayOfYear - 1) / 31 + 1));
        var monthEnd = moy.firstDayOfYear(leap) + moy.length(leap) - 1;
        if (dayOfYear > monthEnd) {
          moy = moy.plus(1);
        }
        var dom = dayOfYear - moy.firstDayOfYear(leap) + 1;
        return new LocalDate2(year, moy.value(), dom);
      };
      LocalDate2.ofEpochDay = function ofEpochDay(epochDay) {
        if (epochDay === void 0) {
          epochDay = 0;
        }
        var adjust, adjustCycles, doyEst, yearEst, zeroDay;
        zeroDay = epochDay + DAYS_0000_TO_1970;
        zeroDay -= 60;
        adjust = 0;
        if (zeroDay < 0) {
          adjustCycles = MathUtil.intDiv(zeroDay + 1, DAYS_PER_CYCLE) - 1;
          adjust = adjustCycles * 400;
          zeroDay += -adjustCycles * DAYS_PER_CYCLE;
        }
        yearEst = MathUtil.intDiv(400 * zeroDay + 591, DAYS_PER_CYCLE);
        doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));
        if (doyEst < 0) {
          yearEst--;
          doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));
        }
        yearEst += adjust;
        var marchDoy0 = doyEst;
        var marchMonth0 = MathUtil.intDiv(marchDoy0 * 5 + 2, 153);
        var month = (marchMonth0 + 2) % 12 + 1;
        var dom = marchDoy0 - MathUtil.intDiv(marchMonth0 * 306 + 5, 10) + 1;
        yearEst += MathUtil.intDiv(marchMonth0, 10);
        var year = yearEst;
        return new LocalDate2(year, month, dom);
      };
      LocalDate2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        var date = temporal.query(TemporalQueries.localDate());
        if (date == null) {
          throw new DateTimeException("Unable to obtain LocalDate from TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
        }
        return date;
      };
      LocalDate2.parse = function parse2(text, formatter) {
        if (formatter === void 0) {
          formatter = DateTimeFormatter.ISO_LOCAL_DATE;
        }
        assert(formatter != null, "formatter", NullPointerException);
        return formatter.parse(text, LocalDate2.FROM);
      };
      LocalDate2._resolvePreviousValid = function _resolvePreviousValid(year, month, day) {
        switch (month) {
          case 2:
            day = Math.min(day, IsoChronology.isLeapYear(year) ? 29 : 28);
            break;
          case 4:
          case 6:
          case 9:
          case 11:
            day = Math.min(day, 30);
            break;
        }
        return LocalDate2.of(year, month, day);
      };
      function LocalDate2(year, month, dayOfMonth) {
        var _this;
        _this = _ChronoLocalDate.call(this) || this;
        requireNonNull(year, "year");
        requireNonNull(month, "month");
        requireNonNull(dayOfMonth, "dayOfMonth");
        if (month instanceof Month) {
          month = month.value();
        }
        _this._year = MathUtil.safeToInt(year);
        _this._month = MathUtil.safeToInt(month);
        _this._day = MathUtil.safeToInt(dayOfMonth);
        LocalDate2._validate(_this._year, _this._month, _this._day);
        return _this;
      }
      LocalDate2._validate = function _validate(year, month, dayOfMonth) {
        var dom;
        ChronoField.YEAR.checkValidValue(year);
        ChronoField.MONTH_OF_YEAR.checkValidValue(month);
        ChronoField.DAY_OF_MONTH.checkValidValue(dayOfMonth);
        if (dayOfMonth > 28) {
          dom = 31;
          switch (month) {
            case 2:
              dom = IsoChronology.isLeapYear(year) ? 29 : 28;
              break;
            case 4:
            case 6:
            case 9:
            case 11:
              dom = 30;
          }
          if (dayOfMonth > dom) {
            if (dayOfMonth === 29) {
              assert(false, "Invalid date 'February 29' as '" + year + "' is not a leap year", DateTimeException);
            } else {
              assert(false, "Invalid date '" + year + "' '" + month + "' '" + dayOfMonth + "'", DateTimeException);
            }
          }
        }
      };
      var _proto = LocalDate2.prototype;
      _proto.isSupported = function isSupported(field) {
        return _ChronoLocalDate.prototype.isSupported.call(this, field);
      };
      _proto.range = function range(field) {
        if (field instanceof ChronoField) {
          if (field.isDateBased()) {
            switch (field) {
              case ChronoField.DAY_OF_MONTH:
                return ValueRange.of(1, this.lengthOfMonth());
              case ChronoField.DAY_OF_YEAR:
                return ValueRange.of(1, this.lengthOfYear());
              case ChronoField.ALIGNED_WEEK_OF_MONTH:
                return ValueRange.of(1, this.month() === Month.FEBRUARY && this.isLeapYear() === false ? 4 : 5);
              case ChronoField.YEAR_OF_ERA:
                return this._year <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE);
            }
            return field.range();
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.rangeRefinedBy(this);
      };
      _proto.get = function get(field) {
        return this.getLong(field);
      };
      _proto.getLong = function getLong(field) {
        assert(field != null, "", NullPointerException);
        if (field instanceof ChronoField) {
          return this._get0(field);
        }
        return field.getFrom(this);
      };
      _proto._get0 = function _get0(field) {
        switch (field) {
          case ChronoField.DAY_OF_WEEK:
            return this.dayOfWeek().value();
          case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH:
            return MathUtil.intMod(this._day - 1, 7) + 1;
          case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR:
            return MathUtil.intMod(this.dayOfYear() - 1, 7) + 1;
          case ChronoField.DAY_OF_MONTH:
            return this._day;
          case ChronoField.DAY_OF_YEAR:
            return this.dayOfYear();
          case ChronoField.EPOCH_DAY:
            return this.toEpochDay();
          case ChronoField.ALIGNED_WEEK_OF_MONTH:
            return MathUtil.intDiv(this._day - 1, 7) + 1;
          case ChronoField.ALIGNED_WEEK_OF_YEAR:
            return MathUtil.intDiv(this.dayOfYear() - 1, 7) + 1;
          case ChronoField.MONTH_OF_YEAR:
            return this._month;
          case ChronoField.PROLEPTIC_MONTH:
            return this._prolepticMonth();
          case ChronoField.YEAR_OF_ERA:
            return this._year >= 1 ? this._year : 1 - this._year;
          case ChronoField.YEAR:
            return this._year;
          case ChronoField.ERA:
            return this._year >= 1 ? 1 : 0;
        }
        throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
      };
      _proto._prolepticMonth = function _prolepticMonth() {
        return this._year * 12 + (this._month - 1);
      };
      _proto.chronology = function chronology() {
        return IsoChronology.INSTANCE;
      };
      _proto.year = function year() {
        return this._year;
      };
      _proto.monthValue = function monthValue() {
        return this._month;
      };
      _proto.month = function month() {
        return Month.of(this._month);
      };
      _proto.dayOfMonth = function dayOfMonth() {
        return this._day;
      };
      _proto.dayOfYear = function dayOfYear() {
        return this.month().firstDayOfYear(this.isLeapYear()) + this._day - 1;
      };
      _proto.dayOfWeek = function dayOfWeek() {
        var dow0 = MathUtil.floorMod(this.toEpochDay() + 3, 7);
        return DayOfWeek.of(dow0 + 1);
      };
      _proto.isLeapYear = function isLeapYear() {
        return IsoChronology.isLeapYear(this._year);
      };
      _proto.lengthOfMonth = function lengthOfMonth() {
        switch (this._month) {
          case 2:
            return this.isLeapYear() ? 29 : 28;
          case 4:
          case 6:
          case 9:
          case 11:
            return 30;
          default:
            return 31;
        }
      };
      _proto.lengthOfYear = function lengthOfYear() {
        return this.isLeapYear() ? 366 : 365;
      };
      _proto._withAdjuster = function _withAdjuster(adjuster) {
        requireNonNull(adjuster, "adjuster");
        if (adjuster instanceof LocalDate2) {
          return adjuster;
        }
        return _ChronoLocalDate.prototype._withAdjuster.call(this, adjuster);
      };
      _proto._withField = function _withField(field, newValue) {
        assert(field != null, "field", NullPointerException);
        if (field instanceof ChronoField) {
          var f = field;
          f.checkValidValue(newValue);
          switch (f) {
            case ChronoField.DAY_OF_WEEK:
              return this.plusDays(newValue - this.dayOfWeek().value());
            case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH:
              return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH));
            case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR:
              return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR));
            case ChronoField.DAY_OF_MONTH:
              return this.withDayOfMonth(newValue);
            case ChronoField.DAY_OF_YEAR:
              return this.withDayOfYear(newValue);
            case ChronoField.EPOCH_DAY:
              return LocalDate2.ofEpochDay(newValue);
            case ChronoField.ALIGNED_WEEK_OF_MONTH:
              return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_MONTH));
            case ChronoField.ALIGNED_WEEK_OF_YEAR:
              return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_YEAR));
            case ChronoField.MONTH_OF_YEAR:
              return this.withMonth(newValue);
            case ChronoField.PROLEPTIC_MONTH:
              return this.plusMonths(newValue - this.getLong(ChronoField.PROLEPTIC_MONTH));
            case ChronoField.YEAR_OF_ERA:
              return this.withYear(this._year >= 1 ? newValue : 1 - newValue);
            case ChronoField.YEAR:
              return this.withYear(newValue);
            case ChronoField.ERA:
              return this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year);
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.adjustInto(this, newValue);
      };
      _proto.withYear = function withYear(year) {
        if (this._year === year) {
          return this;
        }
        ChronoField.YEAR.checkValidValue(year);
        return LocalDate2._resolvePreviousValid(year, this._month, this._day);
      };
      _proto.withMonth = function withMonth(month) {
        var m = month instanceof Month ? month.value() : month;
        if (this._month === m) {
          return this;
        }
        ChronoField.MONTH_OF_YEAR.checkValidValue(m);
        return LocalDate2._resolvePreviousValid(this._year, m, this._day);
      };
      _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
        if (this._day === dayOfMonth) {
          return this;
        }
        return LocalDate2.of(this._year, this._month, dayOfMonth);
      };
      _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
        if (this.dayOfYear() === dayOfYear) {
          return this;
        }
        return LocalDate2.ofYearDay(this._year, dayOfYear);
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        requireNonNull(amountToAdd, "amountToAdd");
        requireNonNull(unit, "unit");
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.DAYS:
              return this.plusDays(amountToAdd);
            case ChronoUnit.WEEKS:
              return this.plusWeeks(amountToAdd);
            case ChronoUnit.MONTHS:
              return this.plusMonths(amountToAdd);
            case ChronoUnit.YEARS:
              return this.plusYears(amountToAdd);
            case ChronoUnit.DECADES:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));
            case ChronoUnit.CENTURIES:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));
            case ChronoUnit.MILLENNIA:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1e3));
            case ChronoUnit.ERAS:
              return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusYears = function plusYears(yearsToAdd) {
        if (yearsToAdd === 0) {
          return this;
        }
        var newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);
        return LocalDate2._resolvePreviousValid(newYear, this._month, this._day);
      };
      _proto.plusMonths = function plusMonths(monthsToAdd) {
        if (monthsToAdd === 0) {
          return this;
        }
        var monthCount = this._year * 12 + (this._month - 1);
        var calcMonths = monthCount + monthsToAdd;
        var newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.floorDiv(calcMonths, 12));
        var newMonth = MathUtil.floorMod(calcMonths, 12) + 1;
        return LocalDate2._resolvePreviousValid(newYear, newMonth, this._day);
      };
      _proto.plusWeeks = function plusWeeks(weeksToAdd) {
        return this.plusDays(MathUtil.safeMultiply(weeksToAdd, 7));
      };
      _proto.plusDays = function plusDays(daysToAdd) {
        if (daysToAdd === 0) {
          return this;
        }
        var mjDay = MathUtil.safeAdd(this.toEpochDay(), daysToAdd);
        return LocalDate2.ofEpochDay(mjDay);
      };
      _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
        requireNonNull(amountToSubtract, "amountToSubtract");
        requireNonNull(unit, "unit");
        return this._plusUnit(-1 * amountToSubtract, unit);
      };
      _proto.minusYears = function minusYears(yearsToSubtract) {
        return this.plusYears(yearsToSubtract * -1);
      };
      _proto.minusMonths = function minusMonths(monthsToSubtract) {
        return this.plusMonths(monthsToSubtract * -1);
      };
      _proto.minusWeeks = function minusWeeks(weeksToSubtract) {
        return this.plusWeeks(weeksToSubtract * -1);
      };
      _proto.minusDays = function minusDays(daysToSubtract) {
        return this.plusDays(daysToSubtract * -1);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        if (_query === TemporalQueries.localDate()) {
          return this;
        }
        return _ChronoLocalDate.prototype.query.call(this, _query);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        return _ChronoLocalDate.prototype.adjustInto.call(this, temporal);
      };
      _proto.until = function until(p1, p2) {
        if (arguments.length < 2) {
          return this.until1(p1);
        } else {
          return this.until2(p1, p2);
        }
      };
      _proto.until2 = function until2(endExclusive, unit) {
        var end = LocalDate2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.DAYS:
              return this.daysUntil(end);
            case ChronoUnit.WEEKS:
              return MathUtil.intDiv(this.daysUntil(end), 7);
            case ChronoUnit.MONTHS:
              return this._monthsUntil(end);
            case ChronoUnit.YEARS:
              return MathUtil.intDiv(this._monthsUntil(end), 12);
            case ChronoUnit.DECADES:
              return MathUtil.intDiv(this._monthsUntil(end), 120);
            case ChronoUnit.CENTURIES:
              return MathUtil.intDiv(this._monthsUntil(end), 1200);
            case ChronoUnit.MILLENNIA:
              return MathUtil.intDiv(this._monthsUntil(end), 12e3);
            case ChronoUnit.ERAS:
              return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.between(this, end);
      };
      _proto.daysUntil = function daysUntil(end) {
        return end.toEpochDay() - this.toEpochDay();
      };
      _proto._monthsUntil = function _monthsUntil(end) {
        var packed1 = this._prolepticMonth() * 32 + this.dayOfMonth();
        var packed2 = end._prolepticMonth() * 32 + end.dayOfMonth();
        return MathUtil.intDiv(packed2 - packed1, 32);
      };
      _proto.until1 = function until1(endDate) {
        var end = LocalDate2.from(endDate);
        var totalMonths = end._prolepticMonth() - this._prolepticMonth();
        var days = end._day - this._day;
        if (totalMonths > 0 && days < 0) {
          totalMonths--;
          var calcDate = this.plusMonths(totalMonths);
          days = end.toEpochDay() - calcDate.toEpochDay();
        } else if (totalMonths < 0 && days > 0) {
          totalMonths++;
          days -= end.lengthOfMonth();
        }
        var years = MathUtil.intDiv(totalMonths, 12);
        var months = MathUtil.intMod(totalMonths, 12);
        return Period.of(years, months, days);
      };
      _proto.atTime = function atTime() {
        if (arguments.length === 1) {
          return this.atTime1.apply(this, arguments);
        } else {
          return this.atTime4.apply(this, arguments);
        }
      };
      _proto.atTime1 = function atTime1(time) {
        requireNonNull(time, "time");
        if (time instanceof LocalTime) {
          return LocalDateTime.of(this, time);
        } else if (time instanceof OffsetTime) {
          return this._atTimeOffsetTime(time);
        } else {
          throw new IllegalArgumentException("time must be an instance of LocalTime or OffsetTime" + (time && time.constructor && time.constructor.name ? ", but is " + time.constructor.name : ""));
        }
      };
      _proto.atTime4 = function atTime4(hour, minute, second, nanoOfSecond) {
        if (second === void 0) {
          second = 0;
        }
        if (nanoOfSecond === void 0) {
          nanoOfSecond = 0;
        }
        return this.atTime1(LocalTime.of(hour, minute, second, nanoOfSecond));
      };
      _proto._atTimeOffsetTime = function _atTimeOffsetTime(time) {
        return OffsetDateTime.of(LocalDateTime.of(this, time.toLocalTime()), time.offset());
      };
      _proto.atStartOfDay = function atStartOfDay(zone) {
        if (zone != null) {
          return this._atStartOfDayWithZone(zone);
        } else {
          return LocalDateTime.of(this, LocalTime.MIDNIGHT);
        }
      };
      _proto._atStartOfDayWithZone = function _atStartOfDayWithZone(zone) {
        requireNonNull(zone, "zone");
        var ldt = this.atTime(LocalTime.MIDNIGHT);
        if (zone instanceof ZoneOffset === false) {
          var trans = zone.rules().transition(ldt);
          if (trans != null && trans.isGap()) {
            ldt = trans.dateTimeAfter();
          }
        }
        return ZonedDateTime.of(ldt, zone);
      };
      _proto.toEpochDay = function toEpochDay() {
        var y = this._year;
        var m = this._month;
        var total = 0;
        total += 365 * y;
        if (y >= 0) {
          total += MathUtil.intDiv(y + 3, 4) - MathUtil.intDiv(y + 99, 100) + MathUtil.intDiv(y + 399, 400);
        } else {
          total -= MathUtil.intDiv(y, -4) - MathUtil.intDiv(y, -100) + MathUtil.intDiv(y, -400);
        }
        total += MathUtil.intDiv(367 * m - 362, 12);
        total += this.dayOfMonth() - 1;
        if (m > 2) {
          total--;
          if (!IsoChronology.isLeapYear(y)) {
            total--;
          }
        }
        return total - DAYS_0000_TO_1970;
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, LocalDate2, "other");
        return this._compareTo0(other);
      };
      _proto._compareTo0 = function _compareTo0(otherDate) {
        var cmp = this._year - otherDate._year;
        if (cmp === 0) {
          cmp = this._month - otherDate._month;
          if (cmp === 0) {
            cmp = this._day - otherDate._day;
          }
        }
        return cmp;
      };
      _proto.isAfter = function isAfter(other) {
        return this.compareTo(other) > 0;
      };
      _proto.isBefore = function isBefore(other) {
        return this.compareTo(other) < 0;
      };
      _proto.isEqual = function isEqual(other) {
        return this.compareTo(other) === 0;
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof LocalDate2) {
          return this._compareTo0(other) === 0;
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        var yearValue = this._year;
        var monthValue = this._month;
        var dayValue = this._day;
        return MathUtil.hash(yearValue & 4294965248 ^ (yearValue << 11) + (monthValue << 6) + dayValue);
      };
      _proto.toString = function toString() {
        var dayString, monthString, yearString;
        var yearValue = this._year;
        var monthValue = this._month;
        var dayValue = this._day;
        var absYear = Math.abs(yearValue);
        if (absYear < 1e3) {
          if (yearValue < 0) {
            yearString = "-" + ("" + (yearValue - 1e4)).slice(-4);
          } else {
            yearString = ("" + (yearValue + 1e4)).slice(-4);
          }
        } else {
          if (yearValue > 9999) {
            yearString = "+" + yearValue;
          } else {
            yearString = "" + yearValue;
          }
        }
        if (monthValue < 10) {
          monthString = "-0" + monthValue;
        } else {
          monthString = "-" + monthValue;
        }
        if (dayValue < 10) {
          dayString = "-0" + dayValue;
        } else {
          dayString = "-" + dayValue;
        }
        return yearString + monthString + dayString;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        requireInstance(formatter, DateTimeFormatter, "formatter");
        return _ChronoLocalDate.prototype.format.call(this, formatter);
      };
      return LocalDate2;
    }(ChronoLocalDate);
    ChronoLocalDateTime = function(_Temporal) {
      _inheritsLoose(ChronoLocalDateTime2, _Temporal);
      function ChronoLocalDateTime2() {
        return _Temporal.apply(this, arguments) || this;
      }
      var _proto = ChronoLocalDateTime2.prototype;
      _proto.chronology = function chronology() {
        return this.toLocalDate().chronology();
      };
      _proto.query = function query(_query) {
        if (_query === TemporalQueries.chronology()) {
          return this.chronology();
        } else if (_query === TemporalQueries.precision()) {
          return ChronoUnit.NANOS;
        } else if (_query === TemporalQueries.localDate()) {
          return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());
        } else if (_query === TemporalQueries.localTime()) {
          return this.toLocalTime();
        } else if (_query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
          return null;
        }
        return _Temporal.prototype.query.call(this, _query);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        return temporal.with(ChronoField.EPOCH_DAY, this.toLocalDate().toEpochDay()).with(ChronoField.NANO_OF_DAY, this.toLocalTime().toNanoOfDay());
      };
      _proto.toInstant = function toInstant(offset) {
        requireInstance(offset, ZoneOffset, "zoneId");
        return Instant.ofEpochSecond(this.toEpochSecond(offset), this.toLocalTime().nano());
      };
      _proto.toEpochSecond = function toEpochSecond(offset) {
        requireNonNull(offset, "offset");
        var epochDay = this.toLocalDate().toEpochDay();
        var secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();
        secs -= offset.totalSeconds();
        return MathUtil.safeToInt(secs);
      };
      return ChronoLocalDateTime2;
    }(Temporal);
    LocalDateTime = function(_ChronoLocalDateTime) {
      _inheritsLoose(LocalDateTime2, _ChronoLocalDateTime);
      LocalDateTime2.now = function now(clockOrZone) {
        if (clockOrZone == null) {
          return LocalDateTime2._now(Clock.systemDefaultZone());
        } else if (clockOrZone instanceof Clock) {
          return LocalDateTime2._now(clockOrZone);
        } else {
          return LocalDateTime2._now(Clock.system(clockOrZone));
        }
      };
      LocalDateTime2._now = function _now(clock) {
        requireNonNull(clock, "clock");
        return LocalDateTime2.ofInstant(clock.instant(), clock.zone());
      };
      LocalDateTime2._ofEpochMillis = function _ofEpochMillis(epochMilli, offset) {
        var localSecond = MathUtil.floorDiv(epochMilli, 1e3) + offset.totalSeconds();
        var localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);
        var secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);
        var nanoOfSecond = MathUtil.floorMod(epochMilli, 1e3) * 1e6;
        var date = LocalDate.ofEpochDay(localEpochDay);
        var time = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);
        return new LocalDateTime2(date, time);
      };
      LocalDateTime2.of = function of() {
        if (arguments.length <= 2) {
          return LocalDateTime2.ofDateAndTime.apply(this, arguments);
        } else {
          return LocalDateTime2.ofNumbers.apply(this, arguments);
        }
      };
      LocalDateTime2.ofNumbers = function ofNumbers(year, month, dayOfMonth, hour, minute, second, nanoOfSecond) {
        if (hour === void 0) {
          hour = 0;
        }
        if (minute === void 0) {
          minute = 0;
        }
        if (second === void 0) {
          second = 0;
        }
        if (nanoOfSecond === void 0) {
          nanoOfSecond = 0;
        }
        var date = LocalDate.of(year, month, dayOfMonth);
        var time = LocalTime.of(hour, minute, second, nanoOfSecond);
        return new LocalDateTime2(date, time);
      };
      LocalDateTime2.ofDateAndTime = function ofDateAndTime(date, time) {
        requireNonNull(date, "date");
        requireNonNull(time, "time");
        return new LocalDateTime2(date, time);
      };
      LocalDateTime2.ofInstant = function ofInstant(instant, zone) {
        if (zone === void 0) {
          zone = ZoneId.systemDefault();
        }
        requireNonNull(instant, "instant");
        requireInstance(instant, Instant, "instant");
        requireNonNull(zone, "zone");
        var offset = zone.rules().offset(instant);
        return LocalDateTime2.ofEpochSecond(instant.epochSecond(), instant.nano(), offset);
      };
      LocalDateTime2.ofEpochSecond = function ofEpochSecond(epochSecond, nanoOfSecond, offset) {
        if (epochSecond === void 0) {
          epochSecond = 0;
        }
        if (nanoOfSecond === void 0) {
          nanoOfSecond = 0;
        }
        if (arguments.length === 2 && nanoOfSecond instanceof ZoneOffset) {
          offset = nanoOfSecond;
          nanoOfSecond = 0;
        }
        requireNonNull(offset, "offset");
        var localSecond = epochSecond + offset.totalSeconds();
        var localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);
        var secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);
        var date = LocalDate.ofEpochDay(localEpochDay);
        var time = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);
        return new LocalDateTime2(date, time);
      };
      LocalDateTime2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        if (temporal instanceof LocalDateTime2) {
          return temporal;
        } else if (temporal instanceof ZonedDateTime) {
          return temporal.toLocalDateTime();
        }
        try {
          var date = LocalDate.from(temporal);
          var time = LocalTime.from(temporal);
          return new LocalDateTime2(date, time);
        } catch (ex) {
          throw new DateTimeException("Unable to obtain LocalDateTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
        }
      };
      LocalDateTime2.parse = function parse2(text, formatter) {
        if (formatter === void 0) {
          formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;
        }
        requireNonNull(formatter, "formatter");
        return formatter.parse(text, LocalDateTime2.FROM);
      };
      function LocalDateTime2(date, time) {
        var _this;
        _this = _ChronoLocalDateTime.call(this) || this;
        requireInstance(date, LocalDate, "date");
        requireInstance(time, LocalTime, "time");
        _this._date = date;
        _this._time = time;
        return _this;
      }
      var _proto = LocalDateTime2.prototype;
      _proto._withDateTime = function _withDateTime(newDate, newTime) {
        if (this._date.equals(newDate) && this._time.equals(newTime)) {
          return this;
        }
        return new LocalDateTime2(newDate, newTime);
      };
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (fieldOrUnit instanceof ChronoField) {
          return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
        } else if (fieldOrUnit instanceof ChronoUnit) {
          return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
        }
        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        if (field instanceof ChronoField) {
          return field.isTimeBased() ? this._time.range(field) : this._date.range(field);
        }
        return field.rangeRefinedBy(this);
      };
      _proto.get = function get(field) {
        if (field instanceof ChronoField) {
          return field.isTimeBased() ? this._time.get(field) : this._date.get(field);
        }
        return _ChronoLocalDateTime.prototype.get.call(this, field);
      };
      _proto.getLong = function getLong(field) {
        requireNonNull(field, "field");
        if (field instanceof ChronoField) {
          return field.isTimeBased() ? this._time.getLong(field) : this._date.getLong(field);
        }
        return field.getFrom(this);
      };
      _proto.year = function year() {
        return this._date.year();
      };
      _proto.monthValue = function monthValue() {
        return this._date.monthValue();
      };
      _proto.month = function month() {
        return this._date.month();
      };
      _proto.dayOfMonth = function dayOfMonth() {
        return this._date.dayOfMonth();
      };
      _proto.dayOfYear = function dayOfYear() {
        return this._date.dayOfYear();
      };
      _proto.dayOfWeek = function dayOfWeek() {
        return this._date.dayOfWeek();
      };
      _proto.hour = function hour() {
        return this._time.hour();
      };
      _proto.minute = function minute() {
        return this._time.minute();
      };
      _proto.second = function second() {
        return this._time.second();
      };
      _proto.nano = function nano() {
        return this._time.nano();
      };
      _proto._withAdjuster = function _withAdjuster(adjuster) {
        requireNonNull(adjuster, "adjuster");
        if (adjuster instanceof LocalDate) {
          return this._withDateTime(adjuster, this._time);
        } else if (adjuster instanceof LocalTime) {
          return this._withDateTime(this._date, adjuster);
        } else if (adjuster instanceof LocalDateTime2) {
          return adjuster;
        }
        return _ChronoLocalDateTime.prototype._withAdjuster.call(this, adjuster);
      };
      _proto._withField = function _withField(field, newValue) {
        requireNonNull(field, "field");
        if (field instanceof ChronoField) {
          if (field.isTimeBased()) {
            return this._withDateTime(this._date, this._time.with(field, newValue));
          } else {
            return this._withDateTime(this._date.with(field, newValue), this._time);
          }
        }
        return field.adjustInto(this, newValue);
      };
      _proto.withYear = function withYear(year) {
        return this._withDateTime(this._date.withYear(year), this._time);
      };
      _proto.withMonth = function withMonth(month) {
        return this._withDateTime(this._date.withMonth(month), this._time);
      };
      _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
        return this._withDateTime(this._date.withDayOfMonth(dayOfMonth), this._time);
      };
      _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
        return this._withDateTime(this._date.withDayOfYear(dayOfYear), this._time);
      };
      _proto.withHour = function withHour(hour) {
        var newTime = this._time.withHour(hour);
        return this._withDateTime(this._date, newTime);
      };
      _proto.withMinute = function withMinute(minute) {
        var newTime = this._time.withMinute(minute);
        return this._withDateTime(this._date, newTime);
      };
      _proto.withSecond = function withSecond(second) {
        var newTime = this._time.withSecond(second);
        return this._withDateTime(this._date, newTime);
      };
      _proto.withNano = function withNano(nanoOfSecond) {
        var newTime = this._time.withNano(nanoOfSecond);
        return this._withDateTime(this._date, newTime);
      };
      _proto.truncatedTo = function truncatedTo(unit) {
        return this._withDateTime(this._date, this._time.truncatedTo(unit));
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        requireNonNull(unit, "unit");
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.NANOS:
              return this.plusNanos(amountToAdd);
            case ChronoUnit.MICROS:
              return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MICROS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MICROS_PER_DAY) * 1e3);
            case ChronoUnit.MILLIS:
              return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MILLIS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MILLIS_PER_DAY) * 1e6);
            case ChronoUnit.SECONDS:
              return this.plusSeconds(amountToAdd);
            case ChronoUnit.MINUTES:
              return this.plusMinutes(amountToAdd);
            case ChronoUnit.HOURS:
              return this.plusHours(amountToAdd);
            case ChronoUnit.HALF_DAYS:
              return this.plusDays(MathUtil.intDiv(amountToAdd, 256)).plusHours(MathUtil.intMod(amountToAdd, 256) * 12);
          }
          return this._withDateTime(this._date.plus(amountToAdd, unit), this._time);
        }
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusYears = function plusYears(years) {
        var newDate = this._date.plusYears(years);
        return this._withDateTime(newDate, this._time);
      };
      _proto.plusMonths = function plusMonths(months) {
        var newDate = this._date.plusMonths(months);
        return this._withDateTime(newDate, this._time);
      };
      _proto.plusWeeks = function plusWeeks(weeks) {
        var newDate = this._date.plusWeeks(weeks);
        return this._withDateTime(newDate, this._time);
      };
      _proto.plusDays = function plusDays(days) {
        var newDate = this._date.plusDays(days);
        return this._withDateTime(newDate, this._time);
      };
      _proto.plusHours = function plusHours(hours) {
        return this._plusWithOverflow(this._date, hours, 0, 0, 0, 1);
      };
      _proto.plusMinutes = function plusMinutes(minutes) {
        return this._plusWithOverflow(this._date, 0, minutes, 0, 0, 1);
      };
      _proto.plusSeconds = function plusSeconds(seconds) {
        return this._plusWithOverflow(this._date, 0, 0, seconds, 0, 1);
      };
      _proto.plusNanos = function plusNanos(nanos) {
        return this._plusWithOverflow(this._date, 0, 0, 0, nanos, 1);
      };
      _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
        requireNonNull(unit, "unit");
        return this._plusUnit(-1 * amountToSubtract, unit);
      };
      _proto.minusYears = function minusYears(years) {
        return this.plusYears(-1 * years);
      };
      _proto.minusMonths = function minusMonths(months) {
        return this.plusMonths(-1 * months);
      };
      _proto.minusWeeks = function minusWeeks(weeks) {
        return this.plusWeeks(-1 * weeks);
      };
      _proto.minusDays = function minusDays(days) {
        return this.plusDays(-1 * days);
      };
      _proto.minusHours = function minusHours(hours) {
        return this._plusWithOverflow(this._date, hours, 0, 0, 0, -1);
      };
      _proto.minusMinutes = function minusMinutes(minutes) {
        return this._plusWithOverflow(this._date, 0, minutes, 0, 0, -1);
      };
      _proto.minusSeconds = function minusSeconds(seconds) {
        return this._plusWithOverflow(this._date, 0, 0, seconds, 0, -1);
      };
      _proto.minusNanos = function minusNanos(nanos) {
        return this._plusWithOverflow(this._date, 0, 0, 0, nanos, -1);
      };
      _proto._plusWithOverflow = function _plusWithOverflow(newDate, hours, minutes, seconds, nanos, sign2) {
        if (hours === 0 && minutes === 0 && seconds === 0 && nanos === 0) {
          return this._withDateTime(newDate, this._time);
        }
        var totDays = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_DAY) + MathUtil.intDiv(seconds, LocalTime.SECONDS_PER_DAY) + MathUtil.intDiv(minutes, LocalTime.MINUTES_PER_DAY) + MathUtil.intDiv(hours, LocalTime.HOURS_PER_DAY);
        totDays *= sign2;
        var totNanos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_DAY) + MathUtil.intMod(seconds, LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + MathUtil.intMod(minutes, LocalTime.MINUTES_PER_DAY) * LocalTime.NANOS_PER_MINUTE + MathUtil.intMod(hours, LocalTime.HOURS_PER_DAY) * LocalTime.NANOS_PER_HOUR;
        var curNoD = this._time.toNanoOfDay();
        totNanos = totNanos * sign2 + curNoD;
        totDays += MathUtil.floorDiv(totNanos, LocalTime.NANOS_PER_DAY);
        var newNoD = MathUtil.floorMod(totNanos, LocalTime.NANOS_PER_DAY);
        var newTime = newNoD === curNoD ? this._time : LocalTime.ofNanoOfDay(newNoD);
        return this._withDateTime(newDate.plusDays(totDays), newTime);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        if (_query === TemporalQueries.localDate()) {
          return this.toLocalDate();
        }
        return _ChronoLocalDateTime.prototype.query.call(this, _query);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        return _ChronoLocalDateTime.prototype.adjustInto.call(this, temporal);
      };
      _proto.until = function until(endExclusive, unit) {
        requireNonNull(endExclusive, "endExclusive");
        requireNonNull(unit, "unit");
        var end = LocalDateTime2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          if (unit.isTimeBased()) {
            var daysUntil = this._date.daysUntil(end._date);
            var timeUntil = end._time.toNanoOfDay() - this._time.toNanoOfDay();
            if (daysUntil > 0 && timeUntil < 0) {
              daysUntil--;
              timeUntil += LocalTime.NANOS_PER_DAY;
            } else if (daysUntil < 0 && timeUntil > 0) {
              daysUntil++;
              timeUntil -= LocalTime.NANOS_PER_DAY;
            }
            var amount = daysUntil;
            switch (unit) {
              case ChronoUnit.NANOS:
                amount = MathUtil.safeMultiply(amount, LocalTime.NANOS_PER_DAY);
                return MathUtil.safeAdd(amount, timeUntil);
              case ChronoUnit.MICROS:
                amount = MathUtil.safeMultiply(amount, LocalTime.MICROS_PER_DAY);
                return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1e3));
              case ChronoUnit.MILLIS:
                amount = MathUtil.safeMultiply(amount, LocalTime.MILLIS_PER_DAY);
                return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1e6));
              case ChronoUnit.SECONDS:
                amount = MathUtil.safeMultiply(amount, LocalTime.SECONDS_PER_DAY);
                return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_SECOND));
              case ChronoUnit.MINUTES:
                amount = MathUtil.safeMultiply(amount, LocalTime.MINUTES_PER_DAY);
                return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_MINUTE));
              case ChronoUnit.HOURS:
                amount = MathUtil.safeMultiply(amount, LocalTime.HOURS_PER_DAY);
                return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_HOUR));
              case ChronoUnit.HALF_DAYS:
                amount = MathUtil.safeMultiply(amount, 2);
                return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_HOUR * 12));
            }
            throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
          }
          var endDate = end._date;
          var endTime = end._time;
          if (endDate.isAfter(this._date) && endTime.isBefore(this._time)) {
            endDate = endDate.minusDays(1);
          } else if (endDate.isBefore(this._date) && endTime.isAfter(this._time)) {
            endDate = endDate.plusDays(1);
          }
          return this._date.until(endDate, unit);
        }
        return unit.between(this, end);
      };
      _proto.atOffset = function atOffset(offset) {
        return OffsetDateTime.of(this, offset);
      };
      _proto.atZone = function atZone(zone) {
        return ZonedDateTime.of(this, zone);
      };
      _proto.toLocalDate = function toLocalDate() {
        return this._date;
      };
      _proto.toLocalTime = function toLocalTime() {
        return this._time;
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, LocalDateTime2, "other");
        return this._compareTo0(other);
      };
      _proto._compareTo0 = function _compareTo0(other) {
        var cmp = this._date.compareTo(other.toLocalDate());
        if (cmp === 0) {
          cmp = this._time.compareTo(other.toLocalTime());
        }
        return cmp;
      };
      _proto.isAfter = function isAfter(other) {
        return this.compareTo(other) > 0;
      };
      _proto.isBefore = function isBefore(other) {
        return this.compareTo(other) < 0;
      };
      _proto.isEqual = function isEqual(other) {
        return this.compareTo(other) === 0;
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof LocalDateTime2) {
          return this._date.equals(other._date) && this._time.equals(other._time);
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return this._date.hashCode() ^ this._time.hashCode();
      };
      _proto.toString = function toString() {
        return this._date.toString() + "T" + this._time.toString();
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        return formatter.format(this);
      };
      return LocalDateTime2;
    }(ChronoLocalDateTime);
    LocalTime = function(_Temporal) {
      _inheritsLoose(LocalTime2, _Temporal);
      LocalTime2.now = function now(clockOrZone) {
        if (clockOrZone == null) {
          return LocalTime2._now(Clock.systemDefaultZone());
        } else if (clockOrZone instanceof Clock) {
          return LocalTime2._now(clockOrZone);
        } else {
          return LocalTime2._now(Clock.system(clockOrZone));
        }
      };
      LocalTime2._now = function _now(clock) {
        if (clock === void 0) {
          clock = Clock.systemDefaultZone();
        }
        requireNonNull(clock, "clock");
        return LocalTime2.ofInstant(clock.instant(), clock.zone());
      };
      LocalTime2.ofInstant = function ofInstant(instant, zone) {
        if (zone === void 0) {
          zone = ZoneId.systemDefault();
        }
        var offset = zone.rules().offset(instant);
        var secsOfDay = MathUtil.intMod(instant.epochSecond(), LocalTime2.SECONDS_PER_DAY);
        secsOfDay = MathUtil.intMod(secsOfDay + offset.totalSeconds(), LocalTime2.SECONDS_PER_DAY);
        if (secsOfDay < 0) {
          secsOfDay += LocalTime2.SECONDS_PER_DAY;
        }
        return LocalTime2.ofSecondOfDay(secsOfDay, instant.nano());
      };
      LocalTime2.of = function of(hour, minute, second, nanoOfSecond) {
        return new LocalTime2(hour, minute, second, nanoOfSecond);
      };
      LocalTime2.ofSecondOfDay = function ofSecondOfDay(secondOfDay, nanoOfSecond) {
        if (secondOfDay === void 0) {
          secondOfDay = 0;
        }
        if (nanoOfSecond === void 0) {
          nanoOfSecond = 0;
        }
        ChronoField.SECOND_OF_DAY.checkValidValue(secondOfDay);
        ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);
        var hours = MathUtil.intDiv(secondOfDay, LocalTime2.SECONDS_PER_HOUR);
        secondOfDay -= hours * LocalTime2.SECONDS_PER_HOUR;
        var minutes = MathUtil.intDiv(secondOfDay, LocalTime2.SECONDS_PER_MINUTE);
        secondOfDay -= minutes * LocalTime2.SECONDS_PER_MINUTE;
        return new LocalTime2(hours, minutes, secondOfDay, nanoOfSecond);
      };
      LocalTime2.ofNanoOfDay = function ofNanoOfDay(nanoOfDay) {
        if (nanoOfDay === void 0) {
          nanoOfDay = 0;
        }
        ChronoField.NANO_OF_DAY.checkValidValue(nanoOfDay);
        var hours = MathUtil.intDiv(nanoOfDay, LocalTime2.NANOS_PER_HOUR);
        nanoOfDay -= hours * LocalTime2.NANOS_PER_HOUR;
        var minutes = MathUtil.intDiv(nanoOfDay, LocalTime2.NANOS_PER_MINUTE);
        nanoOfDay -= minutes * LocalTime2.NANOS_PER_MINUTE;
        var seconds = MathUtil.intDiv(nanoOfDay, LocalTime2.NANOS_PER_SECOND);
        nanoOfDay -= seconds * LocalTime2.NANOS_PER_SECOND;
        return new LocalTime2(hours, minutes, seconds, nanoOfDay);
      };
      LocalTime2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        var time = temporal.query(TemporalQueries.localTime());
        if (time == null) {
          throw new DateTimeException("Unable to obtain LocalTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
        }
        return time;
      };
      LocalTime2.parse = function parse2(text, formatter) {
        if (formatter === void 0) {
          formatter = DateTimeFormatter.ISO_LOCAL_TIME;
        }
        requireNonNull(formatter, "formatter");
        return formatter.parse(text, LocalTime2.FROM);
      };
      function LocalTime2(hour, minute, second, nanoOfSecond) {
        var _this;
        if (hour === void 0) {
          hour = 0;
        }
        if (minute === void 0) {
          minute = 0;
        }
        if (second === void 0) {
          second = 0;
        }
        if (nanoOfSecond === void 0) {
          nanoOfSecond = 0;
        }
        _this = _Temporal.call(this) || this;
        var _hour = MathUtil.safeToInt(hour);
        var _minute = MathUtil.safeToInt(minute);
        var _second = MathUtil.safeToInt(second);
        var _nanoOfSecond = MathUtil.safeToInt(nanoOfSecond);
        LocalTime2._validate(_hour, _minute, _second, _nanoOfSecond);
        if (_minute === 0 && _second === 0 && _nanoOfSecond === 0) {
          if (!LocalTime2.HOURS[_hour]) {
            _this._hour = _hour;
            _this._minute = _minute;
            _this._second = _second;
            _this._nano = _nanoOfSecond;
            LocalTime2.HOURS[_hour] = _assertThisInitialized(_this);
          }
          return LocalTime2.HOURS[_hour] || _assertThisInitialized(_this);
        }
        _this._hour = _hour;
        _this._minute = _minute;
        _this._second = _second;
        _this._nano = _nanoOfSecond;
        return _this;
      }
      LocalTime2._validate = function _validate(hour, minute, second, nanoOfSecond) {
        ChronoField.HOUR_OF_DAY.checkValidValue(hour);
        ChronoField.MINUTE_OF_HOUR.checkValidValue(minute);
        ChronoField.SECOND_OF_MINUTE.checkValidValue(second);
        ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);
      };
      var _proto = LocalTime2.prototype;
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (fieldOrUnit instanceof ChronoField) {
          return fieldOrUnit.isTimeBased();
        } else if (fieldOrUnit instanceof ChronoUnit) {
          return fieldOrUnit.isTimeBased();
        }
        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        requireNonNull(field);
        return _Temporal.prototype.range.call(this, field);
      };
      _proto.get = function get(field) {
        return this.getLong(field);
      };
      _proto.getLong = function getLong(field) {
        requireNonNull(field, "field");
        if (field instanceof ChronoField) {
          return this._get0(field);
        }
        return field.getFrom(this);
      };
      _proto._get0 = function _get0(field) {
        switch (field) {
          case ChronoField.NANO_OF_SECOND:
            return this._nano;
          case ChronoField.NANO_OF_DAY:
            return this.toNanoOfDay();
          case ChronoField.MICRO_OF_SECOND:
            return MathUtil.intDiv(this._nano, 1e3);
          case ChronoField.MICRO_OF_DAY:
            return MathUtil.intDiv(this.toNanoOfDay(), 1e3);
          case ChronoField.MILLI_OF_SECOND:
            return MathUtil.intDiv(this._nano, 1e6);
          case ChronoField.MILLI_OF_DAY:
            return MathUtil.intDiv(this.toNanoOfDay(), 1e6);
          case ChronoField.SECOND_OF_MINUTE:
            return this._second;
          case ChronoField.SECOND_OF_DAY:
            return this.toSecondOfDay();
          case ChronoField.MINUTE_OF_HOUR:
            return this._minute;
          case ChronoField.MINUTE_OF_DAY:
            return this._hour * 60 + this._minute;
          case ChronoField.HOUR_OF_AMPM:
            return MathUtil.intMod(this._hour, 12);
          case ChronoField.CLOCK_HOUR_OF_AMPM: {
            var ham = MathUtil.intMod(this._hour, 12);
            return ham % 12 === 0 ? 12 : ham;
          }
          case ChronoField.HOUR_OF_DAY:
            return this._hour;
          case ChronoField.CLOCK_HOUR_OF_DAY:
            return this._hour === 0 ? 24 : this._hour;
          case ChronoField.AMPM_OF_DAY:
            return MathUtil.intDiv(this._hour, 12);
        }
        throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
      };
      _proto.hour = function hour() {
        return this._hour;
      };
      _proto.minute = function minute() {
        return this._minute;
      };
      _proto.second = function second() {
        return this._second;
      };
      _proto.nano = function nano() {
        return this._nano;
      };
      _proto._withAdjuster = function _withAdjuster(adjuster) {
        requireNonNull(adjuster, "adjuster");
        if (adjuster instanceof LocalTime2) {
          return adjuster;
        }
        return _Temporal.prototype._withAdjuster.call(this, adjuster);
      };
      _proto._withField = function _withField(field, newValue) {
        requireNonNull(field, "field");
        requireInstance(field, TemporalField, "field");
        if (field instanceof ChronoField) {
          field.checkValidValue(newValue);
          switch (field) {
            case ChronoField.NANO_OF_SECOND:
              return this.withNano(newValue);
            case ChronoField.NANO_OF_DAY:
              return LocalTime2.ofNanoOfDay(newValue);
            case ChronoField.MICRO_OF_SECOND:
              return this.withNano(newValue * 1e3);
            case ChronoField.MICRO_OF_DAY:
              return LocalTime2.ofNanoOfDay(newValue * 1e3);
            case ChronoField.MILLI_OF_SECOND:
              return this.withNano(newValue * 1e6);
            case ChronoField.MILLI_OF_DAY:
              return LocalTime2.ofNanoOfDay(newValue * 1e6);
            case ChronoField.SECOND_OF_MINUTE:
              return this.withSecond(newValue);
            case ChronoField.SECOND_OF_DAY:
              return this.plusSeconds(newValue - this.toSecondOfDay());
            case ChronoField.MINUTE_OF_HOUR:
              return this.withMinute(newValue);
            case ChronoField.MINUTE_OF_DAY:
              return this.plusMinutes(newValue - (this._hour * 60 + this._minute));
            case ChronoField.HOUR_OF_AMPM:
              return this.plusHours(newValue - MathUtil.intMod(this._hour, 12));
            case ChronoField.CLOCK_HOUR_OF_AMPM:
              return this.plusHours((newValue === 12 ? 0 : newValue) - MathUtil.intMod(this._hour, 12));
            case ChronoField.HOUR_OF_DAY:
              return this.withHour(newValue);
            case ChronoField.CLOCK_HOUR_OF_DAY:
              return this.withHour(newValue === 24 ? 0 : newValue);
            case ChronoField.AMPM_OF_DAY:
              return this.plusHours((newValue - MathUtil.intDiv(this._hour, 12)) * 12);
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.adjustInto(this, newValue);
      };
      _proto.withHour = function withHour(hour) {
        if (hour === void 0) {
          hour = 0;
        }
        if (this._hour === hour) {
          return this;
        }
        return new LocalTime2(hour, this._minute, this._second, this._nano);
      };
      _proto.withMinute = function withMinute(minute) {
        if (minute === void 0) {
          minute = 0;
        }
        if (this._minute === minute) {
          return this;
        }
        return new LocalTime2(this._hour, minute, this._second, this._nano);
      };
      _proto.withSecond = function withSecond(second) {
        if (second === void 0) {
          second = 0;
        }
        if (this._second === second) {
          return this;
        }
        return new LocalTime2(this._hour, this._minute, second, this._nano);
      };
      _proto.withNano = function withNano(nanoOfSecond) {
        if (nanoOfSecond === void 0) {
          nanoOfSecond = 0;
        }
        if (this._nano === nanoOfSecond) {
          return this;
        }
        return new LocalTime2(this._hour, this._minute, this._second, nanoOfSecond);
      };
      _proto.truncatedTo = function truncatedTo(unit) {
        requireNonNull(unit, "unit");
        if (unit === ChronoUnit.NANOS) {
          return this;
        }
        var unitDur = unit.duration();
        if (unitDur.seconds() > LocalTime2.SECONDS_PER_DAY) {
          throw new DateTimeException("Unit is too large to be used for truncation");
        }
        var dur = unitDur.toNanos();
        if (MathUtil.intMod(LocalTime2.NANOS_PER_DAY, dur) !== 0) {
          throw new DateTimeException("Unit must divide into a standard day without remainder");
        }
        var nod = this.toNanoOfDay();
        return LocalTime2.ofNanoOfDay(MathUtil.intDiv(nod, dur) * dur);
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        requireNonNull(unit, "unit");
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.NANOS:
              return this.plusNanos(amountToAdd);
            case ChronoUnit.MICROS:
              return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime2.MICROS_PER_DAY) * 1e3);
            case ChronoUnit.MILLIS:
              return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime2.MILLIS_PER_DAY) * 1e6);
            case ChronoUnit.SECONDS:
              return this.plusSeconds(amountToAdd);
            case ChronoUnit.MINUTES:
              return this.plusMinutes(amountToAdd);
            case ChronoUnit.HOURS:
              return this.plusHours(amountToAdd);
            case ChronoUnit.HALF_DAYS:
              return this.plusHours(MathUtil.intMod(amountToAdd, 2) * 12);
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusHours = function plusHours(hoursToAdd) {
        if (hoursToAdd === 0) {
          return this;
        }
        var newHour = MathUtil.intMod(MathUtil.intMod(hoursToAdd, LocalTime2.HOURS_PER_DAY) + this._hour + LocalTime2.HOURS_PER_DAY, LocalTime2.HOURS_PER_DAY);
        return new LocalTime2(newHour, this._minute, this._second, this._nano);
      };
      _proto.plusMinutes = function plusMinutes(minutesToAdd) {
        if (minutesToAdd === 0) {
          return this;
        }
        var mofd = this._hour * LocalTime2.MINUTES_PER_HOUR + this._minute;
        var newMofd = MathUtil.intMod(MathUtil.intMod(minutesToAdd, LocalTime2.MINUTES_PER_DAY) + mofd + LocalTime2.MINUTES_PER_DAY, LocalTime2.MINUTES_PER_DAY);
        if (mofd === newMofd) {
          return this;
        }
        var newHour = MathUtil.intDiv(newMofd, LocalTime2.MINUTES_PER_HOUR);
        var newMinute = MathUtil.intMod(newMofd, LocalTime2.MINUTES_PER_HOUR);
        return new LocalTime2(newHour, newMinute, this._second, this._nano);
      };
      _proto.plusSeconds = function plusSeconds(secondsToAdd) {
        if (secondsToAdd === 0) {
          return this;
        }
        var sofd = this._hour * LocalTime2.SECONDS_PER_HOUR + this._minute * LocalTime2.SECONDS_PER_MINUTE + this._second;
        var newSofd = MathUtil.intMod(MathUtil.intMod(secondsToAdd, LocalTime2.SECONDS_PER_DAY) + sofd + LocalTime2.SECONDS_PER_DAY, LocalTime2.SECONDS_PER_DAY);
        if (sofd === newSofd) {
          return this;
        }
        var newHour = MathUtil.intDiv(newSofd, LocalTime2.SECONDS_PER_HOUR);
        var newMinute = MathUtil.intMod(MathUtil.intDiv(newSofd, LocalTime2.SECONDS_PER_MINUTE), LocalTime2.MINUTES_PER_HOUR);
        var newSecond = MathUtil.intMod(newSofd, LocalTime2.SECONDS_PER_MINUTE);
        return new LocalTime2(newHour, newMinute, newSecond, this._nano);
      };
      _proto.plusNanos = function plusNanos(nanosToAdd) {
        if (nanosToAdd === 0) {
          return this;
        }
        var nofd = this.toNanoOfDay();
        var newNofd = MathUtil.intMod(MathUtil.intMod(nanosToAdd, LocalTime2.NANOS_PER_DAY) + nofd + LocalTime2.NANOS_PER_DAY, LocalTime2.NANOS_PER_DAY);
        if (nofd === newNofd) {
          return this;
        }
        var newHour = MathUtil.intDiv(newNofd, LocalTime2.NANOS_PER_HOUR);
        var newMinute = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime2.NANOS_PER_MINUTE), LocalTime2.MINUTES_PER_HOUR);
        var newSecond = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime2.NANOS_PER_SECOND), LocalTime2.SECONDS_PER_MINUTE);
        var newNano = MathUtil.intMod(newNofd, LocalTime2.NANOS_PER_SECOND);
        return new LocalTime2(newHour, newMinute, newSecond, newNano);
      };
      _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
        requireNonNull(unit, "unit");
        return this._plusUnit(-1 * amountToSubtract, unit);
      };
      _proto.minusHours = function minusHours(hoursToSubtract) {
        return this.plusHours(-1 * MathUtil.intMod(hoursToSubtract, LocalTime2.HOURS_PER_DAY));
      };
      _proto.minusMinutes = function minusMinutes(minutesToSubtract) {
        return this.plusMinutes(-1 * MathUtil.intMod(minutesToSubtract, LocalTime2.MINUTES_PER_DAY));
      };
      _proto.minusSeconds = function minusSeconds(secondsToSubtract) {
        return this.plusSeconds(-1 * MathUtil.intMod(secondsToSubtract, LocalTime2.SECONDS_PER_DAY));
      };
      _proto.minusNanos = function minusNanos(nanosToSubtract) {
        return this.plusNanos(-1 * MathUtil.intMod(nanosToSubtract, LocalTime2.NANOS_PER_DAY));
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        if (_query === TemporalQueries.precision()) {
          return ChronoUnit.NANOS;
        } else if (_query === TemporalQueries.localTime()) {
          return this;
        }
        if (_query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.zone() || _query === TemporalQueries.offset() || _query === TemporalQueries.localDate()) {
          return null;
        }
        return _query.queryFrom(this);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        return temporal.with(LocalTime2.NANO_OF_DAY, this.toNanoOfDay());
      };
      _proto.until = function until(endExclusive, unit) {
        requireNonNull(endExclusive, "endExclusive");
        requireNonNull(unit, "unit");
        var end = LocalTime2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          var nanosUntil = end.toNanoOfDay() - this.toNanoOfDay();
          switch (unit) {
            case ChronoUnit.NANOS:
              return nanosUntil;
            case ChronoUnit.MICROS:
              return MathUtil.intDiv(nanosUntil, 1e3);
            case ChronoUnit.MILLIS:
              return MathUtil.intDiv(nanosUntil, 1e6);
            case ChronoUnit.SECONDS:
              return MathUtil.intDiv(nanosUntil, LocalTime2.NANOS_PER_SECOND);
            case ChronoUnit.MINUTES:
              return MathUtil.intDiv(nanosUntil, LocalTime2.NANOS_PER_MINUTE);
            case ChronoUnit.HOURS:
              return MathUtil.intDiv(nanosUntil, LocalTime2.NANOS_PER_HOUR);
            case ChronoUnit.HALF_DAYS:
              return MathUtil.intDiv(nanosUntil, 12 * LocalTime2.NANOS_PER_HOUR);
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.between(this, end);
      };
      _proto.atDate = function atDate(date) {
        return LocalDateTime.of(date, this);
      };
      _proto.atOffset = function atOffset(offset) {
        return OffsetTime.of(this, offset);
      };
      _proto.toSecondOfDay = function toSecondOfDay() {
        var total = this._hour * LocalTime2.SECONDS_PER_HOUR;
        total += this._minute * LocalTime2.SECONDS_PER_MINUTE;
        total += this._second;
        return total;
      };
      _proto.toNanoOfDay = function toNanoOfDay() {
        var total = this._hour * LocalTime2.NANOS_PER_HOUR;
        total += this._minute * LocalTime2.NANOS_PER_MINUTE;
        total += this._second * LocalTime2.NANOS_PER_SECOND;
        total += this._nano;
        return total;
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, LocalTime2, "other");
        var cmp = MathUtil.compareNumbers(this._hour, other._hour);
        if (cmp === 0) {
          cmp = MathUtil.compareNumbers(this._minute, other._minute);
          if (cmp === 0) {
            cmp = MathUtil.compareNumbers(this._second, other._second);
            if (cmp === 0) {
              cmp = MathUtil.compareNumbers(this._nano, other._nano);
            }
          }
        }
        return cmp;
      };
      _proto.isAfter = function isAfter(other) {
        return this.compareTo(other) > 0;
      };
      _proto.isBefore = function isBefore(other) {
        return this.compareTo(other) < 0;
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof LocalTime2) {
          return this._hour === other._hour && this._minute === other._minute && this._second === other._second && this._nano === other._nano;
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        var nod = this.toNanoOfDay();
        return MathUtil.hash(nod);
      };
      _proto.toString = function toString() {
        var buf = "";
        var hourValue = this._hour;
        var minuteValue = this._minute;
        var secondValue = this._second;
        var nanoValue = this._nano;
        buf += hourValue < 10 ? "0" : "";
        buf += hourValue;
        buf += minuteValue < 10 ? ":0" : ":";
        buf += minuteValue;
        if (secondValue > 0 || nanoValue > 0) {
          buf += secondValue < 10 ? ":0" : ":";
          buf += secondValue;
          if (nanoValue > 0) {
            buf += ".";
            if (MathUtil.intMod(nanoValue, 1e6) === 0) {
              buf += ("" + (MathUtil.intDiv(nanoValue, 1e6) + 1e3)).substring(1);
            } else if (MathUtil.intMod(nanoValue, 1e3) === 0) {
              buf += ("" + (MathUtil.intDiv(nanoValue, 1e3) + 1e6)).substring(1);
            } else {
              buf += ("" + (nanoValue + 1e9)).substring(1);
            }
          }
        }
        return buf;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        return formatter.format(this);
      };
      return LocalTime2;
    }(Temporal);
    LocalTime.HOURS_PER_DAY = 24;
    LocalTime.MINUTES_PER_HOUR = 60;
    LocalTime.MINUTES_PER_DAY = LocalTime.MINUTES_PER_HOUR * LocalTime.HOURS_PER_DAY;
    LocalTime.SECONDS_PER_MINUTE = 60;
    LocalTime.SECONDS_PER_HOUR = LocalTime.SECONDS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;
    LocalTime.SECONDS_PER_DAY = LocalTime.SECONDS_PER_HOUR * LocalTime.HOURS_PER_DAY;
    LocalTime.MILLIS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1e3;
    LocalTime.MICROS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1e6;
    LocalTime.NANOS_PER_SECOND = 1e9;
    LocalTime.NANOS_PER_MINUTE = LocalTime.NANOS_PER_SECOND * LocalTime.SECONDS_PER_MINUTE;
    LocalTime.NANOS_PER_HOUR = LocalTime.NANOS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;
    LocalTime.NANOS_PER_DAY = LocalTime.NANOS_PER_HOUR * LocalTime.HOURS_PER_DAY;
    NANOS_PER_MILLI = 1e6;
    Instant = function(_Temporal) {
      _inheritsLoose(Instant2, _Temporal);
      Instant2.now = function now(clock) {
        if (clock === void 0) {
          clock = Clock.systemUTC();
        }
        return clock.instant();
      };
      Instant2.ofEpochSecond = function ofEpochSecond(epochSecond, nanoAdjustment) {
        if (nanoAdjustment === void 0) {
          nanoAdjustment = 0;
        }
        var secs = epochSecond + MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND);
        var nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);
        return Instant2._create(secs, nos);
      };
      Instant2.ofEpochMilli = function ofEpochMilli(epochMilli) {
        var secs = MathUtil.floorDiv(epochMilli, 1e3);
        var mos = MathUtil.floorMod(epochMilli, 1e3);
        return Instant2._create(secs, mos * 1e6);
      };
      Instant2.ofEpochMicro = function ofEpochMicro(epochMicro) {
        var secs = MathUtil.floorDiv(epochMicro, 1e6);
        var mos = MathUtil.floorMod(epochMicro, 1e6);
        return Instant2._create(secs, mos * 1e3);
      };
      Instant2.from = function from(temporal) {
        try {
          var instantSecs = temporal.getLong(ChronoField.INSTANT_SECONDS);
          var nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);
          return Instant2.ofEpochSecond(instantSecs, nanoOfSecond);
        } catch (ex) {
          throw new DateTimeException("Unable to obtain Instant from TemporalAccessor: " + temporal + ", type " + typeof temporal, ex);
        }
      };
      Instant2.parse = function parse2(text) {
        return DateTimeFormatter.ISO_INSTANT.parse(text, Instant2.FROM);
      };
      Instant2._create = function _create(seconds, nanoOfSecond) {
        if (seconds === 0 && nanoOfSecond === 0) {
          return Instant2.EPOCH;
        }
        return new Instant2(seconds, nanoOfSecond);
      };
      Instant2._validate = function _validate(seconds, nanoOfSecond) {
        if (seconds < Instant2.MIN_SECONDS || seconds > Instant2.MAX_SECONDS) {
          throw new DateTimeException("Instant exceeds minimum or maximum instant");
        }
        if (nanoOfSecond < 0 || nanoOfSecond > LocalTime.NANOS_PER_SECOND) {
          throw new DateTimeException("Instant exceeds minimum or maximum instant");
        }
      };
      function Instant2(seconds, nanoOfSecond) {
        var _this;
        _this = _Temporal.call(this) || this;
        Instant2._validate(seconds, nanoOfSecond);
        _this._seconds = MathUtil.safeToInt(seconds);
        _this._nanos = MathUtil.safeToInt(nanoOfSecond);
        return _this;
      }
      var _proto = Instant2.prototype;
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (fieldOrUnit instanceof ChronoField) {
          return fieldOrUnit === ChronoField.INSTANT_SECONDS || fieldOrUnit === ChronoField.NANO_OF_SECOND || fieldOrUnit === ChronoField.MICRO_OF_SECOND || fieldOrUnit === ChronoField.MILLI_OF_SECOND;
        }
        if (fieldOrUnit instanceof ChronoUnit) {
          return fieldOrUnit.isTimeBased() || fieldOrUnit === ChronoUnit.DAYS;
        }
        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        return _Temporal.prototype.range.call(this, field);
      };
      _proto.get = function get(field) {
        return this.getLong(field);
      };
      _proto.getLong = function getLong(field) {
        if (field instanceof ChronoField) {
          switch (field) {
            case ChronoField.NANO_OF_SECOND:
              return this._nanos;
            case ChronoField.MICRO_OF_SECOND:
              return MathUtil.intDiv(this._nanos, 1e3);
            case ChronoField.MILLI_OF_SECOND:
              return MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);
            case ChronoField.INSTANT_SECONDS:
              return this._seconds;
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.getFrom(this);
      };
      _proto.epochSecond = function epochSecond() {
        return this._seconds;
      };
      _proto.nano = function nano() {
        return this._nanos;
      };
      _proto._withField = function _withField(field, newValue) {
        requireNonNull(field, "field");
        if (field instanceof ChronoField) {
          field.checkValidValue(newValue);
          switch (field) {
            case ChronoField.MILLI_OF_SECOND: {
              var nval = newValue * NANOS_PER_MILLI;
              return nval !== this._nanos ? Instant2._create(this._seconds, nval) : this;
            }
            case ChronoField.MICRO_OF_SECOND: {
              var _nval = newValue * 1e3;
              return _nval !== this._nanos ? Instant2._create(this._seconds, _nval) : this;
            }
            case ChronoField.NANO_OF_SECOND:
              return newValue !== this._nanos ? Instant2._create(this._seconds, newValue) : this;
            case ChronoField.INSTANT_SECONDS:
              return newValue !== this._seconds ? Instant2._create(newValue, this._nanos) : this;
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.adjustInto(this, newValue);
      };
      _proto.truncatedTo = function truncatedTo(unit) {
        requireNonNull(unit, "unit");
        if (unit === ChronoUnit.NANOS) {
          return this;
        }
        var unitDur = unit.duration();
        if (unitDur.seconds() > LocalTime.SECONDS_PER_DAY) {
          throw new DateTimeException("Unit is too large to be used for truncation");
        }
        var dur = unitDur.toNanos();
        if (MathUtil.intMod(LocalTime.NANOS_PER_DAY, dur) !== 0) {
          throw new DateTimeException("Unit must divide into a standard day without remainder");
        }
        var nod = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + this._nanos;
        var result = MathUtil.intDiv(nod, dur) * dur;
        return this.plusNanos(result - nod);
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        requireNonNull(amountToAdd, "amountToAdd");
        requireNonNull(unit, "unit");
        requireInstance(unit, TemporalUnit);
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.NANOS:
              return this.plusNanos(amountToAdd);
            case ChronoUnit.MICROS:
              return this.plusMicros(amountToAdd);
            case ChronoUnit.MILLIS:
              return this.plusMillis(amountToAdd);
            case ChronoUnit.SECONDS:
              return this.plusSeconds(amountToAdd);
            case ChronoUnit.MINUTES:
              return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_MINUTE));
            case ChronoUnit.HOURS:
              return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_HOUR));
            case ChronoUnit.HALF_DAYS:
              return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY / 2));
            case ChronoUnit.DAYS:
              return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY));
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusSeconds = function plusSeconds(secondsToAdd) {
        return this._plus(secondsToAdd, 0);
      };
      _proto.plusMillis = function plusMillis(millisToAdd) {
        return this._plus(MathUtil.intDiv(millisToAdd, 1e3), MathUtil.intMod(millisToAdd, 1e3) * NANOS_PER_MILLI);
      };
      _proto.plusNanos = function plusNanos(nanosToAdd) {
        return this._plus(0, nanosToAdd);
      };
      _proto.plusMicros = function plusMicros(microsToAdd) {
        return this._plus(MathUtil.intDiv(microsToAdd, 1e6), MathUtil.intMod(microsToAdd, 1e6) * 1e3);
      };
      _proto._plus = function _plus(secondsToAdd, nanosToAdd) {
        if (secondsToAdd === 0 && nanosToAdd === 0) {
          return this;
        }
        var epochSec = this._seconds + secondsToAdd;
        epochSec = epochSec + MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND);
        var nanoAdjustment = this._nanos + nanosToAdd % LocalTime.NANOS_PER_SECOND;
        return Instant2.ofEpochSecond(epochSec, nanoAdjustment);
      };
      _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
        return this._plusUnit(-1 * amountToSubtract, unit);
      };
      _proto.minusSeconds = function minusSeconds(secondsToSubtract) {
        return this.plusSeconds(secondsToSubtract * -1);
      };
      _proto.minusMillis = function minusMillis(millisToSubtract) {
        return this.plusMillis(-1 * millisToSubtract);
      };
      _proto.minusNanos = function minusNanos(nanosToSubtract) {
        return this.plusNanos(-1 * nanosToSubtract);
      };
      _proto.minusMicros = function minusMicros(microsToSubtract) {
        return this.plusMicros(-1 * microsToSubtract);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        if (_query === TemporalQueries.precision()) {
          return ChronoUnit.NANOS;
        }
        if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.zone() || _query === TemporalQueries.offset()) {
          return null;
        }
        return _query.queryFrom(this);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        requireNonNull(temporal, "temporal");
        return temporal.with(ChronoField.INSTANT_SECONDS, this._seconds).with(ChronoField.NANO_OF_SECOND, this._nanos);
      };
      _proto.until = function until(endExclusive, unit) {
        requireNonNull(endExclusive, "endExclusive");
        requireNonNull(unit, "unit");
        var end = Instant2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.NANOS:
              return this._nanosUntil(end);
            case ChronoUnit.MICROS:
              return this._microsUntil(end);
            case ChronoUnit.MILLIS:
              return MathUtil.safeSubtract(end.toEpochMilli(), this.toEpochMilli());
            case ChronoUnit.SECONDS:
              return this._secondsUntil(end);
            case ChronoUnit.MINUTES:
              return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_MINUTE);
            case ChronoUnit.HOURS:
              return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_HOUR);
            case ChronoUnit.HALF_DAYS:
              return MathUtil.intDiv(this._secondsUntil(end), 12 * LocalTime.SECONDS_PER_HOUR);
            case ChronoUnit.DAYS:
              return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_DAY);
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.between(this, end);
      };
      _proto._microsUntil = function _microsUntil(end) {
        var secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());
        var totalMicros = MathUtil.safeMultiply(secsDiff, 1e6);
        return MathUtil.safeAdd(totalMicros, MathUtil.intDiv(end.nano() - this.nano(), 1e3));
      };
      _proto._nanosUntil = function _nanosUntil(end) {
        var secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());
        var totalNanos = MathUtil.safeMultiply(secsDiff, LocalTime.NANOS_PER_SECOND);
        return MathUtil.safeAdd(totalNanos, end.nano() - this.nano());
      };
      _proto._secondsUntil = function _secondsUntil(end) {
        var secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());
        var nanosDiff = end.nano() - this.nano();
        if (secsDiff > 0 && nanosDiff < 0) {
          secsDiff--;
        } else if (secsDiff < 0 && nanosDiff > 0) {
          secsDiff++;
        }
        return secsDiff;
      };
      _proto.atOffset = function atOffset(offset) {
        return OffsetDateTime.ofInstant(this, offset);
      };
      _proto.atZone = function atZone(zone) {
        return ZonedDateTime.ofInstant(this, zone);
      };
      _proto.toEpochMilli = function toEpochMilli() {
        var millis = MathUtil.safeMultiply(this._seconds, 1e3);
        return millis + MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);
      };
      _proto.compareTo = function compareTo(otherInstant) {
        requireNonNull(otherInstant, "otherInstant");
        requireInstance(otherInstant, Instant2, "otherInstant");
        var cmp = MathUtil.compareNumbers(this._seconds, otherInstant._seconds);
        if (cmp !== 0) {
          return cmp;
        }
        return this._nanos - otherInstant._nanos;
      };
      _proto.isAfter = function isAfter(otherInstant) {
        return this.compareTo(otherInstant) > 0;
      };
      _proto.isBefore = function isBefore(otherInstant) {
        return this.compareTo(otherInstant) < 0;
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof Instant2) {
          return this.epochSecond() === other.epochSecond() && this.nano() === other.nano();
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return MathUtil.hashCode(this._seconds, this._nanos);
      };
      _proto.toString = function toString() {
        return DateTimeFormatter.ISO_INSTANT.format(this);
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      return Instant2;
    }(Temporal);
    Clock = function() {
      function Clock2() {
      }
      Clock2.systemUTC = function systemUTC() {
        return new SystemClock(ZoneOffset.UTC);
      };
      Clock2.systemDefaultZone = function systemDefaultZone() {
        return new SystemClock(ZoneId.systemDefault());
      };
      Clock2.system = function system(zone) {
        return new SystemClock(zone);
      };
      Clock2.fixed = function fixed(fixedInstant, zoneId) {
        return new FixedClock(fixedInstant, zoneId);
      };
      Clock2.offset = function offset(baseClock, duration) {
        return new OffsetClock(baseClock, duration);
      };
      var _proto = Clock2.prototype;
      _proto.millis = function millis() {
        abstractMethodFail("Clock.millis");
      };
      _proto.instant = function instant() {
        abstractMethodFail("Clock.instant");
      };
      _proto.zone = function zone() {
        abstractMethodFail("Clock.zone");
      };
      _proto.withZone = function withZone() {
        abstractMethodFail("Clock.withZone");
      };
      return Clock2;
    }();
    SystemClock = function(_Clock) {
      _inheritsLoose(SystemClock2, _Clock);
      function SystemClock2(zone) {
        var _this;
        requireNonNull(zone, "zone");
        _this = _Clock.call(this) || this;
        _this._zone = zone;
        return _this;
      }
      var _proto2 = SystemClock2.prototype;
      _proto2.zone = function zone() {
        return this._zone;
      };
      _proto2.millis = function millis() {
        return (/* @__PURE__ */ new Date()).getTime();
      };
      _proto2.instant = function instant() {
        return Instant.ofEpochMilli(this.millis());
      };
      _proto2.equals = function equals(obj) {
        if (obj instanceof SystemClock2) {
          return this._zone.equals(obj._zone);
        }
        return false;
      };
      _proto2.withZone = function withZone(zone) {
        if (zone.equals(this._zone)) {
          return this;
        }
        return new SystemClock2(zone);
      };
      _proto2.toString = function toString() {
        return "SystemClock[" + this._zone.toString() + "]";
      };
      return SystemClock2;
    }(Clock);
    FixedClock = function(_Clock2) {
      _inheritsLoose(FixedClock2, _Clock2);
      function FixedClock2(fixedInstant, zoneId) {
        var _this2;
        _this2 = _Clock2.call(this) || this;
        _this2._instant = fixedInstant;
        _this2._zoneId = zoneId;
        return _this2;
      }
      var _proto3 = FixedClock2.prototype;
      _proto3.instant = function instant() {
        return this._instant;
      };
      _proto3.millis = function millis() {
        return this._instant.toEpochMilli();
      };
      _proto3.zone = function zone() {
        return this._zoneId;
      };
      _proto3.toString = function toString() {
        return "FixedClock[]";
      };
      _proto3.equals = function equals(obj) {
        if (obj instanceof FixedClock2) {
          return this._instant.equals(obj._instant) && this._zoneId.equals(obj._zoneId);
        }
        return false;
      };
      _proto3.withZone = function withZone(zone) {
        if (zone.equals(this._zoneId)) {
          return this;
        }
        return new FixedClock2(this._instant, zone);
      };
      return FixedClock2;
    }(Clock);
    OffsetClock = function(_Clock3) {
      _inheritsLoose(OffsetClock2, _Clock3);
      function OffsetClock2(baseClock, offset) {
        var _this3;
        _this3 = _Clock3.call(this) || this;
        _this3._baseClock = baseClock;
        _this3._offset = offset;
        return _this3;
      }
      var _proto4 = OffsetClock2.prototype;
      _proto4.zone = function zone() {
        return this._baseClock.zone();
      };
      _proto4.withZone = function withZone(zone) {
        if (zone.equals(this._baseClock.zone())) {
          return this;
        }
        return new OffsetClock2(this._baseClock.withZone(zone), this._offset);
      };
      _proto4.millis = function millis() {
        return this._baseClock.millis() + this._offset.toMillis();
      };
      _proto4.instant = function instant() {
        return this._baseClock.instant().plus(this._offset);
      };
      _proto4.equals = function equals(obj) {
        if (obj instanceof OffsetClock2) {
          return this._baseClock.equals(obj._baseClock) && this._offset.equals(obj._offset);
        }
        return false;
      };
      _proto4.toString = function toString() {
        return "OffsetClock[" + this._baseClock + "," + this._offset + "]";
      };
      return OffsetClock2;
    }(Clock);
    ZoneOffsetTransition = function() {
      ZoneOffsetTransition2.of = function of(transition, offsetBefore, offsetAfter) {
        return new ZoneOffsetTransition2(transition, offsetBefore, offsetAfter);
      };
      function ZoneOffsetTransition2(transition, offsetBefore, offsetAfter) {
        requireNonNull(transition, "transition");
        requireNonNull(offsetBefore, "offsetBefore");
        requireNonNull(offsetAfter, "offsetAfter");
        if (offsetBefore.equals(offsetAfter)) {
          throw new IllegalArgumentException("Offsets must not be equal");
        }
        if (transition.nano() !== 0) {
          throw new IllegalArgumentException("Nano-of-second must be zero");
        }
        if (transition instanceof LocalDateTime) {
          this._transition = transition;
        } else {
          this._transition = LocalDateTime.ofEpochSecond(transition, 0, offsetBefore);
        }
        this._offsetBefore = offsetBefore;
        this._offsetAfter = offsetAfter;
      }
      var _proto = ZoneOffsetTransition2.prototype;
      _proto.instant = function instant() {
        return this._transition.toInstant(this._offsetBefore);
      };
      _proto.toEpochSecond = function toEpochSecond() {
        return this._transition.toEpochSecond(this._offsetBefore);
      };
      _proto.dateTimeBefore = function dateTimeBefore() {
        return this._transition;
      };
      _proto.dateTimeAfter = function dateTimeAfter() {
        return this._transition.plusSeconds(this.durationSeconds());
      };
      _proto.offsetBefore = function offsetBefore() {
        return this._offsetBefore;
      };
      _proto.offsetAfter = function offsetAfter() {
        return this._offsetAfter;
      };
      _proto.duration = function duration() {
        return Duration.ofSeconds(this.durationSeconds());
      };
      _proto.durationSeconds = function durationSeconds() {
        return this._offsetAfter.totalSeconds() - this._offsetBefore.totalSeconds();
      };
      _proto.isGap = function isGap() {
        return this._offsetAfter.totalSeconds() > this._offsetBefore.totalSeconds();
      };
      _proto.isOverlap = function isOverlap() {
        return this._offsetAfter.totalSeconds() < this._offsetBefore.totalSeconds();
      };
      _proto.isValidOffset = function isValidOffset(offset) {
        return this.isGap() ? false : this._offsetBefore.equals(offset) || this._offsetAfter.equals(offset);
      };
      _proto.validOffsets = function validOffsets() {
        if (this.isGap()) {
          return [];
        } else {
          return [this._offsetBefore, this._offsetAfter];
        }
      };
      _proto.compareTo = function compareTo(transition) {
        return this.instant().compareTo(transition.instant());
      };
      _proto.equals = function equals(other) {
        if (other === this) {
          return true;
        }
        if (other instanceof ZoneOffsetTransition2) {
          var d = other;
          return this._transition.equals(d._transition) && this._offsetBefore.equals(d.offsetBefore()) && this._offsetAfter.equals(d.offsetAfter());
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return this._transition.hashCode() ^ this._offsetBefore.hashCode() ^ this._offsetAfter.hashCode() >>> 16;
      };
      _proto.toString = function toString() {
        return "Transition[" + (this.isGap() ? "Gap" : "Overlap") + " at " + this._transition.toString() + this._offsetBefore.toString() + " to " + this._offsetAfter + "]";
      };
      return ZoneOffsetTransition2;
    }();
    SystemDefaultZoneRules = function(_ZoneRules) {
      _inheritsLoose(SystemDefaultZoneRules2, _ZoneRules);
      function SystemDefaultZoneRules2() {
        return _ZoneRules.apply(this, arguments) || this;
      }
      var _proto = SystemDefaultZoneRules2.prototype;
      _proto.isFixedOffset = function isFixedOffset() {
        return false;
      };
      _proto.offsetOfInstant = function offsetOfInstant(instant) {
        var offsetInMinutes = new Date(instant.toEpochMilli()).getTimezoneOffset();
        return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);
      };
      _proto.offsetOfEpochMilli = function offsetOfEpochMilli(epochMilli) {
        var offsetInMinutes = new Date(epochMilli).getTimezoneOffset();
        return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);
      };
      _proto.offsetOfLocalDateTime = function offsetOfLocalDateTime(localDateTime) {
        var epochMilli = localDateTime.toEpochSecond(ZoneOffset.UTC) * 1e3;
        var offsetInMinutesBeforePossibleTransition = new Date(epochMilli).getTimezoneOffset();
        var epochMilliSystemZone = epochMilli + offsetInMinutesBeforePossibleTransition * 6e4;
        var offsetInMinutesAfterPossibleTransition = new Date(epochMilliSystemZone).getTimezoneOffset();
        return ZoneOffset.ofTotalMinutes(offsetInMinutesAfterPossibleTransition * -1);
      };
      _proto.validOffsets = function validOffsets(localDateTime) {
        return [this.offsetOfLocalDateTime(localDateTime)];
      };
      _proto.transition = function transition() {
        return null;
      };
      _proto.standardOffset = function standardOffset(instant) {
        return this.offsetOfInstant(instant);
      };
      _proto.daylightSavings = function daylightSavings() {
        this._throwNotSupported();
      };
      _proto.isDaylightSavings = function isDaylightSavings() {
        this._throwNotSupported();
      };
      _proto.isValidOffset = function isValidOffset(dateTime, offset) {
        return this.offsetOfLocalDateTime(dateTime).equals(offset);
      };
      _proto.nextTransition = function nextTransition() {
        this._throwNotSupported();
      };
      _proto.previousTransition = function previousTransition() {
        this._throwNotSupported();
      };
      _proto.transitions = function transitions() {
        this._throwNotSupported();
      };
      _proto.transitionRules = function transitionRules() {
        this._throwNotSupported();
      };
      _proto._throwNotSupported = function _throwNotSupported() {
        throw new DateTimeException("not supported operation");
      };
      _proto.equals = function equals(other) {
        if (this === other || other instanceof SystemDefaultZoneRules2) {
          return true;
        } else {
          return false;
        }
      };
      _proto.toString = function toString() {
        return "SYSTEM";
      };
      return SystemDefaultZoneRules2;
    }(ZoneRules);
    SystemDefaultZoneId = function(_ZoneId) {
      _inheritsLoose(SystemDefaultZoneId2, _ZoneId);
      function SystemDefaultZoneId2() {
        var _this;
        _this = _ZoneId.call(this) || this;
        _this._rules = new SystemDefaultZoneRules();
        return _this;
      }
      var _proto = SystemDefaultZoneId2.prototype;
      _proto.rules = function rules() {
        return this._rules;
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        return false;
      };
      _proto.id = function id() {
        return "SYSTEM";
      };
      return SystemDefaultZoneId2;
    }(ZoneId);
    ZoneIdFactory = function() {
      function ZoneIdFactory2() {
      }
      ZoneIdFactory2.systemDefault = function systemDefault() {
        return SYSTEM_DEFAULT_ZONE_ID_INSTANCE;
      };
      ZoneIdFactory2.getAvailableZoneIds = function getAvailableZoneIds() {
        return ZoneRulesProvider.getAvailableZoneIds();
      };
      ZoneIdFactory2.of = function of(zoneId) {
        requireNonNull(zoneId, "zoneId");
        if (zoneId === "Z") {
          return ZoneOffset.UTC;
        }
        if (zoneId.length === 1) {
          throw new DateTimeException("Invalid zone: " + zoneId);
        }
        if (StringUtil.startsWith(zoneId, "+") || StringUtil.startsWith(zoneId, "-")) {
          return ZoneOffset.of(zoneId);
        }
        if (zoneId === "UTC" || zoneId === "GMT" || zoneId === "GMT0" || zoneId === "UT") {
          return new ZoneRegion(zoneId, ZoneOffset.UTC.rules());
        }
        if (StringUtil.startsWith(zoneId, "UTC+") || StringUtil.startsWith(zoneId, "GMT+") || StringUtil.startsWith(zoneId, "UTC-") || StringUtil.startsWith(zoneId, "GMT-")) {
          var offset = ZoneOffset.of(zoneId.substring(3));
          if (offset.totalSeconds() === 0) {
            return new ZoneRegion(zoneId.substring(0, 3), offset.rules());
          }
          return new ZoneRegion(zoneId.substring(0, 3) + offset.id(), offset.rules());
        }
        if (StringUtil.startsWith(zoneId, "UT+") || StringUtil.startsWith(zoneId, "UT-")) {
          var _offset = ZoneOffset.of(zoneId.substring(2));
          if (_offset.totalSeconds() === 0) {
            return new ZoneRegion("UT", _offset.rules());
          }
          return new ZoneRegion("UT" + _offset.id(), _offset.rules());
        }
        if (zoneId === "SYSTEM") {
          return ZoneId.systemDefault();
        }
        return ZoneRegion.ofId(zoneId);
      };
      ZoneIdFactory2.ofOffset = function ofOffset(prefix, offset) {
        requireNonNull(prefix, "prefix");
        requireNonNull(offset, "offset");
        if (prefix.length === 0) {
          return offset;
        }
        if (prefix === "GMT" || prefix === "UTC" || prefix === "UT") {
          if (offset.totalSeconds() === 0) {
            return new ZoneRegion(prefix, offset.rules());
          }
          return new ZoneRegion(prefix + offset.id(), offset.rules());
        }
        throw new IllegalArgumentException("Invalid prefix, must be GMT, UTC or UT: " + prefix);
      };
      ZoneIdFactory2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        var obj = temporal.query(TemporalQueries.zone());
        if (obj == null) {
          throw new DateTimeException("Unable to obtain ZoneId from TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
        }
        return obj;
      };
      return ZoneIdFactory2;
    }();
    SYSTEM_DEFAULT_ZONE_ID_INSTANCE = null;
    isInit = false;
    init();
    ToNativeJsConverter = function() {
      function ToNativeJsConverter2(temporal, zone) {
        var zonedDateTime;
        if (temporal instanceof Instant) {
          this.instant = temporal;
          return;
        } else if (temporal instanceof LocalDate) {
          zone = zone == null ? ZoneId.systemDefault() : zone;
          zonedDateTime = temporal.atStartOfDay(zone);
        } else if (temporal instanceof LocalDateTime) {
          zone = zone == null ? ZoneId.systemDefault() : zone;
          zonedDateTime = temporal.atZone(zone);
        } else if (temporal instanceof ZonedDateTime) {
          if (zone == null) {
            zonedDateTime = temporal;
          } else {
            zonedDateTime = temporal.withZoneSameInstant(zone);
          }
        } else {
          throw new IllegalArgumentException("unsupported instance for convert operation:" + temporal);
        }
        this.instant = zonedDateTime.toInstant();
      }
      var _proto = ToNativeJsConverter2.prototype;
      _proto.toDate = function toDate() {
        return new Date(this.instant.toEpochMilli());
      };
      _proto.toEpochMilli = function toEpochMilli() {
        return this.instant.toEpochMilli();
      };
      return ToNativeJsConverter2;
    }();
    _ = {
      assert: assert$1,
      DateTimeBuilder,
      DateTimeParseContext,
      DateTimePrintContext,
      MathUtil,
      StringUtil,
      StringBuilder
    };
    jsJodaExports = {
      _,
      convert,
      nativeJs,
      ArithmeticException,
      DateTimeException,
      DateTimeParseException,
      IllegalArgumentException,
      IllegalStateException,
      UnsupportedTemporalTypeException,
      NullPointerException,
      Clock,
      DayOfWeek,
      Duration,
      Instant,
      LocalDate,
      LocalTime,
      LocalDateTime,
      OffsetTime,
      OffsetDateTime,
      Month,
      MonthDay,
      ParsePosition,
      Period,
      Year,
      YearConstants,
      YearMonth,
      ZonedDateTime,
      ZoneOffset,
      ZoneId,
      ZoneRegion,
      ZoneOffsetTransition,
      ZoneRules,
      ZoneRulesProvider,
      ChronoLocalDate,
      ChronoLocalDateTime,
      ChronoZonedDateTime,
      IsoChronology,
      ChronoField,
      ChronoUnit,
      IsoFields,
      Temporal,
      TemporalAccessor,
      TemporalAdjuster,
      TemporalAdjusters,
      TemporalAmount,
      TemporalField,
      TemporalQueries,
      TemporalQuery,
      TemporalUnit,
      ValueRange,
      DateTimeFormatter,
      DateTimeFormatterBuilder,
      DecimalStyle,
      ResolverStyle,
      SignStyle,
      TextStyle
    };
    use = bindUse(jsJodaExports);
    jsJodaExports.use = use;
  }
});

// node_modules/tedious/lib/data-types/datetime.js
var require_datetime = __commonJS({
  "node_modules/tedious/lib/data-types/datetime.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _datetimen = _interopRequireDefault(require_datetimen());
    var _core = (init_js_joda_esm(), __toCommonJS(js_joda_esm_exports));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var EPOCH_DATE = _core.LocalDate.ofYearDay(1900, 1);
    var NULL_LENGTH = Buffer.from([0]);
    var DATA_LENGTH = Buffer.from([8]);
    var DateTime = {
      id: 61,
      type: "DATETIME",
      name: "DateTime",
      declaration: function() {
        return "datetime";
      },
      generateTypeInfo() {
        return Buffer.from([_datetimen.default.id, 8]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      generateParameterData: function* (parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const value = parameter.value;
        let date;
        if (options.useUTC) {
          date = _core.LocalDate.of(value.getUTCFullYear(), value.getUTCMonth() + 1, value.getUTCDate());
        } else {
          date = _core.LocalDate.of(value.getFullYear(), value.getMonth() + 1, value.getDate());
        }
        let days = EPOCH_DATE.until(date, _core.ChronoUnit.DAYS);
        let milliseconds, threeHundredthsOfSecond;
        if (options.useUTC) {
          let seconds = value.getUTCHours() * 60 * 60;
          seconds += value.getUTCMinutes() * 60;
          seconds += value.getUTCSeconds();
          milliseconds = seconds * 1e3 + value.getUTCMilliseconds();
        } else {
          let seconds = value.getHours() * 60 * 60;
          seconds += value.getMinutes() * 60;
          seconds += value.getSeconds();
          milliseconds = seconds * 1e3 + value.getMilliseconds();
        }
        threeHundredthsOfSecond = milliseconds / (3 + 1 / 3);
        threeHundredthsOfSecond = Math.round(threeHundredthsOfSecond);
        if (threeHundredthsOfSecond === 2592e4) {
          days += 1;
          threeHundredthsOfSecond = 0;
        }
        const buffer = Buffer.alloc(8);
        buffer.writeInt32LE(days, 0);
        buffer.writeUInt32LE(threeHundredthsOfSecond, 4);
        yield buffer;
      },
      // TODO: type 'any' needs to be revisited.
      validate: function(value, collation, options) {
        if (value == null) {
          return null;
        }
        if (!(value instanceof Date)) {
          value = new Date(Date.parse(value));
        }
        value = value;
        let year;
        if (options && options.useUTC) {
          year = value.getUTCFullYear();
        } else {
          year = value.getFullYear();
        }
        if (year < 1753 || year > 9999) {
          throw new TypeError("Out of range.");
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid date.");
        }
        return value;
      }
    };
    var _default = exports.default = DateTime;
    module.exports = DateTime;
  }
});

// node_modules/tedious/lib/data-types/float.js
var require_float = __commonJS({
  "node_modules/tedious/lib/data-types/float.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _floatn = _interopRequireDefault(require_floatn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([0]);
    var Float = {
      id: 62,
      type: "FLT8",
      name: "Float",
      declaration: function() {
        return "float";
      },
      generateTypeInfo() {
        return Buffer.from([_floatn.default.id, 8]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return Buffer.from([8]);
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = Buffer.alloc(8);
        buffer.writeDoubleLE(parseFloat(parameter.value), 0);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        value = parseFloat(value);
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        return value;
      }
    };
    var _default = exports.default = Float;
    module.exports = Float;
  }
});

// node_modules/tedious/lib/data-types/decimaln.js
var require_decimaln = __commonJS({
  "node_modules/tedious/lib/data-types/decimaln.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DecimalN = {
      id: 106,
      type: "DECIMALN",
      name: "DecimalN",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports.default = DecimalN;
    module.exports = DecimalN;
  }
});

// node_modules/tedious/lib/data-types/decimal.js
var require_decimal = __commonJS({
  "node_modules/tedious/lib/data-types/decimal.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _decimaln = _interopRequireDefault(require_decimaln());
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([0]);
    var Decimal = {
      id: 55,
      type: "DECIMAL",
      name: "Decimal",
      declaration: function(parameter) {
        return "decimal(" + this.resolvePrecision(parameter) + ", " + this.resolveScale(parameter) + ")";
      },
      resolvePrecision: function(parameter) {
        if (parameter.precision != null) {
          return parameter.precision;
        } else if (parameter.value === null) {
          return 1;
        } else {
          return 18;
        }
      },
      resolveScale: function(parameter) {
        if (parameter.scale != null) {
          return parameter.scale;
        } else {
          return 0;
        }
      },
      generateTypeInfo(parameter, _options) {
        let precision;
        if (parameter.precision <= 9) {
          precision = 5;
        } else if (parameter.precision <= 19) {
          precision = 9;
        } else if (parameter.precision <= 28) {
          precision = 13;
        } else {
          precision = 17;
        }
        return Buffer.from([_decimaln.default.id, precision, parameter.precision, parameter.scale]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        const precision = parameter.precision;
        if (precision <= 9) {
          return Buffer.from([5]);
        } else if (precision <= 19) {
          return Buffer.from([9]);
        } else if (precision <= 28) {
          return Buffer.from([13]);
        } else {
          return Buffer.from([17]);
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const sign2 = parameter.value < 0 ? 0 : 1;
        const value = Math.round(Math.abs(parameter.value * Math.pow(10, parameter.scale)));
        const precision = parameter.precision;
        if (precision <= 9) {
          const buffer = Buffer.alloc(5);
          buffer.writeUInt8(sign2, 0);
          buffer.writeUInt32LE(value, 1);
          yield buffer;
        } else if (precision <= 19) {
          const buffer = new _writableTrackingBuffer.default(9);
          buffer.writeUInt8(sign2);
          buffer.writeUInt64LE(value);
          yield buffer.data;
        } else if (precision <= 28) {
          const buffer = new _writableTrackingBuffer.default(13);
          buffer.writeUInt8(sign2);
          buffer.writeUInt64LE(value);
          buffer.writeUInt32LE(0);
          yield buffer.data;
        } else {
          const buffer = new _writableTrackingBuffer.default(17);
          buffer.writeUInt8(sign2);
          buffer.writeUInt64LE(value);
          buffer.writeUInt32LE(0);
          buffer.writeUInt32LE(0);
          yield buffer.data;
        }
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        value = parseFloat(value);
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        return value;
      }
    };
    var _default = exports.default = Decimal;
    module.exports = Decimal;
  }
});

// node_modules/tedious/lib/data-types/numericn.js
var require_numericn = __commonJS({
  "node_modules/tedious/lib/data-types/numericn.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var NumericN = {
      id: 108,
      type: "NUMERICN",
      name: "NumericN",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports.default = NumericN;
    module.exports = NumericN;
  }
});

// node_modules/tedious/lib/data-types/numeric.js
var require_numeric = __commonJS({
  "node_modules/tedious/lib/data-types/numeric.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _numericn = _interopRequireDefault(require_numericn());
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([0]);
    var Numeric = {
      id: 63,
      type: "NUMERIC",
      name: "Numeric",
      declaration: function(parameter) {
        return "numeric(" + this.resolvePrecision(parameter) + ", " + this.resolveScale(parameter) + ")";
      },
      resolvePrecision: function(parameter) {
        if (parameter.precision != null) {
          return parameter.precision;
        } else if (parameter.value === null) {
          return 1;
        } else {
          return 18;
        }
      },
      resolveScale: function(parameter) {
        if (parameter.scale != null) {
          return parameter.scale;
        } else {
          return 0;
        }
      },
      generateTypeInfo(parameter) {
        let precision;
        if (parameter.precision <= 9) {
          precision = 5;
        } else if (parameter.precision <= 19) {
          precision = 9;
        } else if (parameter.precision <= 28) {
          precision = 13;
        } else {
          precision = 17;
        }
        return Buffer.from([_numericn.default.id, precision, parameter.precision, parameter.scale]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        const precision = parameter.precision;
        if (precision <= 9) {
          return Buffer.from([5]);
        } else if (precision <= 19) {
          return Buffer.from([9]);
        } else if (precision <= 28) {
          return Buffer.from([13]);
        } else {
          return Buffer.from([17]);
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const sign2 = parameter.value < 0 ? 0 : 1;
        const value = Math.round(Math.abs(parameter.value * Math.pow(10, parameter.scale)));
        if (parameter.precision <= 9) {
          const buffer = Buffer.alloc(5);
          buffer.writeUInt8(sign2, 0);
          buffer.writeUInt32LE(value, 1);
          yield buffer;
        } else if (parameter.precision <= 19) {
          const buffer = new _writableTrackingBuffer.default(10);
          buffer.writeUInt8(sign2);
          buffer.writeUInt64LE(value);
          yield buffer.data;
        } else if (parameter.precision <= 28) {
          const buffer = new _writableTrackingBuffer.default(14);
          buffer.writeUInt8(sign2);
          buffer.writeUInt64LE(value);
          buffer.writeUInt32LE(0);
          yield buffer.data;
        } else {
          const buffer = new _writableTrackingBuffer.default(18);
          buffer.writeUInt8(sign2);
          buffer.writeUInt64LE(value);
          buffer.writeUInt32LE(0);
          buffer.writeUInt32LE(0);
          yield buffer.data;
        }
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        value = parseFloat(value);
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        return value;
      }
    };
    var _default = exports.default = Numeric;
    module.exports = Numeric;
  }
});

// node_modules/tedious/lib/data-types/smallmoney.js
var require_smallmoney = __commonJS({
  "node_modules/tedious/lib/data-types/smallmoney.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _moneyn = _interopRequireDefault(require_moneyn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var DATA_LENGTH = Buffer.from([4]);
    var NULL_LENGTH = Buffer.from([0]);
    var SmallMoney = {
      id: 122,
      type: "MONEY4",
      name: "SmallMoney",
      declaration: function() {
        return "smallmoney";
      },
      generateTypeInfo: function() {
        return Buffer.from([_moneyn.default.id, 4]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = Buffer.alloc(4);
        buffer.writeInt32LE(parameter.value * 1e4, 0);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        value = parseFloat(value);
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        if (value < -214748.3648 || value > 214748.3647) {
          throw new TypeError("Value must be between -214748.3648 and 214748.3647.");
        }
        return value;
      }
    };
    var _default = exports.default = SmallMoney;
    module.exports = SmallMoney;
  }
});

// node_modules/tedious/lib/data-types/bigint.js
var require_bigint = __commonJS({
  "node_modules/tedious/lib/data-types/bigint.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _intn = _interopRequireDefault(require_intn());
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var DATA_LENGTH = Buffer.from([8]);
    var NULL_LENGTH = Buffer.from([0]);
    var MAX_SAFE_BIGINT = 9223372036854775807n;
    var MIN_SAFE_BIGINT = -9223372036854775808n;
    var BigInt2 = {
      id: 127,
      type: "INT8",
      name: "BigInt",
      declaration: function() {
        return "bigint";
      },
      generateTypeInfo() {
        return Buffer.from([_intn.default.id, 8]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = new _writableTrackingBuffer.default(8);
        buffer.writeBigInt64LE(typeof parameter.value === "bigint" ? parameter.value : globalThis.BigInt(parameter.value));
        yield buffer.data;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "bigint") {
          value = globalThis.BigInt(value);
        }
        if (value < MIN_SAFE_BIGINT || value > MAX_SAFE_BIGINT) {
          throw new TypeError(`Value must be between ${MIN_SAFE_BIGINT} and ${MAX_SAFE_BIGINT}, inclusive.`);
        }
        return value;
      }
    };
    var _default = exports.default = BigInt2;
    module.exports = BigInt2;
  }
});

// node_modules/tedious/lib/data-types/image.js
var require_image = __commonJS({
  "node_modules/tedious/lib/data-types/image.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var NULL_LENGTH = Buffer.from([255, 255, 255, 255]);
    var Image = {
      id: 34,
      type: "IMAGE",
      name: "Image",
      hasTableName: true,
      declaration: function() {
        return "image";
      },
      resolveLength: function(parameter) {
        if (parameter.value != null) {
          const value = parameter.value;
          return value.length;
        } else {
          return -1;
        }
      },
      generateTypeInfo(parameter) {
        const buffer = Buffer.alloc(5);
        buffer.writeUInt8(this.id, 0);
        buffer.writeInt32LE(parameter.length, 1);
        return buffer;
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        const buffer = Buffer.alloc(4);
        buffer.writeInt32LE(parameter.value.length, 0);
        return buffer;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        yield parameter.value;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (!Buffer.isBuffer(value)) {
          throw new TypeError("Invalid buffer.");
        }
        return value;
      }
    };
    var _default = exports.default = Image;
    module.exports = Image;
  }
});

// node_modules/tedious/lib/data-types/text.js
var require_text = __commonJS({
  "node_modules/tedious/lib/data-types/text.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iconvLite = _interopRequireDefault(require_lib());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([255, 255, 255, 255]);
    var Text = {
      id: 35,
      type: "TEXT",
      name: "Text",
      hasTableName: true,
      declaration: function() {
        return "text";
      },
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (value != null) {
          return value.length;
        } else {
          return -1;
        }
      },
      generateTypeInfo(parameter, _options) {
        const buffer = Buffer.alloc(10);
        buffer.writeUInt8(this.id, 0);
        buffer.writeInt32LE(parameter.length, 1);
        if (parameter.collation) {
          parameter.collation.toBuffer().copy(buffer, 5, 0, 5);
        }
        return buffer;
      },
      generateParameterLength(parameter, options) {
        const value = parameter.value;
        if (value == null) {
          return NULL_LENGTH;
        }
        const buffer = Buffer.alloc(4);
        buffer.writeInt32LE(value.length, 0);
        return buffer;
      },
      generateParameterData: function* (parameter, options) {
        const value = parameter.value;
        if (value == null) {
          return;
        }
        yield value;
      },
      validate: function(value, collation) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "string") {
          throw new TypeError("Invalid string.");
        }
        if (!collation) {
          throw new Error("No collation was set by the server for the current connection.");
        }
        if (!collation.codepage) {
          throw new Error("The collation set by the server has no associated encoding.");
        }
        return _iconvLite.default.encode(value, collation.codepage);
      }
    };
    var _default = exports.default = Text;
    module.exports = Text;
  }
});

// node_modules/tedious/lib/guid-parser.js
var require_guid_parser = __commonJS({
  "node_modules/tedious/lib/guid-parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.bufferToLowerCaseGuid = bufferToLowerCaseGuid;
    exports.bufferToUpperCaseGuid = bufferToUpperCaseGuid;
    exports.guidToArray = guidToArray;
    var UPPER_CASE_MAP = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0A", "0B", "0C", "0D", "0E", "0F", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1A", "1B", "1C", "1D", "1E", "1F", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2A", "2B", "2C", "2D", "2E", "2F", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3A", "3B", "3C", "3D", "3E", "3F", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4A", "4B", "4C", "4D", "4E", "4F", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5A", "5B", "5C", "5D", "5E", "5F", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6A", "6B", "6C", "6D", "6E", "6F", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7A", "7B", "7C", "7D", "7E", "7F", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8A", "8B", "8C", "8D", "8E", "8F", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9A", "9B", "9C", "9D", "9E", "9F", "A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7", "A8", "A9", "AA", "AB", "AC", "AD", "AE", "AF", "B0", "B1", "B2", "B3", "B4", "B5", "B6", "B7", "B8", "B9", "BA", "BB", "BC", "BD", "BE", "BF", "C0", "C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8", "C9", "CA", "CB", "CC", "CD", "CE", "CF", "D0", "D1", "D2", "D3", "D4", "D5", "D6", "D7", "D8", "D9", "DA", "DB", "DC", "DD", "DE", "DF", "E0", "E1", "E2", "E3", "E4", "E5", "E6", "E7", "E8", "E9", "EA", "EB", "EC", "ED", "EE", "EF", "F0", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "FA", "FB", "FC", "FD", "FE", "FF"];
    var LOWER_CASE_MAP = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
    function bufferToUpperCaseGuid(buffer) {
      return UPPER_CASE_MAP[buffer[3]] + UPPER_CASE_MAP[buffer[2]] + UPPER_CASE_MAP[buffer[1]] + UPPER_CASE_MAP[buffer[0]] + "-" + UPPER_CASE_MAP[buffer[5]] + UPPER_CASE_MAP[buffer[4]] + "-" + UPPER_CASE_MAP[buffer[7]] + UPPER_CASE_MAP[buffer[6]] + "-" + UPPER_CASE_MAP[buffer[8]] + UPPER_CASE_MAP[buffer[9]] + "-" + UPPER_CASE_MAP[buffer[10]] + UPPER_CASE_MAP[buffer[11]] + UPPER_CASE_MAP[buffer[12]] + UPPER_CASE_MAP[buffer[13]] + UPPER_CASE_MAP[buffer[14]] + UPPER_CASE_MAP[buffer[15]];
    }
    function bufferToLowerCaseGuid(buffer) {
      return LOWER_CASE_MAP[buffer[3]] + LOWER_CASE_MAP[buffer[2]] + LOWER_CASE_MAP[buffer[1]] + LOWER_CASE_MAP[buffer[0]] + "-" + LOWER_CASE_MAP[buffer[5]] + LOWER_CASE_MAP[buffer[4]] + "-" + LOWER_CASE_MAP[buffer[7]] + LOWER_CASE_MAP[buffer[6]] + "-" + LOWER_CASE_MAP[buffer[8]] + LOWER_CASE_MAP[buffer[9]] + "-" + LOWER_CASE_MAP[buffer[10]] + LOWER_CASE_MAP[buffer[11]] + LOWER_CASE_MAP[buffer[12]] + LOWER_CASE_MAP[buffer[13]] + LOWER_CASE_MAP[buffer[14]] + LOWER_CASE_MAP[buffer[15]];
    }
    var CHARCODEMAP = {};
    var hexDigits2 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"].map((d) => d.charCodeAt(0));
    for (let i = 0; i < hexDigits2.length; i++) {
      const map = CHARCODEMAP[hexDigits2[i]] = {};
      for (let j = 0; j < hexDigits2.length; j++) {
        const hex = String.fromCharCode(hexDigits2[i], hexDigits2[j]);
        const value = parseInt(hex, 16);
        map[hexDigits2[j]] = value;
      }
    }
    function guidToArray(guid) {
      return [CHARCODEMAP[guid.charCodeAt(6)][guid.charCodeAt(7)], CHARCODEMAP[guid.charCodeAt(4)][guid.charCodeAt(5)], CHARCODEMAP[guid.charCodeAt(2)][guid.charCodeAt(3)], CHARCODEMAP[guid.charCodeAt(0)][guid.charCodeAt(1)], CHARCODEMAP[guid.charCodeAt(11)][guid.charCodeAt(12)], CHARCODEMAP[guid.charCodeAt(9)][guid.charCodeAt(10)], CHARCODEMAP[guid.charCodeAt(16)][guid.charCodeAt(17)], CHARCODEMAP[guid.charCodeAt(14)][guid.charCodeAt(15)], CHARCODEMAP[guid.charCodeAt(19)][guid.charCodeAt(20)], CHARCODEMAP[guid.charCodeAt(21)][guid.charCodeAt(22)], CHARCODEMAP[guid.charCodeAt(24)][guid.charCodeAt(25)], CHARCODEMAP[guid.charCodeAt(26)][guid.charCodeAt(27)], CHARCODEMAP[guid.charCodeAt(28)][guid.charCodeAt(29)], CHARCODEMAP[guid.charCodeAt(30)][guid.charCodeAt(31)], CHARCODEMAP[guid.charCodeAt(32)][guid.charCodeAt(33)], CHARCODEMAP[guid.charCodeAt(34)][guid.charCodeAt(35)]];
    }
  }
});

// node_modules/tedious/lib/data-types/uniqueidentifier.js
var require_uniqueidentifier = __commonJS({
  "node_modules/tedious/lib/data-types/uniqueidentifier.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _guidParser = require_guid_parser();
    var NULL_LENGTH = Buffer.from([0]);
    var DATA_LENGTH = Buffer.from([16]);
    var UniqueIdentifier = {
      id: 36,
      type: "GUIDN",
      name: "UniqueIdentifier",
      declaration: function() {
        return "uniqueidentifier";
      },
      resolveLength: function() {
        return 16;
      },
      generateTypeInfo() {
        return Buffer.from([this.id, 16]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      generateParameterData: function* (parameter, options) {
        if (parameter.value == null) {
          return;
        }
        yield Buffer.from((0, _guidParser.guidToArray)(parameter.value));
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "string") {
          throw new TypeError("Invalid string.");
        }
        if (!/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(value)) {
          throw new TypeError("Invalid GUID.");
        }
        return value;
      }
    };
    var _default = exports.default = UniqueIdentifier;
    module.exports = UniqueIdentifier;
  }
});

// node_modules/tedious/lib/data-types/ntext.js
var require_ntext = __commonJS({
  "node_modules/tedious/lib/data-types/ntext.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var NULL_LENGTH = Buffer.from([255, 255, 255, 255]);
    var NText = {
      id: 99,
      type: "NTEXT",
      name: "NText",
      hasTableName: true,
      declaration: function() {
        return "ntext";
      },
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (value != null) {
          return value.length;
        } else {
          return -1;
        }
      },
      generateTypeInfo(parameter, _options) {
        const buffer = Buffer.alloc(10);
        buffer.writeUInt8(this.id, 0);
        buffer.writeInt32LE(parameter.length, 1);
        if (parameter.collation) {
          parameter.collation.toBuffer().copy(buffer, 5, 0, 5);
        }
        return buffer;
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        const buffer = Buffer.alloc(4);
        buffer.writeInt32LE(Buffer.byteLength(parameter.value, "ucs2"), 0);
        return buffer;
      },
      generateParameterData: function* (parameter, options) {
        if (parameter.value == null) {
          return;
        }
        yield Buffer.from(parameter.value.toString(), "ucs2");
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "string") {
          throw new TypeError("Invalid string.");
        }
        return value;
      }
    };
    var _default = exports.default = NText;
    module.exports = NText;
  }
});

// node_modules/tedious/lib/data-types/varbinary.js
var require_varbinary = __commonJS({
  "node_modules/tedious/lib/data-types/varbinary.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MAX = (1 << 16) - 1;
    var UNKNOWN_PLP_LEN = Buffer.from([254, 255, 255, 255, 255, 255, 255, 255]);
    var PLP_TERMINATOR = Buffer.from([0, 0, 0, 0]);
    var NULL_LENGTH = Buffer.from([255, 255]);
    var MAX_NULL_LENGTH = Buffer.from([255, 255, 255, 255, 255, 255, 255, 255]);
    var VarBinary = {
      id: 165,
      type: "BIGVARBIN",
      name: "VarBinary",
      maximumLength: 8e3,
      declaration: function(parameter) {
        const value = parameter.value;
        let length;
        if (parameter.length) {
          length = parameter.length;
        } else if (value != null) {
          length = value.length || 1;
        } else if (value === null && !parameter.output) {
          length = 1;
        } else {
          length = this.maximumLength;
        }
        if (length <= this.maximumLength) {
          return "varbinary(" + length + ")";
        } else {
          return "varbinary(max)";
        }
      },
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (parameter.length != null) {
          return parameter.length;
        } else if (value != null) {
          return value.length;
        } else {
          return this.maximumLength;
        }
      },
      generateTypeInfo: function(parameter) {
        const buffer = Buffer.alloc(3);
        buffer.writeUInt8(this.id, 0);
        if (parameter.length <= this.maximumLength) {
          buffer.writeUInt16LE(parameter.length, 1);
        } else {
          buffer.writeUInt16LE(MAX, 1);
        }
        return buffer;
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          if (parameter.length <= this.maximumLength) {
            return NULL_LENGTH;
          } else {
            return MAX_NULL_LENGTH;
          }
        }
        let value = parameter.value;
        if (!Buffer.isBuffer(value)) {
          value = value.toString();
        }
        const length = Buffer.byteLength(value, "ucs2");
        if (parameter.length <= this.maximumLength) {
          const buffer = Buffer.alloc(2);
          buffer.writeUInt16LE(length, 0);
          return buffer;
        } else {
          return UNKNOWN_PLP_LEN;
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        let value = parameter.value;
        if (parameter.length <= this.maximumLength) {
          if (Buffer.isBuffer(value)) {
            yield value;
          } else {
            yield Buffer.from(value.toString(), "ucs2");
          }
        } else {
          if (!Buffer.isBuffer(value)) {
            value = value.toString();
          }
          const length = Buffer.byteLength(value, "ucs2");
          if (length > 0) {
            const buffer = Buffer.alloc(4);
            buffer.writeUInt32LE(length, 0);
            yield buffer;
            if (Buffer.isBuffer(value)) {
              yield value;
            } else {
              yield Buffer.from(value, "ucs2");
            }
          }
          yield PLP_TERMINATOR;
        }
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (!Buffer.isBuffer(value)) {
          throw new TypeError("Invalid buffer.");
        }
        return value;
      }
    };
    var _default = exports.default = VarBinary;
    module.exports = VarBinary;
  }
});

// node_modules/tedious/lib/data-types/varchar.js
var require_varchar = __commonJS({
  "node_modules/tedious/lib/data-types/varchar.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iconvLite = _interopRequireDefault(require_lib());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var MAX = (1 << 16) - 1;
    var UNKNOWN_PLP_LEN = Buffer.from([254, 255, 255, 255, 255, 255, 255, 255]);
    var PLP_TERMINATOR = Buffer.from([0, 0, 0, 0]);
    var NULL_LENGTH = Buffer.from([255, 255]);
    var MAX_NULL_LENGTH = Buffer.from([255, 255, 255, 255, 255, 255, 255, 255]);
    var VarChar = {
      id: 167,
      type: "BIGVARCHR",
      name: "VarChar",
      maximumLength: 8e3,
      declaration: function(parameter) {
        const value = parameter.value;
        let length;
        if (parameter.length) {
          length = parameter.length;
        } else if (value != null) {
          length = value.length || 1;
        } else if (value === null && !parameter.output) {
          length = 1;
        } else {
          length = this.maximumLength;
        }
        if (length <= this.maximumLength) {
          return "varchar(" + length + ")";
        } else {
          return "varchar(max)";
        }
      },
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (parameter.length != null) {
          return parameter.length;
        } else if (value != null) {
          return value.length || 1;
        } else {
          return this.maximumLength;
        }
      },
      generateTypeInfo(parameter) {
        const buffer = Buffer.alloc(8);
        buffer.writeUInt8(this.id, 0);
        if (parameter.length <= this.maximumLength) {
          buffer.writeUInt16LE(parameter.length, 1);
        } else {
          buffer.writeUInt16LE(MAX, 1);
        }
        if (parameter.collation) {
          parameter.collation.toBuffer().copy(buffer, 3, 0, 5);
        }
        return buffer;
      },
      generateParameterLength(parameter, options) {
        const value = parameter.value;
        if (value == null) {
          if (parameter.length <= this.maximumLength) {
            return NULL_LENGTH;
          } else {
            return MAX_NULL_LENGTH;
          }
        }
        if (parameter.length <= this.maximumLength) {
          const buffer = Buffer.alloc(2);
          buffer.writeUInt16LE(value.length, 0);
          return buffer;
        } else {
          return UNKNOWN_PLP_LEN;
        }
      },
      *generateParameterData(parameter, options) {
        const value = parameter.value;
        if (value == null) {
          return;
        }
        if (parameter.length <= this.maximumLength) {
          yield value;
        } else {
          if (value.length > 0) {
            const buffer = Buffer.alloc(4);
            buffer.writeUInt32LE(value.length, 0);
            yield buffer;
            yield value;
          }
          yield PLP_TERMINATOR;
        }
      },
      validate: function(value, collation) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "string") {
          throw new TypeError("Invalid string.");
        }
        if (!collation) {
          throw new Error("No collation was set by the server for the current connection.");
        }
        if (!collation.codepage) {
          throw new Error("The collation set by the server has no associated encoding.");
        }
        return _iconvLite.default.encode(value, collation.codepage);
      }
    };
    var _default = exports.default = VarChar;
    module.exports = VarChar;
  }
});

// node_modules/tedious/lib/data-types/binary.js
var require_binary = __commonJS({
  "node_modules/tedious/lib/data-types/binary.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var NULL_LENGTH = Buffer.from([255, 255]);
    var Binary = {
      id: 173,
      type: "BIGBinary",
      name: "Binary",
      maximumLength: 8e3,
      declaration: function(parameter) {
        const value = parameter.value;
        let length;
        if (parameter.length) {
          length = parameter.length;
        } else if (value != null) {
          length = value.length || 1;
        } else if (value === null && !parameter.output) {
          length = 1;
        } else {
          length = this.maximumLength;
        }
        return "binary(" + length + ")";
      },
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (value != null) {
          return value.length;
        } else {
          return this.maximumLength;
        }
      },
      generateTypeInfo(parameter) {
        const buffer = Buffer.alloc(3);
        buffer.writeUInt8(this.id, 0);
        buffer.writeUInt16LE(parameter.length, 1);
        return buffer;
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        const buffer = Buffer.alloc(2);
        buffer.writeUInt16LE(parameter.length, 0);
        return buffer;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        yield parameter.value.slice(0, parameter.length !== void 0 ? Math.min(parameter.length, this.maximumLength) : this.maximumLength);
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (!Buffer.isBuffer(value)) {
          throw new TypeError("Invalid buffer.");
        }
        return value;
      }
    };
    var _default = exports.default = Binary;
    module.exports = Binary;
  }
});

// node_modules/tedious/lib/data-types/char.js
var require_char = __commonJS({
  "node_modules/tedious/lib/data-types/char.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iconvLite = _interopRequireDefault(require_lib());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([255, 255]);
    var Char = {
      id: 175,
      type: "BIGCHAR",
      name: "Char",
      maximumLength: 8e3,
      declaration: function(parameter) {
        const value = parameter.value;
        let length;
        if (parameter.length) {
          length = parameter.length;
        } else if (value != null) {
          length = value.length || 1;
        } else if (value === null && !parameter.output) {
          length = 1;
        } else {
          length = this.maximumLength;
        }
        if (length < this.maximumLength) {
          return "char(" + length + ")";
        } else {
          return "char(" + this.maximumLength + ")";
        }
      },
      // ParameterData<any> is temporary solution. TODO: need to understand what type ParameterData<...> can be.
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (parameter.length != null) {
          return parameter.length;
        } else if (value != null) {
          return value.length || 1;
        } else {
          return this.maximumLength;
        }
      },
      generateTypeInfo(parameter) {
        const buffer = Buffer.alloc(8);
        buffer.writeUInt8(this.id, 0);
        buffer.writeUInt16LE(parameter.length, 1);
        if (parameter.collation) {
          parameter.collation.toBuffer().copy(buffer, 3, 0, 5);
        }
        return buffer;
      },
      generateParameterLength(parameter, options) {
        const value = parameter.value;
        if (value == null) {
          return NULL_LENGTH;
        }
        const buffer = Buffer.alloc(2);
        buffer.writeUInt16LE(value.length, 0);
        return buffer;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        yield Buffer.from(parameter.value, "ascii");
      },
      validate: function(value, collation) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "string") {
          throw new TypeError("Invalid string.");
        }
        if (!collation) {
          throw new Error("No collation was set by the server for the current connection.");
        }
        if (!collation.codepage) {
          throw new Error("The collation set by the server has no associated encoding.");
        }
        return _iconvLite.default.encode(value, collation.codepage);
      }
    };
    var _default = exports.default = Char;
    module.exports = Char;
  }
});

// node_modules/tedious/lib/data-types/nvarchar.js
var require_nvarchar = __commonJS({
  "node_modules/tedious/lib/data-types/nvarchar.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MAX = (1 << 16) - 1;
    var UNKNOWN_PLP_LEN = Buffer.from([254, 255, 255, 255, 255, 255, 255, 255]);
    var PLP_TERMINATOR = Buffer.from([0, 0, 0, 0]);
    var NULL_LENGTH = Buffer.from([255, 255]);
    var MAX_NULL_LENGTH = Buffer.from([255, 255, 255, 255, 255, 255, 255, 255]);
    var NVarChar = {
      id: 231,
      type: "NVARCHAR",
      name: "NVarChar",
      maximumLength: 4e3,
      declaration: function(parameter) {
        const value = parameter.value;
        let length;
        if (parameter.length) {
          length = parameter.length;
        } else if (value != null) {
          length = value.toString().length || 1;
        } else if (value === null && !parameter.output) {
          length = 1;
        } else {
          length = this.maximumLength;
        }
        if (length <= this.maximumLength) {
          return "nvarchar(" + length + ")";
        } else {
          return "nvarchar(max)";
        }
      },
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (parameter.length != null) {
          return parameter.length;
        } else if (value != null) {
          if (Buffer.isBuffer(value)) {
            return value.length / 2 || 1;
          } else {
            return value.toString().length || 1;
          }
        } else {
          return this.maximumLength;
        }
      },
      generateTypeInfo(parameter) {
        const buffer = Buffer.alloc(8);
        buffer.writeUInt8(this.id, 0);
        if (parameter.length <= this.maximumLength) {
          buffer.writeUInt16LE(parameter.length * 2, 1);
        } else {
          buffer.writeUInt16LE(MAX, 1);
        }
        if (parameter.collation) {
          parameter.collation.toBuffer().copy(buffer, 3, 0, 5);
        }
        return buffer;
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          if (parameter.length <= this.maximumLength) {
            return NULL_LENGTH;
          } else {
            return MAX_NULL_LENGTH;
          }
        }
        let value = parameter.value;
        if (parameter.length <= this.maximumLength) {
          let length;
          if (value instanceof Buffer) {
            length = value.length;
          } else {
            value = value.toString();
            length = Buffer.byteLength(value, "ucs2");
          }
          const buffer = Buffer.alloc(2);
          buffer.writeUInt16LE(length, 0);
          return buffer;
        } else {
          return UNKNOWN_PLP_LEN;
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        let value = parameter.value;
        if (parameter.length <= this.maximumLength) {
          if (value instanceof Buffer) {
            yield value;
          } else {
            value = value.toString();
            yield Buffer.from(value, "ucs2");
          }
        } else {
          if (value instanceof Buffer) {
            const length = value.length;
            if (length > 0) {
              const buffer = Buffer.alloc(4);
              buffer.writeUInt32LE(length, 0);
              yield buffer;
              yield value;
            }
          } else {
            value = value.toString();
            const length = Buffer.byteLength(value, "ucs2");
            if (length > 0) {
              const buffer = Buffer.alloc(4);
              buffer.writeUInt32LE(length, 0);
              yield buffer;
              yield Buffer.from(value, "ucs2");
            }
          }
          yield PLP_TERMINATOR;
        }
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "string") {
          throw new TypeError("Invalid string.");
        }
        return value;
      }
    };
    var _default = exports.default = NVarChar;
    module.exports = NVarChar;
  }
});

// node_modules/tedious/lib/data-types/nchar.js
var require_nchar = __commonJS({
  "node_modules/tedious/lib/data-types/nchar.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var NULL_LENGTH = Buffer.from([255, 255]);
    var NChar = {
      id: 239,
      type: "NCHAR",
      name: "NChar",
      maximumLength: 4e3,
      declaration: function(parameter) {
        const value = parameter.value;
        let length;
        if (parameter.length) {
          length = parameter.length;
        } else if (parameter.value != null) {
          length = value.toString().length || 1;
        } else if (parameter.value === null && !parameter.output) {
          length = 1;
        } else {
          length = this.maximumLength;
        }
        if (length < this.maximumLength) {
          return "nchar(" + length + ")";
        } else {
          return "nchar(" + this.maximumLength + ")";
        }
      },
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (parameter.length != null) {
          return parameter.length;
        } else if (parameter.value != null) {
          if (Buffer.isBuffer(parameter.value)) {
            return parameter.value.length / 2 || 1;
          } else {
            return value.toString().length || 1;
          }
        } else {
          return this.maximumLength;
        }
      },
      generateTypeInfo: function(parameter) {
        const buffer = Buffer.alloc(8);
        buffer.writeUInt8(this.id, 0);
        buffer.writeUInt16LE(parameter.length * 2, 1);
        if (parameter.collation) {
          parameter.collation.toBuffer().copy(buffer, 3, 0, 5);
        }
        return buffer;
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        const {
          value
        } = parameter;
        if (value instanceof Buffer) {
          const length = value.length;
          const buffer = Buffer.alloc(2);
          buffer.writeUInt16LE(length, 0);
          return buffer;
        } else {
          const length = Buffer.byteLength(value.toString(), "ucs2");
          const buffer = Buffer.alloc(2);
          buffer.writeUInt16LE(length, 0);
          return buffer;
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const value = parameter.value;
        if (value instanceof Buffer) {
          yield value;
        } else {
          yield Buffer.from(value, "ucs2");
        }
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "string") {
          throw new TypeError("Invalid string.");
        }
        return value;
      }
    };
    var _default = exports.default = NChar;
    module.exports = NChar;
  }
});

// node_modules/tedious/lib/data-types/xml.js
var require_xml = __commonJS({
  "node_modules/tedious/lib/data-types/xml.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var XML = {
      id: 241,
      type: "XML",
      name: "Xml",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports.default = XML;
    module.exports = XML;
  }
});

// node_modules/tedious/lib/data-types/time.js
var require_time = __commonJS({
  "node_modules/tedious/lib/data-types/time.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([0]);
    var Time = {
      id: 41,
      type: "TIMEN",
      name: "Time",
      declaration: function(parameter) {
        return "time(" + this.resolveScale(parameter) + ")";
      },
      resolveScale: function(parameter) {
        if (parameter.scale != null) {
          return parameter.scale;
        } else if (parameter.value === null) {
          return 0;
        } else {
          return 7;
        }
      },
      generateTypeInfo(parameter) {
        return Buffer.from([this.id, parameter.scale]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        switch (parameter.scale) {
          case 0:
          case 1:
          case 2:
            return Buffer.from([3]);
          case 3:
          case 4:
            return Buffer.from([4]);
          case 5:
          case 6:
          case 7:
            return Buffer.from([5]);
          default:
            throw new Error("invalid scale");
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = new _writableTrackingBuffer.default(16);
        const time = parameter.value;
        let timestamp;
        if (options.useUTC) {
          timestamp = ((time.getUTCHours() * 60 + time.getUTCMinutes()) * 60 + time.getUTCSeconds()) * 1e3 + time.getUTCMilliseconds();
        } else {
          timestamp = ((time.getHours() * 60 + time.getMinutes()) * 60 + time.getSeconds()) * 1e3 + time.getMilliseconds();
        }
        timestamp = timestamp * Math.pow(10, parameter.scale - 3);
        timestamp += (parameter.value.nanosecondDelta != null ? parameter.value.nanosecondDelta : 0) * Math.pow(10, parameter.scale);
        timestamp = Math.round(timestamp);
        switch (parameter.scale) {
          case 0:
          case 1:
          case 2:
            buffer.writeUInt24LE(timestamp);
            break;
          case 3:
          case 4:
            buffer.writeUInt32LE(timestamp);
            break;
          case 5:
          case 6:
          case 7:
            buffer.writeUInt40LE(timestamp);
        }
        yield buffer.data;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (!(value instanceof Date)) {
          value = new Date(Date.parse(value));
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid time.");
        }
        return value;
      }
    };
    var _default = exports.default = Time;
    module.exports = Time;
  }
});

// node_modules/tedious/lib/data-types/date.js
var require_date = __commonJS({
  "node_modules/tedious/lib/data-types/date.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _core = (init_js_joda_esm(), __toCommonJS(js_joda_esm_exports));
    var globalDate = global.Date;
    var EPOCH_DATE = _core.LocalDate.ofYearDay(1, 1);
    var NULL_LENGTH = Buffer.from([0]);
    var DATA_LENGTH = Buffer.from([3]);
    var Date2 = {
      id: 40,
      type: "DATEN",
      name: "Date",
      declaration: function() {
        return "date";
      },
      generateTypeInfo: function() {
        return Buffer.from([this.id]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const value = parameter.value;
        let date;
        if (options.useUTC) {
          date = _core.LocalDate.of(value.getUTCFullYear(), value.getUTCMonth() + 1, value.getUTCDate());
        } else {
          date = _core.LocalDate.of(value.getFullYear(), value.getMonth() + 1, value.getDate());
        }
        const days = EPOCH_DATE.until(date, _core.ChronoUnit.DAYS);
        const buffer = Buffer.alloc(3);
        buffer.writeUIntLE(days, 0, 3);
        yield buffer;
      },
      // TODO: value is technically of type 'unknown'.
      validate: function(value, collation, options) {
        if (value == null) {
          return null;
        }
        if (!(value instanceof globalDate)) {
          value = new globalDate(globalDate.parse(value));
        }
        value = value;
        let year;
        if (options && options.useUTC) {
          year = value.getUTCFullYear();
        } else {
          year = value.getFullYear();
        }
        if (year < 1 || year > 9999) {
          throw new TypeError("Out of range.");
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid date.");
        }
        return value;
      }
    };
    var _default = exports.default = Date2;
    module.exports = Date2;
  }
});

// node_modules/tedious/lib/data-types/datetime2.js
var require_datetime2 = __commonJS({
  "node_modules/tedious/lib/data-types/datetime2.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _core = (init_js_joda_esm(), __toCommonJS(js_joda_esm_exports));
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var EPOCH_DATE = _core.LocalDate.ofYearDay(1, 1);
    var NULL_LENGTH = Buffer.from([0]);
    var DateTime2 = {
      id: 42,
      type: "DATETIME2N",
      name: "DateTime2",
      declaration: function(parameter) {
        return "datetime2(" + this.resolveScale(parameter) + ")";
      },
      resolveScale: function(parameter) {
        if (parameter.scale != null) {
          return parameter.scale;
        } else if (parameter.value === null) {
          return 0;
        } else {
          return 7;
        }
      },
      generateTypeInfo(parameter, _options) {
        return Buffer.from([this.id, parameter.scale]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        switch (parameter.scale) {
          case 0:
          case 1:
          case 2:
            return Buffer.from([6]);
          case 3:
          case 4:
            return Buffer.from([7]);
          case 5:
          case 6:
          case 7:
            return Buffer.from([8]);
          default:
            throw new Error("invalid scale");
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const value = parameter.value;
        let scale = parameter.scale;
        const buffer = new _writableTrackingBuffer.default(16);
        scale = scale;
        let timestamp;
        if (options.useUTC) {
          timestamp = ((value.getUTCHours() * 60 + value.getUTCMinutes()) * 60 + value.getUTCSeconds()) * 1e3 + value.getUTCMilliseconds();
        } else {
          timestamp = ((value.getHours() * 60 + value.getMinutes()) * 60 + value.getSeconds()) * 1e3 + value.getMilliseconds();
        }
        timestamp = timestamp * Math.pow(10, scale - 3);
        timestamp += (value.nanosecondDelta != null ? value.nanosecondDelta : 0) * Math.pow(10, scale);
        timestamp = Math.round(timestamp);
        switch (scale) {
          case 0:
          case 1:
          case 2:
            buffer.writeUInt24LE(timestamp);
            break;
          case 3:
          case 4:
            buffer.writeUInt32LE(timestamp);
            break;
          case 5:
          case 6:
          case 7:
            buffer.writeUInt40LE(timestamp);
        }
        let date;
        if (options.useUTC) {
          date = _core.LocalDate.of(value.getUTCFullYear(), value.getUTCMonth() + 1, value.getUTCDate());
        } else {
          date = _core.LocalDate.of(value.getFullYear(), value.getMonth() + 1, value.getDate());
        }
        const days = EPOCH_DATE.until(date, _core.ChronoUnit.DAYS);
        buffer.writeUInt24LE(days);
        yield buffer.data;
      },
      validate: function(value, collation, options) {
        if (value == null) {
          return null;
        }
        if (!(value instanceof Date)) {
          value = new Date(Date.parse(value));
        }
        value = value;
        let year;
        if (options && options.useUTC) {
          year = value.getUTCFullYear();
        } else {
          year = value.getFullYear();
        }
        if (year < 1 || year > 9999) {
          throw new TypeError("Out of range.");
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid date.");
        }
        return value;
      }
    };
    var _default = exports.default = DateTime2;
    module.exports = DateTime2;
  }
});

// node_modules/tedious/lib/data-types/datetimeoffset.js
var require_datetimeoffset = __commonJS({
  "node_modules/tedious/lib/data-types/datetimeoffset.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _core = (init_js_joda_esm(), __toCommonJS(js_joda_esm_exports));
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var EPOCH_DATE = _core.LocalDate.ofYearDay(1, 1);
    var NULL_LENGTH = Buffer.from([0]);
    var DateTimeOffset = {
      id: 43,
      type: "DATETIMEOFFSETN",
      name: "DateTimeOffset",
      declaration: function(parameter) {
        return "datetimeoffset(" + this.resolveScale(parameter) + ")";
      },
      resolveScale: function(parameter) {
        if (parameter.scale != null) {
          return parameter.scale;
        } else if (parameter.value === null) {
          return 0;
        } else {
          return 7;
        }
      },
      generateTypeInfo(parameter) {
        return Buffer.from([this.id, parameter.scale]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        switch (parameter.scale) {
          case 0:
          case 1:
          case 2:
            return Buffer.from([8]);
          case 3:
          case 4:
            return Buffer.from([9]);
          case 5:
          case 6:
          case 7:
            return Buffer.from([10]);
          default:
            throw new Error("invalid scale");
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const value = parameter.value;
        let scale = parameter.scale;
        const buffer = new _writableTrackingBuffer.default(16);
        scale = scale;
        let timestamp;
        timestamp = ((value.getUTCHours() * 60 + value.getUTCMinutes()) * 60 + value.getUTCSeconds()) * 1e3 + value.getMilliseconds();
        timestamp = timestamp * Math.pow(10, scale - 3);
        timestamp += (value.nanosecondDelta != null ? value.nanosecondDelta : 0) * Math.pow(10, scale);
        timestamp = Math.round(timestamp);
        switch (scale) {
          case 0:
          case 1:
          case 2:
            buffer.writeUInt24LE(timestamp);
            break;
          case 3:
          case 4:
            buffer.writeUInt32LE(timestamp);
            break;
          case 5:
          case 6:
          case 7:
            buffer.writeUInt40LE(timestamp);
        }
        const date = _core.LocalDate.of(value.getUTCFullYear(), value.getUTCMonth() + 1, value.getUTCDate());
        const days = EPOCH_DATE.until(date, _core.ChronoUnit.DAYS);
        buffer.writeUInt24LE(days);
        const offset = -value.getTimezoneOffset();
        buffer.writeInt16LE(offset);
        yield buffer.data;
      },
      validate: function(value, collation, options) {
        if (value == null) {
          return null;
        }
        if (!(value instanceof Date)) {
          value = new Date(Date.parse(value));
        }
        value = value;
        let year;
        if (options && options.useUTC) {
          year = value.getUTCFullYear();
        } else {
          year = value.getFullYear();
        }
        if (year < 1 || year > 9999) {
          throw new TypeError("Out of range.");
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid date.");
        }
        return value;
      }
    };
    var _default = exports.default = DateTimeOffset;
    module.exports = DateTimeOffset;
  }
});

// node_modules/tedious/lib/data-types/udt.js
var require_udt = __commonJS({
  "node_modules/tedious/lib/data-types/udt.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var UDT = {
      id: 240,
      type: "UDTTYPE",
      name: "UDT",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports.default = UDT;
    module.exports = UDT;
  }
});

// node_modules/tedious/lib/data-types/tvp.js
var require_tvp = __commonJS({
  "node_modules/tedious/lib/data-types/tvp.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _errors = require_errors();
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var TVP_ROW_TOKEN = Buffer.from([1]);
    var TVP_END_TOKEN = Buffer.from([0]);
    var NULL_LENGTH = Buffer.from([255, 255]);
    var TVP = {
      id: 243,
      type: "TVPTYPE",
      name: "TVP",
      declaration: function(parameter) {
        const value = parameter.value;
        return value.name + " readonly";
      },
      generateTypeInfo(parameter) {
        var _a3, _b2;
        const databaseName = "";
        const schema = ((_a3 = parameter.value) == null ? void 0 : _a3.schema) ?? "";
        const typeName = ((_b2 = parameter.value) == null ? void 0 : _b2.name) ?? "";
        const bufferLength = 1 + 1 + Buffer.byteLength(databaseName, "ucs2") + 1 + Buffer.byteLength(schema, "ucs2") + 1 + Buffer.byteLength(typeName, "ucs2");
        const buffer = new _writableTrackingBuffer.default(bufferLength, "ucs2");
        buffer.writeUInt8(this.id);
        buffer.writeBVarchar(databaseName);
        buffer.writeBVarchar(schema);
        buffer.writeBVarchar(typeName);
        return buffer.data;
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        const {
          columns
        } = parameter.value;
        const buffer = Buffer.alloc(2);
        buffer.writeUInt16LE(columns.length, 0);
        return buffer;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          yield TVP_END_TOKEN;
          yield TVP_END_TOKEN;
          return;
        }
        const {
          columns,
          rows
        } = parameter.value;
        for (let i = 0, len = columns.length; i < len; i++) {
          const column = columns[i];
          const buff = Buffer.alloc(6);
          buff.writeUInt32LE(0, 0);
          buff.writeUInt16LE(0, 4);
          yield buff;
          yield column.type.generateTypeInfo(column);
          yield Buffer.from([0]);
        }
        yield TVP_END_TOKEN;
        for (let i = 0, length = rows.length; i < length; i++) {
          yield TVP_ROW_TOKEN;
          const row = rows[i];
          for (let k = 0, len2 = row.length; k < len2; k++) {
            const column = columns[k];
            const value = row[k];
            let paramValue;
            try {
              paramValue = column.type.validate(value, parameter.collation);
            } catch (error) {
              throw new _errors.InputError(`TVP column '${column.name}' has invalid data at row index ${i}`, {
                cause: error
              });
            }
            const param = {
              value: paramValue,
              length: column.length,
              scale: column.scale,
              precision: column.precision
            };
            yield column.type.generateParameterLength(param, options);
            yield* column.type.generateParameterData(param, options);
          }
        }
        yield TVP_END_TOKEN;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "object") {
          throw new TypeError("Invalid table.");
        }
        if (!Array.isArray(value.columns)) {
          throw new TypeError("Invalid table.");
        }
        if (!Array.isArray(value.rows)) {
          throw new TypeError("Invalid table.");
        }
        return value;
      }
    };
    var _default = exports.default = TVP;
    module.exports = TVP;
  }
});

// node_modules/tedious/lib/data-types/sql-variant.js
var require_sql_variant = __commonJS({
  "node_modules/tedious/lib/data-types/sql-variant.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var Variant = {
      id: 98,
      type: "SSVARIANTTYPE",
      name: "Variant",
      declaration: function() {
        return "sql_variant";
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports.default = Variant;
    module.exports = Variant;
  }
});

// node_modules/tedious/lib/data-type.js
var require_data_type = __commonJS({
  "node_modules/tedious/lib/data-type.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.typeByName = exports.TYPES = exports.TYPE = void 0;
    var _null = _interopRequireDefault(require_null());
    var _tinyint = _interopRequireDefault(require_tinyint());
    var _bit = _interopRequireDefault(require_bit());
    var _smallint = _interopRequireDefault(require_smallint());
    var _int = _interopRequireDefault(require_int());
    var _smalldatetime = _interopRequireDefault(require_smalldatetime());
    var _real = _interopRequireDefault(require_real());
    var _money = _interopRequireDefault(require_money());
    var _datetime = _interopRequireDefault(require_datetime());
    var _float = _interopRequireDefault(require_float());
    var _decimal = _interopRequireDefault(require_decimal());
    var _numeric = _interopRequireDefault(require_numeric());
    var _smallmoney = _interopRequireDefault(require_smallmoney());
    var _bigint = _interopRequireDefault(require_bigint());
    var _image = _interopRequireDefault(require_image());
    var _text = _interopRequireDefault(require_text());
    var _uniqueidentifier = _interopRequireDefault(require_uniqueidentifier());
    var _intn = _interopRequireDefault(require_intn());
    var _ntext = _interopRequireDefault(require_ntext());
    var _bitn = _interopRequireDefault(require_bitn());
    var _decimaln = _interopRequireDefault(require_decimaln());
    var _numericn = _interopRequireDefault(require_numericn());
    var _floatn = _interopRequireDefault(require_floatn());
    var _moneyn = _interopRequireDefault(require_moneyn());
    var _datetimen = _interopRequireDefault(require_datetimen());
    var _varbinary = _interopRequireDefault(require_varbinary());
    var _varchar = _interopRequireDefault(require_varchar());
    var _binary = _interopRequireDefault(require_binary());
    var _char = _interopRequireDefault(require_char());
    var _nvarchar = _interopRequireDefault(require_nvarchar());
    var _nchar = _interopRequireDefault(require_nchar());
    var _xml = _interopRequireDefault(require_xml());
    var _time = _interopRequireDefault(require_time());
    var _date = _interopRequireDefault(require_date());
    var _datetime2 = _interopRequireDefault(require_datetime2());
    var _datetimeoffset = _interopRequireDefault(require_datetimeoffset());
    var _udt = _interopRequireDefault(require_udt());
    var _tvp = _interopRequireDefault(require_tvp());
    var _sqlVariant = _interopRequireDefault(require_sql_variant());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var TYPE = exports.TYPE = {
      [_null.default.id]: _null.default,
      [_tinyint.default.id]: _tinyint.default,
      [_bit.default.id]: _bit.default,
      [_smallint.default.id]: _smallint.default,
      [_int.default.id]: _int.default,
      [_smalldatetime.default.id]: _smalldatetime.default,
      [_real.default.id]: _real.default,
      [_money.default.id]: _money.default,
      [_datetime.default.id]: _datetime.default,
      [_float.default.id]: _float.default,
      [_decimal.default.id]: _decimal.default,
      [_numeric.default.id]: _numeric.default,
      [_smallmoney.default.id]: _smallmoney.default,
      [_bigint.default.id]: _bigint.default,
      [_image.default.id]: _image.default,
      [_text.default.id]: _text.default,
      [_uniqueidentifier.default.id]: _uniqueidentifier.default,
      [_intn.default.id]: _intn.default,
      [_ntext.default.id]: _ntext.default,
      [_bitn.default.id]: _bitn.default,
      [_decimaln.default.id]: _decimaln.default,
      [_numericn.default.id]: _numericn.default,
      [_floatn.default.id]: _floatn.default,
      [_moneyn.default.id]: _moneyn.default,
      [_datetimen.default.id]: _datetimen.default,
      [_varbinary.default.id]: _varbinary.default,
      [_varchar.default.id]: _varchar.default,
      [_binary.default.id]: _binary.default,
      [_char.default.id]: _char.default,
      [_nvarchar.default.id]: _nvarchar.default,
      [_nchar.default.id]: _nchar.default,
      [_xml.default.id]: _xml.default,
      [_time.default.id]: _time.default,
      [_date.default.id]: _date.default,
      [_datetime2.default.id]: _datetime2.default,
      [_datetimeoffset.default.id]: _datetimeoffset.default,
      [_udt.default.id]: _udt.default,
      [_tvp.default.id]: _tvp.default,
      [_sqlVariant.default.id]: _sqlVariant.default
    };
    var TYPES = exports.TYPES = {
      TinyInt: _tinyint.default,
      Bit: _bit.default,
      SmallInt: _smallint.default,
      Int: _int.default,
      SmallDateTime: _smalldatetime.default,
      Real: _real.default,
      Money: _money.default,
      DateTime: _datetime.default,
      Float: _float.default,
      Decimal: _decimal.default,
      Numeric: _numeric.default,
      SmallMoney: _smallmoney.default,
      BigInt: _bigint.default,
      Image: _image.default,
      Text: _text.default,
      UniqueIdentifier: _uniqueidentifier.default,
      NText: _ntext.default,
      VarBinary: _varbinary.default,
      VarChar: _varchar.default,
      Binary: _binary.default,
      Char: _char.default,
      NVarChar: _nvarchar.default,
      NChar: _nchar.default,
      Xml: _xml.default,
      Time: _time.default,
      Date: _date.default,
      DateTime2: _datetime2.default,
      DateTimeOffset: _datetimeoffset.default,
      UDT: _udt.default,
      TVP: _tvp.default,
      Variant: _sqlVariant.default
    };
    var typeByName = exports.typeByName = TYPES;
  }
});

// node_modules/tedious/lib/token/helpers.js
var require_helpers = __commonJS({
  "node_modules/tedious/lib/token/helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Result = exports.NotEnoughDataError = void 0;
    exports.readBVarByte = readBVarByte;
    exports.readBVarChar = readBVarChar;
    exports.readBigInt64LE = readBigInt64LE;
    exports.readBigUInt64LE = readBigUInt64LE;
    exports.readDoubleLE = readDoubleLE;
    exports.readFloatLE = readFloatLE;
    exports.readInt16LE = readInt16LE;
    exports.readInt32LE = readInt32LE;
    exports.readUInt16LE = readUInt16LE;
    exports.readUInt24LE = readUInt24LE;
    exports.readUInt32BE = readUInt32BE;
    exports.readUInt32LE = readUInt32LE;
    exports.readUInt40LE = readUInt40LE;
    exports.readUInt8 = readUInt8;
    exports.readUNumeric128LE = readUNumeric128LE;
    exports.readUNumeric64LE = readUNumeric64LE;
    exports.readUNumeric96LE = readUNumeric96LE;
    exports.readUsVarByte = readUsVarByte;
    exports.readUsVarChar = readUsVarChar;
    var Result = class {
      constructor(value, offset) {
        this.value = value;
        this.offset = offset;
      }
    };
    exports.Result = Result;
    var NotEnoughDataError = class extends Error {
      constructor(byteCount) {
        super();
        __publicField(this, "byteCount");
        this.byteCount = byteCount;
      }
    };
    exports.NotEnoughDataError = NotEnoughDataError;
    function readUInt8(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 1) {
        throw new NotEnoughDataError(offset + 1);
      }
      return new Result(buf.readUInt8(offset), offset + 1);
    }
    function readUInt16LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 2) {
        throw new NotEnoughDataError(offset + 2);
      }
      return new Result(buf.readUInt16LE(offset), offset + 2);
    }
    function readInt16LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 2) {
        throw new NotEnoughDataError(offset + 2);
      }
      return new Result(buf.readInt16LE(offset), offset + 2);
    }
    function readUInt24LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 3) {
        throw new NotEnoughDataError(offset + 3);
      }
      return new Result(buf.readUIntLE(offset, 3), offset + 3);
    }
    function readUInt32LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 4) {
        throw new NotEnoughDataError(offset + 4);
      }
      return new Result(buf.readUInt32LE(offset), offset + 4);
    }
    function readUInt32BE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 4) {
        throw new NotEnoughDataError(offset + 4);
      }
      return new Result(buf.readUInt32BE(offset), offset + 4);
    }
    function readUInt40LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 5) {
        throw new NotEnoughDataError(offset + 5);
      }
      return new Result(buf.readUIntLE(offset, 5), offset + 5);
    }
    function readInt32LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 4) {
        throw new NotEnoughDataError(offset + 4);
      }
      return new Result(buf.readInt32LE(offset), offset + 4);
    }
    function readBigUInt64LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 8) {
        throw new NotEnoughDataError(offset + 8);
      }
      return new Result(buf.readBigUInt64LE(offset), offset + 8);
    }
    function readBigInt64LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 8) {
        throw new NotEnoughDataError(offset + 8);
      }
      return new Result(buf.readBigInt64LE(offset), offset + 8);
    }
    function readFloatLE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 4) {
        throw new NotEnoughDataError(offset + 4);
      }
      return new Result(buf.readFloatLE(offset), offset + 4);
    }
    function readDoubleLE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 8) {
        throw new NotEnoughDataError(offset + 8);
      }
      return new Result(buf.readDoubleLE(offset), offset + 8);
    }
    function readBVarChar(buf, offset) {
      offset = +offset;
      let charCount;
      ({
        offset,
        value: charCount
      } = readUInt8(buf, offset));
      const byteLength = charCount * 2;
      if (buf.length < offset + byteLength) {
        throw new NotEnoughDataError(offset + byteLength);
      }
      return new Result(buf.toString("ucs2", offset, offset + byteLength), offset + byteLength);
    }
    function readBVarByte(buf, offset) {
      offset = +offset;
      let byteLength;
      ({
        offset,
        value: byteLength
      } = readUInt8(buf, offset));
      if (buf.length < offset + byteLength) {
        throw new NotEnoughDataError(offset + byteLength);
      }
      return new Result(buf.slice(offset, offset + byteLength), offset + byteLength);
    }
    function readUsVarChar(buf, offset) {
      offset = +offset;
      let charCount;
      ({
        offset,
        value: charCount
      } = readUInt16LE(buf, offset));
      const byteLength = charCount * 2;
      if (buf.length < offset + byteLength) {
        throw new NotEnoughDataError(offset + byteLength);
      }
      return new Result(buf.toString("ucs2", offset, offset + byteLength), offset + byteLength);
    }
    function readUsVarByte(buf, offset) {
      offset = +offset;
      let byteLength;
      ({
        offset,
        value: byteLength
      } = readUInt16LE(buf, offset));
      if (buf.length < offset + byteLength) {
        throw new NotEnoughDataError(offset + byteLength);
      }
      return new Result(buf.slice(offset, offset + byteLength), offset + byteLength);
    }
    function readUNumeric64LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 8) {
        throw new NotEnoughDataError(offset + 8);
      }
      const low = buf.readUInt32LE(offset);
      const high = buf.readUInt32LE(offset + 4);
      return new Result(4294967296 * high + low, offset + 8);
    }
    function readUNumeric96LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 12) {
        throw new NotEnoughDataError(offset + 12);
      }
      const dword1 = buf.readUInt32LE(offset);
      const dword2 = buf.readUInt32LE(offset + 4);
      const dword3 = buf.readUInt32LE(offset + 8);
      return new Result(dword1 + 4294967296 * dword2 + 4294967296 * 4294967296 * dword3, offset + 12);
    }
    function readUNumeric128LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 16) {
        throw new NotEnoughDataError(offset + 16);
      }
      const dword1 = buf.readUInt32LE(offset);
      const dword2 = buf.readUInt32LE(offset + 4);
      const dword3 = buf.readUInt32LE(offset + 8);
      const dword4 = buf.readUInt32LE(offset + 12);
      return new Result(dword1 + 4294967296 * dword2 + 4294967296 * 4294967296 * dword3 + 4294967296 * 4294967296 * 4294967296 * dword4, offset + 16);
    }
  }
});

// node_modules/tedious/lib/metadata-parser.js
var require_metadata_parser = __commonJS({
  "node_modules/tedious/lib/metadata-parser.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    exports.readCollation = readCollation;
    exports.readMetadata = readMetadata;
    var _collation = require_collation();
    var _dataType = require_data_type();
    var _sprintfJs = require_sprintf();
    var _helpers = require_helpers();
    function readCollation(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 5) {
        throw new _helpers.NotEnoughDataError(offset + 5);
      }
      const collation = _collation.Collation.fromBuffer(buf.slice(offset, offset + 5));
      return new _helpers.Result(collation, offset + 5);
    }
    function readSchema(buf, offset) {
      offset = +offset;
      let schemaPresent;
      ({
        offset,
        value: schemaPresent
      } = (0, _helpers.readUInt8)(buf, offset));
      if (schemaPresent !== 1) {
        return new _helpers.Result(void 0, offset);
      }
      let dbname;
      ({
        offset,
        value: dbname
      } = (0, _helpers.readBVarChar)(buf, offset));
      let owningSchema;
      ({
        offset,
        value: owningSchema
      } = (0, _helpers.readBVarChar)(buf, offset));
      let xmlSchemaCollection;
      ({
        offset,
        value: xmlSchemaCollection
      } = (0, _helpers.readUsVarChar)(buf, offset));
      return new _helpers.Result({
        dbname,
        owningSchema,
        xmlSchemaCollection
      }, offset);
    }
    function readUDTInfo(buf, offset) {
      let maxByteSize;
      ({
        offset,
        value: maxByteSize
      } = (0, _helpers.readUInt16LE)(buf, offset));
      let dbname;
      ({
        offset,
        value: dbname
      } = (0, _helpers.readBVarChar)(buf, offset));
      let owningSchema;
      ({
        offset,
        value: owningSchema
      } = (0, _helpers.readBVarChar)(buf, offset));
      let typeName;
      ({
        offset,
        value: typeName
      } = (0, _helpers.readBVarChar)(buf, offset));
      let assemblyName;
      ({
        offset,
        value: assemblyName
      } = (0, _helpers.readUsVarChar)(buf, offset));
      return new _helpers.Result({
        maxByteSize,
        dbname,
        owningSchema,
        typeName,
        assemblyName
      }, offset);
    }
    function readMetadata(buf, offset, options) {
      let userType;
      ({
        offset,
        value: userType
      } = (options.tdsVersion < "7_2" ? _helpers.readUInt16LE : _helpers.readUInt32LE)(buf, offset));
      let flags;
      ({
        offset,
        value: flags
      } = (0, _helpers.readUInt16LE)(buf, offset));
      let typeNumber;
      ({
        offset,
        value: typeNumber
      } = (0, _helpers.readUInt8)(buf, offset));
      const type = _dataType.TYPE[typeNumber];
      if (!type) {
        throw new Error((0, _sprintfJs.sprintf)("Unrecognised data type 0x%02X", typeNumber));
      }
      switch (type.name) {
        case "Null":
        case "TinyInt":
        case "SmallInt":
        case "Int":
        case "BigInt":
        case "Real":
        case "Float":
        case "SmallMoney":
        case "Money":
        case "Bit":
        case "SmallDateTime":
        case "DateTime":
        case "Date":
          return new _helpers.Result({
            userType,
            flags,
            type,
            collation: void 0,
            precision: void 0,
            scale: void 0,
            dataLength: void 0,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        case "IntN":
        case "FloatN":
        case "MoneyN":
        case "BitN":
        case "UniqueIdentifier":
        case "DateTimeN": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type,
            collation: void 0,
            precision: void 0,
            scale: void 0,
            dataLength,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        }
        case "Variant": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt32LE)(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type,
            collation: void 0,
            precision: void 0,
            scale: void 0,
            dataLength,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        }
        case "VarChar":
        case "Char":
        case "NVarChar":
        case "NChar": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt16LE)(buf, offset));
          let collation;
          ({
            offset,
            value: collation
          } = readCollation(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type,
            collation,
            precision: void 0,
            scale: void 0,
            dataLength,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        }
        case "Text":
        case "NText": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt32LE)(buf, offset));
          let collation;
          ({
            offset,
            value: collation
          } = readCollation(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type,
            collation,
            precision: void 0,
            scale: void 0,
            dataLength,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        }
        case "VarBinary":
        case "Binary": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt16LE)(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type,
            collation: void 0,
            precision: void 0,
            scale: void 0,
            dataLength,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        }
        case "Image": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt32LE)(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type,
            collation: void 0,
            precision: void 0,
            scale: void 0,
            dataLength,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        }
        case "Xml": {
          let schema;
          ({
            offset,
            value: schema
          } = readSchema(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type,
            collation: void 0,
            precision: void 0,
            scale: void 0,
            dataLength: void 0,
            schema,
            udtInfo: void 0
          }, offset);
        }
        case "Time":
        case "DateTime2":
        case "DateTimeOffset": {
          let scale;
          ({
            offset,
            value: scale
          } = (0, _helpers.readUInt8)(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type,
            collation: void 0,
            precision: void 0,
            scale,
            dataLength: void 0,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        }
        case "NumericN":
        case "DecimalN": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          let precision;
          ({
            offset,
            value: precision
          } = (0, _helpers.readUInt8)(buf, offset));
          let scale;
          ({
            offset,
            value: scale
          } = (0, _helpers.readUInt8)(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type,
            collation: void 0,
            precision,
            scale,
            dataLength,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        }
        case "UDT": {
          let udtInfo;
          ({
            offset,
            value: udtInfo
          } = readUDTInfo(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type,
            collation: void 0,
            precision: void 0,
            scale: void 0,
            dataLength: void 0,
            schema: void 0,
            udtInfo
          }, offset);
        }
        default:
          throw new Error((0, _sprintfJs.sprintf)("Unrecognised type %s", type.name));
      }
    }
    function metadataParse(parser, options, callback) {
      (async () => {
        while (true) {
          let result;
          try {
            result = readMetadata(parser.buffer, parser.position, options);
          } catch (err) {
            if (err instanceof _helpers.NotEnoughDataError) {
              await parser.waitForChunk();
              continue;
            }
            throw err;
          }
          parser.position = result.offset;
          return callback(result.value);
        }
      })();
    }
    var _default = exports.default = metadataParse;
    module.exports = metadataParse;
    module.exports.readCollation = readCollation;
    module.exports.readMetadata = readMetadata;
  }
});

// node_modules/tedious/lib/token/colmetadata-token-parser.js
var require_colmetadata_token_parser = __commonJS({
  "node_modules/tedious/lib/token/colmetadata-token-parser.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _metadataParser = require_metadata_parser();
    var _token = require_token();
    var _helpers = require_helpers();
    function readTableName(buf, offset, metadata, options) {
      if (!metadata.type.hasTableName) {
        return new _helpers.Result(void 0, offset);
      }
      if (options.tdsVersion < "7_2") {
        return (0, _helpers.readUsVarChar)(buf, offset);
      }
      let numberOfTableNameParts;
      ({
        offset,
        value: numberOfTableNameParts
      } = (0, _helpers.readUInt8)(buf, offset));
      const tableName = [];
      for (let i = 0; i < numberOfTableNameParts; i++) {
        let tableNamePart;
        ({
          offset,
          value: tableNamePart
        } = (0, _helpers.readUsVarChar)(buf, offset));
        tableName.push(tableNamePart);
      }
      return new _helpers.Result(tableName, offset);
    }
    function readColumnName(buf, offset, index, metadata, options) {
      let colName;
      ({
        offset,
        value: colName
      } = (0, _helpers.readBVarChar)(buf, offset));
      if (options.columnNameReplacer) {
        return new _helpers.Result(options.columnNameReplacer(colName, index, metadata), offset);
      } else if (options.camelCaseColumns) {
        return new _helpers.Result(colName.replace(/^[A-Z]/, function(s) {
          return s.toLowerCase();
        }), offset);
      } else {
        return new _helpers.Result(colName, offset);
      }
    }
    function readColumn(buf, offset, options, index) {
      let metadata;
      ({
        offset,
        value: metadata
      } = (0, _metadataParser.readMetadata)(buf, offset, options));
      let tableName;
      ({
        offset,
        value: tableName
      } = readTableName(buf, offset, metadata, options));
      let colName;
      ({
        offset,
        value: colName
      } = readColumnName(buf, offset, index, metadata, options));
      return new _helpers.Result({
        userType: metadata.userType,
        flags: metadata.flags,
        type: metadata.type,
        collation: metadata.collation,
        precision: metadata.precision,
        scale: metadata.scale,
        udtInfo: metadata.udtInfo,
        dataLength: metadata.dataLength,
        schema: metadata.schema,
        colName,
        tableName
      }, offset);
    }
    async function colMetadataParser(parser) {
      let columnCount;
      while (true) {
        let offset;
        try {
          ({
            offset,
            value: columnCount
          } = (0, _helpers.readUInt16LE)(parser.buffer, parser.position));
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            await parser.waitForChunk();
            continue;
          }
          throw err;
        }
        parser.position = offset;
        break;
      }
      const columns = [];
      for (let i = 0; i < columnCount; i++) {
        while (true) {
          let column;
          let offset;
          try {
            ({
              offset,
              value: column
            } = readColumn(parser.buffer, parser.position, parser.options, i));
          } catch (err) {
            if (err instanceof _helpers.NotEnoughDataError) {
              await parser.waitForChunk();
              continue;
            }
            throw err;
          }
          parser.position = offset;
          columns.push(column);
          break;
        }
      }
      return new _token.ColMetadataToken(columns);
    }
    var _default = exports.default = colMetadataParser;
    module.exports = colMetadataParser;
  }
});

// node_modules/tedious/lib/token/done-token-parser.js
var require_done_token_parser = __commonJS({
  "node_modules/tedious/lib/token/done-token-parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.doneInProcParser = doneInProcParser;
    exports.doneParser = doneParser;
    exports.doneProcParser = doneProcParser;
    var _token = require_token();
    var _helpers = require_helpers();
    var STATUS = {
      MORE: 1,
      ERROR: 2,
      // This bit is not yet in use by SQL Server, so is not exposed in the returned token
      INXACT: 4,
      COUNT: 16,
      ATTN: 32,
      SRVERROR: 256
    };
    function readToken(buf, offset, options) {
      let status;
      ({
        offset,
        value: status
      } = (0, _helpers.readUInt16LE)(buf, offset));
      const more = !!(status & STATUS.MORE);
      const sqlError = !!(status & STATUS.ERROR);
      const rowCountValid = !!(status & STATUS.COUNT);
      const attention = !!(status & STATUS.ATTN);
      const serverError = !!(status & STATUS.SRVERROR);
      let curCmd;
      ({
        offset,
        value: curCmd
      } = (0, _helpers.readUInt16LE)(buf, offset));
      let rowCount;
      ({
        offset,
        value: rowCount
      } = (options.tdsVersion < "7_2" ? _helpers.readUInt32LE : _helpers.readBigUInt64LE)(buf, offset));
      return new _helpers.Result({
        more,
        sqlError,
        attention,
        serverError,
        rowCount: rowCountValid ? Number(rowCount) : void 0,
        curCmd
      }, offset);
    }
    function doneParser(buf, offset, options) {
      let value;
      ({
        offset,
        value
      } = readToken(buf, offset, options));
      return new _helpers.Result(new _token.DoneToken(value), offset);
    }
    function doneInProcParser(buf, offset, options) {
      let value;
      ({
        offset,
        value
      } = readToken(buf, offset, options));
      return new _helpers.Result(new _token.DoneInProcToken(value), offset);
    }
    function doneProcParser(buf, offset, options) {
      let value;
      ({
        offset,
        value
      } = readToken(buf, offset, options));
      return new _helpers.Result(new _token.DoneProcToken(value), offset);
    }
  }
});

// node_modules/tedious/lib/token/env-change-token-parser.js
var require_env_change_token_parser = __commonJS({
  "node_modules/tedious/lib/token/env-change-token-parser.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _collation = require_collation();
    var _token = require_token();
    var _helpers = require_helpers();
    var types = {
      1: {
        name: "DATABASE",
        event: "databaseChange"
      },
      2: {
        name: "LANGUAGE",
        event: "languageChange"
      },
      3: {
        name: "CHARSET",
        event: "charsetChange"
      },
      4: {
        name: "PACKET_SIZE",
        event: "packetSizeChange"
      },
      7: {
        name: "SQL_COLLATION",
        event: "sqlCollationChange"
      },
      8: {
        name: "BEGIN_TXN",
        event: "beginTransaction"
      },
      9: {
        name: "COMMIT_TXN",
        event: "commitTransaction"
      },
      10: {
        name: "ROLLBACK_TXN",
        event: "rollbackTransaction"
      },
      13: {
        name: "DATABASE_MIRRORING_PARTNER",
        event: "partnerNode"
      },
      17: {
        name: "TXN_ENDED"
      },
      18: {
        name: "RESET_CONNECTION",
        event: "resetConnection"
      },
      20: {
        name: "ROUTING_CHANGE",
        event: "routingChange"
      }
    };
    function _readNewAndOldValue(buf, offset, length, type) {
      switch (type.name) {
        case "DATABASE":
        case "LANGUAGE":
        case "CHARSET":
        case "PACKET_SIZE":
        case "DATABASE_MIRRORING_PARTNER": {
          let newValue;
          ({
            offset,
            value: newValue
          } = (0, _helpers.readBVarChar)(buf, offset));
          let oldValue;
          ({
            offset,
            value: oldValue
          } = (0, _helpers.readBVarChar)(buf, offset));
          switch (type.name) {
            case "PACKET_SIZE":
              return new _helpers.Result(new _token.PacketSizeEnvChangeToken(parseInt(newValue), parseInt(oldValue)), offset);
            case "DATABASE":
              return new _helpers.Result(new _token.DatabaseEnvChangeToken(newValue, oldValue), offset);
            case "LANGUAGE":
              return new _helpers.Result(new _token.LanguageEnvChangeToken(newValue, oldValue), offset);
            case "CHARSET":
              return new _helpers.Result(new _token.CharsetEnvChangeToken(newValue, oldValue), offset);
            case "DATABASE_MIRRORING_PARTNER":
              return new _helpers.Result(new _token.DatabaseMirroringPartnerEnvChangeToken(newValue, oldValue), offset);
          }
          throw new Error("unreachable");
        }
        case "SQL_COLLATION":
        case "BEGIN_TXN":
        case "COMMIT_TXN":
        case "ROLLBACK_TXN":
        case "RESET_CONNECTION": {
          let newValue;
          ({
            offset,
            value: newValue
          } = (0, _helpers.readBVarByte)(buf, offset));
          let oldValue;
          ({
            offset,
            value: oldValue
          } = (0, _helpers.readBVarByte)(buf, offset));
          switch (type.name) {
            case "SQL_COLLATION": {
              const newCollation = newValue.length ? _collation.Collation.fromBuffer(newValue) : void 0;
              const oldCollation = oldValue.length ? _collation.Collation.fromBuffer(oldValue) : void 0;
              return new _helpers.Result(new _token.CollationChangeToken(newCollation, oldCollation), offset);
            }
            case "BEGIN_TXN":
              return new _helpers.Result(new _token.BeginTransactionEnvChangeToken(newValue, oldValue), offset);
            case "COMMIT_TXN":
              return new _helpers.Result(new _token.CommitTransactionEnvChangeToken(newValue, oldValue), offset);
            case "ROLLBACK_TXN":
              return new _helpers.Result(new _token.RollbackTransactionEnvChangeToken(newValue, oldValue), offset);
            case "RESET_CONNECTION":
              return new _helpers.Result(new _token.ResetConnectionEnvChangeToken(newValue, oldValue), offset);
          }
          throw new Error("unreachable");
        }
        case "ROUTING_CHANGE": {
          let routePacket;
          ({
            offset,
            value: routePacket
          } = (0, _helpers.readUsVarByte)(buf, offset));
          let oldValue;
          ({
            offset,
            value: oldValue
          } = (0, _helpers.readUsVarByte)(buf, offset));
          const protocol = routePacket.readUInt8(0);
          if (protocol !== 0) {
            throw new Error("Unknown protocol byte in routing change event");
          }
          const port = routePacket.readUInt16LE(1);
          const serverLen = routePacket.readUInt16LE(3);
          const server = routePacket.toString("ucs2", 5, 5 + serverLen * 2);
          const newValue = {
            protocol,
            port,
            server
          };
          return new _helpers.Result(new _token.RoutingEnvChangeToken(newValue, oldValue), offset);
        }
        default: {
          console.error("Tedious > Unsupported ENVCHANGE type " + type.name);
          return new _helpers.Result(void 0, offset + length - 1);
        }
      }
    }
    function envChangeParser(buf, offset, _options) {
      let tokenLength;
      ({
        offset,
        value: tokenLength
      } = (0, _helpers.readUInt16LE)(buf, offset));
      if (buf.length < offset + tokenLength) {
        throw new _helpers.NotEnoughDataError(offset + tokenLength);
      }
      let typeNumber;
      ({
        offset,
        value: typeNumber
      } = (0, _helpers.readUInt8)(buf, offset));
      const type = types[typeNumber];
      if (!type) {
        console.error("Tedious > Unsupported ENVCHANGE type " + typeNumber);
        return new _helpers.Result(void 0, offset + tokenLength - 1);
      }
      return _readNewAndOldValue(buf, offset, tokenLength, type);
    }
    var _default = exports.default = envChangeParser;
    module.exports = envChangeParser;
  }
});

// node_modules/tedious/lib/token/infoerror-token-parser.js
var require_infoerror_token_parser = __commonJS({
  "node_modules/tedious/lib/token/infoerror-token-parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.errorParser = errorParser;
    exports.infoParser = infoParser;
    var _helpers = require_helpers();
    var _token = require_token();
    function readToken(buf, offset, options) {
      let tokenLength;
      ({
        offset,
        value: tokenLength
      } = (0, _helpers.readUInt16LE)(buf, offset));
      if (buf.length < tokenLength + offset) {
        throw new _helpers.NotEnoughDataError(tokenLength + offset);
      }
      let number;
      ({
        offset,
        value: number
      } = (0, _helpers.readUInt32LE)(buf, offset));
      let state3;
      ({
        offset,
        value: state3
      } = (0, _helpers.readUInt8)(buf, offset));
      let clazz;
      ({
        offset,
        value: clazz
      } = (0, _helpers.readUInt8)(buf, offset));
      let message;
      ({
        offset,
        value: message
      } = (0, _helpers.readUsVarChar)(buf, offset));
      let serverName;
      ({
        offset,
        value: serverName
      } = (0, _helpers.readBVarChar)(buf, offset));
      let procName;
      ({
        offset,
        value: procName
      } = (0, _helpers.readBVarChar)(buf, offset));
      let lineNumber;
      ({
        offset,
        value: lineNumber
      } = options.tdsVersion < "7_2" ? (0, _helpers.readUInt16LE)(buf, offset) : (0, _helpers.readUInt32LE)(buf, offset));
      return new _helpers.Result({
        "number": number,
        "state": state3,
        "class": clazz,
        "message": message,
        "serverName": serverName,
        "procName": procName,
        "lineNumber": lineNumber
      }, offset);
    }
    function infoParser(buf, offset, options) {
      let data;
      ({
        offset,
        value: data
      } = readToken(buf, offset, options));
      return new _helpers.Result(new _token.InfoMessageToken(data), offset);
    }
    function errorParser(buf, offset, options) {
      let data;
      ({
        offset,
        value: data
      } = readToken(buf, offset, options));
      return new _helpers.Result(new _token.ErrorMessageToken(data), offset);
    }
  }
});

// node_modules/tedious/lib/token/fedauth-info-parser.js
var require_fedauth_info_parser = __commonJS({
  "node_modules/tedious/lib/token/fedauth-info-parser.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _helpers = require_helpers();
    var _token = require_token();
    var FEDAUTHINFOID = {
      STSURL: 1,
      SPN: 2
    };
    function readFedAuthInfo(data) {
      let offset = 0;
      let spn, stsurl;
      const countOfInfoIDs = data.readUInt32LE(offset);
      offset += 4;
      for (let i = 0; i < countOfInfoIDs; i++) {
        const fedauthInfoID = data.readUInt8(offset);
        offset += 1;
        const fedAuthInfoDataLen = data.readUInt32LE(offset);
        offset += 4;
        const fedAuthInfoDataOffset = data.readUInt32LE(offset);
        offset += 4;
        switch (fedauthInfoID) {
          case FEDAUTHINFOID.SPN:
            spn = data.toString("ucs2", fedAuthInfoDataOffset, fedAuthInfoDataOffset + fedAuthInfoDataLen);
            break;
          case FEDAUTHINFOID.STSURL:
            stsurl = data.toString("ucs2", fedAuthInfoDataOffset, fedAuthInfoDataOffset + fedAuthInfoDataLen);
            break;
          // ignoring unknown fedauthinfo options
          default:
            break;
        }
      }
      return {
        spn,
        stsurl
      };
    }
    function fedAuthInfoParser(buf, offset, _options) {
      let tokenLength;
      ({
        offset,
        value: tokenLength
      } = (0, _helpers.readUInt32LE)(buf, offset));
      if (buf.length < offset + tokenLength) {
        throw new _helpers.NotEnoughDataError(offset + tokenLength);
      }
      const data = buf.slice(offset, offset + tokenLength);
      offset += tokenLength;
      const {
        spn,
        stsurl
      } = readFedAuthInfo(data);
      return new _helpers.Result(new _token.FedAuthInfoToken(spn, stsurl), offset);
    }
    var _default = exports.default = fedAuthInfoParser;
    module.exports = fedAuthInfoParser;
  }
});

// node_modules/tedious/lib/token/feature-ext-ack-parser.js
var require_feature_ext_ack_parser = __commonJS({
  "node_modules/tedious/lib/token/feature-ext-ack-parser.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _helpers = require_helpers();
    var _token = require_token();
    var FEATURE_ID = {
      SESSIONRECOVERY: 1,
      FEDAUTH: 2,
      COLUMNENCRYPTION: 4,
      GLOBALTRANSACTIONS: 5,
      AZURESQLSUPPORT: 8,
      UTF8_SUPPORT: 10,
      TERMINATOR: 255
    };
    function featureExtAckParser(buf, offset, _options) {
      let fedAuth;
      let utf8Support;
      while (true) {
        let featureId;
        ({
          value: featureId,
          offset
        } = (0, _helpers.readUInt8)(buf, offset));
        if (featureId === FEATURE_ID.TERMINATOR) {
          return new _helpers.Result(new _token.FeatureExtAckToken(fedAuth, utf8Support), offset);
        }
        let featureAckDataLen;
        ({
          value: featureAckDataLen,
          offset
        } = (0, _helpers.readUInt32LE)(buf, offset));
        if (buf.length < offset + featureAckDataLen) {
          throw new _helpers.NotEnoughDataError(offset + featureAckDataLen);
        }
        const featureData = buf.slice(offset, offset + featureAckDataLen);
        offset += featureAckDataLen;
        switch (featureId) {
          case FEATURE_ID.FEDAUTH:
            fedAuth = featureData;
            break;
          case FEATURE_ID.UTF8_SUPPORT:
            utf8Support = !!featureData[0];
            break;
        }
      }
    }
    var _default = exports.default = featureExtAckParser;
    module.exports = featureExtAckParser;
  }
});

// node_modules/tedious/lib/token/loginack-token-parser.js
var require_loginack_token_parser = __commonJS({
  "node_modules/tedious/lib/token/loginack-token-parser.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _token = require_token();
    var _tdsVersions = require_tds_versions();
    var _helpers = require_helpers();
    var interfaceTypes = {
      0: "SQL_DFLT",
      1: "SQL_TSQL"
    };
    function loginAckParser(buf, offset, _options) {
      let tokenLength;
      ({
        offset,
        value: tokenLength
      } = (0, _helpers.readUInt16LE)(buf, offset));
      if (buf.length < tokenLength + offset) {
        throw new _helpers.NotEnoughDataError(tokenLength + offset);
      }
      let interfaceNumber;
      ({
        offset,
        value: interfaceNumber
      } = (0, _helpers.readUInt8)(buf, offset));
      const interfaceType = interfaceTypes[interfaceNumber];
      let tdsVersionNumber;
      ({
        offset,
        value: tdsVersionNumber
      } = (0, _helpers.readUInt32BE)(buf, offset));
      const tdsVersion = _tdsVersions.versionsByValue[tdsVersionNumber];
      let progName;
      ({
        offset,
        value: progName
      } = (0, _helpers.readBVarChar)(buf, offset));
      let major;
      ({
        offset,
        value: major
      } = (0, _helpers.readUInt8)(buf, offset));
      let minor;
      ({
        offset,
        value: minor
      } = (0, _helpers.readUInt8)(buf, offset));
      let buildNumHi;
      ({
        offset,
        value: buildNumHi
      } = (0, _helpers.readUInt8)(buf, offset));
      let buildNumLow;
      ({
        offset,
        value: buildNumLow
      } = (0, _helpers.readUInt8)(buf, offset));
      return new _helpers.Result(new _token.LoginAckToken({
        interface: interfaceType,
        tdsVersion,
        progName,
        progVersion: {
          major,
          minor,
          buildNumHi,
          buildNumLow
        }
      }), offset);
    }
    var _default = exports.default = loginAckParser;
    module.exports = loginAckParser;
  }
});

// node_modules/tedious/lib/token/order-token-parser.js
var require_order_token_parser = __commonJS({
  "node_modules/tedious/lib/token/order-token-parser.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _token = require_token();
    var _helpers = require_helpers();
    function orderParser(buf, offset, _options) {
      let tokenLength;
      ({
        offset,
        value: tokenLength
      } = (0, _helpers.readUInt16LE)(buf, offset));
      if (buf.length < offset + tokenLength) {
        throw new _helpers.NotEnoughDataError(offset + tokenLength);
      }
      const orderColumns = [];
      for (let i = 0; i < tokenLength; i += 2) {
        let column;
        ({
          offset,
          value: column
        } = (0, _helpers.readUInt16LE)(buf, offset));
        orderColumns.push(column);
      }
      return new _helpers.Result(new _token.OrderToken(orderColumns), offset);
    }
    var _default = exports.default = orderParser;
    module.exports = orderParser;
  }
});

// node_modules/tedious/lib/token/returnstatus-token-parser.js
var require_returnstatus_token_parser = __commonJS({
  "node_modules/tedious/lib/token/returnstatus-token-parser.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _helpers = require_helpers();
    var _token = require_token();
    function returnStatusParser(buf, offset, _options) {
      let value;
      ({
        value,
        offset
      } = (0, _helpers.readInt32LE)(buf, offset));
      return new _helpers.Result(new _token.ReturnStatusToken(value), offset);
    }
    var _default = exports.default = returnStatusParser;
    module.exports = returnStatusParser;
  }
});

// node_modules/tedious/lib/value-parser.js
var require_value_parser = __commonJS({
  "node_modules/tedious/lib/value-parser.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isPLPStream = isPLPStream;
    exports.readPLPStream = readPLPStream;
    exports.readValue = readValue;
    var _metadataParser = require_metadata_parser();
    var _dataType = require_data_type();
    var _iconvLite = _interopRequireDefault(require_lib());
    var _sprintfJs = require_sprintf();
    var _guidParser = require_guid_parser();
    var _helpers = require_helpers();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL = (1 << 16) - 1;
    var MAX = (1 << 16) - 1;
    var THREE_AND_A_THIRD = 3 + 1 / 3;
    var MONEY_DIVISOR = 1e4;
    var PLP_NULL = 0xFFFFFFFFFFFFFFFFn;
    var UNKNOWN_PLP_LEN = 0xFFFFFFFFFFFFFFFEn;
    var DEFAULT_ENCODING = "utf8";
    function readTinyInt(buf, offset) {
      return (0, _helpers.readUInt8)(buf, offset);
    }
    function readSmallInt(buf, offset) {
      return (0, _helpers.readInt16LE)(buf, offset);
    }
    function readInt(buf, offset) {
      return (0, _helpers.readInt32LE)(buf, offset);
    }
    function readBigInt(buf, offset) {
      let value;
      ({
        offset,
        value
      } = (0, _helpers.readBigInt64LE)(buf, offset));
      return new _helpers.Result(value.toString(), offset);
    }
    function readReal(buf, offset) {
      return (0, _helpers.readFloatLE)(buf, offset);
    }
    function readFloat(buf, offset) {
      return (0, _helpers.readDoubleLE)(buf, offset);
    }
    function readSmallMoney(buf, offset) {
      let value;
      ({
        offset,
        value
      } = (0, _helpers.readInt32LE)(buf, offset));
      return new _helpers.Result(value / MONEY_DIVISOR, offset);
    }
    function readMoney(buf, offset) {
      let high;
      ({
        offset,
        value: high
      } = (0, _helpers.readInt32LE)(buf, offset));
      let low;
      ({
        offset,
        value: low
      } = (0, _helpers.readUInt32LE)(buf, offset));
      return new _helpers.Result((low + 4294967296 * high) / MONEY_DIVISOR, offset);
    }
    function readBit(buf, offset) {
      let value;
      ({
        offset,
        value
      } = (0, _helpers.readUInt8)(buf, offset));
      return new _helpers.Result(!!value, offset);
    }
    function readValue(buf, offset, metadata, options) {
      const type = metadata.type;
      switch (type.name) {
        case "Null":
          return new _helpers.Result(null, offset);
        case "TinyInt": {
          return readTinyInt(buf, offset);
        }
        case "SmallInt": {
          return readSmallInt(buf, offset);
        }
        case "Int": {
          return readInt(buf, offset);
        }
        case "BigInt": {
          return readBigInt(buf, offset);
        }
        case "IntN": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          switch (dataLength) {
            case 0:
              return new _helpers.Result(null, offset);
            case 1:
              return readTinyInt(buf, offset);
            case 2:
              return readSmallInt(buf, offset);
            case 4:
              return readInt(buf, offset);
            case 8:
              return readBigInt(buf, offset);
            default:
              throw new Error("Unsupported dataLength " + dataLength + " for IntN");
          }
        }
        case "Real": {
          return readReal(buf, offset);
        }
        case "Float": {
          return readFloat(buf, offset);
        }
        case "FloatN": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          switch (dataLength) {
            case 0:
              return new _helpers.Result(null, offset);
            case 4:
              return readReal(buf, offset);
            case 8:
              return readFloat(buf, offset);
            default:
              throw new Error("Unsupported dataLength " + dataLength + " for FloatN");
          }
        }
        case "SmallMoney": {
          return readSmallMoney(buf, offset);
        }
        case "Money":
          return readMoney(buf, offset);
        case "MoneyN": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          switch (dataLength) {
            case 0:
              return new _helpers.Result(null, offset);
            case 4:
              return readSmallMoney(buf, offset);
            case 8:
              return readMoney(buf, offset);
            default:
              throw new Error("Unsupported dataLength " + dataLength + " for MoneyN");
          }
        }
        case "Bit": {
          return readBit(buf, offset);
        }
        case "BitN": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          switch (dataLength) {
            case 0:
              return new _helpers.Result(null, offset);
            case 1:
              return readBit(buf, offset);
            default:
              throw new Error("Unsupported dataLength " + dataLength + " for BitN");
          }
        }
        case "VarChar":
        case "Char": {
          const codepage = metadata.collation.codepage;
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt16LE)(buf, offset));
          if (dataLength === NULL) {
            return new _helpers.Result(null, offset);
          }
          return readChars(buf, offset, dataLength, codepage);
        }
        case "NVarChar":
        case "NChar": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt16LE)(buf, offset));
          if (dataLength === NULL) {
            return new _helpers.Result(null, offset);
          }
          return readNChars(buf, offset, dataLength);
        }
        case "VarBinary":
        case "Binary": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt16LE)(buf, offset));
          if (dataLength === NULL) {
            return new _helpers.Result(null, offset);
          }
          return readBinary(buf, offset, dataLength);
        }
        case "Text": {
          let textPointerLength;
          ({
            offset,
            value: textPointerLength
          } = (0, _helpers.readUInt8)(buf, offset));
          if (textPointerLength === 0) {
            return new _helpers.Result(null, offset);
          }
          ({
            offset
          } = readBinary(buf, offset, textPointerLength));
          ({
            offset
          } = readBinary(buf, offset, 8));
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt32LE)(buf, offset));
          return readChars(buf, offset, dataLength, metadata.collation.codepage);
        }
        case "NText": {
          let textPointerLength;
          ({
            offset,
            value: textPointerLength
          } = (0, _helpers.readUInt8)(buf, offset));
          if (textPointerLength === 0) {
            return new _helpers.Result(null, offset);
          }
          ({
            offset
          } = readBinary(buf, offset, textPointerLength));
          ({
            offset
          } = readBinary(buf, offset, 8));
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt32LE)(buf, offset));
          return readNChars(buf, offset, dataLength);
        }
        case "Image": {
          let textPointerLength;
          ({
            offset,
            value: textPointerLength
          } = (0, _helpers.readUInt8)(buf, offset));
          if (textPointerLength === 0) {
            return new _helpers.Result(null, offset);
          }
          ({
            offset
          } = readBinary(buf, offset, textPointerLength));
          ({
            offset
          } = readBinary(buf, offset, 8));
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt32LE)(buf, offset));
          return readBinary(buf, offset, dataLength);
        }
        case "SmallDateTime": {
          return readSmallDateTime(buf, offset, options.useUTC);
        }
        case "DateTime": {
          return readDateTime(buf, offset, options.useUTC);
        }
        case "DateTimeN": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          switch (dataLength) {
            case 0:
              return new _helpers.Result(null, offset);
            case 4:
              return readSmallDateTime(buf, offset, options.useUTC);
            case 8:
              return readDateTime(buf, offset, options.useUTC);
            default:
              throw new Error("Unsupported dataLength " + dataLength + " for DateTimeN");
          }
        }
        case "Time": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          if (dataLength === 0) {
            return new _helpers.Result(null, offset);
          }
          return readTime(buf, offset, dataLength, metadata.scale, options.useUTC);
        }
        case "Date": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          if (dataLength === 0) {
            return new _helpers.Result(null, offset);
          }
          return readDate(buf, offset, options.useUTC);
        }
        case "DateTime2": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          if (dataLength === 0) {
            return new _helpers.Result(null, offset);
          }
          return readDateTime2(buf, offset, dataLength, metadata.scale, options.useUTC);
        }
        case "DateTimeOffset": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          if (dataLength === 0) {
            return new _helpers.Result(null, offset);
          }
          return readDateTimeOffset(buf, offset, dataLength, metadata.scale);
        }
        case "NumericN":
        case "DecimalN": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          if (dataLength === 0) {
            return new _helpers.Result(null, offset);
          }
          return readNumeric(buf, offset, dataLength, metadata.precision, metadata.scale);
        }
        case "UniqueIdentifier": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          switch (dataLength) {
            case 0:
              return new _helpers.Result(null, offset);
            case 16:
              return readUniqueIdentifier(buf, offset, options);
            default:
              throw new Error((0, _sprintfJs.sprintf)("Unsupported guid size %d", dataLength - 1));
          }
        }
        case "Variant": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt32LE)(buf, offset));
          if (dataLength === 0) {
            return new _helpers.Result(null, offset);
          }
          return readVariant(buf, offset, options, dataLength);
        }
        default: {
          throw new Error("Invalid type!");
        }
      }
    }
    function isPLPStream(metadata) {
      switch (metadata.type.name) {
        case "VarChar":
        case "NVarChar":
        case "VarBinary": {
          return metadata.dataLength === MAX;
        }
        case "Xml": {
          return true;
        }
        case "UDT": {
          return true;
        }
      }
    }
    function readUniqueIdentifier(buf, offset, options) {
      let data;
      ({
        value: data,
        offset
      } = readBinary(buf, offset, 16));
      return new _helpers.Result(options.lowerCaseGuids ? (0, _guidParser.bufferToLowerCaseGuid)(data) : (0, _guidParser.bufferToUpperCaseGuid)(data), offset);
    }
    function readNumeric(buf, offset, dataLength, _precision, scale) {
      let sign2;
      ({
        offset,
        value: sign2
      } = (0, _helpers.readUInt8)(buf, offset));
      sign2 = sign2 === 1 ? 1 : -1;
      let value;
      if (dataLength === 5) {
        ({
          offset,
          value
        } = (0, _helpers.readUInt32LE)(buf, offset));
      } else if (dataLength === 9) {
        ({
          offset,
          value
        } = (0, _helpers.readUNumeric64LE)(buf, offset));
      } else if (dataLength === 13) {
        ({
          offset,
          value
        } = (0, _helpers.readUNumeric96LE)(buf, offset));
      } else if (dataLength === 17) {
        ({
          offset,
          value
        } = (0, _helpers.readUNumeric128LE)(buf, offset));
      } else {
        throw new Error((0, _sprintfJs.sprintf)("Unsupported numeric dataLength %d", dataLength));
      }
      return new _helpers.Result(value * sign2 / Math.pow(10, scale), offset);
    }
    function readVariant(buf, offset, options, dataLength) {
      let baseType;
      ({
        value: baseType,
        offset
      } = (0, _helpers.readUInt8)(buf, offset));
      const type = _dataType.TYPE[baseType];
      let propBytes;
      ({
        value: propBytes,
        offset
      } = (0, _helpers.readUInt8)(buf, offset));
      dataLength = dataLength - propBytes - 2;
      switch (type.name) {
        case "UniqueIdentifier":
          return readUniqueIdentifier(buf, offset, options);
        case "Bit":
          return readBit(buf, offset);
        case "TinyInt":
          return readTinyInt(buf, offset);
        case "SmallInt":
          return readSmallInt(buf, offset);
        case "Int":
          return readInt(buf, offset);
        case "BigInt":
          return readBigInt(buf, offset);
        case "SmallDateTime":
          return readSmallDateTime(buf, offset, options.useUTC);
        case "DateTime":
          return readDateTime(buf, offset, options.useUTC);
        case "Real":
          return readReal(buf, offset);
        case "Float":
          return readFloat(buf, offset);
        case "SmallMoney":
          return readSmallMoney(buf, offset);
        case "Money":
          return readMoney(buf, offset);
        case "Date":
          return readDate(buf, offset, options.useUTC);
        case "Time": {
          let scale;
          ({
            value: scale,
            offset
          } = (0, _helpers.readUInt8)(buf, offset));
          return readTime(buf, offset, dataLength, scale, options.useUTC);
        }
        case "DateTime2": {
          let scale;
          ({
            value: scale,
            offset
          } = (0, _helpers.readUInt8)(buf, offset));
          return readDateTime2(buf, offset, dataLength, scale, options.useUTC);
        }
        case "DateTimeOffset": {
          let scale;
          ({
            value: scale,
            offset
          } = (0, _helpers.readUInt8)(buf, offset));
          return readDateTimeOffset(buf, offset, dataLength, scale);
        }
        case "VarBinary":
        case "Binary": {
          ({
            offset
          } = (0, _helpers.readUInt16LE)(buf, offset));
          return readBinary(buf, offset, dataLength);
        }
        case "NumericN":
        case "DecimalN": {
          let precision;
          ({
            value: precision,
            offset
          } = (0, _helpers.readUInt8)(buf, offset));
          let scale;
          ({
            value: scale,
            offset
          } = (0, _helpers.readUInt8)(buf, offset));
          return readNumeric(buf, offset, dataLength, precision, scale);
        }
        case "VarChar":
        case "Char": {
          ({
            offset
          } = (0, _helpers.readUInt16LE)(buf, offset));
          let collation;
          ({
            value: collation,
            offset
          } = (0, _metadataParser.readCollation)(buf, offset));
          return readChars(buf, offset, dataLength, collation.codepage);
        }
        case "NVarChar":
        case "NChar": {
          ({
            offset
          } = (0, _helpers.readUInt16LE)(buf, offset));
          ({
            offset
          } = (0, _metadataParser.readCollation)(buf, offset));
          return readNChars(buf, offset, dataLength);
        }
        default:
          throw new Error("Invalid type!");
      }
    }
    function readBinary(buf, offset, dataLength) {
      if (buf.length < offset + dataLength) {
        throw new _helpers.NotEnoughDataError(offset + dataLength);
      }
      return new _helpers.Result(buf.slice(offset, offset + dataLength), offset + dataLength);
    }
    function readChars(buf, offset, dataLength, codepage) {
      if (buf.length < offset + dataLength) {
        throw new _helpers.NotEnoughDataError(offset + dataLength);
      }
      return new _helpers.Result(_iconvLite.default.decode(buf.slice(offset, offset + dataLength), codepage ?? DEFAULT_ENCODING), offset + dataLength);
    }
    function readNChars(buf, offset, dataLength) {
      if (buf.length < offset + dataLength) {
        throw new _helpers.NotEnoughDataError(offset + dataLength);
      }
      return new _helpers.Result(buf.toString("ucs2", offset, offset + dataLength), offset + dataLength);
    }
    async function readPLPStream(parser) {
      while (parser.buffer.length < parser.position + 8) {
        await parser.waitForChunk();
      }
      const expectedLength = parser.buffer.readBigUInt64LE(parser.position);
      parser.position += 8;
      if (expectedLength === PLP_NULL) {
        return null;
      }
      const chunks = [];
      let currentLength = 0;
      while (true) {
        while (parser.buffer.length < parser.position + 4) {
          await parser.waitForChunk();
        }
        const chunkLength = parser.buffer.readUInt32LE(parser.position);
        parser.position += 4;
        if (!chunkLength) {
          break;
        }
        while (parser.buffer.length < parser.position + chunkLength) {
          await parser.waitForChunk();
        }
        chunks.push(parser.buffer.slice(parser.position, parser.position + chunkLength));
        parser.position += chunkLength;
        currentLength += chunkLength;
      }
      if (expectedLength !== UNKNOWN_PLP_LEN) {
        if (currentLength !== Number(expectedLength)) {
          throw new Error("Partially Length-prefixed Bytes unmatched lengths : expected " + expectedLength + ", but got " + currentLength + " bytes");
        }
      }
      return chunks;
    }
    function readSmallDateTime(buf, offset, useUTC) {
      let days;
      ({
        offset,
        value: days
      } = (0, _helpers.readUInt16LE)(buf, offset));
      let minutes;
      ({
        offset,
        value: minutes
      } = (0, _helpers.readUInt16LE)(buf, offset));
      let value;
      if (useUTC) {
        value = new Date(Date.UTC(1900, 0, 1 + days, 0, minutes));
      } else {
        value = new Date(1900, 0, 1 + days, 0, minutes);
      }
      return new _helpers.Result(value, offset);
    }
    function readDateTime(buf, offset, useUTC) {
      let days;
      ({
        offset,
        value: days
      } = (0, _helpers.readInt32LE)(buf, offset));
      let threeHundredthsOfSecond;
      ({
        offset,
        value: threeHundredthsOfSecond
      } = (0, _helpers.readInt32LE)(buf, offset));
      const milliseconds = Math.round(threeHundredthsOfSecond * THREE_AND_A_THIRD);
      let value;
      if (useUTC) {
        value = new Date(Date.UTC(1900, 0, 1 + days, 0, 0, 0, milliseconds));
      } else {
        value = new Date(1900, 0, 1 + days, 0, 0, 0, milliseconds);
      }
      return new _helpers.Result(value, offset);
    }
    function readTime(buf, offset, dataLength, scale, useUTC) {
      let value;
      switch (dataLength) {
        case 3: {
          ({
            value,
            offset
          } = (0, _helpers.readUInt24LE)(buf, offset));
          break;
        }
        case 4: {
          ({
            value,
            offset
          } = (0, _helpers.readUInt32LE)(buf, offset));
          break;
        }
        case 5: {
          ({
            value,
            offset
          } = (0, _helpers.readUInt40LE)(buf, offset));
          break;
        }
        default: {
          throw new Error("unreachable");
        }
      }
      if (scale < 7) {
        for (let i = scale; i < 7; i++) {
          value *= 10;
        }
      }
      let date;
      if (useUTC) {
        date = new Date(Date.UTC(1970, 0, 1, 0, 0, 0, value / 1e4));
      } else {
        date = new Date(1970, 0, 1, 0, 0, 0, value / 1e4);
      }
      Object.defineProperty(date, "nanosecondsDelta", {
        enumerable: false,
        value: value % 1e4 / Math.pow(10, 7)
      });
      return new _helpers.Result(date, offset);
    }
    function readDate(buf, offset, useUTC) {
      let days;
      ({
        offset,
        value: days
      } = (0, _helpers.readUInt24LE)(buf, offset));
      if (useUTC) {
        return new _helpers.Result(new Date(Date.UTC(2e3, 0, days - 730118)), offset);
      } else {
        return new _helpers.Result(new Date(2e3, 0, days - 730118), offset);
      }
    }
    function readDateTime2(buf, offset, dataLength, scale, useUTC) {
      let time;
      ({
        offset,
        value: time
      } = readTime(buf, offset, dataLength - 3, scale, useUTC));
      let days;
      ({
        offset,
        value: days
      } = (0, _helpers.readUInt24LE)(buf, offset));
      let date;
      if (useUTC) {
        date = new Date(Date.UTC(2e3, 0, days - 730118, 0, 0, 0, +time));
      } else {
        date = new Date(2e3, 0, days - 730118, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
      }
      Object.defineProperty(date, "nanosecondsDelta", {
        enumerable: false,
        value: time.nanosecondsDelta
      });
      return new _helpers.Result(date, offset);
    }
    function readDateTimeOffset(buf, offset, dataLength, scale) {
      let time;
      ({
        offset,
        value: time
      } = readTime(buf, offset, dataLength - 5, scale, true));
      let days;
      ({
        offset,
        value: days
      } = (0, _helpers.readUInt24LE)(buf, offset));
      ({
        offset
      } = (0, _helpers.readUInt16LE)(buf, offset));
      const date = new Date(Date.UTC(2e3, 0, days - 730118, 0, 0, 0, +time));
      Object.defineProperty(date, "nanosecondsDelta", {
        enumerable: false,
        value: time.nanosecondsDelta
      });
      return new _helpers.Result(date, offset);
    }
    module.exports.readValue = readValue;
    module.exports.isPLPStream = isPLPStream;
    module.exports.readPLPStream = readPLPStream;
  }
});

// node_modules/tedious/lib/token/returnvalue-token-parser.js
var require_returnvalue_token_parser = __commonJS({
  "node_modules/tedious/lib/token/returnvalue-token-parser.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _token = require_token();
    var _metadataParser = require_metadata_parser();
    var _valueParser = require_value_parser();
    var _helpers = require_helpers();
    var iconv = _interopRequireWildcard(require_lib());
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
      return n.default = e, t && t.set(e, n), n;
    }
    async function returnParser(parser) {
      var _a3;
      let paramName;
      let paramOrdinal;
      let metadata;
      while (true) {
        const buf = parser.buffer;
        let offset = parser.position;
        try {
          ({
            offset,
            value: paramOrdinal
          } = (0, _helpers.readUInt16LE)(buf, offset));
          ({
            offset,
            value: paramName
          } = (0, _helpers.readBVarChar)(buf, offset));
          ({
            offset
          } = (0, _helpers.readUInt8)(buf, offset));
          ({
            offset,
            value: metadata
          } = (0, _metadataParser.readMetadata)(buf, offset, parser.options));
          if (paramName.charAt(0) === "@") {
            paramName = paramName.slice(1);
          }
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            await parser.waitForChunk();
            continue;
          }
          throw err;
        }
        parser.position = offset;
        break;
      }
      let value;
      while (true) {
        const buf = parser.buffer;
        let offset = parser.position;
        if ((0, _valueParser.isPLPStream)(metadata)) {
          const chunks = await (0, _valueParser.readPLPStream)(parser);
          if (chunks === null) {
            value = chunks;
          } else if (metadata.type.name === "NVarChar" || metadata.type.name === "Xml") {
            value = Buffer.concat(chunks).toString("ucs2");
          } else if (metadata.type.name === "VarChar") {
            value = iconv.decode(Buffer.concat(chunks), ((_a3 = metadata.collation) == null ? void 0 : _a3.codepage) ?? "utf8");
          } else if (metadata.type.name === "VarBinary" || metadata.type.name === "UDT") {
            value = Buffer.concat(chunks);
          }
        } else {
          try {
            ({
              value,
              offset
            } = (0, _valueParser.readValue)(buf, offset, metadata, parser.options));
          } catch (err) {
            if (err instanceof _helpers.NotEnoughDataError) {
              await parser.waitForChunk();
              continue;
            }
            throw err;
          }
          parser.position = offset;
        }
        break;
      }
      return new _token.ReturnValueToken({
        paramOrdinal,
        paramName,
        metadata,
        value
      });
    }
    var _default = exports.default = returnParser;
    module.exports = returnParser;
  }
});

// node_modules/tedious/lib/token/row-token-parser.js
var require_row_token_parser = __commonJS({
  "node_modules/tedious/lib/token/row-token-parser.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _token = require_token();
    var iconv = _interopRequireWildcard(require_lib());
    var _valueParser = require_value_parser();
    var _helpers = require_helpers();
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
      return n.default = e, t && t.set(e, n), n;
    }
    async function rowParser(parser) {
      var _a3;
      const columns = [];
      for (const metadata of parser.colMetadata) {
        while (true) {
          if ((0, _valueParser.isPLPStream)(metadata)) {
            const chunks = await (0, _valueParser.readPLPStream)(parser);
            if (chunks === null) {
              columns.push({
                value: chunks,
                metadata
              });
            } else if (metadata.type.name === "NVarChar" || metadata.type.name === "Xml") {
              columns.push({
                value: Buffer.concat(chunks).toString("ucs2"),
                metadata
              });
            } else if (metadata.type.name === "VarChar") {
              columns.push({
                value: iconv.decode(Buffer.concat(chunks), ((_a3 = metadata.collation) == null ? void 0 : _a3.codepage) ?? "utf8"),
                metadata
              });
            } else if (metadata.type.name === "VarBinary" || metadata.type.name === "UDT") {
              columns.push({
                value: Buffer.concat(chunks),
                metadata
              });
            }
          } else {
            let result;
            try {
              result = (0, _valueParser.readValue)(parser.buffer, parser.position, metadata, parser.options);
            } catch (err) {
              if (err instanceof _helpers.NotEnoughDataError) {
                await parser.waitForChunk();
                continue;
              }
              throw err;
            }
            parser.position = result.offset;
            columns.push({
              value: result.value,
              metadata
            });
          }
          break;
        }
      }
      if (parser.options.useColumnNames) {
        const columnsMap = /* @__PURE__ */ Object.create(null);
        columns.forEach((column) => {
          const colName = column.metadata.colName;
          if (columnsMap[colName] == null) {
            columnsMap[colName] = column;
          }
        });
        return new _token.RowToken(columnsMap);
      } else {
        return new _token.RowToken(columns);
      }
    }
    var _default = exports.default = rowParser;
    module.exports = rowParser;
  }
});

// node_modules/tedious/lib/token/nbcrow-token-parser.js
var require_nbcrow_token_parser = __commonJS({
  "node_modules/tedious/lib/token/nbcrow-token-parser.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _token = require_token();
    var iconv = _interopRequireWildcard(require_lib());
    var _valueParser = require_value_parser();
    var _helpers = require_helpers();
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
      return n.default = e, t && t.set(e, n), n;
    }
    async function nbcRowParser(parser) {
      var _a3;
      const colMetadata = parser.colMetadata;
      const columns = [];
      const bitmap = [];
      const bitmapByteLength = Math.ceil(colMetadata.length / 8);
      while (parser.buffer.length - parser.position < bitmapByteLength) {
        await parser.waitForChunk();
      }
      const bytes = parser.buffer.slice(parser.position, parser.position + bitmapByteLength);
      parser.position += bitmapByteLength;
      for (let i = 0, len = bytes.length; i < len; i++) {
        const byte = bytes[i];
        bitmap.push(byte & 1 ? true : false);
        bitmap.push(byte & 2 ? true : false);
        bitmap.push(byte & 4 ? true : false);
        bitmap.push(byte & 8 ? true : false);
        bitmap.push(byte & 16 ? true : false);
        bitmap.push(byte & 32 ? true : false);
        bitmap.push(byte & 64 ? true : false);
        bitmap.push(byte & 128 ? true : false);
      }
      for (let i = 0; i < colMetadata.length; i++) {
        const metadata = colMetadata[i];
        if (bitmap[i]) {
          columns.push({
            value: null,
            metadata
          });
          continue;
        }
        while (true) {
          if ((0, _valueParser.isPLPStream)(metadata)) {
            const chunks = await (0, _valueParser.readPLPStream)(parser);
            if (chunks === null) {
              columns.push({
                value: chunks,
                metadata
              });
            } else if (metadata.type.name === "NVarChar" || metadata.type.name === "Xml") {
              columns.push({
                value: Buffer.concat(chunks).toString("ucs2"),
                metadata
              });
            } else if (metadata.type.name === "VarChar") {
              columns.push({
                value: iconv.decode(Buffer.concat(chunks), ((_a3 = metadata.collation) == null ? void 0 : _a3.codepage) ?? "utf8"),
                metadata
              });
            } else if (metadata.type.name === "VarBinary" || metadata.type.name === "UDT") {
              columns.push({
                value: Buffer.concat(chunks),
                metadata
              });
            }
          } else {
            let result;
            try {
              result = (0, _valueParser.readValue)(parser.buffer, parser.position, metadata, parser.options);
            } catch (err) {
              if (err instanceof _helpers.NotEnoughDataError) {
                await parser.waitForChunk();
                continue;
              }
              throw err;
            }
            parser.position = result.offset;
            columns.push({
              value: result.value,
              metadata
            });
          }
          break;
        }
      }
      if (parser.options.useColumnNames) {
        const columnsMap = /* @__PURE__ */ Object.create(null);
        columns.forEach((column) => {
          const colName = column.metadata.colName;
          if (columnsMap[colName] == null) {
            columnsMap[colName] = column;
          }
        });
        return new _token.NBCRowToken(columnsMap);
      } else {
        return new _token.NBCRowToken(columns);
      }
    }
    var _default = exports.default = nbcRowParser;
    module.exports = nbcRowParser;
  }
});

// node_modules/tedious/lib/token/sspi-token-parser.js
var require_sspi_token_parser = __commonJS({
  "node_modules/tedious/lib/token/sspi-token-parser.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _helpers = require_helpers();
    var _token = require_token();
    function parseChallenge(buffer) {
      const challenge = {};
      challenge.magic = buffer.slice(0, 8).toString("utf8");
      challenge.type = buffer.readInt32LE(8);
      challenge.domainLen = buffer.readInt16LE(12);
      challenge.domainMax = buffer.readInt16LE(14);
      challenge.domainOffset = buffer.readInt32LE(16);
      challenge.flags = buffer.readInt32LE(20);
      challenge.nonce = buffer.slice(24, 32);
      challenge.zeroes = buffer.slice(32, 40);
      challenge.targetLen = buffer.readInt16LE(40);
      challenge.targetMax = buffer.readInt16LE(42);
      challenge.targetOffset = buffer.readInt32LE(44);
      challenge.oddData = buffer.slice(48, 56);
      challenge.domain = buffer.slice(56, 56 + challenge.domainLen).toString("ucs2");
      challenge.target = buffer.slice(56 + challenge.domainLen, 56 + challenge.domainLen + challenge.targetLen);
      return challenge;
    }
    function sspiParser(buf, offset, _options) {
      let tokenLength;
      ({
        offset,
        value: tokenLength
      } = (0, _helpers.readUInt16LE)(buf, offset));
      if (buf.length < offset + tokenLength) {
        throw new _helpers.NotEnoughDataError(offset + tokenLength);
      }
      const data = buf.slice(offset, offset + tokenLength);
      offset += tokenLength;
      return new _helpers.Result(new _token.SSPIToken(parseChallenge(data), data), offset);
    }
    var _default = exports.default = sspiParser;
    module.exports = sspiParser;
  }
});

// node_modules/tedious/lib/token/stream-parser.js
var require_stream_parser = __commonJS({
  "node_modules/tedious/lib/token/stream-parser.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _token = require_token();
    var _colmetadataTokenParser = _interopRequireDefault(require_colmetadata_token_parser());
    var _doneTokenParser = require_done_token_parser();
    var _envChangeTokenParser = _interopRequireDefault(require_env_change_token_parser());
    var _infoerrorTokenParser = require_infoerror_token_parser();
    var _fedauthInfoParser = _interopRequireDefault(require_fedauth_info_parser());
    var _featureExtAckParser = _interopRequireDefault(require_feature_ext_ack_parser());
    var _loginackTokenParser = _interopRequireDefault(require_loginack_token_parser());
    var _orderTokenParser = _interopRequireDefault(require_order_token_parser());
    var _returnstatusTokenParser = _interopRequireDefault(require_returnstatus_token_parser());
    var _returnvalueTokenParser = _interopRequireDefault(require_returnvalue_token_parser());
    var _rowTokenParser = _interopRequireDefault(require_row_token_parser());
    var _nbcrowTokenParser = _interopRequireDefault(require_nbcrow_token_parser());
    var _sspiTokenParser = _interopRequireDefault(require_sspi_token_parser());
    var _helpers = require_helpers();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Parser = class _Parser {
      constructor(iterable, debug, options) {
        __publicField(this, "debug");
        __publicField(this, "colMetadata");
        __publicField(this, "options");
        __publicField(this, "iterator");
        __publicField(this, "buffer");
        __publicField(this, "position");
        this.debug = debug;
        this.colMetadata = [];
        this.options = options;
        this.iterator = (iterable[Symbol.asyncIterator] || iterable[Symbol.iterator]).call(iterable);
        this.buffer = Buffer.alloc(0);
        this.position = 0;
      }
      static async *parseTokens(iterable, debug, options, colMetadata = []) {
        const parser = new _Parser(iterable, debug, options);
        parser.colMetadata = colMetadata;
        while (true) {
          try {
            await parser.waitForChunk();
          } catch (err) {
            if (parser.position === parser.buffer.length) {
              return;
            }
            throw err;
          }
          while (parser.buffer.length >= parser.position + 1) {
            const type = parser.buffer.readUInt8(parser.position);
            parser.position += 1;
            const token = parser.readToken(type);
            if (token !== void 0) {
              yield token;
            }
          }
        }
      }
      readToken(type) {
        switch (type) {
          case _token.TYPE.DONE: {
            return this.readDoneToken();
          }
          case _token.TYPE.DONEPROC: {
            return this.readDoneProcToken();
          }
          case _token.TYPE.DONEINPROC: {
            return this.readDoneInProcToken();
          }
          case _token.TYPE.ERROR: {
            return this.readErrorToken();
          }
          case _token.TYPE.INFO: {
            return this.readInfoToken();
          }
          case _token.TYPE.ENVCHANGE: {
            return this.readEnvChangeToken();
          }
          case _token.TYPE.LOGINACK: {
            return this.readLoginAckToken();
          }
          case _token.TYPE.RETURNSTATUS: {
            return this.readReturnStatusToken();
          }
          case _token.TYPE.ORDER: {
            return this.readOrderToken();
          }
          case _token.TYPE.FEDAUTHINFO: {
            return this.readFedAuthInfoToken();
          }
          case _token.TYPE.SSPI: {
            return this.readSSPIToken();
          }
          case _token.TYPE.COLMETADATA: {
            return this.readColMetadataToken();
          }
          case _token.TYPE.RETURNVALUE: {
            return this.readReturnValueToken();
          }
          case _token.TYPE.ROW: {
            return this.readRowToken();
          }
          case _token.TYPE.NBCROW: {
            return this.readNbcRowToken();
          }
          case _token.TYPE.FEATUREEXTACK: {
            return this.readFeatureExtAckToken();
          }
          default: {
            throw new Error("Unknown type: " + type);
          }
        }
      }
      readFeatureExtAckToken() {
        let result;
        try {
          result = (0, _featureExtAckParser.default)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readFeatureExtAckToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      async readNbcRowToken() {
        return await (0, _nbcrowTokenParser.default)(this);
      }
      async readReturnValueToken() {
        return await (0, _returnvalueTokenParser.default)(this);
      }
      async readColMetadataToken() {
        const token = await (0, _colmetadataTokenParser.default)(this);
        this.colMetadata = token.columns;
        return token;
      }
      readSSPIToken() {
        let result;
        try {
          result = (0, _sspiTokenParser.default)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readSSPIToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readFedAuthInfoToken() {
        let result;
        try {
          result = (0, _fedauthInfoParser.default)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readFedAuthInfoToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readOrderToken() {
        let result;
        try {
          result = (0, _orderTokenParser.default)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readOrderToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readReturnStatusToken() {
        let result;
        try {
          result = (0, _returnstatusTokenParser.default)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readReturnStatusToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readLoginAckToken() {
        let result;
        try {
          result = (0, _loginackTokenParser.default)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readLoginAckToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readEnvChangeToken() {
        let result;
        try {
          result = (0, _envChangeTokenParser.default)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readEnvChangeToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readRowToken() {
        return (0, _rowTokenParser.default)(this);
      }
      readInfoToken() {
        let result;
        try {
          result = (0, _infoerrorTokenParser.infoParser)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readInfoToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readErrorToken() {
        let result;
        try {
          result = (0, _infoerrorTokenParser.errorParser)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readErrorToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readDoneInProcToken() {
        let result;
        try {
          result = (0, _doneTokenParser.doneInProcParser)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readDoneInProcToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readDoneProcToken() {
        let result;
        try {
          result = (0, _doneTokenParser.doneProcParser)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readDoneProcToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readDoneToken() {
        let result;
        try {
          result = (0, _doneTokenParser.doneParser)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readDoneToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      async waitForChunk() {
        const result = await this.iterator.next();
        if (result.done) {
          throw new Error("unexpected end of data");
        }
        if (this.position === this.buffer.length) {
          this.buffer = result.value;
        } else {
          this.buffer = Buffer.concat([this.buffer.slice(this.position), result.value]);
        }
        this.position = 0;
      }
    };
    var _default = exports.default = Parser;
    module.exports = Parser;
  }
});

// node_modules/tedious/lib/token/token-stream-parser.js
var require_token_stream_parser = __commonJS({
  "node_modules/tedious/lib/token/token-stream-parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Parser = void 0;
    var _events = require_events();
    var _streamParser = _interopRequireDefault(require_stream_parser());
    var _stream = require_stream();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Parser = class extends _events.EventEmitter {
      constructor(message, debug, handler, options) {
        super();
        this.debug = debug;
        this.options = options;
        this.parser = _stream.Readable.from(_streamParser.default.parseTokens(message, this.debug, this.options));
        this.parser.on("data", (token) => {
          debug.token(token);
          handler[token.handlerName](token);
        });
        this.parser.on("drain", () => {
          this.emit("drain");
        });
        this.parser.on("end", () => {
          this.emit("end");
        });
      }
      pause() {
        return this.parser.pause();
      }
      resume() {
        return this.parser.resume();
      }
    };
    exports.Parser = Parser;
  }
});

// node_modules/tedious/lib/transaction.js
var require_transaction2 = __commonJS({
  "node_modules/tedious/lib/transaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Transaction = exports.OPERATION_TYPE = exports.ISOLATION_LEVEL = void 0;
    exports.assertValidIsolationLevel = assertValidIsolationLevel;
    exports.isolationLevelByValue = void 0;
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    var _allHeaders = require_all_headers();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var OPERATION_TYPE = exports.OPERATION_TYPE = {
      TM_GET_DTC_ADDRESS: 0,
      TM_PROPAGATE_XACT: 1,
      TM_BEGIN_XACT: 5,
      TM_PROMOTE_XACT: 6,
      TM_COMMIT_XACT: 7,
      TM_ROLLBACK_XACT: 8,
      TM_SAVE_XACT: 9
    };
    var ISOLATION_LEVEL = exports.ISOLATION_LEVEL = {
      NO_CHANGE: 0,
      READ_UNCOMMITTED: 1,
      READ_COMMITTED: 2,
      REPEATABLE_READ: 3,
      SERIALIZABLE: 4,
      SNAPSHOT: 5
    };
    var isolationLevelByValue = exports.isolationLevelByValue = {};
    for (const name3 in ISOLATION_LEVEL) {
      const value = ISOLATION_LEVEL[name3];
      isolationLevelByValue[value] = name3;
    }
    function assertValidIsolationLevel(isolationLevel, name3) {
      if (typeof isolationLevel !== "number") {
        throw new TypeError(`The "${name3}" ${name3.includes(".") ? "property" : "argument"} must be of type number. Received type ${typeof isolationLevel} (${isolationLevel})`);
      }
      if (!Number.isInteger(isolationLevel)) {
        throw new RangeError(`The value of "${name3}" is out of range. It must be an integer. Received: ${isolationLevel}`);
      }
      if (!(isolationLevel >= 0 && isolationLevel <= 5)) {
        throw new RangeError(`The value of "${name3}" is out of range. It must be >= 0 && <= 5. Received: ${isolationLevel}`);
      }
    }
    var Transaction = class {
      constructor(name3, isolationLevel = ISOLATION_LEVEL.NO_CHANGE) {
        this.name = name3;
        this.isolationLevel = isolationLevel;
        this.outstandingRequestCount = 1;
      }
      beginPayload(txnDescriptor) {
        const buffer = new _writableTrackingBuffer.default(100, "ucs2");
        (0, _allHeaders.writeToTrackingBuffer)(buffer, txnDescriptor, this.outstandingRequestCount);
        buffer.writeUShort(OPERATION_TYPE.TM_BEGIN_XACT);
        buffer.writeUInt8(this.isolationLevel);
        buffer.writeUInt8(this.name.length * 2);
        buffer.writeString(this.name, "ucs2");
        return {
          *[Symbol.iterator]() {
            yield buffer.data;
          },
          toString: () => {
            return "Begin Transaction: name=" + this.name + ", isolationLevel=" + isolationLevelByValue[this.isolationLevel];
          }
        };
      }
      commitPayload(txnDescriptor) {
        const buffer = new _writableTrackingBuffer.default(100, "ascii");
        (0, _allHeaders.writeToTrackingBuffer)(buffer, txnDescriptor, this.outstandingRequestCount);
        buffer.writeUShort(OPERATION_TYPE.TM_COMMIT_XACT);
        buffer.writeUInt8(this.name.length * 2);
        buffer.writeString(this.name, "ucs2");
        buffer.writeUInt8(0);
        return {
          *[Symbol.iterator]() {
            yield buffer.data;
          },
          toString: () => {
            return "Commit Transaction: name=" + this.name;
          }
        };
      }
      rollbackPayload(txnDescriptor) {
        const buffer = new _writableTrackingBuffer.default(100, "ascii");
        (0, _allHeaders.writeToTrackingBuffer)(buffer, txnDescriptor, this.outstandingRequestCount);
        buffer.writeUShort(OPERATION_TYPE.TM_ROLLBACK_XACT);
        buffer.writeUInt8(this.name.length * 2);
        buffer.writeString(this.name, "ucs2");
        buffer.writeUInt8(0);
        return {
          *[Symbol.iterator]() {
            yield buffer.data;
          },
          toString: () => {
            return "Rollback Transaction: name=" + this.name;
          }
        };
      }
      savePayload(txnDescriptor) {
        const buffer = new _writableTrackingBuffer.default(100, "ascii");
        (0, _allHeaders.writeToTrackingBuffer)(buffer, txnDescriptor, this.outstandingRequestCount);
        buffer.writeUShort(OPERATION_TYPE.TM_SAVE_XACT);
        buffer.writeUInt8(this.name.length * 2);
        buffer.writeString(this.name, "ucs2");
        return {
          *[Symbol.iterator]() {
            yield buffer.data;
          },
          toString: () => {
            return "Save Transaction: name=" + this.name;
          }
        };
      }
      isolationLevelToTSQL() {
        switch (this.isolationLevel) {
          case ISOLATION_LEVEL.READ_UNCOMMITTED:
            return "READ UNCOMMITTED";
          case ISOLATION_LEVEL.READ_COMMITTED:
            return "READ COMMITTED";
          case ISOLATION_LEVEL.REPEATABLE_READ:
            return "REPEATABLE READ";
          case ISOLATION_LEVEL.SERIALIZABLE:
            return "SERIALIZABLE";
          case ISOLATION_LEVEL.SNAPSHOT:
            return "SNAPSHOT";
        }
        return "";
      }
    };
    exports.Transaction = Transaction;
  }
});

// node_modules/tedious/lib/connector.js
var require_connector = __commonJS({
  "node_modules/tedious/lib/connector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.connectInParallel = connectInParallel;
    exports.connectInSequence = connectInSequence;
    exports.lookupAllAddresses = lookupAllAddresses;
    var _net = _interopRequireDefault(require_net());
    var _nodeUrl = _interopRequireDefault(require_node_url());
    var _abortError = _interopRequireDefault(require_abort_error());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    async function connectInParallel(options, lookup, signal) {
      if (signal.aborted) {
        throw new _abortError.default();
      }
      const addresses = await lookupAllAddresses(options.host, lookup, signal);
      return await new Promise((resolve, reject) => {
        const sockets = new Array(addresses.length);
        const errors = [];
        function onError(err) {
          errors.push(err);
          this.removeListener("error", onError);
          this.removeListener("connect", onConnect);
          this.destroy();
          if (errors.length === addresses.length) {
            signal.removeEventListener("abort", onAbort);
            reject(new AggregateError(errors, "Could not connect (parallel)"));
          }
        }
        function onConnect() {
          signal.removeEventListener("abort", onAbort);
          for (let j = 0; j < sockets.length; j++) {
            const socket = sockets[j];
            if (this === socket) {
              continue;
            }
            socket.removeListener("error", onError);
            socket.removeListener("connect", onConnect);
            socket.destroy();
          }
          resolve(this);
        }
        const onAbort = () => {
          for (let j = 0; j < sockets.length; j++) {
            const socket = sockets[j];
            socket.removeListener("error", onError);
            socket.removeListener("connect", onConnect);
            socket.destroy();
          }
          reject(new _abortError.default());
        };
        for (let i = 0, len = addresses.length; i < len; i++) {
          const socket = sockets[i] = _net.default.connect({
            ...options,
            host: addresses[i].address,
            family: addresses[i].family
          });
          socket.on("error", onError);
          socket.on("connect", onConnect);
        }
        signal.addEventListener("abort", onAbort, {
          once: true
        });
      });
    }
    async function connectInSequence(options, lookup, signal) {
      if (signal.aborted) {
        throw new _abortError.default();
      }
      const errors = [];
      const addresses = await lookupAllAddresses(options.host, lookup, signal);
      for (const address of addresses) {
        try {
          return await new Promise((resolve, reject) => {
            const socket = _net.default.connect({
              ...options,
              host: address.address,
              family: address.family
            });
            const onAbort = () => {
              socket.removeListener("error", onError);
              socket.removeListener("connect", onConnect);
              socket.destroy();
              reject(new _abortError.default());
            };
            const onError = (err) => {
              signal.removeEventListener("abort", onAbort);
              socket.removeListener("error", onError);
              socket.removeListener("connect", onConnect);
              socket.destroy();
              reject(err);
            };
            const onConnect = () => {
              signal.removeEventListener("abort", onAbort);
              socket.removeListener("error", onError);
              socket.removeListener("connect", onConnect);
              resolve(socket);
            };
            signal.addEventListener("abort", onAbort, {
              once: true
            });
            socket.on("error", onError);
            socket.on("connect", onConnect);
          });
        } catch (err) {
          if (err instanceof Error && err.name === "AbortError") {
            throw err;
          }
          errors.push(err);
          continue;
        }
      }
      throw new AggregateError(errors, "Could not connect (sequence)");
    }
    async function lookupAllAddresses(host, lookup, signal) {
      if (signal.aborted) {
        throw new _abortError.default();
      }
      if (_net.default.isIPv6(host)) {
        return [{
          address: host,
          family: 6
        }];
      } else if (_net.default.isIPv4(host)) {
        return [{
          address: host,
          family: 4
        }];
      } else {
        return await new Promise((resolve, reject) => {
          const onAbort = () => {
            reject(new _abortError.default());
          };
          signal.addEventListener("abort", onAbort);
          const domainInASCII = _nodeUrl.default.domainToASCII(host);
          lookup(domainInASCII === "" ? host : domainInASCII, {
            all: true
          }, (err, addresses) => {
            signal.removeEventListener("abort", onAbort);
            err ? reject(err) : resolve(addresses);
          });
        });
      }
    }
  }
});

// node_modules/tedious/lib/library.js
var require_library = __commonJS({
  "node_modules/tedious/lib/library.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.name = void 0;
    var name3 = exports.name = "Tedious";
  }
});

// node_modules/tedious/lib/ntlm.js
var require_ntlm = __commonJS({
  "node_modules/tedious/lib/ntlm.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createNTLMRequest = createNTLMRequest;
    var NTLMFlags = {
      NTLM_NegotiateUnicode: 1,
      NTLM_NegotiateOEM: 2,
      NTLM_RequestTarget: 4,
      NTLM_Unknown9: 8,
      NTLM_NegotiateSign: 16,
      NTLM_NegotiateSeal: 32,
      NTLM_NegotiateDatagram: 64,
      NTLM_NegotiateLanManagerKey: 128,
      NTLM_Unknown8: 256,
      NTLM_NegotiateNTLM: 512,
      NTLM_NegotiateNTOnly: 1024,
      NTLM_Anonymous: 2048,
      NTLM_NegotiateOemDomainSupplied: 4096,
      NTLM_NegotiateOemWorkstationSupplied: 8192,
      NTLM_Unknown6: 16384,
      NTLM_NegotiateAlwaysSign: 32768,
      NTLM_TargetTypeDomain: 65536,
      NTLM_TargetTypeServer: 131072,
      NTLM_TargetTypeShare: 262144,
      NTLM_NegotiateExtendedSecurity: 524288,
      NTLM_NegotiateIdentify: 1048576,
      NTLM_Unknown5: 2097152,
      NTLM_RequestNonNTSessionKey: 4194304,
      NTLM_NegotiateTargetInfo: 8388608,
      NTLM_Unknown4: 16777216,
      NTLM_NegotiateVersion: 33554432,
      NTLM_Unknown3: 67108864,
      NTLM_Unknown2: 134217728,
      NTLM_Unknown1: 268435456,
      NTLM_Negotiate128: 536870912,
      NTLM_NegotiateKeyExchange: 1073741824,
      NTLM_Negotiate56: 2147483648
    };
    function createNTLMRequest(options) {
      const domain = escape(options.domain.toUpperCase());
      const workstation = options.workstation ? escape(options.workstation.toUpperCase()) : "";
      let type1flags = NTLMFlags.NTLM_NegotiateUnicode + NTLMFlags.NTLM_NegotiateOEM + NTLMFlags.NTLM_RequestTarget + NTLMFlags.NTLM_NegotiateNTLM + NTLMFlags.NTLM_NegotiateOemDomainSupplied + NTLMFlags.NTLM_NegotiateOemWorkstationSupplied + NTLMFlags.NTLM_NegotiateAlwaysSign + NTLMFlags.NTLM_NegotiateVersion + NTLMFlags.NTLM_NegotiateExtendedSecurity + NTLMFlags.NTLM_Negotiate128 + NTLMFlags.NTLM_Negotiate56;
      if (workstation === "") {
        type1flags -= NTLMFlags.NTLM_NegotiateOemWorkstationSupplied;
      }
      const fixedData = Buffer.alloc(40);
      const buffers = [fixedData];
      let offset = 0;
      offset += fixedData.write("NTLMSSP", offset, 7, "ascii");
      offset = fixedData.writeUInt8(0, offset);
      offset = fixedData.writeUInt32LE(1, offset);
      offset = fixedData.writeUInt32LE(type1flags, offset);
      offset = fixedData.writeUInt16LE(domain.length, offset);
      offset = fixedData.writeUInt16LE(domain.length, offset);
      offset = fixedData.writeUInt32LE(fixedData.length + workstation.length, offset);
      offset = fixedData.writeUInt16LE(workstation.length, offset);
      offset = fixedData.writeUInt16LE(workstation.length, offset);
      offset = fixedData.writeUInt32LE(fixedData.length, offset);
      offset = fixedData.writeUInt8(5, offset);
      offset = fixedData.writeUInt8(0, offset);
      offset = fixedData.writeUInt16LE(2195, offset);
      offset = fixedData.writeUInt8(0, offset);
      offset = fixedData.writeUInt8(0, offset);
      offset = fixedData.writeUInt8(0, offset);
      fixedData.writeUInt8(15, offset);
      buffers.push(Buffer.from(workstation, "ascii"));
      buffers.push(Buffer.from(domain, "ascii"));
      return Buffer.concat(buffers);
    }
  }
});

// node_modules/tedious/lib/bulk-load-payload.js
var require_bulk_load_payload = __commonJS({
  "node_modules/tedious/lib/bulk-load-payload.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.BulkLoadPayload = void 0;
    var BulkLoadPayload = class {
      constructor(bulkLoad) {
        this.bulkLoad = bulkLoad;
        this.iterator = this.bulkLoad.rowToPacketTransform[Symbol.asyncIterator]();
      }
      [Symbol.asyncIterator]() {
        return this.iterator;
      }
      toString(indent = "") {
        return indent + "BulkLoad";
      }
    };
    exports.BulkLoadPayload = BulkLoadPayload;
  }
});

// node_modules/tedious/lib/special-stored-procedure.js
var require_special_stored_procedure = __commonJS({
  "node_modules/tedious/lib/special-stored-procedure.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var procedures = {
      Sp_Cursor: 1,
      Sp_CursorOpen: 2,
      Sp_CursorPrepare: 3,
      Sp_CursorExecute: 4,
      Sp_CursorPrepExec: 5,
      Sp_CursorUnprepare: 6,
      Sp_CursorFetch: 7,
      Sp_CursorOption: 8,
      Sp_CursorClose: 9,
      Sp_ExecuteSql: 10,
      Sp_Prepare: 11,
      Sp_Execute: 12,
      Sp_PrepExec: 13,
      Sp_PrepExecRpc: 14,
      Sp_Unprepare: 15
    };
    var _default = exports.default = procedures;
    module.exports = procedures;
  }
});

// node_modules/tedious/package.json
var require_package = __commonJS({
  "node_modules/tedious/package.json"(exports, module) {
    module.exports = {
      author: "Mike D Pilsbury <mike.pilsbury@gmail.com>",
      contributors: [
        "Alex Robson",
        "Arthur Schreiber",
        "Bret Copeland <bret@atlantisflight.org> (https://github.com/bretcope)",
        "Bryan Ross <bryan@rossipedia.com> (https://github.com/rossipedia)",
        "Ciaran Jessup <ciaranj@gmail.com>",
        "Cort Fritz <cfritz@caa.com>",
        "lastonesky",
        "Patrik Simek <patrik@patriksimek.cz>",
        "Phil Dodderidge <pdodde@poyntz.com>",
        "Zach Aller"
      ],
      name: "tedious",
      description: "A TDS driver, for connecting to MS SQLServer databases.",
      keywords: [
        "sql",
        "database",
        "mssql",
        "sqlserver",
        "sql-server",
        "tds",
        "msnodesql",
        "azure"
      ],
      homepage: "https://github.com/tediousjs/tedious",
      bugs: "https://github.com/tediousjs/tedious/issues",
      license: "MIT",
      version: "18.6.1",
      main: "./lib/tedious.js",
      types: "./lib/tedious.d.ts",
      repository: {
        type: "git",
        url: "https://github.com/tediousjs/tedious.git"
      },
      engines: {
        node: ">=18"
      },
      publishConfig: {
        tag: "next",
        provenance: true
      },
      dependencies: {
        "@azure/core-auth": "^1.7.2",
        "@azure/identity": "^4.2.1",
        "@azure/keyvault-keys": "^4.4.0",
        "@js-joda/core": "^5.6.1",
        "@types/node": ">=18",
        bl: "^6.0.11",
        "iconv-lite": "^0.6.3",
        "js-md4": "^0.3.2",
        "native-duplexpair": "^1.0.0",
        "sprintf-js": "^1.1.3"
      },
      devDependencies: {
        "@babel/cli": "^7.23.9",
        "@babel/core": "^7.23.9",
        "@babel/node": "^7.23.9",
        "@babel/preset-env": "^7.23.9",
        "@babel/preset-typescript": "^7.23.3",
        "@babel/register": "^7.23.7",
        "@types/async": "^3.2.24",
        "@types/bl": "^5.1.0",
        "@types/chai": "^4.3.12",
        "@types/depd": "^1.1.36",
        "@types/lru-cache": "^5.1.1",
        "@types/mocha": "^10.0.6",
        "@types/sprintf-js": "^1.1.4",
        "@typescript-eslint/eslint-plugin": "^7.0.2",
        "@typescript-eslint/parser": "^7.0.2",
        async: "^3.2.5",
        "babel-plugin-istanbul": "^6.1.1",
        chai: "^4.4.1",
        codecov: "^3.8.3",
        eslint: "^8.57.0",
        mitm: "^1.7.2",
        mocha: "^10.3.0",
        nyc: "^15.1.0",
        rimraf: "^5.0.5",
        "semantic-release": "^19.0.3",
        sinon: "^15.2.0",
        typedoc: "^0.26.5",
        typescript: "^5.5.4"
      },
      scripts: {
        docs: "typedoc",
        lint: "eslint src test --ext .js,.ts && tsc",
        test: "mocha --forbid-only test/unit test/unit/token test/unit/tracking-buffer",
        "test-integration": "mocha --forbid-only test/integration/",
        "test-all": "mocha --forbid-only test/unit/ test/unit/token/ test/unit/tracking-buffer test/integration/",
        "build:types": "tsc --project tsconfig.build-types.json",
        build: "rimraf lib && babel src --out-dir lib --extensions .js,.ts && npm run build:types",
        prepublish: "npm run build",
        "semantic-release": "semantic-release"
      },
      babel: {
        sourceMaps: "both",
        ignore: [
          "./src/**/*.d.ts"
        ],
        presets: [
          [
            "@babel/preset-env",
            {
              targets: {
                node: 18
              }
            }
          ],
          [
            "@babel/preset-typescript",
            {
              allowDeclareFields: true
            }
          ]
        ],
        plugins: [
          [
            "@babel/transform-typescript",
            {
              allowDeclareFields: true
            }
          ]
        ]
      },
      mocha: {
        require: "test/setup.js",
        timeout: 5e3,
        extension: [
          "js",
          "ts"
        ]
      },
      nyc: {
        sourceMap: false,
        instrument: false,
        extension: [
          ".ts"
        ]
      }
    };
  }
});

// node_modules/tedious/lib/token/handler.js
var require_handler = __commonJS({
  "node_modules/tedious/lib/token/handler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UnexpectedTokenError = exports.TokenHandler = exports.RequestTokenHandler = exports.Login7TokenHandler = exports.InitialSqlTokenHandler = exports.AttentionTokenHandler = void 0;
    var _request = _interopRequireDefault(require_request2());
    var _errors = require_errors();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var UnexpectedTokenError = class extends Error {
      constructor(handler, token) {
        super("Unexpected token `" + token.name + "` in `" + handler.constructor.name + "`");
      }
    };
    exports.UnexpectedTokenError = UnexpectedTokenError;
    var TokenHandler = class {
      onInfoMessage(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onErrorMessage(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onSSPI(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onDatabaseChange(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onLanguageChange(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onCharsetChange(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onSqlCollationChange(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onRoutingChange(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onPacketSizeChange(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onResetConnection(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onBeginTransaction(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onCommitTransaction(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onRollbackTransaction(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onFedAuthInfo(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onFeatureExtAck(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onLoginAck(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onColMetadata(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onOrder(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onRow(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onReturnStatus(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onReturnValue(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onDoneProc(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onDoneInProc(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onDone(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onDatabaseMirroringPartner(token) {
        throw new UnexpectedTokenError(this, token);
      }
    };
    exports.TokenHandler = TokenHandler;
    var InitialSqlTokenHandler = class extends TokenHandler {
      constructor(connection) {
        super();
        this.connection = connection;
      }
      onInfoMessage(token) {
        this.connection.emit("infoMessage", token);
      }
      onErrorMessage(token) {
        this.connection.emit("errorMessage", token);
      }
      onDatabaseChange(token) {
        this.connection.emit("databaseChange", token.newValue);
      }
      onLanguageChange(token) {
        this.connection.emit("languageChange", token.newValue);
      }
      onCharsetChange(token) {
        this.connection.emit("charsetChange", token.newValue);
      }
      onSqlCollationChange(token) {
        this.connection.databaseCollation = token.newValue;
      }
      onPacketSizeChange(token) {
        this.connection.messageIo.packetSize(token.newValue);
      }
      onBeginTransaction(token) {
        this.connection.transactionDescriptors.push(token.newValue);
        this.connection.inTransaction = true;
      }
      onCommitTransaction(token) {
        this.connection.transactionDescriptors.length = 1;
        this.connection.inTransaction = false;
      }
      onRollbackTransaction(token) {
        this.connection.transactionDescriptors.length = 1;
        this.connection.inTransaction = false;
        this.connection.emit("rollbackTransaction");
      }
      onColMetadata(token) {
        this.connection.emit("error", new Error("Received 'columnMetadata' when no sqlRequest is in progress"));
        this.connection.close();
      }
      onOrder(token) {
        this.connection.emit("error", new Error("Received 'order' when no sqlRequest is in progress"));
        this.connection.close();
      }
      onRow(token) {
        this.connection.emit("error", new Error("Received 'row' when no sqlRequest is in progress"));
        this.connection.close();
      }
      onReturnStatus(token) {
      }
      onReturnValue(token) {
      }
      onDoneProc(token) {
      }
      onDoneInProc(token) {
      }
      onDone(token) {
      }
      onResetConnection(token) {
        this.connection.emit("resetConnection");
      }
    };
    exports.InitialSqlTokenHandler = InitialSqlTokenHandler;
    var Login7TokenHandler = class extends TokenHandler {
      constructor(connection) {
        super();
        this.loginAckReceived = false;
        this.connection = connection;
      }
      onInfoMessage(token) {
        this.connection.emit("infoMessage", token);
      }
      onErrorMessage(token) {
        this.connection.emit("errorMessage", token);
        const error = new _errors.ConnectionError(token.message, "ELOGIN");
        const isLoginErrorTransient = this.connection.transientErrorLookup.isTransientError(token.number);
        if (isLoginErrorTransient && this.connection.curTransientRetryCount !== this.connection.config.options.maxRetriesOnTransientErrors) {
          error.isTransient = true;
        }
        this.connection.loginError = error;
      }
      onSSPI(token) {
        if (token.ntlmpacket) {
          this.connection.ntlmpacket = token.ntlmpacket;
          this.connection.ntlmpacketBuffer = token.ntlmpacketBuffer;
        }
      }
      onDatabaseChange(token) {
        this.connection.emit("databaseChange", token.newValue);
      }
      onLanguageChange(token) {
        this.connection.emit("languageChange", token.newValue);
      }
      onCharsetChange(token) {
        this.connection.emit("charsetChange", token.newValue);
      }
      onSqlCollationChange(token) {
        this.connection.databaseCollation = token.newValue;
      }
      onFedAuthInfo(token) {
        this.fedAuthInfoToken = token;
      }
      onFeatureExtAck(token) {
        const {
          authentication
        } = this.connection.config;
        if (authentication.type === "azure-active-directory-password" || authentication.type === "azure-active-directory-access-token" || authentication.type === "azure-active-directory-msi-vm" || authentication.type === "azure-active-directory-msi-app-service" || authentication.type === "azure-active-directory-service-principal-secret" || authentication.type === "azure-active-directory-default") {
          if (token.fedAuth === void 0) {
            this.connection.loginError = new _errors.ConnectionError("Did not receive Active Directory authentication acknowledgement");
          } else if (token.fedAuth.length !== 0) {
            this.connection.loginError = new _errors.ConnectionError(`Active Directory authentication acknowledgment for ${authentication.type} authentication method includes extra data`);
          }
        } else if (token.fedAuth === void 0 && token.utf8Support === void 0) {
          this.connection.loginError = new _errors.ConnectionError("Received acknowledgement for unknown feature");
        } else if (token.fedAuth) {
          this.connection.loginError = new _errors.ConnectionError("Did not request Active Directory authentication, but received the acknowledgment");
        }
      }
      onLoginAck(token) {
        if (!token.tdsVersion) {
          this.connection.loginError = new _errors.ConnectionError("Server responded with unknown TDS version.", "ETDS");
          return;
        }
        if (!token.interface) {
          this.connection.loginError = new _errors.ConnectionError("Server responded with unsupported interface.", "EINTERFACENOTSUPP");
          return;
        }
        this.connection.config.options.tdsVersion = token.tdsVersion;
        this.loginAckReceived = true;
      }
      onRoutingChange(token) {
        const [server] = token.newValue.server.split("\\");
        this.routingData = {
          server,
          port: token.newValue.port
        };
      }
      onDoneInProc(token) {
      }
      onDone(token) {
      }
      onPacketSizeChange(token) {
        this.connection.messageIo.packetSize(token.newValue);
      }
      onDatabaseMirroringPartner(token) {
      }
    };
    exports.Login7TokenHandler = Login7TokenHandler;
    var RequestTokenHandler = class extends TokenHandler {
      constructor(connection, request) {
        super();
        this.connection = connection;
        this.request = request;
        this.errors = [];
      }
      onInfoMessage(token) {
        this.connection.emit("infoMessage", token);
      }
      onErrorMessage(token) {
        this.connection.emit("errorMessage", token);
        if (!this.request.canceled) {
          const error = new _errors.RequestError(token.message, "EREQUEST");
          error.number = token.number;
          error.state = token.state;
          error.class = token.class;
          error.serverName = token.serverName;
          error.procName = token.procName;
          error.lineNumber = token.lineNumber;
          this.errors.push(error);
          this.request.error = error;
          if (this.request instanceof _request.default && this.errors.length > 1) {
            this.request.error = new AggregateError(this.errors);
          }
        }
      }
      onDatabaseChange(token) {
        this.connection.emit("databaseChange", token.newValue);
      }
      onLanguageChange(token) {
        this.connection.emit("languageChange", token.newValue);
      }
      onCharsetChange(token) {
        this.connection.emit("charsetChange", token.newValue);
      }
      onSqlCollationChange(token) {
        this.connection.databaseCollation = token.newValue;
      }
      onPacketSizeChange(token) {
        this.connection.messageIo.packetSize(token.newValue);
      }
      onBeginTransaction(token) {
        this.connection.transactionDescriptors.push(token.newValue);
        this.connection.inTransaction = true;
      }
      onCommitTransaction(token) {
        this.connection.transactionDescriptors.length = 1;
        this.connection.inTransaction = false;
      }
      onRollbackTransaction(token) {
        this.connection.transactionDescriptors.length = 1;
        this.connection.inTransaction = false;
        this.connection.emit("rollbackTransaction");
      }
      onColMetadata(token) {
        if (!this.request.canceled) {
          if (this.connection.config.options.useColumnNames) {
            const columns = /* @__PURE__ */ Object.create(null);
            for (let j = 0, len = token.columns.length; j < len; j++) {
              const col = token.columns[j];
              if (columns[col.colName] == null) {
                columns[col.colName] = col;
              }
            }
            this.request.emit("columnMetadata", columns);
          } else {
            this.request.emit("columnMetadata", token.columns);
          }
        }
      }
      onOrder(token) {
        if (!this.request.canceled) {
          this.request.emit("order", token.orderColumns);
        }
      }
      onRow(token) {
        if (!this.request.canceled) {
          if (this.connection.config.options.rowCollectionOnRequestCompletion) {
            this.request.rows.push(token.columns);
          }
          if (this.connection.config.options.rowCollectionOnDone) {
            this.request.rst.push(token.columns);
          }
          this.request.emit("row", token.columns);
        }
      }
      onReturnStatus(token) {
        if (!this.request.canceled) {
          this.connection.procReturnStatusValue = token.value;
        }
      }
      onReturnValue(token) {
        if (!this.request.canceled) {
          this.request.emit("returnValue", token.paramName, token.value, token.metadata);
        }
      }
      onDoneProc(token) {
        if (!this.request.canceled) {
          if (token.sqlError && !this.request.error) {
            this.request.error = new _errors.RequestError("An unknown error has occurred.", "UNKNOWN");
          }
          this.request.emit("doneProc", token.rowCount, token.more, this.connection.procReturnStatusValue, this.request.rst);
          this.connection.procReturnStatusValue = void 0;
          if (token.rowCount !== void 0) {
            this.request.rowCount += token.rowCount;
          }
          if (this.connection.config.options.rowCollectionOnDone) {
            this.request.rst = [];
          }
        }
      }
      onDoneInProc(token) {
        if (!this.request.canceled) {
          this.request.emit("doneInProc", token.rowCount, token.more, this.request.rst);
          if (token.rowCount !== void 0) {
            this.request.rowCount += token.rowCount;
          }
          if (this.connection.config.options.rowCollectionOnDone) {
            this.request.rst = [];
          }
        }
      }
      onDone(token) {
        if (!this.request.canceled) {
          if (token.sqlError && !this.request.error) {
            this.request.error = new _errors.RequestError("An unknown error has occurred.", "UNKNOWN");
          }
          this.request.emit("done", token.rowCount, token.more, this.request.rst);
          if (token.rowCount !== void 0) {
            this.request.rowCount += token.rowCount;
          }
          if (this.connection.config.options.rowCollectionOnDone) {
            this.request.rst = [];
          }
        }
      }
      onResetConnection(token) {
        this.connection.emit("resetConnection");
      }
    };
    exports.RequestTokenHandler = RequestTokenHandler;
    var AttentionTokenHandler = class extends TokenHandler {
      /**
       * Returns whether an attention acknowledgement was received.
       */
      constructor(connection, request) {
        super();
        this.connection = connection;
        this.request = request;
        this.attentionReceived = false;
      }
      onDone(token) {
        if (token.attention) {
          this.attentionReceived = true;
        }
      }
    };
    exports.AttentionTokenHandler = AttentionTokenHandler;
  }
});

// node_modules/tedious/lib/connection.js
var require_connection = __commonJS({
  "node_modules/tedious/lib/connection.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _crypto = _interopRequireDefault(require_crypto());
    var _os = _interopRequireDefault(require_os());
    var tls = _interopRequireWildcard(require_tls());
    var net = _interopRequireWildcard(require_net());
    var _dns = _interopRequireDefault(require_dns());
    var _constants = _interopRequireDefault(require_constants());
    var _stream = require_stream();
    var _identity = (init_browser8(), __toCommonJS(browser_exports));
    var _coreAuth = (init_browser9(), __toCommonJS(browser_exports2));
    var _bulkLoad = _interopRequireDefault(require_bulk_load());
    var _debug = _interopRequireDefault(require_debug());
    var _events = require_events();
    var _instanceLookup = require_instance_lookup();
    var _transientErrorLookup = require_transient_error_lookup();
    var _packet = require_packet();
    var _preloginPayload = _interopRequireDefault(require_prelogin_payload());
    var _login7Payload = _interopRequireDefault(require_login7_payload());
    var _ntlmPayload = _interopRequireDefault(require_ntlm_payload());
    var _request = _interopRequireDefault(require_request2());
    var _rpcrequestPayload = _interopRequireDefault(require_rpcrequest_payload());
    var _sqlbatchPayload = _interopRequireDefault(require_sqlbatch_payload());
    var _messageIo = _interopRequireDefault(require_message_io());
    var _tokenStreamParser = require_token_stream_parser();
    var _transaction = require_transaction2();
    var _errors = require_errors();
    var _connector = require_connector();
    var _library = require_library();
    var _tdsVersions = require_tds_versions();
    var _message = _interopRequireDefault(require_message());
    var _ntlm = require_ntlm();
    var _dataType = require_data_type();
    var _bulkLoadPayload = require_bulk_load_payload();
    var _specialStoredProcedure = _interopRequireDefault(require_special_stored_procedure());
    var _package = require_package();
    var _url = require_url();
    var _handler = require_handler();
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
      return n.default = e, t && t.set(e, n), n;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var KEEP_ALIVE_INITIAL_DELAY = 30 * 1e3;
    var DEFAULT_CONNECT_TIMEOUT = 15 * 1e3;
    var DEFAULT_CLIENT_REQUEST_TIMEOUT = 15 * 1e3;
    var DEFAULT_CANCEL_TIMEOUT = 5 * 1e3;
    var DEFAULT_CONNECT_RETRY_INTERVAL = 500;
    var DEFAULT_PACKET_SIZE = 4 * 1024;
    var DEFAULT_TEXTSIZE = 2147483647;
    var DEFAULT_DATEFIRST = 7;
    var DEFAULT_PORT = 1433;
    var DEFAULT_TDS_VERSION = "7_4";
    var DEFAULT_LANGUAGE = "us_english";
    var DEFAULT_DATEFORMAT = "mdy";
    var CLEANUP_TYPE = {
      NORMAL: 0,
      REDIRECT: 1,
      RETRY: 2
    };
    var Connection = class extends _events.EventEmitter {
      /**
       * @private
       */
      /**
       * Note: be aware of the different options field:
       * 1. config.authentication.options
       * 2. config.options
       *
       * ```js
       * const { Connection } = require('tedious');
       *
       * const config = {
       *  "authentication": {
       *    ...,
       *    "options": {...}
       *  },
       *  "options": {...}
       * };
       *
       * const connection = new Connection(config);
       * ```
       *
       * @param config
       */
      constructor(config) {
        super();
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        __publicField(this, "_cancelAfterRequestSent");
        if (typeof config !== "object" || config === null) {
          throw new TypeError('The "config" argument is required and must be of type Object.');
        }
        if (typeof config.server !== "string") {
          throw new TypeError('The "config.server" property is required and must be of type string.');
        }
        this.fedAuthRequired = false;
        let authentication;
        if (config.authentication !== void 0) {
          if (typeof config.authentication !== "object" || config.authentication === null) {
            throw new TypeError('The "config.authentication" property must be of type Object.');
          }
          const type = config.authentication.type;
          const options = config.authentication.options === void 0 ? {} : config.authentication.options;
          if (typeof type !== "string") {
            throw new TypeError('The "config.authentication.type" property must be of type string.');
          }
          if (type !== "default" && type !== "ntlm" && type !== "token-credential" && type !== "azure-active-directory-password" && type !== "azure-active-directory-access-token" && type !== "azure-active-directory-msi-vm" && type !== "azure-active-directory-msi-app-service" && type !== "azure-active-directory-service-principal-secret" && type !== "azure-active-directory-default") {
            throw new TypeError('The "type" property must one of "default", "ntlm", "token-credential", "azure-active-directory-password", "azure-active-directory-access-token", "azure-active-directory-default", "azure-active-directory-msi-vm" or "azure-active-directory-msi-app-service" or "azure-active-directory-service-principal-secret".');
          }
          if (typeof options !== "object" || options === null) {
            throw new TypeError('The "config.authentication.options" property must be of type object.');
          }
          if (type === "ntlm") {
            if (typeof options.domain !== "string") {
              throw new TypeError('The "config.authentication.options.domain" property must be of type string.');
            }
            if (options.userName !== void 0 && typeof options.userName !== "string") {
              throw new TypeError('The "config.authentication.options.userName" property must be of type string.');
            }
            if (options.password !== void 0 && typeof options.password !== "string") {
              throw new TypeError('The "config.authentication.options.password" property must be of type string.');
            }
            authentication = {
              type: "ntlm",
              options: {
                userName: options.userName,
                password: options.password,
                domain: options.domain && options.domain.toUpperCase()
              }
            };
          } else if (type === "token-credential") {
            if (!(0, _coreAuth.isTokenCredential)(options.credential)) {
              throw new TypeError('The "config.authentication.options.credential" property must be an instance of the token credential class.');
            }
            authentication = {
              type: "token-credential",
              options: {
                credential: options.credential
              }
            };
          } else if (type === "azure-active-directory-password") {
            if (typeof options.clientId !== "string") {
              throw new TypeError('The "config.authentication.options.clientId" property must be of type string.');
            }
            if (options.userName !== void 0 && typeof options.userName !== "string") {
              throw new TypeError('The "config.authentication.options.userName" property must be of type string.');
            }
            if (options.password !== void 0 && typeof options.password !== "string") {
              throw new TypeError('The "config.authentication.options.password" property must be of type string.');
            }
            if (options.tenantId !== void 0 && typeof options.tenantId !== "string") {
              throw new TypeError('The "config.authentication.options.tenantId" property must be of type string.');
            }
            authentication = {
              type: "azure-active-directory-password",
              options: {
                userName: options.userName,
                password: options.password,
                tenantId: options.tenantId,
                clientId: options.clientId
              }
            };
          } else if (type === "azure-active-directory-access-token") {
            if (typeof options.token !== "string") {
              throw new TypeError('The "config.authentication.options.token" property must be of type string.');
            }
            authentication = {
              type: "azure-active-directory-access-token",
              options: {
                token: options.token
              }
            };
          } else if (type === "azure-active-directory-msi-vm") {
            if (options.clientId !== void 0 && typeof options.clientId !== "string") {
              throw new TypeError('The "config.authentication.options.clientId" property must be of type string.');
            }
            authentication = {
              type: "azure-active-directory-msi-vm",
              options: {
                clientId: options.clientId
              }
            };
          } else if (type === "azure-active-directory-default") {
            if (options.clientId !== void 0 && typeof options.clientId !== "string") {
              throw new TypeError('The "config.authentication.options.clientId" property must be of type string.');
            }
            authentication = {
              type: "azure-active-directory-default",
              options: {
                clientId: options.clientId
              }
            };
          } else if (type === "azure-active-directory-msi-app-service") {
            if (options.clientId !== void 0 && typeof options.clientId !== "string") {
              throw new TypeError('The "config.authentication.options.clientId" property must be of type string.');
            }
            authentication = {
              type: "azure-active-directory-msi-app-service",
              options: {
                clientId: options.clientId
              }
            };
          } else if (type === "azure-active-directory-service-principal-secret") {
            if (typeof options.clientId !== "string") {
              throw new TypeError('The "config.authentication.options.clientId" property must be of type string.');
            }
            if (typeof options.clientSecret !== "string") {
              throw new TypeError('The "config.authentication.options.clientSecret" property must be of type string.');
            }
            if (typeof options.tenantId !== "string") {
              throw new TypeError('The "config.authentication.options.tenantId" property must be of type string.');
            }
            authentication = {
              type: "azure-active-directory-service-principal-secret",
              options: {
                clientId: options.clientId,
                clientSecret: options.clientSecret,
                tenantId: options.tenantId
              }
            };
          } else {
            if (options.userName !== void 0 && typeof options.userName !== "string") {
              throw new TypeError('The "config.authentication.options.userName" property must be of type string.');
            }
            if (options.password !== void 0 && typeof options.password !== "string") {
              throw new TypeError('The "config.authentication.options.password" property must be of type string.');
            }
            authentication = {
              type: "default",
              options: {
                userName: options.userName,
                password: options.password
              }
            };
          }
        } else {
          authentication = {
            type: "default",
            options: {
              userName: void 0,
              password: void 0
            }
          };
        }
        this.config = {
          server: config.server,
          authentication,
          options: {
            abortTransactionOnError: false,
            appName: void 0,
            camelCaseColumns: false,
            cancelTimeout: DEFAULT_CANCEL_TIMEOUT,
            columnEncryptionKeyCacheTTL: 2 * 60 * 60 * 1e3,
            // Units: milliseconds
            columnEncryptionSetting: false,
            columnNameReplacer: void 0,
            connectionRetryInterval: DEFAULT_CONNECT_RETRY_INTERVAL,
            connectTimeout: DEFAULT_CONNECT_TIMEOUT,
            connector: void 0,
            connectionIsolationLevel: _transaction.ISOLATION_LEVEL.READ_COMMITTED,
            cryptoCredentialsDetails: {},
            database: void 0,
            datefirst: DEFAULT_DATEFIRST,
            dateFormat: DEFAULT_DATEFORMAT,
            debug: {
              data: false,
              packet: false,
              payload: false,
              token: false
            },
            enableAnsiNull: true,
            enableAnsiNullDefault: true,
            enableAnsiPadding: true,
            enableAnsiWarnings: true,
            enableArithAbort: true,
            enableConcatNullYieldsNull: true,
            enableCursorCloseOnCommit: null,
            enableImplicitTransactions: false,
            enableNumericRoundabort: false,
            enableQuotedIdentifier: true,
            encrypt: true,
            fallbackToDefaultDb: false,
            encryptionKeyStoreProviders: void 0,
            instanceName: void 0,
            isolationLevel: _transaction.ISOLATION_LEVEL.READ_COMMITTED,
            language: DEFAULT_LANGUAGE,
            localAddress: void 0,
            maxRetriesOnTransientErrors: 3,
            multiSubnetFailover: false,
            packetSize: DEFAULT_PACKET_SIZE,
            port: DEFAULT_PORT,
            readOnlyIntent: false,
            requestTimeout: DEFAULT_CLIENT_REQUEST_TIMEOUT,
            rowCollectionOnDone: false,
            rowCollectionOnRequestCompletion: false,
            serverName: void 0,
            serverSupportsColumnEncryption: false,
            tdsVersion: DEFAULT_TDS_VERSION,
            textsize: DEFAULT_TEXTSIZE,
            trustedServerNameAE: void 0,
            trustServerCertificate: false,
            useColumnNames: false,
            useUTC: true,
            workstationId: void 0,
            lowerCaseGuids: false
          }
        };
        if (config.options) {
          if (config.options.port && config.options.instanceName) {
            throw new Error("Port and instanceName are mutually exclusive, but " + config.options.port + " and " + config.options.instanceName + " provided");
          }
          if (config.options.abortTransactionOnError !== void 0) {
            if (typeof config.options.abortTransactionOnError !== "boolean" && config.options.abortTransactionOnError !== null) {
              throw new TypeError('The "config.options.abortTransactionOnError" property must be of type string or null.');
            }
            this.config.options.abortTransactionOnError = config.options.abortTransactionOnError;
          }
          if (config.options.appName !== void 0) {
            if (typeof config.options.appName !== "string") {
              throw new TypeError('The "config.options.appName" property must be of type string.');
            }
            this.config.options.appName = config.options.appName;
          }
          if (config.options.camelCaseColumns !== void 0) {
            if (typeof config.options.camelCaseColumns !== "boolean") {
              throw new TypeError('The "config.options.camelCaseColumns" property must be of type boolean.');
            }
            this.config.options.camelCaseColumns = config.options.camelCaseColumns;
          }
          if (config.options.cancelTimeout !== void 0) {
            if (typeof config.options.cancelTimeout !== "number") {
              throw new TypeError('The "config.options.cancelTimeout" property must be of type number.');
            }
            this.config.options.cancelTimeout = config.options.cancelTimeout;
          }
          if (config.options.columnNameReplacer) {
            if (typeof config.options.columnNameReplacer !== "function") {
              throw new TypeError('The "config.options.cancelTimeout" property must be of type function.');
            }
            this.config.options.columnNameReplacer = config.options.columnNameReplacer;
          }
          if (config.options.connectionIsolationLevel !== void 0) {
            (0, _transaction.assertValidIsolationLevel)(config.options.connectionIsolationLevel, "config.options.connectionIsolationLevel");
            this.config.options.connectionIsolationLevel = config.options.connectionIsolationLevel;
          }
          if (config.options.connectTimeout !== void 0) {
            if (typeof config.options.connectTimeout !== "number") {
              throw new TypeError('The "config.options.connectTimeout" property must be of type number.');
            }
            this.config.options.connectTimeout = config.options.connectTimeout;
          }
          if (config.options.connector !== void 0) {
            if (typeof config.options.connector !== "function") {
              throw new TypeError('The "config.options.connector" property must be a function.');
            }
            this.config.options.connector = config.options.connector;
          }
          if (config.options.cryptoCredentialsDetails !== void 0) {
            if (typeof config.options.cryptoCredentialsDetails !== "object" || config.options.cryptoCredentialsDetails === null) {
              throw new TypeError('The "config.options.cryptoCredentialsDetails" property must be of type Object.');
            }
            this.config.options.cryptoCredentialsDetails = config.options.cryptoCredentialsDetails;
          }
          if (config.options.database !== void 0) {
            if (typeof config.options.database !== "string") {
              throw new TypeError('The "config.options.database" property must be of type string.');
            }
            this.config.options.database = config.options.database;
          }
          if (config.options.datefirst !== void 0) {
            if (typeof config.options.datefirst !== "number" && config.options.datefirst !== null) {
              throw new TypeError('The "config.options.datefirst" property must be of type number.');
            }
            if (config.options.datefirst !== null && (config.options.datefirst < 1 || config.options.datefirst > 7)) {
              throw new RangeError('The "config.options.datefirst" property must be >= 1 and <= 7');
            }
            this.config.options.datefirst = config.options.datefirst;
          }
          if (config.options.dateFormat !== void 0) {
            if (typeof config.options.dateFormat !== "string" && config.options.dateFormat !== null) {
              throw new TypeError('The "config.options.dateFormat" property must be of type string or null.');
            }
            this.config.options.dateFormat = config.options.dateFormat;
          }
          if (config.options.debug) {
            if (config.options.debug.data !== void 0) {
              if (typeof config.options.debug.data !== "boolean") {
                throw new TypeError('The "config.options.debug.data" property must be of type boolean.');
              }
              this.config.options.debug.data = config.options.debug.data;
            }
            if (config.options.debug.packet !== void 0) {
              if (typeof config.options.debug.packet !== "boolean") {
                throw new TypeError('The "config.options.debug.packet" property must be of type boolean.');
              }
              this.config.options.debug.packet = config.options.debug.packet;
            }
            if (config.options.debug.payload !== void 0) {
              if (typeof config.options.debug.payload !== "boolean") {
                throw new TypeError('The "config.options.debug.payload" property must be of type boolean.');
              }
              this.config.options.debug.payload = config.options.debug.payload;
            }
            if (config.options.debug.token !== void 0) {
              if (typeof config.options.debug.token !== "boolean") {
                throw new TypeError('The "config.options.debug.token" property must be of type boolean.');
              }
              this.config.options.debug.token = config.options.debug.token;
            }
          }
          if (config.options.enableAnsiNull !== void 0) {
            if (typeof config.options.enableAnsiNull !== "boolean" && config.options.enableAnsiNull !== null) {
              throw new TypeError('The "config.options.enableAnsiNull" property must be of type boolean or null.');
            }
            this.config.options.enableAnsiNull = config.options.enableAnsiNull;
          }
          if (config.options.enableAnsiNullDefault !== void 0) {
            if (typeof config.options.enableAnsiNullDefault !== "boolean" && config.options.enableAnsiNullDefault !== null) {
              throw new TypeError('The "config.options.enableAnsiNullDefault" property must be of type boolean or null.');
            }
            this.config.options.enableAnsiNullDefault = config.options.enableAnsiNullDefault;
          }
          if (config.options.enableAnsiPadding !== void 0) {
            if (typeof config.options.enableAnsiPadding !== "boolean" && config.options.enableAnsiPadding !== null) {
              throw new TypeError('The "config.options.enableAnsiPadding" property must be of type boolean or null.');
            }
            this.config.options.enableAnsiPadding = config.options.enableAnsiPadding;
          }
          if (config.options.enableAnsiWarnings !== void 0) {
            if (typeof config.options.enableAnsiWarnings !== "boolean" && config.options.enableAnsiWarnings !== null) {
              throw new TypeError('The "config.options.enableAnsiWarnings" property must be of type boolean or null.');
            }
            this.config.options.enableAnsiWarnings = config.options.enableAnsiWarnings;
          }
          if (config.options.enableArithAbort !== void 0) {
            if (typeof config.options.enableArithAbort !== "boolean" && config.options.enableArithAbort !== null) {
              throw new TypeError('The "config.options.enableArithAbort" property must be of type boolean or null.');
            }
            this.config.options.enableArithAbort = config.options.enableArithAbort;
          }
          if (config.options.enableConcatNullYieldsNull !== void 0) {
            if (typeof config.options.enableConcatNullYieldsNull !== "boolean" && config.options.enableConcatNullYieldsNull !== null) {
              throw new TypeError('The "config.options.enableConcatNullYieldsNull" property must be of type boolean or null.');
            }
            this.config.options.enableConcatNullYieldsNull = config.options.enableConcatNullYieldsNull;
          }
          if (config.options.enableCursorCloseOnCommit !== void 0) {
            if (typeof config.options.enableCursorCloseOnCommit !== "boolean" && config.options.enableCursorCloseOnCommit !== null) {
              throw new TypeError('The "config.options.enableCursorCloseOnCommit" property must be of type boolean or null.');
            }
            this.config.options.enableCursorCloseOnCommit = config.options.enableCursorCloseOnCommit;
          }
          if (config.options.enableImplicitTransactions !== void 0) {
            if (typeof config.options.enableImplicitTransactions !== "boolean" && config.options.enableImplicitTransactions !== null) {
              throw new TypeError('The "config.options.enableImplicitTransactions" property must be of type boolean or null.');
            }
            this.config.options.enableImplicitTransactions = config.options.enableImplicitTransactions;
          }
          if (config.options.enableNumericRoundabort !== void 0) {
            if (typeof config.options.enableNumericRoundabort !== "boolean" && config.options.enableNumericRoundabort !== null) {
              throw new TypeError('The "config.options.enableNumericRoundabort" property must be of type boolean or null.');
            }
            this.config.options.enableNumericRoundabort = config.options.enableNumericRoundabort;
          }
          if (config.options.enableQuotedIdentifier !== void 0) {
            if (typeof config.options.enableQuotedIdentifier !== "boolean" && config.options.enableQuotedIdentifier !== null) {
              throw new TypeError('The "config.options.enableQuotedIdentifier" property must be of type boolean or null.');
            }
            this.config.options.enableQuotedIdentifier = config.options.enableQuotedIdentifier;
          }
          if (config.options.encrypt !== void 0) {
            if (typeof config.options.encrypt !== "boolean") {
              if (config.options.encrypt !== "strict") {
                throw new TypeError('The "encrypt" property must be set to "strict", or of type boolean.');
              }
            }
            this.config.options.encrypt = config.options.encrypt;
          }
          if (config.options.fallbackToDefaultDb !== void 0) {
            if (typeof config.options.fallbackToDefaultDb !== "boolean") {
              throw new TypeError('The "config.options.fallbackToDefaultDb" property must be of type boolean.');
            }
            this.config.options.fallbackToDefaultDb = config.options.fallbackToDefaultDb;
          }
          if (config.options.instanceName !== void 0) {
            if (typeof config.options.instanceName !== "string") {
              throw new TypeError('The "config.options.instanceName" property must be of type string.');
            }
            this.config.options.instanceName = config.options.instanceName;
            this.config.options.port = void 0;
          }
          if (config.options.isolationLevel !== void 0) {
            (0, _transaction.assertValidIsolationLevel)(config.options.isolationLevel, "config.options.isolationLevel");
            this.config.options.isolationLevel = config.options.isolationLevel;
          }
          if (config.options.language !== void 0) {
            if (typeof config.options.language !== "string" && config.options.language !== null) {
              throw new TypeError('The "config.options.language" property must be of type string or null.');
            }
            this.config.options.language = config.options.language;
          }
          if (config.options.localAddress !== void 0) {
            if (typeof config.options.localAddress !== "string") {
              throw new TypeError('The "config.options.localAddress" property must be of type string.');
            }
            this.config.options.localAddress = config.options.localAddress;
          }
          if (config.options.multiSubnetFailover !== void 0) {
            if (typeof config.options.multiSubnetFailover !== "boolean") {
              throw new TypeError('The "config.options.multiSubnetFailover" property must be of type boolean.');
            }
            this.config.options.multiSubnetFailover = config.options.multiSubnetFailover;
          }
          if (config.options.packetSize !== void 0) {
            if (typeof config.options.packetSize !== "number") {
              throw new TypeError('The "config.options.packetSize" property must be of type number.');
            }
            this.config.options.packetSize = config.options.packetSize;
          }
          if (config.options.port !== void 0) {
            if (typeof config.options.port !== "number") {
              throw new TypeError('The "config.options.port" property must be of type number.');
            }
            if (config.options.port <= 0 || config.options.port >= 65536) {
              throw new RangeError('The "config.options.port" property must be > 0 and < 65536');
            }
            this.config.options.port = config.options.port;
            this.config.options.instanceName = void 0;
          }
          if (config.options.readOnlyIntent !== void 0) {
            if (typeof config.options.readOnlyIntent !== "boolean") {
              throw new TypeError('The "config.options.readOnlyIntent" property must be of type boolean.');
            }
            this.config.options.readOnlyIntent = config.options.readOnlyIntent;
          }
          if (config.options.requestTimeout !== void 0) {
            if (typeof config.options.requestTimeout !== "number") {
              throw new TypeError('The "config.options.requestTimeout" property must be of type number.');
            }
            this.config.options.requestTimeout = config.options.requestTimeout;
          }
          if (config.options.maxRetriesOnTransientErrors !== void 0) {
            if (typeof config.options.maxRetriesOnTransientErrors !== "number") {
              throw new TypeError('The "config.options.maxRetriesOnTransientErrors" property must be of type number.');
            }
            if (config.options.maxRetriesOnTransientErrors < 0) {
              throw new TypeError('The "config.options.maxRetriesOnTransientErrors" property must be equal or greater than 0.');
            }
            this.config.options.maxRetriesOnTransientErrors = config.options.maxRetriesOnTransientErrors;
          }
          if (config.options.connectionRetryInterval !== void 0) {
            if (typeof config.options.connectionRetryInterval !== "number") {
              throw new TypeError('The "config.options.connectionRetryInterval" property must be of type number.');
            }
            if (config.options.connectionRetryInterval <= 0) {
              throw new TypeError('The "config.options.connectionRetryInterval" property must be greater than 0.');
            }
            this.config.options.connectionRetryInterval = config.options.connectionRetryInterval;
          }
          if (config.options.rowCollectionOnDone !== void 0) {
            if (typeof config.options.rowCollectionOnDone !== "boolean") {
              throw new TypeError('The "config.options.rowCollectionOnDone" property must be of type boolean.');
            }
            this.config.options.rowCollectionOnDone = config.options.rowCollectionOnDone;
          }
          if (config.options.rowCollectionOnRequestCompletion !== void 0) {
            if (typeof config.options.rowCollectionOnRequestCompletion !== "boolean") {
              throw new TypeError('The "config.options.rowCollectionOnRequestCompletion" property must be of type boolean.');
            }
            this.config.options.rowCollectionOnRequestCompletion = config.options.rowCollectionOnRequestCompletion;
          }
          if (config.options.tdsVersion !== void 0) {
            if (typeof config.options.tdsVersion !== "string") {
              throw new TypeError('The "config.options.tdsVersion" property must be of type string.');
            }
            this.config.options.tdsVersion = config.options.tdsVersion;
          }
          if (config.options.textsize !== void 0) {
            if (typeof config.options.textsize !== "number" && config.options.textsize !== null) {
              throw new TypeError('The "config.options.textsize" property must be of type number or null.');
            }
            if (config.options.textsize > 2147483647) {
              throw new TypeError(`The "config.options.textsize" can't be greater than 2147483647.`);
            } else if (config.options.textsize < -1) {
              throw new TypeError(`The "config.options.textsize" can't be smaller than -1.`);
            }
            this.config.options.textsize = config.options.textsize | 0;
          }
          if (config.options.trustServerCertificate !== void 0) {
            if (typeof config.options.trustServerCertificate !== "boolean") {
              throw new TypeError('The "config.options.trustServerCertificate" property must be of type boolean.');
            }
            this.config.options.trustServerCertificate = config.options.trustServerCertificate;
          }
          if (config.options.serverName !== void 0) {
            if (typeof config.options.serverName !== "string") {
              throw new TypeError('The "config.options.serverName" property must be of type string.');
            }
            this.config.options.serverName = config.options.serverName;
          }
          if (config.options.useColumnNames !== void 0) {
            if (typeof config.options.useColumnNames !== "boolean") {
              throw new TypeError('The "config.options.useColumnNames" property must be of type boolean.');
            }
            this.config.options.useColumnNames = config.options.useColumnNames;
          }
          if (config.options.useUTC !== void 0) {
            if (typeof config.options.useUTC !== "boolean") {
              throw new TypeError('The "config.options.useUTC" property must be of type boolean.');
            }
            this.config.options.useUTC = config.options.useUTC;
          }
          if (config.options.workstationId !== void 0) {
            if (typeof config.options.workstationId !== "string") {
              throw new TypeError('The "config.options.workstationId" property must be of type string.');
            }
            this.config.options.workstationId = config.options.workstationId;
          }
          if (config.options.lowerCaseGuids !== void 0) {
            if (typeof config.options.lowerCaseGuids !== "boolean") {
              throw new TypeError('The "config.options.lowerCaseGuids" property must be of type boolean.');
            }
            this.config.options.lowerCaseGuids = config.options.lowerCaseGuids;
          }
        }
        this.secureContextOptions = this.config.options.cryptoCredentialsDetails;
        if (this.secureContextOptions.secureOptions === void 0) {
          this.secureContextOptions = Object.create(this.secureContextOptions, {
            secureOptions: {
              value: _constants.default.SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS
            }
          });
        }
        this.debug = this.createDebug();
        this.inTransaction = false;
        this.transactionDescriptors = [Buffer.from([0, 0, 0, 0, 0, 0, 0, 0])];
        this.transactionDepth = 0;
        this.isSqlBatch = false;
        this.closed = false;
        this.messageBuffer = Buffer.alloc(0);
        this.curTransientRetryCount = 0;
        this.transientErrorLookup = new _transientErrorLookup.TransientErrorLookup();
        this.state = this.STATE.INITIALIZED;
        this._cancelAfterRequestSent = () => {
          this.messageIo.sendMessage(_packet.TYPE.ATTENTION);
          this.createCancelTimer();
        };
      }
      connect(connectListener) {
        if (this.state !== this.STATE.INITIALIZED) {
          throw new _errors.ConnectionError("`.connect` can not be called on a Connection in `" + this.state.name + "` state.");
        }
        if (connectListener) {
          const onConnect = (err) => {
            this.removeListener("error", onError);
            connectListener(err);
          };
          const onError = (err) => {
            this.removeListener("connect", onConnect);
            connectListener(err);
          };
          this.once("connect", onConnect);
          this.once("error", onError);
        }
        this.transitionTo(this.STATE.CONNECTING);
      }
      /**
       * The server has reported that the charset has changed.
       */
      /**
       * The attempt to connect and validate has completed.
       */
      /**
       * The server has reported that the active database has changed.
       * This may be as a result of a successful login, or a `use` statement.
       */
      /**
       * A debug message is available. It may be logged or ignored.
       */
      /**
       * Internal error occurs.
       */
      /**
       * The server has issued an error message.
       */
      /**
       * The connection has ended.
       *
       * This may be as a result of the client calling [[close]], the server
       * closing the connection, or a network error.
       */
      /**
       * The server has issued an information message.
       */
      /**
       * The server has reported that the language has changed.
       */
      /**
       * The connection was reset.
       */
      /**
       * A secure connection has been established.
       */
      on(event, listener) {
        return super.on(event, listener);
      }
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      emit(event, ...args) {
        return super.emit(event, ...args);
      }
      /**
       * Closes the connection to the database.
       *
       * The [[Event_end]] will be emitted once the connection has been closed.
       */
      close() {
        this.transitionTo(this.STATE.FINAL);
      }
      /**
       * @private
       */
      initialiseConnection() {
        const signal = this.createConnectTimer();
        if (this.config.options.port) {
          return this.connectOnPort(this.config.options.port, this.config.options.multiSubnetFailover, signal, this.config.options.connector);
        } else {
          return (0, _instanceLookup.instanceLookup)({
            server: this.config.server,
            instanceName: this.config.options.instanceName,
            timeout: this.config.options.connectTimeout,
            signal
          }).then((port) => {
            process.nextTick(() => {
              this.connectOnPort(port, this.config.options.multiSubnetFailover, signal, this.config.options.connector);
            });
          }, (err) => {
            this.clearConnectTimer();
            if (signal.aborted) {
              return;
            }
            process.nextTick(() => {
              this.emit("connect", new _errors.ConnectionError(err.message, "EINSTLOOKUP", {
                cause: err
              }));
            });
          });
        }
      }
      /**
       * @private
       */
      cleanupConnection(cleanupType) {
        if (!this.closed) {
          this.clearConnectTimer();
          this.clearRequestTimer();
          this.clearRetryTimer();
          this.closeConnection();
          if (cleanupType === CLEANUP_TYPE.REDIRECT) {
            this.emit("rerouting");
          } else if (cleanupType !== CLEANUP_TYPE.RETRY) {
            process.nextTick(() => {
              this.emit("end");
            });
          }
          const request = this.request;
          if (request) {
            const err = new _errors.RequestError("Connection closed before request completed.", "ECLOSE");
            request.callback(err);
            this.request = void 0;
          }
          this.closed = true;
          this.loginError = void 0;
        }
      }
      /**
       * @private
       */
      createDebug() {
        const debug = new _debug.default(this.config.options.debug);
        debug.on("debug", (message) => {
          this.emit("debug", message);
        });
        return debug;
      }
      /**
       * @private
       */
      createTokenStreamParser(message, handler) {
        return new _tokenStreamParser.Parser(message, this.debug, handler, this.config.options);
      }
      socketHandlingForSendPreLogin(socket) {
        socket.on("error", (error) => {
          this.socketError(error);
        });
        socket.on("close", () => {
          this.socketClose();
        });
        socket.on("end", () => {
          this.socketEnd();
        });
        socket.setKeepAlive(true, KEEP_ALIVE_INITIAL_DELAY);
        this.messageIo = new _messageIo.default(socket, this.config.options.packetSize, this.debug);
        this.messageIo.on("secure", (cleartext) => {
          this.emit("secure", cleartext);
        });
        this.socket = socket;
        this.closed = false;
        this.debug.log("connected to " + this.config.server + ":" + this.config.options.port);
        this.sendPreLogin();
        this.transitionTo(this.STATE.SENT_PRELOGIN);
      }
      wrapWithTls(socket, signal) {
        signal.throwIfAborted();
        return new Promise((resolve, reject) => {
          const secureContext = tls.createSecureContext(this.secureContextOptions);
          const serverName = !net.isIP(this.config.server) ? this.config.server : "";
          const encryptOptions = {
            host: this.config.server,
            socket,
            ALPNProtocols: ["tds/8.0"],
            secureContext,
            servername: this.config.options.serverName ? this.config.options.serverName : serverName
          };
          const encryptsocket = tls.connect(encryptOptions);
          const onAbort = () => {
            encryptsocket.removeListener("error", onError);
            encryptsocket.removeListener("connect", onConnect);
            encryptsocket.destroy();
            reject(signal.reason);
          };
          const onError = (err) => {
            signal.removeEventListener("abort", onAbort);
            encryptsocket.removeListener("error", onError);
            encryptsocket.removeListener("connect", onConnect);
            encryptsocket.destroy();
            reject(err);
          };
          const onConnect = () => {
            signal.removeEventListener("abort", onAbort);
            encryptsocket.removeListener("error", onError);
            encryptsocket.removeListener("connect", onConnect);
            resolve(encryptsocket);
          };
          signal.addEventListener("abort", onAbort, {
            once: true
          });
          encryptsocket.on("error", onError);
          encryptsocket.on("secureConnect", onConnect);
        });
      }
      connectOnPort(port, multiSubnetFailover, signal, customConnector) {
        const connectOpts = {
          host: this.routingData ? this.routingData.server : this.config.server,
          port: this.routingData ? this.routingData.port : port,
          localAddress: this.config.options.localAddress
        };
        const connect = customConnector || (multiSubnetFailover ? _connector.connectInParallel : _connector.connectInSequence);
        (async () => {
          let socket = await connect(connectOpts, _dns.default.lookup, signal);
          if (this.config.options.encrypt === "strict") {
            try {
              socket = await this.wrapWithTls(socket, signal);
            } catch (err) {
              socket.end();
              throw err;
            }
          }
          this.socketHandlingForSendPreLogin(socket);
        })().catch((err) => {
          this.clearConnectTimer();
          if (signal.aborted) {
            return;
          }
          process.nextTick(() => {
            this.socketError(err);
          });
        });
      }
      /**
       * @private
       */
      closeConnection() {
        if (this.socket) {
          this.socket.destroy();
        }
      }
      /**
       * @private
       */
      createConnectTimer() {
        const controller = new AbortController();
        this.connectTimer = setTimeout(() => {
          controller.abort();
          this.connectTimeout();
        }, this.config.options.connectTimeout);
        return controller.signal;
      }
      /**
       * @private
       */
      createCancelTimer() {
        this.clearCancelTimer();
        const timeout = this.config.options.cancelTimeout;
        if (timeout > 0) {
          this.cancelTimer = setTimeout(() => {
            this.cancelTimeout();
          }, timeout);
        }
      }
      /**
       * @private
       */
      createRequestTimer() {
        this.clearRequestTimer();
        const request = this.request;
        const timeout = request.timeout !== void 0 ? request.timeout : this.config.options.requestTimeout;
        if (timeout) {
          this.requestTimer = setTimeout(() => {
            this.requestTimeout();
          }, timeout);
        }
      }
      /**
       * @private
       */
      createRetryTimer() {
        this.clearRetryTimer();
        this.retryTimer = setTimeout(() => {
          this.retryTimeout();
        }, this.config.options.connectionRetryInterval);
      }
      /**
       * @private
       */
      connectTimeout() {
        const hostPostfix = this.config.options.port ? `:${this.config.options.port}` : `\\${this.config.options.instanceName}`;
        const server = this.routingData ? this.routingData.server : this.config.server;
        const port = this.routingData ? `:${this.routingData.port}` : hostPostfix;
        const routingMessage = this.routingData ? ` (redirected from ${this.config.server}${hostPostfix})` : "";
        const message = `Failed to connect to ${server}${port}${routingMessage} in ${this.config.options.connectTimeout}ms`;
        this.debug.log(message);
        this.emit("connect", new _errors.ConnectionError(message, "ETIMEOUT"));
        this.connectTimer = void 0;
        this.dispatchEvent("connectTimeout");
      }
      /**
       * @private
       */
      cancelTimeout() {
        const message = `Failed to cancel request in ${this.config.options.cancelTimeout}ms`;
        this.debug.log(message);
        this.dispatchEvent("socketError", new _errors.ConnectionError(message, "ETIMEOUT"));
      }
      /**
       * @private
       */
      requestTimeout() {
        this.requestTimer = void 0;
        const request = this.request;
        request.cancel();
        const timeout = request.timeout !== void 0 ? request.timeout : this.config.options.requestTimeout;
        const message = "Timeout: Request failed to complete in " + timeout + "ms";
        request.error = new _errors.RequestError(message, "ETIMEOUT");
      }
      /**
       * @private
       */
      retryTimeout() {
        this.retryTimer = void 0;
        this.emit("retry");
        this.transitionTo(this.STATE.CONNECTING);
      }
      /**
       * @private
       */
      clearConnectTimer() {
        if (this.connectTimer) {
          clearTimeout(this.connectTimer);
          this.connectTimer = void 0;
        }
      }
      /**
       * @private
       */
      clearCancelTimer() {
        if (this.cancelTimer) {
          clearTimeout(this.cancelTimer);
          this.cancelTimer = void 0;
        }
      }
      /**
       * @private
       */
      clearRequestTimer() {
        if (this.requestTimer) {
          clearTimeout(this.requestTimer);
          this.requestTimer = void 0;
        }
      }
      /**
       * @private
       */
      clearRetryTimer() {
        if (this.retryTimer) {
          clearTimeout(this.retryTimer);
          this.retryTimer = void 0;
        }
      }
      /**
       * @private
       */
      transitionTo(newState) {
        if (this.state === newState) {
          this.debug.log("State is already " + newState.name);
          return;
        }
        if (this.state && this.state.exit) {
          this.state.exit.call(this, newState);
        }
        this.debug.log("State change: " + (this.state ? this.state.name : "undefined") + " -> " + newState.name);
        this.state = newState;
        if (this.state.enter) {
          this.state.enter.apply(this);
        }
      }
      /**
       * @private
       */
      getEventHandler(eventName) {
        const handler = this.state.events[eventName];
        if (!handler) {
          throw new Error(`No event '${eventName}' in state '${this.state.name}'`);
        }
        return handler;
      }
      /**
       * @private
       */
      dispatchEvent(eventName, ...args) {
        const handler = this.state.events[eventName];
        if (handler) {
          handler.apply(this, args);
        } else {
          this.emit("error", new Error(`No event '${eventName}' in state '${this.state.name}'`));
          this.close();
        }
      }
      /**
       * @private
       */
      socketError(error) {
        if (this.state === this.STATE.CONNECTING || this.state === this.STATE.SENT_TLSSSLNEGOTIATION) {
          const hostPostfix = this.config.options.port ? `:${this.config.options.port}` : `\\${this.config.options.instanceName}`;
          const server = this.routingData ? this.routingData.server : this.config.server;
          const port = this.routingData ? `:${this.routingData.port}` : hostPostfix;
          const routingMessage = this.routingData ? ` (redirected from ${this.config.server}${hostPostfix})` : "";
          const message = `Failed to connect to ${server}${port}${routingMessage} - ${error.message}`;
          this.debug.log(message);
          this.emit("connect", new _errors.ConnectionError(message, "ESOCKET", {
            cause: error
          }));
        } else {
          const message = `Connection lost - ${error.message}`;
          this.debug.log(message);
          this.emit("error", new _errors.ConnectionError(message, "ESOCKET", {
            cause: error
          }));
        }
        this.dispatchEvent("socketError", error);
      }
      /**
       * @private
       */
      socketEnd() {
        this.debug.log("socket ended");
        if (this.state !== this.STATE.FINAL) {
          const error = new Error("socket hang up");
          error.code = "ECONNRESET";
          this.socketError(error);
        }
      }
      /**
       * @private
       */
      socketClose() {
        this.debug.log("connection to " + this.config.server + ":" + this.config.options.port + " closed");
        if (this.state === this.STATE.REROUTING) {
          this.debug.log("Rerouting to " + this.routingData.server + ":" + this.routingData.port);
          this.dispatchEvent("reconnect");
        } else if (this.state === this.STATE.TRANSIENT_FAILURE_RETRY) {
          const server = this.routingData ? this.routingData.server : this.config.server;
          const port = this.routingData ? this.routingData.port : this.config.options.port;
          this.debug.log("Retry after transient failure connecting to " + server + ":" + port);
          this.dispatchEvent("retry");
        } else {
          this.transitionTo(this.STATE.FINAL);
        }
      }
      /**
       * @private
       */
      sendPreLogin() {
        const [, major, minor, build] = /^(\d+)\.(\d+)\.(\d+)/.exec(_package.version) ?? ["0.0.0", "0", "0", "0"];
        const payload = new _preloginPayload.default({
          // If encrypt setting is set to 'strict', then we should have already done the encryption before calling
          // this function. Therefore, the encrypt will be set to false here.
          // Otherwise, we will set encrypt here based on the encrypt Boolean value from the configuration.
          encrypt: typeof this.config.options.encrypt === "boolean" && this.config.options.encrypt,
          version: {
            major: Number(major),
            minor: Number(minor),
            build: Number(build),
            subbuild: 0
          }
        });
        this.messageIo.sendMessage(_packet.TYPE.PRELOGIN, payload.data);
        this.debug.payload(function() {
          return payload.toString("  ");
        });
      }
      /**
       * @private
       */
      sendLogin7Packet() {
        const payload = new _login7Payload.default({
          tdsVersion: _tdsVersions.versions[this.config.options.tdsVersion],
          packetSize: this.config.options.packetSize,
          clientProgVer: 0,
          clientPid: process.pid,
          connectionId: 0,
          clientTimeZone: (/* @__PURE__ */ new Date()).getTimezoneOffset(),
          clientLcid: 1033
        });
        const {
          authentication
        } = this.config;
        switch (authentication.type) {
          case "azure-active-directory-password":
            payload.fedAuth = {
              type: "ADAL",
              echo: this.fedAuthRequired,
              workflow: "default"
            };
            break;
          case "azure-active-directory-access-token":
            payload.fedAuth = {
              type: "SECURITYTOKEN",
              echo: this.fedAuthRequired,
              fedAuthToken: authentication.options.token
            };
            break;
          case "token-credential":
          case "azure-active-directory-msi-vm":
          case "azure-active-directory-default":
          case "azure-active-directory-msi-app-service":
          case "azure-active-directory-service-principal-secret":
            payload.fedAuth = {
              type: "ADAL",
              echo: this.fedAuthRequired,
              workflow: "integrated"
            };
            break;
          case "ntlm":
            payload.sspi = (0, _ntlm.createNTLMRequest)({
              domain: authentication.options.domain
            });
            break;
          default:
            payload.userName = authentication.options.userName;
            payload.password = authentication.options.password;
        }
        payload.hostname = this.config.options.workstationId || _os.default.hostname();
        payload.serverName = this.routingData ? this.routingData.server : this.config.server;
        payload.appName = this.config.options.appName || "Tedious";
        payload.libraryName = _library.name;
        payload.language = this.config.options.language;
        payload.database = this.config.options.database;
        payload.clientId = Buffer.from([1, 2, 3, 4, 5, 6]);
        payload.readOnlyIntent = this.config.options.readOnlyIntent;
        payload.initDbFatal = !this.config.options.fallbackToDefaultDb;
        this.routingData = void 0;
        this.messageIo.sendMessage(_packet.TYPE.LOGIN7, payload.toBuffer());
        this.debug.payload(function() {
          return payload.toString("  ");
        });
      }
      /**
       * @private
       */
      sendFedAuthTokenMessage(token) {
        const accessTokenLen = Buffer.byteLength(token, "ucs2");
        const data = Buffer.alloc(8 + accessTokenLen);
        let offset = 0;
        offset = data.writeUInt32LE(accessTokenLen + 4, offset);
        offset = data.writeUInt32LE(accessTokenLen, offset);
        data.write(token, offset, "ucs2");
        this.messageIo.sendMessage(_packet.TYPE.FEDAUTH_TOKEN, data);
        this.transitionTo(this.STATE.SENT_LOGIN7_WITH_STANDARD_LOGIN);
      }
      /**
       * @private
       */
      sendInitialSql() {
        const payload = new _sqlbatchPayload.default(this.getInitialSql(), this.currentTransactionDescriptor(), this.config.options);
        const message = new _message.default({
          type: _packet.TYPE.SQL_BATCH
        });
        this.messageIo.outgoingMessageStream.write(message);
        _stream.Readable.from(payload).pipe(message);
      }
      /**
       * @private
       */
      getInitialSql() {
        const options = [];
        if (this.config.options.enableAnsiNull === true) {
          options.push("set ansi_nulls on");
        } else if (this.config.options.enableAnsiNull === false) {
          options.push("set ansi_nulls off");
        }
        if (this.config.options.enableAnsiNullDefault === true) {
          options.push("set ansi_null_dflt_on on");
        } else if (this.config.options.enableAnsiNullDefault === false) {
          options.push("set ansi_null_dflt_on off");
        }
        if (this.config.options.enableAnsiPadding === true) {
          options.push("set ansi_padding on");
        } else if (this.config.options.enableAnsiPadding === false) {
          options.push("set ansi_padding off");
        }
        if (this.config.options.enableAnsiWarnings === true) {
          options.push("set ansi_warnings on");
        } else if (this.config.options.enableAnsiWarnings === false) {
          options.push("set ansi_warnings off");
        }
        if (this.config.options.enableArithAbort === true) {
          options.push("set arithabort on");
        } else if (this.config.options.enableArithAbort === false) {
          options.push("set arithabort off");
        }
        if (this.config.options.enableConcatNullYieldsNull === true) {
          options.push("set concat_null_yields_null on");
        } else if (this.config.options.enableConcatNullYieldsNull === false) {
          options.push("set concat_null_yields_null off");
        }
        if (this.config.options.enableCursorCloseOnCommit === true) {
          options.push("set cursor_close_on_commit on");
        } else if (this.config.options.enableCursorCloseOnCommit === false) {
          options.push("set cursor_close_on_commit off");
        }
        if (this.config.options.datefirst !== null) {
          options.push(`set datefirst ${this.config.options.datefirst}`);
        }
        if (this.config.options.dateFormat !== null) {
          options.push(`set dateformat ${this.config.options.dateFormat}`);
        }
        if (this.config.options.enableImplicitTransactions === true) {
          options.push("set implicit_transactions on");
        } else if (this.config.options.enableImplicitTransactions === false) {
          options.push("set implicit_transactions off");
        }
        if (this.config.options.language !== null) {
          options.push(`set language ${this.config.options.language}`);
        }
        if (this.config.options.enableNumericRoundabort === true) {
          options.push("set numeric_roundabort on");
        } else if (this.config.options.enableNumericRoundabort === false) {
          options.push("set numeric_roundabort off");
        }
        if (this.config.options.enableQuotedIdentifier === true) {
          options.push("set quoted_identifier on");
        } else if (this.config.options.enableQuotedIdentifier === false) {
          options.push("set quoted_identifier off");
        }
        if (this.config.options.textsize !== null) {
          options.push(`set textsize ${this.config.options.textsize}`);
        }
        if (this.config.options.connectionIsolationLevel !== null) {
          options.push(`set transaction isolation level ${this.getIsolationLevelText(this.config.options.connectionIsolationLevel)}`);
        }
        if (this.config.options.abortTransactionOnError === true) {
          options.push("set xact_abort on");
        } else if (this.config.options.abortTransactionOnError === false) {
          options.push("set xact_abort off");
        }
        return options.join("\n");
      }
      /**
       * @private
       */
      processedInitialSql() {
        this.clearConnectTimer();
        this.emit("connect");
      }
      /**
       * Execute the SQL batch represented by [[Request]].
       * There is no param support, and unlike [[Request.execSql]],
       * it is not likely that SQL Server will reuse the execution plan it generates for the SQL.
       *
       * In almost all cases, [[Request.execSql]] will be a better choice.
       *
       * @param request A [[Request]] object representing the request.
       */
      execSqlBatch(request) {
        this.makeRequest(request, _packet.TYPE.SQL_BATCH, new _sqlbatchPayload.default(request.sqlTextOrProcedure, this.currentTransactionDescriptor(), this.config.options));
      }
      /**
       *  Execute the SQL represented by [[Request]].
       *
       * As `sp_executesql` is used to execute the SQL, if the same SQL is executed multiples times
       * using this function, the SQL Server query optimizer is likely to reuse the execution plan it generates
       * for the first execution. This may also result in SQL server treating the request like a stored procedure
       * which can result in the [[Event_doneInProc]] or [[Event_doneProc]] events being emitted instead of the
       * [[Event_done]] event you might expect. Using [[execSqlBatch]] will prevent this from occurring but may have a negative performance impact.
       *
       * Beware of the way that scoping rules apply, and how they may [affect local temp tables](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)
       * If you're running in to scoping issues, then [[execSqlBatch]] may be a better choice.
       * See also [issue #24](https://github.com/pekim/tedious/issues/24)
       *
       * @param request A [[Request]] object representing the request.
       */
      execSql(request) {
        try {
          request.validateParameters(this.databaseCollation);
        } catch (error) {
          request.error = error;
          process.nextTick(() => {
            this.debug.log(error.message);
            request.callback(error);
          });
          return;
        }
        const parameters = [];
        parameters.push({
          type: _dataType.TYPES.NVarChar,
          name: "statement",
          value: request.sqlTextOrProcedure,
          output: false,
          length: void 0,
          precision: void 0,
          scale: void 0
        });
        if (request.parameters.length) {
          parameters.push({
            type: _dataType.TYPES.NVarChar,
            name: "params",
            value: request.makeParamsParameter(request.parameters),
            output: false,
            length: void 0,
            precision: void 0,
            scale: void 0
          });
          parameters.push(...request.parameters);
        }
        this.makeRequest(request, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(_specialStoredProcedure.default.Sp_ExecuteSql, parameters, this.currentTransactionDescriptor(), this.config.options, this.databaseCollation));
      }
      /**
       * Creates a new BulkLoad instance.
       *
       * @param table The name of the table to bulk-insert into.
       * @param options A set of bulk load options.
       */
      newBulkLoad(table, callbackOrOptions, callback) {
        let options;
        if (callback === void 0) {
          callback = callbackOrOptions;
          options = {};
        } else {
          options = callbackOrOptions;
        }
        if (typeof options !== "object") {
          throw new TypeError('"options" argument must be an object');
        }
        return new _bulkLoad.default(table, this.databaseCollation, this.config.options, options, callback);
      }
      /**
       * Execute a [[BulkLoad]].
       *
       * ```js
       * // We want to perform a bulk load into a table with the following format:
       * // CREATE TABLE employees (first_name nvarchar(255), last_name nvarchar(255), day_of_birth date);
       *
       * const bulkLoad = connection.newBulkLoad('employees', (err, rowCount) => {
       *   // ...
       * });
       *
       * // First, we need to specify the columns that we want to write to,
       * // and their definitions. These definitions must match the actual table,
       * // otherwise the bulk load will fail.
       * bulkLoad.addColumn('first_name', TYPES.NVarchar, { nullable: false });
       * bulkLoad.addColumn('last_name', TYPES.NVarchar, { nullable: false });
       * bulkLoad.addColumn('date_of_birth', TYPES.Date, { nullable: false });
       *
       * // Execute a bulk load with a predefined list of rows.
       * //
       * // Note that these rows are held in memory until the
       * // bulk load was performed, so if you need to write a large
       * // number of rows (e.g. by reading from a CSV file),
       * // passing an `AsyncIterable` is advisable to keep memory usage low.
       * connection.execBulkLoad(bulkLoad, [
       *   { 'first_name': 'Steve', 'last_name': 'Jobs', 'day_of_birth': new Date('02-24-1955') },
       *   { 'first_name': 'Bill', 'last_name': 'Gates', 'day_of_birth': new Date('10-28-1955') }
       * ]);
       * ```
       *
       * @param bulkLoad A previously created [[BulkLoad]].
       * @param rows A [[Iterable]] or [[AsyncIterable]] that contains the rows that should be bulk loaded.
       */
      execBulkLoad(bulkLoad, rows) {
        bulkLoad.executionStarted = true;
        if (rows) {
          if (bulkLoad.streamingMode) {
            throw new Error("Connection.execBulkLoad can't be called with a BulkLoad that was put in streaming mode.");
          }
          if (bulkLoad.firstRowWritten) {
            throw new Error("Connection.execBulkLoad can't be called with a BulkLoad that already has rows written to it.");
          }
          const rowStream = _stream.Readable.from(rows);
          rowStream.on("error", (err) => {
            bulkLoad.rowToPacketTransform.destroy(err);
          });
          bulkLoad.rowToPacketTransform.on("error", (err) => {
            rowStream.destroy(err);
          });
          rowStream.pipe(bulkLoad.rowToPacketTransform);
        } else if (!bulkLoad.streamingMode) {
          bulkLoad.rowToPacketTransform.end();
        }
        const onCancel = () => {
          request.cancel();
        };
        const payload = new _bulkLoadPayload.BulkLoadPayload(bulkLoad);
        const request = new _request.default(bulkLoad.getBulkInsertSql(), (error) => {
          bulkLoad.removeListener("cancel", onCancel);
          if (error) {
            if (error.code === "UNKNOWN") {
              error.message += " This is likely because the schema of the BulkLoad does not match the schema of the table you are attempting to insert into.";
            }
            bulkLoad.error = error;
            bulkLoad.callback(error);
            return;
          }
          this.makeRequest(bulkLoad, _packet.TYPE.BULK_LOAD, payload);
        });
        bulkLoad.once("cancel", onCancel);
        this.execSqlBatch(request);
      }
      /**
       * Prepare the SQL represented by the request.
       *
       * The request can then be used in subsequent calls to
       * [[execute]] and [[unprepare]]
       *
       * @param request A [[Request]] object representing the request.
       *   Parameters only require a name and type. Parameter values are ignored.
       */
      prepare(request) {
        const parameters = [];
        parameters.push({
          type: _dataType.TYPES.Int,
          name: "handle",
          value: void 0,
          output: true,
          length: void 0,
          precision: void 0,
          scale: void 0
        });
        parameters.push({
          type: _dataType.TYPES.NVarChar,
          name: "params",
          value: request.parameters.length ? request.makeParamsParameter(request.parameters) : null,
          output: false,
          length: void 0,
          precision: void 0,
          scale: void 0
        });
        parameters.push({
          type: _dataType.TYPES.NVarChar,
          name: "stmt",
          value: request.sqlTextOrProcedure,
          output: false,
          length: void 0,
          precision: void 0,
          scale: void 0
        });
        request.preparing = true;
        request.on("returnValue", (name3, value) => {
          if (name3 === "handle") {
            request.handle = value;
          } else {
            request.error = new _errors.RequestError(`Tedious > Unexpected output parameter ${name3} from sp_prepare`);
          }
        });
        this.makeRequest(request, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(_specialStoredProcedure.default.Sp_Prepare, parameters, this.currentTransactionDescriptor(), this.config.options, this.databaseCollation));
      }
      /**
       * Release the SQL Server resources associated with a previously prepared request.
       *
       * @param request A [[Request]] object representing the request.
       *   Parameters only require a name and type.
       *   Parameter values are ignored.
       */
      unprepare(request) {
        const parameters = [];
        parameters.push({
          type: _dataType.TYPES.Int,
          name: "handle",
          // TODO: Abort if `request.handle` is not set
          value: request.handle,
          output: false,
          length: void 0,
          precision: void 0,
          scale: void 0
        });
        this.makeRequest(request, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(_specialStoredProcedure.default.Sp_Unprepare, parameters, this.currentTransactionDescriptor(), this.config.options, this.databaseCollation));
      }
      /**
       * Execute previously prepared SQL, using the supplied parameters.
       *
       * @param request A previously prepared [[Request]].
       * @param parameters  An object whose names correspond to the names of
       *   parameters that were added to the [[Request]] before it was prepared.
       *   The object's values are passed as the parameters' values when the
       *   request is executed.
       */
      execute(request, parameters) {
        const executeParameters = [];
        executeParameters.push({
          type: _dataType.TYPES.Int,
          name: "",
          // TODO: Abort if `request.handle` is not set
          value: request.handle,
          output: false,
          length: void 0,
          precision: void 0,
          scale: void 0
        });
        try {
          for (let i = 0, len = request.parameters.length; i < len; i++) {
            const parameter = request.parameters[i];
            executeParameters.push({
              ...parameter,
              value: parameter.type.validate(parameters ? parameters[parameter.name] : null, this.databaseCollation)
            });
          }
        } catch (error) {
          request.error = error;
          process.nextTick(() => {
            this.debug.log(error.message);
            request.callback(error);
          });
          return;
        }
        this.makeRequest(request, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(_specialStoredProcedure.default.Sp_Execute, executeParameters, this.currentTransactionDescriptor(), this.config.options, this.databaseCollation));
      }
      /**
       * Call a stored procedure represented by [[Request]].
       *
       * @param request A [[Request]] object representing the request.
       */
      callProcedure(request) {
        try {
          request.validateParameters(this.databaseCollation);
        } catch (error) {
          request.error = error;
          process.nextTick(() => {
            this.debug.log(error.message);
            request.callback(error);
          });
          return;
        }
        this.makeRequest(request, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(request.sqlTextOrProcedure, request.parameters, this.currentTransactionDescriptor(), this.config.options, this.databaseCollation));
      }
      /**
       * Start a transaction.
       *
       * @param callback
       * @param name A string representing a name to associate with the transaction.
       *   Optional, and defaults to an empty string. Required when `isolationLevel`
       *   is present.
       * @param isolationLevel The isolation level that the transaction is to be run with.
       *
       *   The isolation levels are available from `require('tedious').ISOLATION_LEVEL`.
       *   * `READ_UNCOMMITTED`
       *   * `READ_COMMITTED`
       *   * `REPEATABLE_READ`
       *   * `SERIALIZABLE`
       *   * `SNAPSHOT`
       *
       *   Optional, and defaults to the Connection's isolation level.
       */
      beginTransaction(callback, name3 = "", isolationLevel = this.config.options.isolationLevel) {
        (0, _transaction.assertValidIsolationLevel)(isolationLevel, "isolationLevel");
        const transaction = new _transaction.Transaction(name3, isolationLevel);
        if (this.config.options.tdsVersion < "7_2") {
          return this.execSqlBatch(new _request.default("SET TRANSACTION ISOLATION LEVEL " + transaction.isolationLevelToTSQL() + ";BEGIN TRAN " + transaction.name, (err) => {
            this.transactionDepth++;
            if (this.transactionDepth === 1) {
              this.inTransaction = true;
            }
            callback(err);
          }));
        }
        const request = new _request.default(void 0, (err) => {
          return callback(err, this.currentTransactionDescriptor());
        });
        return this.makeRequest(request, _packet.TYPE.TRANSACTION_MANAGER, transaction.beginPayload(this.currentTransactionDescriptor()));
      }
      /**
       * Commit a transaction.
       *
       * There should be an active transaction - that is, [[beginTransaction]]
       * should have been previously called.
       *
       * @param callback
       * @param name A string representing a name to associate with the transaction.
       *   Optional, and defaults to an empty string. Required when `isolationLevel`is present.
       */
      commitTransaction(callback, name3 = "") {
        const transaction = new _transaction.Transaction(name3);
        if (this.config.options.tdsVersion < "7_2") {
          return this.execSqlBatch(new _request.default("COMMIT TRAN " + transaction.name, (err) => {
            this.transactionDepth--;
            if (this.transactionDepth === 0) {
              this.inTransaction = false;
            }
            callback(err);
          }));
        }
        const request = new _request.default(void 0, callback);
        return this.makeRequest(request, _packet.TYPE.TRANSACTION_MANAGER, transaction.commitPayload(this.currentTransactionDescriptor()));
      }
      /**
       * Rollback a transaction.
       *
       * There should be an active transaction - that is, [[beginTransaction]]
       * should have been previously called.
       *
       * @param callback
       * @param name A string representing a name to associate with the transaction.
       *   Optional, and defaults to an empty string.
       *   Required when `isolationLevel` is present.
       */
      rollbackTransaction(callback, name3 = "") {
        const transaction = new _transaction.Transaction(name3);
        if (this.config.options.tdsVersion < "7_2") {
          return this.execSqlBatch(new _request.default("ROLLBACK TRAN " + transaction.name, (err) => {
            this.transactionDepth--;
            if (this.transactionDepth === 0) {
              this.inTransaction = false;
            }
            callback(err);
          }));
        }
        const request = new _request.default(void 0, callback);
        return this.makeRequest(request, _packet.TYPE.TRANSACTION_MANAGER, transaction.rollbackPayload(this.currentTransactionDescriptor()));
      }
      /**
       * Set a savepoint within a transaction.
       *
       * There should be an active transaction - that is, [[beginTransaction]]
       * should have been previously called.
       *
       * @param callback
       * @param name A string representing a name to associate with the transaction.\
       *   Optional, and defaults to an empty string.
       *   Required when `isolationLevel` is present.
       */
      saveTransaction(callback, name3) {
        const transaction = new _transaction.Transaction(name3);
        if (this.config.options.tdsVersion < "7_2") {
          return this.execSqlBatch(new _request.default("SAVE TRAN " + transaction.name, (err) => {
            this.transactionDepth++;
            callback(err);
          }));
        }
        const request = new _request.default(void 0, callback);
        return this.makeRequest(request, _packet.TYPE.TRANSACTION_MANAGER, transaction.savePayload(this.currentTransactionDescriptor()));
      }
      /**
       * Run the given callback after starting a transaction, and commit or
       * rollback the transaction afterwards.
       *
       * This is a helper that employs [[beginTransaction]], [[commitTransaction]],
       * [[rollbackTransaction]], and [[saveTransaction]] to greatly simplify the
       * use of database transactions and automatically handle transaction nesting.
       *
       * @param cb
       * @param isolationLevel
       *   The isolation level that the transaction is to be run with.
       *
       *   The isolation levels are available from `require('tedious').ISOLATION_LEVEL`.
       *   * `READ_UNCOMMITTED`
       *   * `READ_COMMITTED`
       *   * `REPEATABLE_READ`
       *   * `SERIALIZABLE`
       *   * `SNAPSHOT`
       *
       *   Optional, and defaults to the Connection's isolation level.
       */
      transaction(cb, isolationLevel) {
        if (typeof cb !== "function") {
          throw new TypeError("`cb` must be a function");
        }
        const useSavepoint = this.inTransaction;
        const name3 = "_tedious_" + _crypto.default.randomBytes(10).toString("hex");
        const txDone = (err, done, ...args) => {
          if (err) {
            if (this.inTransaction && this.state === this.STATE.LOGGED_IN) {
              this.rollbackTransaction((txErr) => {
                done(txErr || err, ...args);
              }, name3);
            } else {
              done(err, ...args);
            }
          } else if (useSavepoint) {
            if (this.config.options.tdsVersion < "7_2") {
              this.transactionDepth--;
            }
            done(null, ...args);
          } else {
            this.commitTransaction((txErr) => {
              done(txErr, ...args);
            }, name3);
          }
        };
        if (useSavepoint) {
          return this.saveTransaction((err) => {
            if (err) {
              return cb(err);
            }
            if (isolationLevel) {
              return this.execSqlBatch(new _request.default("SET transaction isolation level " + this.getIsolationLevelText(isolationLevel), (err2) => {
                return cb(err2, txDone);
              }));
            } else {
              return cb(null, txDone);
            }
          }, name3);
        } else {
          return this.beginTransaction((err) => {
            if (err) {
              return cb(err);
            }
            return cb(null, txDone);
          }, name3, isolationLevel);
        }
      }
      /**
       * @private
       */
      makeRequest(request, packetType, payload) {
        if (this.state !== this.STATE.LOGGED_IN) {
          const message = "Requests can only be made in the " + this.STATE.LOGGED_IN.name + " state, not the " + this.state.name + " state";
          this.debug.log(message);
          request.callback(new _errors.RequestError(message, "EINVALIDSTATE"));
        } else if (request.canceled) {
          process.nextTick(() => {
            request.callback(new _errors.RequestError("Canceled.", "ECANCEL"));
          });
        } else {
          if (packetType === _packet.TYPE.SQL_BATCH) {
            this.isSqlBatch = true;
          } else {
            this.isSqlBatch = false;
          }
          this.request = request;
          request.connection = this;
          request.rowCount = 0;
          request.rows = [];
          request.rst = [];
          const onCancel = () => {
            payloadStream.unpipe(message);
            payloadStream.destroy(new _errors.RequestError("Canceled.", "ECANCEL"));
            message.ignore = true;
            message.end();
            if (request instanceof _request.default && request.paused) {
              request.resume();
            }
          };
          request.once("cancel", onCancel);
          this.createRequestTimer();
          const message = new _message.default({
            type: packetType,
            resetConnection: this.resetConnectionOnNextRequest
          });
          this.messageIo.outgoingMessageStream.write(message);
          this.transitionTo(this.STATE.SENT_CLIENT_REQUEST);
          message.once("finish", () => {
            request.removeListener("cancel", onCancel);
            request.once("cancel", this._cancelAfterRequestSent);
            this.resetConnectionOnNextRequest = false;
            this.debug.payload(function() {
              return payload.toString("  ");
            });
          });
          const payloadStream = _stream.Readable.from(payload);
          payloadStream.once("error", (error) => {
            payloadStream.unpipe(message);
            request.error ?? (request.error = error);
            message.ignore = true;
            message.end();
          });
          payloadStream.pipe(message);
        }
      }
      /**
       * Cancel currently executed request.
       */
      cancel() {
        if (!this.request) {
          return false;
        }
        if (this.request.canceled) {
          return false;
        }
        this.request.cancel();
        return true;
      }
      /**
       * Reset the connection to its initial state.
       * Can be useful for connection pool implementations.
       *
       * @param callback
       */
      reset(callback) {
        const request = new _request.default(this.getInitialSql(), (err) => {
          if (this.config.options.tdsVersion < "7_2") {
            this.inTransaction = false;
          }
          callback(err);
        });
        this.resetConnectionOnNextRequest = true;
        this.execSqlBatch(request);
      }
      /**
       * @private
       */
      currentTransactionDescriptor() {
        return this.transactionDescriptors[this.transactionDescriptors.length - 1];
      }
      /**
       * @private
       */
      getIsolationLevelText(isolationLevel) {
        switch (isolationLevel) {
          case _transaction.ISOLATION_LEVEL.READ_UNCOMMITTED:
            return "read uncommitted";
          case _transaction.ISOLATION_LEVEL.REPEATABLE_READ:
            return "repeatable read";
          case _transaction.ISOLATION_LEVEL.SERIALIZABLE:
            return "serializable";
          case _transaction.ISOLATION_LEVEL.SNAPSHOT:
            return "snapshot";
          default:
            return "read committed";
        }
      }
    };
    function isTransientError(error) {
      if (error instanceof AggregateError) {
        error = error.errors[0];
      }
      return error instanceof _errors.ConnectionError && !!error.isTransient;
    }
    var _default = exports.default = Connection;
    module.exports = Connection;
    Connection.prototype.STATE = {
      INITIALIZED: {
        name: "Initialized",
        events: {}
      },
      CONNECTING: {
        name: "Connecting",
        enter: function() {
          this.initialiseConnection();
        },
        events: {
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      SENT_PRELOGIN: {
        name: "SentPrelogin",
        enter: function() {
          (async () => {
            var _a3;
            let messageBuffer = Buffer.alloc(0);
            let message;
            try {
              message = await this.messageIo.readMessage();
            } catch (err) {
              return this.socketError(err);
            }
            for await (const data of message) {
              messageBuffer = Buffer.concat([messageBuffer, data]);
            }
            const preloginPayload = new _preloginPayload.default(messageBuffer);
            this.debug.payload(function() {
              return preloginPayload.toString("  ");
            });
            if (preloginPayload.fedAuthRequired === 1) {
              this.fedAuthRequired = true;
            }
            if ("strict" !== this.config.options.encrypt && (preloginPayload.encryptionString === "ON" || preloginPayload.encryptionString === "REQ")) {
              if (!this.config.options.encrypt) {
                this.emit("connect", new _errors.ConnectionError("Server requires encryption, set 'encrypt' config option to true.", "EENCRYPT"));
                return this.close();
              }
              try {
                this.transitionTo(this.STATE.SENT_TLSSSLNEGOTIATION);
                await this.messageIo.startTls(this.secureContextOptions, this.config.options.serverName ? this.config.options.serverName : ((_a3 = this.routingData) == null ? void 0 : _a3.server) ?? this.config.server, this.config.options.trustServerCertificate);
              } catch (err) {
                return this.socketError(err);
              }
            }
            this.sendLogin7Packet();
            const {
              authentication
            } = this.config;
            switch (authentication.type) {
              case "token-credential":
              case "azure-active-directory-password":
              case "azure-active-directory-msi-vm":
              case "azure-active-directory-msi-app-service":
              case "azure-active-directory-service-principal-secret":
              case "azure-active-directory-default":
                this.transitionTo(this.STATE.SENT_LOGIN7_WITH_FEDAUTH);
                break;
              case "ntlm":
                this.transitionTo(this.STATE.SENT_LOGIN7_WITH_NTLM);
                break;
              default:
                this.transitionTo(this.STATE.SENT_LOGIN7_WITH_STANDARD_LOGIN);
                break;
            }
          })().catch((err) => {
            process.nextTick(() => {
              throw err;
            });
          });
        },
        events: {
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      REROUTING: {
        name: "ReRouting",
        enter: function() {
          this.cleanupConnection(CLEANUP_TYPE.REDIRECT);
        },
        events: {
          message: function() {
          },
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          reconnect: function() {
            this.transitionTo(this.STATE.CONNECTING);
          }
        }
      },
      TRANSIENT_FAILURE_RETRY: {
        name: "TRANSIENT_FAILURE_RETRY",
        enter: function() {
          this.curTransientRetryCount++;
          this.cleanupConnection(CLEANUP_TYPE.RETRY);
        },
        events: {
          message: function() {
          },
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          retry: function() {
            this.createRetryTimer();
          }
        }
      },
      SENT_TLSSSLNEGOTIATION: {
        name: "SentTLSSSLNegotiation",
        events: {
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      SENT_LOGIN7_WITH_STANDARD_LOGIN: {
        name: "SentLogin7WithStandardLogin",
        enter: function() {
          (async () => {
            let message;
            try {
              message = await this.messageIo.readMessage();
            } catch (err) {
              return this.socketError(err);
            }
            const handler = new _handler.Login7TokenHandler(this);
            const tokenStreamParser = this.createTokenStreamParser(message, handler);
            await (0, _events.once)(tokenStreamParser, "end");
            if (handler.loginAckReceived) {
              if (handler.routingData) {
                this.routingData = handler.routingData;
                this.transitionTo(this.STATE.REROUTING);
              } else {
                this.transitionTo(this.STATE.LOGGED_IN_SENDING_INITIAL_SQL);
              }
            } else if (this.loginError) {
              if (isTransientError(this.loginError)) {
                this.debug.log("Initiating retry on transient error");
                this.transitionTo(this.STATE.TRANSIENT_FAILURE_RETRY);
              } else {
                this.emit("connect", this.loginError);
                this.transitionTo(this.STATE.FINAL);
              }
            } else {
              this.emit("connect", new _errors.ConnectionError("Login failed.", "ELOGIN"));
              this.transitionTo(this.STATE.FINAL);
            }
          })().catch((err) => {
            process.nextTick(() => {
              throw err;
            });
          });
        },
        events: {
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      SENT_LOGIN7_WITH_NTLM: {
        name: "SentLogin7WithNTLMLogin",
        enter: function() {
          (async () => {
            while (true) {
              let message;
              try {
                message = await this.messageIo.readMessage();
              } catch (err) {
                return this.socketError(err);
              }
              const handler = new _handler.Login7TokenHandler(this);
              const tokenStreamParser = this.createTokenStreamParser(message, handler);
              await (0, _events.once)(tokenStreamParser, "end");
              if (handler.loginAckReceived) {
                if (handler.routingData) {
                  this.routingData = handler.routingData;
                  return this.transitionTo(this.STATE.REROUTING);
                } else {
                  return this.transitionTo(this.STATE.LOGGED_IN_SENDING_INITIAL_SQL);
                }
              } else if (this.ntlmpacket) {
                const authentication = this.config.authentication;
                const payload = new _ntlmPayload.default({
                  domain: authentication.options.domain,
                  userName: authentication.options.userName,
                  password: authentication.options.password,
                  ntlmpacket: this.ntlmpacket
                });
                this.messageIo.sendMessage(_packet.TYPE.NTLMAUTH_PKT, payload.data);
                this.debug.payload(function() {
                  return payload.toString("  ");
                });
                this.ntlmpacket = void 0;
              } else if (this.loginError) {
                if (isTransientError(this.loginError)) {
                  this.debug.log("Initiating retry on transient error");
                  return this.transitionTo(this.STATE.TRANSIENT_FAILURE_RETRY);
                } else {
                  this.emit("connect", this.loginError);
                  return this.transitionTo(this.STATE.FINAL);
                }
              } else {
                this.emit("connect", new _errors.ConnectionError("Login failed.", "ELOGIN"));
                return this.transitionTo(this.STATE.FINAL);
              }
            }
          })().catch((err) => {
            process.nextTick(() => {
              throw err;
            });
          });
        },
        events: {
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      SENT_LOGIN7_WITH_FEDAUTH: {
        name: "SentLogin7Withfedauth",
        enter: function() {
          (async () => {
            let message;
            try {
              message = await this.messageIo.readMessage();
            } catch (err) {
              return this.socketError(err);
            }
            const handler = new _handler.Login7TokenHandler(this);
            const tokenStreamParser = this.createTokenStreamParser(message, handler);
            await (0, _events.once)(tokenStreamParser, "end");
            if (handler.loginAckReceived) {
              if (handler.routingData) {
                this.routingData = handler.routingData;
                this.transitionTo(this.STATE.REROUTING);
              } else {
                this.transitionTo(this.STATE.LOGGED_IN_SENDING_INITIAL_SQL);
              }
              return;
            }
            const fedAuthInfoToken = handler.fedAuthInfoToken;
            if (fedAuthInfoToken && fedAuthInfoToken.stsurl && fedAuthInfoToken.spn) {
              const authentication = this.config.authentication;
              const tokenScope = new _url.URL("/.default", fedAuthInfoToken.spn).toString();
              let credentials;
              switch (authentication.type) {
                case "token-credential":
                  credentials = authentication.options.credential;
                  break;
                case "azure-active-directory-password":
                  credentials = new _identity.UsernamePasswordCredential(authentication.options.tenantId ?? "common", authentication.options.clientId, authentication.options.userName, authentication.options.password);
                  break;
                case "azure-active-directory-msi-vm":
                case "azure-active-directory-msi-app-service":
                  const msiArgs = authentication.options.clientId ? [authentication.options.clientId, {}] : [{}];
                  credentials = new _identity.ManagedIdentityCredential(...msiArgs);
                  break;
                case "azure-active-directory-default":
                  const args = authentication.options.clientId ? {
                    managedIdentityClientId: authentication.options.clientId
                  } : {};
                  credentials = new _identity.DefaultAzureCredential(args);
                  break;
                case "azure-active-directory-service-principal-secret":
                  credentials = new _identity.ClientSecretCredential(authentication.options.tenantId, authentication.options.clientId, authentication.options.clientSecret);
                  break;
              }
              let tokenResponse;
              try {
                tokenResponse = await credentials.getToken(tokenScope);
              } catch (err) {
                this.loginError = new AggregateError([new _errors.ConnectionError("Security token could not be authenticated or authorized.", "EFEDAUTH"), err]);
                this.emit("connect", this.loginError);
                this.transitionTo(this.STATE.FINAL);
                return;
              }
              if (tokenResponse === null) {
                this.loginError = new AggregateError([new _errors.ConnectionError("Security token could not be authenticated or authorized.", "EFEDAUTH")]);
                this.emit("connect", this.loginError);
                this.transitionTo(this.STATE.FINAL);
                return;
              }
              this.sendFedAuthTokenMessage(tokenResponse.token);
            } else if (this.loginError) {
              if (isTransientError(this.loginError)) {
                this.debug.log("Initiating retry on transient error");
                this.transitionTo(this.STATE.TRANSIENT_FAILURE_RETRY);
              } else {
                this.emit("connect", this.loginError);
                this.transitionTo(this.STATE.FINAL);
              }
            } else {
              this.emit("connect", new _errors.ConnectionError("Login failed.", "ELOGIN"));
              this.transitionTo(this.STATE.FINAL);
            }
          })().catch((err) => {
            process.nextTick(() => {
              throw err;
            });
          });
        },
        events: {
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      LOGGED_IN_SENDING_INITIAL_SQL: {
        name: "LoggedInSendingInitialSql",
        enter: function() {
          (async () => {
            this.sendInitialSql();
            let message;
            try {
              message = await this.messageIo.readMessage();
            } catch (err) {
              return this.socketError(err);
            }
            const tokenStreamParser = this.createTokenStreamParser(message, new _handler.InitialSqlTokenHandler(this));
            await (0, _events.once)(tokenStreamParser, "end");
            this.transitionTo(this.STATE.LOGGED_IN);
            this.processedInitialSql();
          })().catch((err) => {
            process.nextTick(() => {
              throw err;
            });
          });
        },
        events: {
          socketError: function socketError() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      LOGGED_IN: {
        name: "LoggedIn",
        events: {
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      SENT_CLIENT_REQUEST: {
        name: "SentClientRequest",
        enter: function() {
          (async () => {
            var _a3, _b2, _c2;
            let message;
            try {
              message = await this.messageIo.readMessage();
            } catch (err) {
              return this.socketError(err);
            }
            this.clearRequestTimer();
            const tokenStreamParser = this.createTokenStreamParser(message, new _handler.RequestTokenHandler(this, this.request));
            if (((_a3 = this.request) == null ? void 0 : _a3.canceled) && this.cancelTimer) {
              return this.transitionTo(this.STATE.SENT_ATTENTION);
            }
            const onResume = () => {
              tokenStreamParser.resume();
            };
            const onPause = () => {
              var _a4;
              tokenStreamParser.pause();
              (_a4 = this.request) == null ? void 0 : _a4.once("resume", onResume);
            };
            (_b2 = this.request) == null ? void 0 : _b2.on("pause", onPause);
            if (this.request instanceof _request.default && this.request.paused) {
              onPause();
            }
            const onCancel = () => {
              var _a4, _b3;
              tokenStreamParser.removeListener("end", onEndOfMessage);
              if (this.request instanceof _request.default && this.request.paused) {
                this.request.resume();
              }
              (_a4 = this.request) == null ? void 0 : _a4.removeListener("pause", onPause);
              (_b3 = this.request) == null ? void 0 : _b3.removeListener("resume", onResume);
              this.transitionTo(this.STATE.SENT_ATTENTION);
            };
            const onEndOfMessage = () => {
              var _a4, _b3, _c3, _d2;
              (_a4 = this.request) == null ? void 0 : _a4.removeListener("cancel", this._cancelAfterRequestSent);
              (_b3 = this.request) == null ? void 0 : _b3.removeListener("cancel", onCancel);
              (_c3 = this.request) == null ? void 0 : _c3.removeListener("pause", onPause);
              (_d2 = this.request) == null ? void 0 : _d2.removeListener("resume", onResume);
              this.transitionTo(this.STATE.LOGGED_IN);
              const sqlRequest = this.request;
              this.request = void 0;
              if (this.config.options.tdsVersion < "7_2" && sqlRequest.error && this.isSqlBatch) {
                this.inTransaction = false;
              }
              sqlRequest.callback(sqlRequest.error, sqlRequest.rowCount, sqlRequest.rows);
            };
            tokenStreamParser.once("end", onEndOfMessage);
            (_c2 = this.request) == null ? void 0 : _c2.once("cancel", onCancel);
          })();
        },
        exit: function(nextState) {
          this.clearRequestTimer();
        },
        events: {
          socketError: function(err) {
            const sqlRequest = this.request;
            this.request = void 0;
            this.transitionTo(this.STATE.FINAL);
            sqlRequest.callback(err);
          }
        }
      },
      SENT_ATTENTION: {
        name: "SentAttention",
        enter: function() {
          (async () => {
            let message;
            try {
              message = await this.messageIo.readMessage();
            } catch (err) {
              return this.socketError(err);
            }
            const handler = new _handler.AttentionTokenHandler(this, this.request);
            const tokenStreamParser = this.createTokenStreamParser(message, handler);
            await (0, _events.once)(tokenStreamParser, "end");
            if (handler.attentionReceived) {
              this.clearCancelTimer();
              const sqlRequest = this.request;
              this.request = void 0;
              this.transitionTo(this.STATE.LOGGED_IN);
              if (sqlRequest.error && sqlRequest.error instanceof _errors.RequestError && sqlRequest.error.code === "ETIMEOUT") {
                sqlRequest.callback(sqlRequest.error);
              } else {
                sqlRequest.callback(new _errors.RequestError("Canceled.", "ECANCEL"));
              }
            }
          })().catch((err) => {
            process.nextTick(() => {
              throw err;
            });
          });
        },
        events: {
          socketError: function(err) {
            const sqlRequest = this.request;
            this.request = void 0;
            this.transitionTo(this.STATE.FINAL);
            sqlRequest.callback(err);
          }
        }
      },
      FINAL: {
        name: "Final",
        enter: function() {
          this.cleanupConnection(CLEANUP_TYPE.NORMAL);
        },
        events: {
          connectTimeout: function() {
          },
          message: function() {
          },
          socketError: function() {
          }
        }
      }
    };
  }
});

// node_modules/tedious/lib/tedious.js
var require_tedious = __commonJS({
  "node_modules/tedious/lib/tedious.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "BulkLoad", {
      enumerable: true,
      get: function() {
        return _bulkLoad.default;
      }
    });
    Object.defineProperty(exports, "Connection", {
      enumerable: true,
      get: function() {
        return _connection.default;
      }
    });
    Object.defineProperty(exports, "ConnectionError", {
      enumerable: true,
      get: function() {
        return _errors.ConnectionError;
      }
    });
    Object.defineProperty(exports, "ISOLATION_LEVEL", {
      enumerable: true,
      get: function() {
        return _transaction.ISOLATION_LEVEL;
      }
    });
    Object.defineProperty(exports, "Request", {
      enumerable: true,
      get: function() {
        return _request.default;
      }
    });
    Object.defineProperty(exports, "RequestError", {
      enumerable: true,
      get: function() {
        return _errors.RequestError;
      }
    });
    Object.defineProperty(exports, "TDS_VERSION", {
      enumerable: true,
      get: function() {
        return _tdsVersions.versions;
      }
    });
    Object.defineProperty(exports, "TYPES", {
      enumerable: true,
      get: function() {
        return _dataType.TYPES;
      }
    });
    exports.connect = connect;
    exports.library = void 0;
    var _bulkLoad = _interopRequireDefault(require_bulk_load());
    var _connection = _interopRequireDefault(require_connection());
    var _request = _interopRequireDefault(require_request2());
    var _library = require_library();
    var _errors = require_errors();
    var _dataType = require_data_type();
    var _transaction = require_transaction2();
    var _tdsVersions = require_tds_versions();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var library = exports.library = {
      name: _library.name
    };
    function connect(config, connectListener) {
      const connection = new _connection.default(config);
      connection.connect(connectListener);
      return connection;
    }
  }
});

// node_modules/mssql/lib/tedious/connection-pool.js
var require_connection_pool2 = __commonJS({
  "node_modules/mssql/lib/tedious/connection-pool.js"(exports, module) {
    "use strict";
    var tds = require_tedious();
    var debug = require_browser()("mssql:tedi");
    var BaseConnectionPool = require_connection_pool();
    var { IDS } = require_utils2();
    var shared = require_shared();
    var ConnectionError = require_connection_error();
    var ConnectionPool = class extends BaseConnectionPool {
      _config() {
        const cfg = {
          server: this.config.server,
          options: Object.assign({
            encrypt: typeof this.config.encrypt === "boolean" ? this.config.encrypt : true,
            trustServerCertificate: typeof this.config.trustServerCertificate === "boolean" ? this.config.trustServerCertificate : false
          }, this.config.options),
          authentication: Object.assign({
            type: this.config.domain !== void 0 ? "ntlm" : this.config.authentication_type !== void 0 ? this.config.authentication_type : "default",
            options: Object.entries({
              userName: this.config.user,
              password: this.config.password,
              domain: this.config.domain,
              clientId: this.config.clientId,
              clientSecret: this.config.clientSecret,
              tenantId: this.config.tenantId,
              token: this.config.token,
              msiEndpoint: this.config.msiEndpoint,
              msiSecret: this.config.msiSecret
            }).reduce((acc, [key, val]) => {
              if (typeof val !== "undefined") {
                return { ...acc, [key]: val };
              }
              return acc;
            }, {})
          }, this.config.authentication)
        };
        cfg.options.database = cfg.options.database || this.config.database;
        cfg.options.port = cfg.options.port || this.config.port;
        cfg.options.connectTimeout = cfg.options.connectTimeout ?? this.config.connectionTimeout ?? this.config.timeout ?? 15e3;
        cfg.options.requestTimeout = cfg.options.requestTimeout ?? this.config.requestTimeout ?? this.config.timeout ?? 15e3;
        cfg.options.tdsVersion = cfg.options.tdsVersion || "7_4";
        cfg.options.rowCollectionOnDone = cfg.options.rowCollectionOnDone || false;
        cfg.options.rowCollectionOnRequestCompletion = cfg.options.rowCollectionOnRequestCompletion || false;
        cfg.options.useColumnNames = cfg.options.useColumnNames || false;
        cfg.options.appName = cfg.options.appName || "node-mssql";
        if (cfg.options.instanceName) delete cfg.options.port;
        if (isNaN(cfg.options.requestTimeout)) cfg.options.requestTimeout = 15e3;
        if (cfg.options.requestTimeout === Infinity || cfg.options.requestTimeout < 0) cfg.options.requestTimeout = 0;
        if (!cfg.options.debug && this.config.debug) {
          cfg.options.debug = {
            packet: true,
            token: true,
            data: true,
            payload: true
          };
        }
        return cfg;
      }
      _poolCreate() {
        return new shared.Promise((resolve, reject) => {
          const resolveOnce = (v) => {
            resolve(v);
            resolve = reject = () => {
            };
          };
          const rejectOnce = (e) => {
            reject(e);
            resolve = reject = () => {
            };
          };
          let tedious;
          try {
            tedious = new tds.Connection(this._config());
          } catch (err) {
            rejectOnce(err);
            return;
          }
          tedious.connect((err) => {
            if (err) {
              err = new ConnectionError(err);
              return rejectOnce(err);
            }
            debug("connection(%d): established", IDS.get(tedious));
            this.collation = tedious.databaseCollation;
            resolveOnce(tedious);
          });
          IDS.add(tedious, "Connection");
          debug("pool(%d): connection #%d created", IDS.get(this), IDS.get(tedious));
          debug("connection(%d): establishing", IDS.get(tedious));
          tedious.on("end", () => {
            const err = new ConnectionError("The connection ended without ever completing the connection");
            rejectOnce(err);
          });
          tedious.on("error", (err) => {
            if (err.code === "ESOCKET") {
              tedious.hasError = true;
            } else {
              this.emit("error", err);
            }
            rejectOnce(err);
          });
          if (this.config.debug) {
            tedious.on("debug", this.emit.bind(this, "debug", tedious));
          }
          if (typeof this.config.beforeConnect === "function") {
            this.config.beforeConnect(tedious);
          }
        });
      }
      _poolValidate(tedious) {
        if (tedious && !tedious.closed && !tedious.hasError) {
          return !this.config.validateConnection || new shared.Promise((resolve) => {
            const req = new tds.Request("SELECT 1;", (err) => {
              resolve(!err);
            });
            tedious.execSql(req);
          });
        }
        return false;
      }
      _poolDestroy(tedious) {
        return new shared.Promise((resolve, reject) => {
          if (!tedious) {
            resolve();
            return;
          }
          debug("connection(%d): destroying", IDS.get(tedious));
          if (tedious.closed) {
            debug("connection(%d): already closed", IDS.get(tedious));
            resolve();
          } else {
            tedious.once("end", () => {
              debug("connection(%d): destroyed", IDS.get(tedious));
              resolve();
            });
            tedious.close();
          }
        });
      }
    };
    module.exports = ConnectionPool;
  }
});

// node_modules/mssql/lib/tedious/transaction.js
var require_transaction3 = __commonJS({
  "node_modules/mssql/lib/tedious/transaction.js"(exports, module) {
    "use strict";
    var debug = require_browser()("mssql:tedi");
    var BaseTransaction = require_transaction();
    var { IDS } = require_utils2();
    var TransactionError = require_transaction_error();
    var Transaction = class extends BaseTransaction {
      constructor(parent) {
        super(parent);
        this._abort = () => {
          if (!this._rollbackRequested) {
            const pc = this._acquiredConnection;
            setImmediate(this.parent.release.bind(this.parent), pc);
            this._acquiredConnection.removeListener("rollbackTransaction", this._abort);
            this._acquiredConnection = null;
            this._acquiredConfig = null;
            this._aborted = true;
            this.emit("rollback", true);
          }
        };
      }
      _begin(isolationLevel, callback) {
        super._begin(isolationLevel, (err) => {
          if (err) return callback(err);
          debug("transaction(%d): begin", IDS.get(this));
          this.parent.acquire(this, (err2, connection, config) => {
            if (err2) return callback(err2);
            this._acquiredConnection = connection;
            this._acquiredConnection.on("rollbackTransaction", this._abort);
            this._acquiredConfig = config;
            connection.beginTransaction((err3) => {
              if (err3) err3 = new TransactionError(err3);
              debug("transaction(%d): begun", IDS.get(this));
              callback(err3);
            }, this.name, this.isolationLevel);
          });
        });
      }
      _commit(callback) {
        super._commit((err) => {
          if (err) return callback(err);
          debug("transaction(%d): commit", IDS.get(this));
          this._acquiredConnection.commitTransaction((err2) => {
            if (err2) err2 = new TransactionError(err2);
            this._acquiredConnection.removeListener("rollbackTransaction", this._abort);
            this.parent.release(this._acquiredConnection);
            this._acquiredConnection = null;
            this._acquiredConfig = null;
            if (!err2) debug("transaction(%d): commited", IDS.get(this));
            callback(err2);
          });
        });
      }
      _rollback(callback) {
        super._rollback((err) => {
          if (err) return callback(err);
          debug("transaction(%d): rollback", IDS.get(this));
          this._acquiredConnection.rollbackTransaction((err2) => {
            if (err2) err2 = new TransactionError(err2);
            this._acquiredConnection.removeListener("rollbackTransaction", this._abort);
            this.parent.release(this._acquiredConnection);
            this._acquiredConnection = null;
            this._acquiredConfig = null;
            if (!err2) debug("transaction(%d): rolled back", IDS.get(this));
            callback(err2);
          });
        });
      }
    };
    module.exports = Transaction;
  }
});

// node_modules/mssql/lib/udt.js
var require_udt2 = __commonJS({
  "node_modules/mssql/lib/udt.js"(exports, module) {
    "use strict";
    var Point = class {
      constructor() {
        this.x = 0;
        this.y = 0;
        this.z = null;
        this.m = null;
      }
    };
    var parsePoints = (buffer, count, isGeometryPoint) => {
      const points = [];
      if (count < 1) {
        return points;
      }
      if (isGeometryPoint) {
        for (let i = 1; i <= count; i++) {
          const point = new Point();
          points.push(point);
          point.x = buffer.readDoubleLE(buffer.position);
          point.y = buffer.readDoubleLE(buffer.position + 8);
          buffer.position += 16;
        }
      } else {
        for (let i = 1; i <= count; i++) {
          const point = new Point();
          points.push(point);
          point.lat = buffer.readDoubleLE(buffer.position);
          point.lng = buffer.readDoubleLE(buffer.position + 8);
          point.x = point.lat;
          point.y = point.lng;
          buffer.position += 16;
        }
      }
      return points;
    };
    var parseZ = (buffer, points) => {
      if (points < 1) {
        return;
      }
      points.forEach((point) => {
        point.z = buffer.readDoubleLE(buffer.position);
        buffer.position += 8;
      });
    };
    var parseM = (buffer, points) => {
      if (points < 1) {
        return;
      }
      points.forEach((point) => {
        point.m = buffer.readDoubleLE(buffer.position);
        buffer.position += 8;
      });
    };
    var parseFigures = (buffer, count, properties) => {
      const figures = [];
      if (count < 1) {
        return figures;
      }
      if (properties.P) {
        figures.push({
          attribute: 1,
          pointOffset: 0
        });
      } else if (properties.L) {
        figures.push({
          attribute: 1,
          pointOffset: 0
        });
      } else {
        for (let i = 1; i <= count; i++) {
          figures.push({
            attribute: buffer.readUInt8(buffer.position),
            pointOffset: buffer.readInt32LE(buffer.position + 1)
          });
          buffer.position += 5;
        }
      }
      return figures;
    };
    var parseShapes = (buffer, count, properties) => {
      const shapes = [];
      if (count < 1) {
        return shapes;
      }
      if (properties.P) {
        shapes.push({
          parentOffset: -1,
          figureOffset: 0,
          type: 1
        });
      } else if (properties.L) {
        shapes.push({
          parentOffset: -1,
          figureOffset: 0,
          type: 2
        });
      } else {
        for (let i = 1; i <= count; i++) {
          shapes.push({
            parentOffset: buffer.readInt32LE(buffer.position),
            figureOffset: buffer.readInt32LE(buffer.position + 4),
            type: buffer.readUInt8(buffer.position + 8)
          });
          buffer.position += 9;
        }
      }
      return shapes;
    };
    var parseSegments = (buffer, count) => {
      const segments = [];
      if (count < 1) {
        return segments;
      }
      for (let i = 1; i <= count; i++) {
        segments.push({ type: buffer.readUInt8(buffer.position) });
        buffer.position++;
      }
      return segments;
    };
    var parseGeography = (buffer, isUsingGeometryPoints) => {
      const srid = buffer.readInt32LE(0);
      if (srid === -1) {
        return null;
      }
      const value = {
        srid,
        version: buffer.readUInt8(4)
      };
      const flags = buffer.readUInt8(5);
      buffer.position = 6;
      const properties = {
        Z: (flags & 1 << 0) > 0,
        M: (flags & 1 << 1) > 0,
        V: (flags & 1 << 2) > 0,
        P: (flags & 1 << 3) > 0,
        L: (flags & 1 << 4) > 0
      };
      if (value.version === 2) {
        properties.H = (flags & 1 << 3) > 0;
      }
      let numberOfPoints;
      if (properties.P) {
        numberOfPoints = 1;
      } else if (properties.L) {
        numberOfPoints = 2;
      } else {
        numberOfPoints = buffer.readUInt32LE(buffer.position);
        buffer.position += 4;
      }
      value.points = parsePoints(buffer, numberOfPoints, isUsingGeometryPoints);
      if (properties.Z) {
        parseZ(buffer, value.points);
      }
      if (properties.M) {
        parseM(buffer, value.points);
      }
      let numberOfFigures;
      if (properties.P) {
        numberOfFigures = 1;
      } else if (properties.L) {
        numberOfFigures = 1;
      } else {
        numberOfFigures = buffer.readUInt32LE(buffer.position);
        buffer.position += 4;
      }
      value.figures = parseFigures(buffer, numberOfFigures, properties);
      let numberOfShapes;
      if (properties.P) {
        numberOfShapes = 1;
      } else if (properties.L) {
        numberOfShapes = 1;
      } else {
        numberOfShapes = buffer.readUInt32LE(buffer.position);
        buffer.position += 4;
      }
      value.shapes = parseShapes(buffer, numberOfShapes, properties);
      if (value.version === 2 && buffer.position < buffer.length) {
        const numberOfSegments = buffer.readUInt32LE(buffer.position);
        buffer.position += 4;
        value.segments = parseSegments(buffer, numberOfSegments);
      } else {
        value.segments = [];
      }
      return value;
    };
    module.exports.PARSERS = {
      geography(buffer) {
        return parseGeography(
          buffer,
          /* isUsingGeometryPoints: */
          false
        );
      },
      geometry(buffer) {
        return parseGeography(
          buffer,
          /* isUsingGeometryPoints: */
          true
        );
      }
    };
  }
});

// node_modules/mssql/lib/tedious/request.js
var require_request3 = __commonJS({
  "node_modules/mssql/lib/tedious/request.js"(exports, module) {
    "use strict";
    var tds = require_tedious();
    var debug = require_browser()("mssql:tedi");
    var BaseRequest = require_request();
    var RequestError = require_request_error();
    var { IDS, objectHasProperty: objectHasProperty2 } = require_utils2();
    var { TYPES, DECLARATIONS, declare, cast } = require_datatypes();
    var Table = require_table();
    var { PARSERS: UDT } = require_udt2();
    var { valueHandler } = require_shared();
    var JSON_COLUMN_ID = "JSON_F52E2B61-18A1-11d1-B105-00805F49916B";
    var XML_COLUMN_ID = "XML_F52E2B61-18A1-11d1-B105-00805F49916B";
    var N_TYPES = {
      BitN: 104,
      DateTimeN: 111,
      DecimalN: 106,
      FloatN: 109,
      IntN: 38,
      MoneyN: 110,
      NumericN: 108
    };
    var getTediousType = function(type) {
      switch (type) {
        case TYPES.VarChar:
          return tds.TYPES.VarChar;
        case TYPES.NVarChar:
          return tds.TYPES.NVarChar;
        case TYPES.Text:
          return tds.TYPES.Text;
        case TYPES.Int:
          return tds.TYPES.Int;
        case TYPES.BigInt:
          return tds.TYPES.BigInt;
        case TYPES.TinyInt:
          return tds.TYPES.TinyInt;
        case TYPES.SmallInt:
          return tds.TYPES.SmallInt;
        case TYPES.Bit:
          return tds.TYPES.Bit;
        case TYPES.Float:
          return tds.TYPES.Float;
        case TYPES.Decimal:
          return tds.TYPES.Decimal;
        case TYPES.Numeric:
          return tds.TYPES.Numeric;
        case TYPES.Real:
          return tds.TYPES.Real;
        case TYPES.Money:
          return tds.TYPES.Money;
        case TYPES.SmallMoney:
          return tds.TYPES.SmallMoney;
        case TYPES.Time:
          return tds.TYPES.Time;
        case TYPES.Date:
          return tds.TYPES.Date;
        case TYPES.DateTime:
          return tds.TYPES.DateTime;
        case TYPES.DateTime2:
          return tds.TYPES.DateTime2;
        case TYPES.DateTimeOffset:
          return tds.TYPES.DateTimeOffset;
        case TYPES.SmallDateTime:
          return tds.TYPES.SmallDateTime;
        case TYPES.UniqueIdentifier:
          return tds.TYPES.UniqueIdentifier;
        case TYPES.Xml:
          return tds.TYPES.NVarChar;
        case TYPES.Char:
          return tds.TYPES.Char;
        case TYPES.NChar:
          return tds.TYPES.NChar;
        case TYPES.NText:
          return tds.TYPES.NVarChar;
        case TYPES.Image:
          return tds.TYPES.Image;
        case TYPES.Binary:
          return tds.TYPES.Binary;
        case TYPES.VarBinary:
          return tds.TYPES.VarBinary;
        case TYPES.UDT:
        case TYPES.Geography:
        case TYPES.Geometry:
          return tds.TYPES.UDT;
        case TYPES.TVP:
          return tds.TYPES.TVP;
        case TYPES.Variant:
          return tds.TYPES.Variant;
        default:
          return type;
      }
    };
    var getMssqlType = function(type, length) {
      if (typeof type !== "object") return void 0;
      switch (type) {
        case tds.TYPES.Char:
          return TYPES.Char;
        case tds.TYPES.NChar:
          return TYPES.NChar;
        case tds.TYPES.VarChar:
          return TYPES.VarChar;
        case tds.TYPES.NVarChar:
          return TYPES.NVarChar;
        case tds.TYPES.Text:
          return TYPES.Text;
        case tds.TYPES.NText:
          return TYPES.NText;
        case tds.TYPES.Int:
          return TYPES.Int;
        case tds.TYPES.BigInt:
          return TYPES.BigInt;
        case tds.TYPES.TinyInt:
          return TYPES.TinyInt;
        case tds.TYPES.SmallInt:
          return TYPES.SmallInt;
        case tds.TYPES.Bit:
          return TYPES.Bit;
        case tds.TYPES.Float:
          return TYPES.Float;
        case tds.TYPES.Real:
          return TYPES.Real;
        case tds.TYPES.Money:
          return TYPES.Money;
        case tds.TYPES.SmallMoney:
          return TYPES.SmallMoney;
        case tds.TYPES.Numeric:
          return TYPES.Numeric;
        case tds.TYPES.Decimal:
          return TYPES.Decimal;
        case tds.TYPES.DateTime:
          return TYPES.DateTime;
        case tds.TYPES.Time:
          return TYPES.Time;
        case tds.TYPES.Date:
          return TYPES.Date;
        case tds.TYPES.DateTime2:
          return TYPES.DateTime2;
        case tds.TYPES.DateTimeOffset:
          return TYPES.DateTimeOffset;
        case tds.TYPES.SmallDateTime:
          return TYPES.SmallDateTime;
        case tds.TYPES.UniqueIdentifier:
          return TYPES.UniqueIdentifier;
        case tds.TYPES.Image:
          return TYPES.Image;
        case tds.TYPES.Binary:
          return TYPES.Binary;
        case tds.TYPES.VarBinary:
          return TYPES.VarBinary;
        case tds.TYPES.Xml:
          return TYPES.Xml;
        case tds.TYPES.UDT:
          return TYPES.UDT;
        case tds.TYPES.TVP:
          return TYPES.TVP;
        case tds.TYPES.Variant:
          return TYPES.Variant;
        default:
          switch (type.id) {
            case N_TYPES.BitN:
              return TYPES.Bit;
            case N_TYPES.NumericN:
              return TYPES.Numeric;
            case N_TYPES.DecimalN:
              return TYPES.Decimal;
            case N_TYPES.IntN:
              if (length === 8) return TYPES.BigInt;
              if (length === 4) return TYPES.Int;
              if (length === 2) return TYPES.SmallInt;
              return TYPES.TinyInt;
            case N_TYPES.FloatN:
              if (length === 8) return TYPES.Float;
              return TYPES.Real;
            case N_TYPES.MoneyN:
              if (length === 8) return TYPES.Money;
              return TYPES.SmallMoney;
            case N_TYPES.DateTimeN:
              if (length === 8) return TYPES.DateTime;
              return TYPES.SmallDateTime;
          }
      }
    };
    var createColumns = function(metadata, arrayRowMode) {
      let out = {};
      if (arrayRowMode) out = [];
      for (let index = 0, length = metadata.length; index < length; index++) {
        const column = metadata[index];
        const outColumn = {
          index,
          name: column.colName,
          length: column.dataLength,
          type: getMssqlType(column.type, column.dataLength),
          scale: column.scale,
          precision: column.precision,
          nullable: !!(column.flags & 1),
          caseSensitive: !!(column.flags & 2),
          identity: !!(column.flags & 16),
          readOnly: !(column.flags & 12)
        };
        if (column.udtInfo) {
          outColumn.udt = {
            name: column.udtInfo.typeName,
            database: column.udtInfo.dbname,
            schema: column.udtInfo.owningSchema,
            assembly: column.udtInfo.assemblyName
          };
          if (DECLARATIONS[column.udtInfo.typeName]) {
            outColumn.type = DECLARATIONS[column.udtInfo.typeName];
          }
        }
        if (arrayRowMode) {
          out.push(outColumn);
        } else {
          out[column.colName] = outColumn;
        }
      }
      return out;
    };
    var valueCorrection = function(value, metadata) {
      const type = getMssqlType(metadata.type);
      if (valueHandler.has(type)) {
        return valueHandler.get(type)(value);
      } else if (metadata.type === tds.TYPES.UDT && value != null) {
        if (UDT[metadata.udtInfo.typeName]) {
          return UDT[metadata.udtInfo.typeName](value);
        } else {
          return value;
        }
      } else {
        return value;
      }
    };
    var parameterCorrection = function(value) {
      if (value instanceof Table) {
        const tvp = {
          name: value.name,
          schema: value.schema,
          columns: [],
          rows: value.rows
        };
        for (const col of value.columns) {
          tvp.columns.push({
            name: col.name,
            type: getTediousType(col.type),
            length: col.length,
            scale: col.scale,
            precision: col.precision
          });
        }
        return tvp;
      } else {
        return value;
      }
    };
    var Request2 = class extends BaseRequest {
      /*
      Execute specified sql batch.
      */
      _batch(batch, callback) {
        this._isBatch = true;
        this._query(batch, callback);
      }
      /*
      Bulk load.
      */
      _bulk(table, options, callback) {
        super._bulk(table, options, (err) => {
          if (err) return callback(err);
          try {
            table._makeBulk();
          } catch (e) {
            return callback(new RequestError(e, "EREQUEST"));
          }
          if (!table.name) {
            return callback(new RequestError("Table name must be specified for bulk insert.", "ENAME"));
          }
          if (table.name.charAt(0) === "@") {
            return callback(new RequestError("You can't use table variables for bulk insert.", "ENAME"));
          }
          const errors = [];
          const errorHandlers = {};
          let hasReturned = false;
          const handleError = (doReturn, connection, info) => {
            let err2 = new Error(info.message);
            err2.info = info;
            err2 = new RequestError(err2, "EREQUEST");
            if (this.stream) {
              this.emit("error", err2);
            } else {
              if (doReturn && !hasReturned) {
                if (connection) {
                  for (const event in errorHandlers) {
                    connection.removeListener(event, errorHandlers[event]);
                  }
                  this.parent.release(connection);
                }
                hasReturned = true;
                callback(err2);
              }
            }
            errors.push(err2);
          };
          const handleInfo = (msg) => {
            this.emit("info", {
              message: msg.message,
              number: msg.number,
              state: msg.state,
              class: msg.class,
              lineNumber: msg.lineNumber,
              serverName: msg.serverName,
              procName: msg.procName
            });
          };
          this.parent.acquire(this, (err2, connection) => {
            const callbackWithRelease = (err3, ...args) => {
              try {
                this.parent.release(connection);
              } catch (e) {
              }
              callback(err3, ...args);
            };
            if (err2) return callbackWithRelease(err2);
            debug("connection(%d): borrowed to request #%d", IDS.get(connection), IDS.get(this));
            if (this.canceled) {
              debug("request(%d): canceled", IDS.get(this));
              return callbackWithRelease(new RequestError("Canceled.", "ECANCEL"));
            }
            this._cancel = () => {
              debug("request(%d): cancel", IDS.get(this));
              connection.cancel();
            };
            connection.on("infoMessage", errorHandlers.infoMessage = handleInfo);
            connection.on("errorMessage", errorHandlers.errorMessage = handleError.bind(null, false, connection));
            connection.on("error", errorHandlers.error = handleError.bind(null, true, connection));
            const done = (err3, rowCount) => {
              if (err3 && (!errors.length || errors.length && err3.message !== errors[errors.length - 1].message)) {
                err3 = new RequestError(err3, "EREQUEST");
                if (this.stream) this.emit("error", err3);
                errors.push(err3);
              }
              delete this._cancel;
              let error;
              if (errors.length && !this.stream) {
                error = errors.pop();
                error.precedingErrors = errors;
              }
              if (!hasReturned) {
                for (const event in errorHandlers) {
                  connection.removeListener(event, errorHandlers[event]);
                }
                hasReturned = true;
                if (this.stream) {
                  callbackWithRelease(null, rowCount);
                } else {
                  callbackWithRelease(error, rowCount);
                }
              }
            };
            const bulk = connection.newBulkLoad(table.path, options, done);
            for (const col of table.columns) {
              bulk.addColumn(col.name, getTediousType(col.type), { nullable: col.nullable, length: col.length, scale: col.scale, precision: col.precision });
            }
            if (table.create) {
              const objectid = table.temporary ? `tempdb..[${table.name}]` : table.path;
              const req = new tds.Request(`if object_id('${objectid.replace(/'/g, "''")}') is null ${table.declare()}`, (err3) => {
                if (err3) return done(err3);
                connection.execBulkLoad(bulk, table.rows);
              });
              this._setCurrentRequest(req);
              connection.execSqlBatch(req);
            } else {
              connection.execBulkLoad(bulk, table.rows);
            }
          });
        });
      }
      /*
      Execute specified sql command.
      */
      _query(command, callback) {
        super._query(command, (err) => {
          if (err) return callback(err);
          const recordsets = [];
          const recordsetcolumns = [];
          const errors = [];
          const errorHandlers = {};
          const output = {};
          const rowsAffected = [];
          let columns = {};
          let recordset = [];
          let batchLastRow = null;
          let batchHasOutput = false;
          let isChunkedRecordset = false;
          let chunksBuffer = null;
          let hasReturned = false;
          const handleError = (doReturn, connection, info) => {
            let err2 = new Error(info.message);
            err2.info = info;
            err2 = new RequestError(err2, "EREQUEST");
            if (this.stream) {
              this.emit("error", err2);
            } else {
              if (doReturn && !hasReturned) {
                if (connection) {
                  for (const event in errorHandlers) {
                    connection.removeListener(event, errorHandlers[event]);
                  }
                  this.parent.release(connection);
                }
                hasReturned = true;
                callback(err2);
              }
            }
            errors.push(err2);
          };
          const handleInfo = (msg) => {
            this.emit("info", {
              message: msg.message,
              number: msg.number,
              state: msg.state,
              class: msg.class,
              lineNumber: msg.lineNumber,
              serverName: msg.serverName,
              procName: msg.procName
            });
          };
          this.parent.acquire(this, (err2, connection, config) => {
            if (err2) return callback(err2);
            debug("connection(%d): borrowed to request #%d", IDS.get(connection), IDS.get(this));
            let row;
            if (this.canceled) {
              debug("request(%d): canceled", IDS.get(this));
              this.parent.release(connection);
              return callback(new RequestError("Canceled.", "ECANCEL"));
            }
            this._cancel = () => {
              debug("request(%d): cancel", IDS.get(this));
              connection.cancel();
            };
            connection.on("infoMessage", errorHandlers.infoMessage = handleInfo);
            connection.on("errorMessage", errorHandlers.errorMessage = handleError.bind(null, false, connection));
            connection.on("error", errorHandlers.error = handleError.bind(null, true, connection));
            debug("request(%d): query", IDS.get(this), command);
            const req = new tds.Request(command, (err3) => {
              ((err3 == null ? void 0 : err3.errors) ? err3.errors : [err3]).forEach((e, i, { length }) => {
                if (e && (!errors.length || errors.length && errors.length >= length && e.message !== errors[errors.length - length + i].message)) {
                  e = new RequestError(e, "EREQUEST");
                  if (this.stream) this.emit("error", e);
                  errors.push(e);
                }
              });
              if (batchHasOutput) {
                if (!this.stream) batchLastRow = recordsets.pop()[0];
                for (const name3 in batchLastRow) {
                  const value = batchLastRow[name3];
                  if (name3 !== "___return___") {
                    output[name3] = value;
                  }
                }
              }
              delete this._cancel;
              let error;
              if (errors.length && !this.stream) {
                error = errors.pop();
                error.precedingErrors = errors;
              }
              if (!hasReturned) {
                for (const event in errorHandlers) {
                  connection.removeListener(event, errorHandlers[event]);
                }
                this.parent.release(connection);
                hasReturned = true;
                if (error) {
                  debug("request(%d): failed", IDS.get(this), error);
                } else {
                  debug("request(%d): completed", IDS.get(this));
                }
                if (this.stream) {
                  callback(null, null, output, rowsAffected, recordsetcolumns);
                } else {
                  callback(error, recordsets, output, rowsAffected, recordsetcolumns);
                }
              }
            });
            this._setCurrentRequest(req);
            req.on("columnMetadata", (metadata) => {
              columns = createColumns(metadata, this.arrayRowMode);
              isChunkedRecordset = false;
              if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {
                isChunkedRecordset = true;
                chunksBuffer = [];
              }
              if (this.stream) {
                if (this._isBatch) {
                  if (!columns.___return___) {
                    this.emit("recordset", columns);
                  }
                } else {
                  this.emit("recordset", columns);
                }
              }
              if (this.arrayRowMode) recordsetcolumns.push(columns);
            });
            const doneHandler = (rowCount, more) => {
              if (rowCount != null) {
                rowsAffected.push(rowCount);
                if (this.stream) {
                  this.emit("rowsaffected", rowCount);
                }
              }
              if (Object.keys(columns).length === 0) return;
              if (isChunkedRecordset) {
                const concatenatedChunks = chunksBuffer.join("");
                if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {
                  try {
                    if (concatenatedChunks === "") {
                      row = null;
                    } else {
                      row = JSON.parse(concatenatedChunks);
                    }
                  } catch (ex) {
                    row = null;
                    const ex2 = new RequestError(new Error(`Failed to parse incoming JSON. ${ex.message}`), "EJSON");
                    if (this.stream) this.emit("error", ex2);
                    errors.push(ex2);
                  }
                } else {
                  row = {};
                  row[Object.keys(columns)[0]] = concatenatedChunks;
                }
                chunksBuffer = null;
                if (this.stream) {
                  this.emit("row", row);
                } else {
                  recordset.push(row);
                }
              }
              if (!this.stream) {
                Object.defineProperty(recordset, "columns", {
                  enumerable: false,
                  configurable: true,
                  value: columns
                });
                Object.defineProperty(recordset, "toTable", {
                  enumerable: false,
                  configurable: true,
                  value(name3) {
                    return Table.fromRecordset(this, name3);
                  }
                });
                recordsets.push(recordset);
              }
              recordset = [];
              columns = {};
            };
            req.on("doneInProc", doneHandler);
            req.on("done", doneHandler);
            req.on("returnValue", (parameterName, value, metadata) => {
              output[parameterName] = value;
            });
            req.on("row", (columns2) => {
              if (!recordset) recordset = [];
              if (isChunkedRecordset) {
                return chunksBuffer.push(columns2[0].value);
              }
              if (this.arrayRowMode) {
                row = [];
              } else {
                row = {};
              }
              for (const col of columns2) {
                col.value = valueCorrection(col.value, col.metadata);
                if (this.arrayRowMode) {
                  row.push(col.value);
                } else {
                  const exi = row[col.metadata.colName];
                  if (exi !== void 0) {
                    if (exi instanceof Array) {
                      exi.push(col.value);
                    } else {
                      row[col.metadata.colName] = [exi, col.value];
                    }
                  } else {
                    row[col.metadata.colName] = col.value;
                  }
                }
              }
              if (this.stream) {
                if (this._isBatch) {
                  if (row.___return___) {
                    batchLastRow = row;
                  } else {
                    this.emit("row", row);
                  }
                } else {
                  this.emit("row", row);
                }
              } else {
                recordset.push(row);
              }
            });
            if (this._isBatch) {
              if (Object.keys(this.parameters).length) {
                for (const name3 in this.parameters) {
                  if (!objectHasProperty2(this.parameters, name3)) {
                    continue;
                  }
                  const param = this.parameters[name3];
                  try {
                    param.value = getTediousType(param.type).validate(param.value, this.parent.collation);
                  } catch (e) {
                    e.message = `Validation failed for parameter '${name3}'. ${e.message}`;
                    const err3 = new RequestError(e, "EPARAM");
                    this.parent.release(connection);
                    return callback(err3);
                  }
                }
                const declarations = [];
                for (const name3 in this.parameters) {
                  if (!objectHasProperty2(this.parameters, name3)) {
                    continue;
                  }
                  const param = this.parameters[name3];
                  declarations.push(`@${name3} ${declare(param.type, param)}`);
                }
                const assigns = [];
                for (const name3 in this.parameters) {
                  if (!objectHasProperty2(this.parameters, name3)) {
                    continue;
                  }
                  const param = this.parameters[name3];
                  assigns.push(`@${name3} = ${cast(param.value, param.type, param)}`);
                }
                const selects = [];
                for (const name3 in this.parameters) {
                  if (!objectHasProperty2(this.parameters, name3)) {
                    continue;
                  }
                  const param = this.parameters[name3];
                  if (param.io === 2) {
                    selects.push(`@${name3} as [${name3}]`);
                  }
                }
                batchHasOutput = selects.length > 0;
                req.sqlTextOrProcedure = `declare ${declarations.join(", ")};select ${assigns.join(", ")};${req.sqlTextOrProcedure};${batchHasOutput ? `select 1 as [___return___], ${selects.join(", ")}` : ""}`;
              }
            } else {
              for (const name3 in this.parameters) {
                if (!objectHasProperty2(this.parameters, name3)) {
                  continue;
                }
                const param = this.parameters[name3];
                if (param.io === 1) {
                  req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision });
                } else {
                  req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision });
                }
              }
            }
            try {
              connection[this._isBatch ? "execSqlBatch" : "execSql"](req);
            } catch (error) {
              handleError(true, connection, error);
            }
          });
        });
      }
      /*
      Execute stored procedure with specified parameters.
      */
      _execute(procedure, callback) {
        super._execute(procedure, (err) => {
          if (err) return callback(err);
          const recordsets = [];
          const recordsetcolumns = [];
          const errors = [];
          const errorHandlers = {};
          const output = {};
          const rowsAffected = [];
          let columns = {};
          let recordset = [];
          let returnValue = 0;
          let isChunkedRecordset = false;
          let chunksBuffer = null;
          let hasReturned = false;
          const handleError = (doReturn, connection, info) => {
            let err2 = new Error(info.message);
            err2.info = info;
            err2 = new RequestError(err2, "EREQUEST");
            if (this.stream) {
              this.emit("error", err2);
            } else {
              if (doReturn && !hasReturned) {
                if (connection) {
                  for (const event in errorHandlers) {
                    connection.removeListener(event, errorHandlers[event]);
                  }
                  this.parent.release(connection);
                }
                hasReturned = true;
                callback(err2);
              }
            }
            errors.push(err2);
          };
          const handleInfo = (msg) => {
            this.emit("info", {
              message: msg.message,
              number: msg.number,
              state: msg.state,
              class: msg.class,
              lineNumber: msg.lineNumber,
              serverName: msg.serverName,
              procName: msg.procName
            });
          };
          this.parent.acquire(this, (err2, connection, config) => {
            if (err2) return callback(err2);
            debug("connection(%d): borrowed to request #%d", IDS.get(connection), IDS.get(this));
            let row;
            if (this.canceled) {
              debug("request(%d): canceled", IDS.get(this));
              this.parent.release(connection);
              return callback(new RequestError("Canceled.", "ECANCEL"));
            }
            this._cancel = () => {
              debug("request(%d): cancel", IDS.get(this));
              connection.cancel();
            };
            connection.on("infoMessage", errorHandlers.infoMessage = handleInfo);
            connection.on("errorMessage", errorHandlers.errorMessage = handleError.bind(null, false, connection));
            connection.on("error", errorHandlers.error = handleError.bind(null, true, connection));
            if (debug.enabled) {
              const params = Object.keys(this.parameters).map((k) => this.parameters[k]);
              const logValue = (s) => typeof s === "string" && s.length > 50 ? s.substring(0, 47) + "..." : s;
              const logName = (param) => param.name + " [sql." + param.type.name + "]";
              const logParams = {};
              params.forEach((p) => {
                logParams[logName(p)] = logValue(p.value);
              });
              debug("request(%d): execute %s %O", IDS.get(this), procedure, logParams);
            }
            const req = new tds.Request(procedure, (err3) => {
              if (err3 && (!errors.length || errors.length && err3.message !== errors[errors.length - 1].message)) {
                err3 = new RequestError(err3, "EREQUEST");
                if (this.stream) this.emit("error", err3);
                errors.push(err3);
              }
              delete this._cancel;
              let error;
              if (errors.length && !this.stream) {
                error = errors.pop();
                error.precedingErrors = errors;
              }
              if (!hasReturned) {
                for (const event in errorHandlers) {
                  connection.removeListener(event, errorHandlers[event]);
                }
                this.parent.release(connection);
                hasReturned = true;
                if (error) {
                  debug("request(%d): failed", IDS.get(this), error);
                } else {
                  debug("request(%d): complete", IDS.get(this));
                }
                if (this.stream) {
                  callback(null, null, output, returnValue, rowsAffected, recordsetcolumns);
                } else {
                  callback(error, recordsets, output, returnValue, rowsAffected, recordsetcolumns);
                }
              }
            });
            this._setCurrentRequest(req);
            req.on("columnMetadata", (metadata) => {
              columns = createColumns(metadata, this.arrayRowMode);
              isChunkedRecordset = false;
              if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {
                isChunkedRecordset = true;
                chunksBuffer = [];
              }
              if (this.stream) this.emit("recordset", columns);
              if (this.arrayRowMode) recordsetcolumns.push(columns);
            });
            req.on("row", (columns2) => {
              if (!recordset) recordset = [];
              if (isChunkedRecordset) {
                return chunksBuffer.push(columns2[0].value);
              }
              if (this.arrayRowMode) {
                row = [];
              } else {
                row = {};
              }
              for (const col of columns2) {
                col.value = valueCorrection(col.value, col.metadata);
                if (this.arrayRowMode) {
                  row.push(col.value);
                } else {
                  const exi = row[col.metadata.colName];
                  if (exi != null) {
                    if (exi instanceof Array) {
                      exi.push(col.value);
                    } else {
                      row[col.metadata.colName] = [exi, col.value];
                    }
                  } else {
                    row[col.metadata.colName] = col.value;
                  }
                }
              }
              if (this.stream) {
                this.emit("row", row);
              } else {
                recordset.push(row);
              }
            });
            req.on("doneInProc", (rowCount, more) => {
              if (rowCount != null) {
                rowsAffected.push(rowCount);
                if (this.stream) {
                  this.emit("rowsaffected", rowCount);
                }
              }
              if (Object.keys(columns).length === 0) return;
              if (isChunkedRecordset) {
                if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {
                  try {
                    if (chunksBuffer.length === 0) {
                      row = null;
                    } else {
                      row = JSON.parse(chunksBuffer.join(""));
                    }
                  } catch (ex) {
                    row = null;
                    const ex2 = new RequestError(new Error(`Failed to parse incoming JSON. ${ex.message}`), "EJSON");
                    if (this.stream) this.emit("error", ex2);
                    errors.push(ex2);
                  }
                } else {
                  row = {};
                  row[Object.keys(columns)[0]] = chunksBuffer.join("");
                }
                chunksBuffer = null;
                if (this.stream) {
                  this.emit("row", row);
                } else {
                  recordset.push(row);
                }
              }
              if (!this.stream) {
                Object.defineProperty(recordset, "columns", {
                  enumerable: false,
                  configurable: true,
                  value: columns
                });
                Object.defineProperty(recordset, "toTable", {
                  enumerable: false,
                  configurable: true,
                  value(name3) {
                    return Table.fromRecordset(this, name3);
                  }
                });
                recordsets.push(recordset);
              }
              recordset = [];
              columns = {};
            });
            req.on("doneProc", (rowCount, more, returnStatus) => {
              returnValue = returnStatus;
            });
            req.on("returnValue", (parameterName, value, metadata) => {
              output[parameterName] = value;
            });
            for (const name3 in this.parameters) {
              if (!objectHasProperty2(this.parameters, name3)) {
                continue;
              }
              const param = this.parameters[name3];
              if (param.io === 1) {
                req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision });
              } else {
                req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision });
              }
            }
            connection.callProcedure(req);
          });
        });
      }
      _pause() {
        super._pause();
        if (this._currentRequest) {
          this._currentRequest.pause();
        }
      }
      _resume() {
        super._resume();
        if (this._currentRequest) {
          this._currentRequest.resume();
        }
      }
    };
    module.exports = Request2;
  }
});

// node_modules/mssql/lib/tedious/index.js
var require_tedious2 = __commonJS({
  "node_modules/mssql/lib/tedious/index.js"(exports, module) {
    "use strict";
    var base = require_base();
    var ConnectionPool = require_connection_pool2();
    var Transaction = require_transaction3();
    var Request2 = require_request3();
    module.exports = Object.assign({
      ConnectionPool,
      Transaction,
      Request: Request2,
      PreparedStatement: base.PreparedStatement
    }, base.exports);
    Object.defineProperty(module.exports, "Promise", {
      enumerable: true,
      get: () => {
        return base.Promise;
      },
      set: (value) => {
        base.Promise = value;
      }
    });
    Object.defineProperty(module.exports, "valueHandler", {
      enumerable: true,
      value: base.valueHandler,
      writable: false,
      configurable: false
    });
    base.driver.name = "tedious";
    base.driver.ConnectionPool = ConnectionPool;
    base.driver.Transaction = Transaction;
    base.driver.Request = Request2;
  }
});

// node_modules/mssql/index.js
var require_mssql = __commonJS({
  "node_modules/mssql/index.js"(exports, module) {
    module.exports = require_tedious2();
  }
});
export default require_mssql();
/*! Bundled license information:

@azure/msal-common/dist/utils/Constants.mjs:
@azure/msal-common/dist/error/AuthErrorCodes.mjs:
@azure/msal-common/dist/error/AuthError.mjs:
@azure/msal-common/dist/error/ClientAuthErrorCodes.mjs:
@azure/msal-common/dist/error/ClientAuthError.mjs:
@azure/msal-common/dist/crypto/ICrypto.mjs:
@azure/msal-common/dist/logger/Logger.mjs:
@azure/msal-common/dist/packageMetadata.mjs:
@azure/msal-common/dist/authority/AuthorityOptions.mjs:
@azure/msal-common/dist/account/AuthToken.mjs:
@azure/msal-common/dist/utils/TimeUtils.mjs:
@azure/msal-common/dist/cache/utils/CacheHelpers.mjs:
@azure/msal-common/dist/error/ClientConfigurationErrorCodes.mjs:
@azure/msal-common/dist/error/ClientConfigurationError.mjs:
@azure/msal-common/dist/utils/StringUtils.mjs:
@azure/msal-common/dist/request/ScopeSet.mjs:
@azure/msal-common/dist/account/ClientInfo.mjs:
@azure/msal-common/dist/account/AccountInfo.mjs:
@azure/msal-common/dist/authority/AuthorityType.mjs:
@azure/msal-common/dist/account/TokenClaims.mjs:
@azure/msal-common/dist/authority/ProtocolMode.mjs:
@azure/msal-common/dist/cache/entities/AccountEntity.mjs:
@azure/msal-common/dist/utils/UrlUtils.mjs:
@azure/msal-common/dist/url/UrlString.mjs:
@azure/msal-common/dist/authority/AuthorityMetadata.mjs:
@azure/msal-common/dist/error/CacheErrorCodes.mjs:
@azure/msal-common/dist/error/CacheError.mjs:
@azure/msal-common/dist/cache/CacheManager.mjs:
@azure/msal-common/dist/telemetry/performance/PerformanceEvent.mjs:
@azure/msal-common/dist/telemetry/performance/StubPerformanceClient.mjs:
@azure/msal-common/dist/config/ClientConfiguration.mjs:
@azure/msal-common/dist/account/CcsCredential.mjs:
@azure/msal-common/dist/constants/AADServerParamKeys.mjs:
@azure/msal-common/dist/request/RequestParameterBuilder.mjs:
@azure/msal-common/dist/authority/OpenIdConfigResponse.mjs:
@azure/msal-common/dist/authority/CloudInstanceDiscoveryResponse.mjs:
@azure/msal-common/dist/authority/CloudInstanceDiscoveryErrorResponse.mjs:
@azure/msal-common/dist/utils/FunctionWrappers.mjs:
@azure/msal-common/dist/authority/RegionDiscovery.mjs:
@azure/msal-common/dist/authority/Authority.mjs:
@azure/msal-common/dist/authority/AuthorityFactory.mjs:
@azure/msal-common/dist/error/ServerError.mjs:
@azure/msal-common/dist/network/RequestThumbprint.mjs:
@azure/msal-common/dist/network/ThrottlingUtils.mjs:
@azure/msal-common/dist/error/NetworkError.mjs:
@azure/msal-common/dist/client/BaseClient.mjs:
@azure/msal-common/dist/error/InteractionRequiredAuthErrorCodes.mjs:
@azure/msal-common/dist/error/InteractionRequiredAuthError.mjs:
@azure/msal-common/dist/utils/ProtocolUtils.mjs:
@azure/msal-common/dist/crypto/PopTokenGenerator.mjs:
@azure/msal-common/dist/cache/persistence/TokenCacheContext.mjs:
@azure/msal-common/dist/response/ResponseHandler.mjs:
@azure/msal-common/dist/utils/ClientAssertionUtils.mjs:
@azure/msal-common/dist/client/AuthorizationCodeClient.mjs:
@azure/msal-common/dist/client/RefreshTokenClient.mjs:
@azure/msal-common/dist/client/SilentFlowClient.mjs:
@azure/msal-common/dist/network/INetworkModule.mjs:
@azure/msal-common/dist/protocol/Authorize.mjs:
@azure/msal-common/dist/request/AuthenticationHeaderParser.mjs:
@azure/msal-common/dist/telemetry/server/ServerTelemetryManager.mjs:
@azure/msal-common/dist/error/JoseHeaderErrorCodes.mjs:
@azure/msal-common/dist/error/JoseHeaderError.mjs:
@azure/msal-common/dist/crypto/JoseHeader.mjs:
@azure/msal-common/dist/telemetry/performance/PerformanceClient.mjs:
@azure/msal-common/dist/index-browser.mjs:
  (*! @azure/msal-common v15.9.0 2025-07-23 *)

@azure/msal-browser/dist/error/BrowserAuthErrorCodes.mjs:
@azure/msal-browser/dist/error/BrowserAuthError.mjs:
@azure/msal-browser/dist/utils/BrowserConstants.mjs:
@azure/msal-browser/dist/encode/Base64Encode.mjs:
@azure/msal-browser/dist/encode/Base64Decode.mjs:
@azure/msal-browser/dist/crypto/BrowserCrypto.mjs:
@azure/msal-browser/dist/error/BrowserConfigurationAuthErrorCodes.mjs:
@azure/msal-browser/dist/error/BrowserConfigurationAuthError.mjs:
@azure/msal-browser/dist/utils/BrowserUtils.mjs:
@azure/msal-browser/dist/navigation/NavigationClient.mjs:
@azure/msal-browser/dist/network/FetchClient.mjs:
@azure/msal-browser/dist/config/Configuration.mjs:
@azure/msal-browser/dist/packageMetadata.mjs:
@azure/msal-browser/dist/operatingcontext/BaseOperatingContext.mjs:
@azure/msal-browser/dist/naa/BridgeStatusCode.mjs:
@azure/msal-browser/dist/naa/BridgeProxy.mjs:
@azure/msal-browser/dist/operatingcontext/NestedAppOperatingContext.mjs:
@azure/msal-browser/dist/operatingcontext/StandardOperatingContext.mjs:
@azure/msal-browser/dist/cache/DatabaseStorage.mjs:
@azure/msal-browser/dist/cache/MemoryStorage.mjs:
@azure/msal-browser/dist/cache/AsyncMemoryStorage.mjs:
@azure/msal-browser/dist/crypto/CryptoOps.mjs:
@azure/msal-browser/dist/cache/CookieStorage.mjs:
@azure/msal-browser/dist/cache/CacheHelpers.mjs:
@azure/msal-browser/dist/cache/LocalStorage.mjs:
@azure/msal-browser/dist/cache/SessionStorage.mjs:
@azure/msal-browser/dist/event/EventType.mjs:
@azure/msal-browser/dist/cache/BrowserCacheManager.mjs:
@azure/msal-browser/dist/cache/AccountManager.mjs:
@azure/msal-browser/dist/event/EventHandler.mjs:
@azure/msal-browser/dist/interaction_client/BaseInteractionClient.mjs:
@azure/msal-browser/dist/request/RequestHelpers.mjs:
@azure/msal-browser/dist/interaction_client/StandardInteractionClient.mjs:
@azure/msal-browser/dist/utils/BrowserProtocolUtils.mjs:
@azure/msal-browser/dist/response/ResponseHandler.mjs:
@azure/msal-browser/dist/interaction_handler/InteractionHandler.mjs:
@azure/msal-browser/dist/error/NativeAuthErrorCodes.mjs:
@azure/msal-browser/dist/broker/nativeBroker/NativeStatusCodes.mjs:
@azure/msal-browser/dist/error/NativeAuthError.mjs:
@azure/msal-browser/dist/interaction_client/SilentCacheClient.mjs:
@azure/msal-browser/dist/interaction_client/PlatformAuthInteractionClient.mjs:
@azure/msal-browser/dist/protocol/Authorize.mjs:
@azure/msal-browser/dist/crypto/PkceGenerator.mjs:
@azure/msal-browser/dist/broker/nativeBroker/PlatformAuthExtensionHandler.mjs:
@azure/msal-browser/dist/broker/nativeBroker/PlatformAuthDOMHandler.mjs:
@azure/msal-browser/dist/broker/nativeBroker/PlatformAuthProvider.mjs:
@azure/msal-browser/dist/interaction_client/PopupClient.mjs:
@azure/msal-browser/dist/interaction_client/RedirectClient.mjs:
@azure/msal-browser/dist/interaction_handler/SilentHandler.mjs:
@azure/msal-browser/dist/interaction_client/SilentIframeClient.mjs:
@azure/msal-browser/dist/interaction_client/SilentRefreshClient.mjs:
@azure/msal-browser/dist/cache/TokenCache.mjs:
@azure/msal-browser/dist/interaction_client/HybridSpaAuthorizationCodeClient.mjs:
@azure/msal-browser/dist/interaction_client/SilentAuthCodeClient.mjs:
@azure/msal-browser/dist/utils/MsalFrameStatsUtils.mjs:
@azure/msal-browser/dist/controllers/StandardController.mjs:
@azure/msal-browser/dist/naa/BridgeError.mjs:
@azure/msal-browser/dist/naa/mapping/NestedAppAuthAdapter.mjs:
@azure/msal-browser/dist/error/NestedAppAuthError.mjs:
@azure/msal-browser/dist/controllers/NestedAppAuthController.mjs:
@azure/msal-browser/dist/controllers/ControllerFactory.mjs:
@azure/msal-browser/dist/app/PublicClientApplication.mjs:
@azure/msal-browser/dist/controllers/UnknownOperatingContextController.mjs:
@azure/msal-browser/dist/operatingcontext/UnknownOperatingContext.mjs:
@azure/msal-browser/dist/app/PublicClientNext.mjs:
@azure/msal-browser/dist/app/IPublicClientApplication.mjs:
@azure/msal-browser/dist/event/EventMessage.mjs:
@azure/msal-browser/dist/crypto/SignedHttpRequest.mjs:
@azure/msal-browser/dist/telemetry/BrowserPerformanceClient.mjs:
@azure/msal-browser/dist/index.mjs:
  (*! @azure/msal-browser v4.18.0 2025-07-30 *)

js-md4/src/md4.js:
  (**
   * [js-md4]{@link https://github.com/emn178/js-md4}
   *
   * @namespace md4
   * @version 0.3.2
   * @author Yi-Cyuan Chen [emn178@gmail.com]
   * @copyright Yi-Cyuan Chen 2015-2027
   * @license MIT
   *)

@js-joda/core/dist/js-joda.esm.js:
  (*! @version @js-joda/core - 5.6.5 *)
  (*! @copyright (c) 2015-present, Philipp Thürwächter, Pattrick Hüper & js-joda contributors *)
  (*! @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos *)
  (*! @license BSD-3-Clause (see LICENSE in the root directory of this source tree) *)
  (**
   * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
   * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
   *)
  (**
   * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
   * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
   * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
   *)
  (*
   * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
   * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
   * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
   *)
  (*
   * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
   * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)
   *)
  (*
   * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
   * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
   *)
  (*
   * @copyright (c) 2016, Philipp Thürwächter, Pattrick Hüper
   * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
   * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
   *)
  (*
   * @copyright (c) 2015-present, Philipp Thürwächter, Pattrick Hüper & js-joda contributors
   * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
   *)
*/
//# sourceMappingURL=mssql.js.map
